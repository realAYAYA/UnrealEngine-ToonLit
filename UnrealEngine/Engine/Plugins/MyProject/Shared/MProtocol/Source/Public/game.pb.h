// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_game_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_game_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "defines.pb.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_game_2eproto MPROTOCOL_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct MPROTOCOL_API TableStruct_game_2eproto {
  static const uint32_t offsets[];
};
MPROTOCOL_API extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_game_2eproto;
namespace idlepb {
class ActivateGongFaMaxEffectAck;
struct ActivateGongFaMaxEffectAckDefaultTypeInternal;
MPROTOCOL_API extern ActivateGongFaMaxEffectAckDefaultTypeInternal _ActivateGongFaMaxEffectAck_default_instance_;
class ActivateGongFaMaxEffectReq;
struct ActivateGongFaMaxEffectReqDefaultTypeInternal;
MPROTOCOL_API extern ActivateGongFaMaxEffectReqDefaultTypeInternal _ActivateGongFaMaxEffectReq_default_instance_;
class AddBiographyRoleLogAck;
struct AddBiographyRoleLogAckDefaultTypeInternal;
MPROTOCOL_API extern AddBiographyRoleLogAckDefaultTypeInternal _AddBiographyRoleLogAck_default_instance_;
class AddBiographyRoleLogReq;
struct AddBiographyRoleLogReqDefaultTypeInternal;
MPROTOCOL_API extern AddBiographyRoleLogReqDefaultTypeInternal _AddBiographyRoleLogReq_default_instance_;
class AlchemyRefineCancelAck;
struct AlchemyRefineCancelAckDefaultTypeInternal;
MPROTOCOL_API extern AlchemyRefineCancelAckDefaultTypeInternal _AlchemyRefineCancelAck_default_instance_;
class AlchemyRefineCancelReq;
struct AlchemyRefineCancelReqDefaultTypeInternal;
MPROTOCOL_API extern AlchemyRefineCancelReqDefaultTypeInternal _AlchemyRefineCancelReq_default_instance_;
class AlchemyRefineExtractAck;
struct AlchemyRefineExtractAckDefaultTypeInternal;
MPROTOCOL_API extern AlchemyRefineExtractAckDefaultTypeInternal _AlchemyRefineExtractAck_default_instance_;
class AlchemyRefineExtractReq;
struct AlchemyRefineExtractReqDefaultTypeInternal;
MPROTOCOL_API extern AlchemyRefineExtractReqDefaultTypeInternal _AlchemyRefineExtractReq_default_instance_;
class AlchemyRefineStartAck;
struct AlchemyRefineStartAckDefaultTypeInternal;
MPROTOCOL_API extern AlchemyRefineStartAckDefaultTypeInternal _AlchemyRefineStartAck_default_instance_;
class AlchemyRefineStartReq;
struct AlchemyRefineStartReqDefaultTypeInternal;
MPROTOCOL_API extern AlchemyRefineStartReqDefaultTypeInternal _AlchemyRefineStartReq_default_instance_;
class AppearanceActiveAck;
struct AppearanceActiveAckDefaultTypeInternal;
MPROTOCOL_API extern AppearanceActiveAckDefaultTypeInternal _AppearanceActiveAck_default_instance_;
class AppearanceActiveReq;
struct AppearanceActiveReqDefaultTypeInternal;
MPROTOCOL_API extern AppearanceActiveReqDefaultTypeInternal _AppearanceActiveReq_default_instance_;
class AppearanceAddAck;
struct AppearanceAddAckDefaultTypeInternal;
MPROTOCOL_API extern AppearanceAddAckDefaultTypeInternal _AppearanceAddAck_default_instance_;
class AppearanceAddReq;
struct AppearanceAddReqDefaultTypeInternal;
MPROTOCOL_API extern AppearanceAddReqDefaultTypeInternal _AppearanceAddReq_default_instance_;
class AppearanceBuyAck;
struct AppearanceBuyAckDefaultTypeInternal;
MPROTOCOL_API extern AppearanceBuyAckDefaultTypeInternal _AppearanceBuyAck_default_instance_;
class AppearanceBuyReq;
struct AppearanceBuyReqDefaultTypeInternal;
MPROTOCOL_API extern AppearanceBuyReqDefaultTypeInternal _AppearanceBuyReq_default_instance_;
class AppearanceChangeSkTypeAck;
struct AppearanceChangeSkTypeAckDefaultTypeInternal;
MPROTOCOL_API extern AppearanceChangeSkTypeAckDefaultTypeInternal _AppearanceChangeSkTypeAck_default_instance_;
class AppearanceChangeSkTypeReq;
struct AppearanceChangeSkTypeReqDefaultTypeInternal;
MPROTOCOL_API extern AppearanceChangeSkTypeReqDefaultTypeInternal _AppearanceChangeSkTypeReq_default_instance_;
class AppearanceWearAck;
struct AppearanceWearAckDefaultTypeInternal;
MPROTOCOL_API extern AppearanceWearAckDefaultTypeInternal _AppearanceWearAck_default_instance_;
class AppearanceWearReq;
struct AppearanceWearReqDefaultTypeInternal;
MPROTOCOL_API extern AppearanceWearReqDefaultTypeInternal _AppearanceWearReq_default_instance_;
class ArenaCheckListRewardSubmitAck;
struct ArenaCheckListRewardSubmitAckDefaultTypeInternal;
MPROTOCOL_API extern ArenaCheckListRewardSubmitAckDefaultTypeInternal _ArenaCheckListRewardSubmitAck_default_instance_;
class ArenaCheckListRewardSubmitReq;
struct ArenaCheckListRewardSubmitReqDefaultTypeInternal;
MPROTOCOL_API extern ArenaCheckListRewardSubmitReqDefaultTypeInternal _ArenaCheckListRewardSubmitReq_default_instance_;
class ArenaCheckListSubmitAck;
struct ArenaCheckListSubmitAckDefaultTypeInternal;
MPROTOCOL_API extern ArenaCheckListSubmitAckDefaultTypeInternal _ArenaCheckListSubmitAck_default_instance_;
class ArenaCheckListSubmitReq;
struct ArenaCheckListSubmitReqDefaultTypeInternal;
MPROTOCOL_API extern ArenaCheckListSubmitReqDefaultTypeInternal _ArenaCheckListSubmitReq_default_instance_;
class AvatarRankUpAck;
struct AvatarRankUpAckDefaultTypeInternal;
MPROTOCOL_API extern AvatarRankUpAckDefaultTypeInternal _AvatarRankUpAck_default_instance_;
class AvatarRankUpReq;
struct AvatarRankUpReqDefaultTypeInternal;
MPROTOCOL_API extern AvatarRankUpReqDefaultTypeInternal _AvatarRankUpReq_default_instance_;
class BuyDeluxeShopItemAck;
struct BuyDeluxeShopItemAckDefaultTypeInternal;
MPROTOCOL_API extern BuyDeluxeShopItemAckDefaultTypeInternal _BuyDeluxeShopItemAck_default_instance_;
class BuyDeluxeShopItemReq;
struct BuyDeluxeShopItemReqDefaultTypeInternal;
MPROTOCOL_API extern BuyDeluxeShopItemReqDefaultTypeInternal _BuyDeluxeShopItemReq_default_instance_;
class BuySeptShopItemAck;
struct BuySeptShopItemAckDefaultTypeInternal;
MPROTOCOL_API extern BuySeptShopItemAckDefaultTypeInternal _BuySeptShopItemAck_default_instance_;
class BuySeptShopItemReq;
struct BuySeptShopItemReqDefaultTypeInternal;
MPROTOCOL_API extern BuySeptShopItemReqDefaultTypeInternal _BuySeptShopItemReq_default_instance_;
class BuyShopItemAck;
struct BuyShopItemAckDefaultTypeInternal;
MPROTOCOL_API extern BuyShopItemAckDefaultTypeInternal _BuyShopItemAck_default_instance_;
class BuyShopItemReq;
struct BuyShopItemReqDefaultTypeInternal;
MPROTOCOL_API extern BuyShopItemReqDefaultTypeInternal _BuyShopItemReq_default_instance_;
class ChecklistOpAck;
struct ChecklistOpAckDefaultTypeInternal;
MPROTOCOL_API extern ChecklistOpAckDefaultTypeInternal _ChecklistOpAck_default_instance_;
class ChecklistOpReq;
struct ChecklistOpReqDefaultTypeInternal;
MPROTOCOL_API extern ChecklistOpReqDefaultTypeInternal _ChecklistOpReq_default_instance_;
class ClearChatUnreadNumAck;
struct ClearChatUnreadNumAckDefaultTypeInternal;
MPROTOCOL_API extern ClearChatUnreadNumAckDefaultTypeInternal _ClearChatUnreadNumAck_default_instance_;
class ClearChatUnreadNumReq;
struct ClearChatUnreadNumReqDefaultTypeInternal;
MPROTOCOL_API extern ClearChatUnreadNumReqDefaultTypeInternal _ClearChatUnreadNumReq_default_instance_;
class CollectionActivatedSuit;
struct CollectionActivatedSuitDefaultTypeInternal;
MPROTOCOL_API extern CollectionActivatedSuitDefaultTypeInternal _CollectionActivatedSuit_default_instance_;
class CreateCharacterAck;
struct CreateCharacterAckDefaultTypeInternal;
MPROTOCOL_API extern CreateCharacterAckDefaultTypeInternal _CreateCharacterAck_default_instance_;
class CreateCharacterReq;
struct CreateCharacterReqDefaultTypeInternal;
MPROTOCOL_API extern CreateCharacterReqDefaultTypeInternal _CreateCharacterReq_default_instance_;
class DelUserVar;
struct DelUserVarDefaultTypeInternal;
MPROTOCOL_API extern DelUserVarDefaultTypeInternal _DelUserVar_default_instance_;
class DeleteMailAck;
struct DeleteMailAckDefaultTypeInternal;
MPROTOCOL_API extern DeleteMailAckDefaultTypeInternal _DeleteMailAck_default_instance_;
class DeleteMailReq;
struct DeleteMailReqDefaultTypeInternal;
MPROTOCOL_API extern DeleteMailReqDefaultTypeInternal _DeleteMailReq_default_instance_;
class DeletePrivateChatRecordAck;
struct DeletePrivateChatRecordAckDefaultTypeInternal;
MPROTOCOL_API extern DeletePrivateChatRecordAckDefaultTypeInternal _DeletePrivateChatRecordAck_default_instance_;
class DeletePrivateChatRecordReq;
struct DeletePrivateChatRecordReqDefaultTypeInternal;
MPROTOCOL_API extern DeletePrivateChatRecordReqDefaultTypeInternal _DeletePrivateChatRecordReq_default_instance_;
class DispatchAvatarAck;
struct DispatchAvatarAckDefaultTypeInternal;
MPROTOCOL_API extern DispatchAvatarAckDefaultTypeInternal _DispatchAvatarAck_default_instance_;
class DispatchAvatarReq;
struct DispatchAvatarReqDefaultTypeInternal;
MPROTOCOL_API extern DispatchAvatarReqDefaultTypeInternal _DispatchAvatarReq_default_instance_;
class DoBreakthroughAck;
struct DoBreakthroughAckDefaultTypeInternal;
MPROTOCOL_API extern DoBreakthroughAckDefaultTypeInternal _DoBreakthroughAck_default_instance_;
class DoBreakthroughReq;
struct DoBreakthroughReqDefaultTypeInternal;
MPROTOCOL_API extern DoBreakthroughReqDefaultTypeInternal _DoBreakthroughReq_default_instance_;
class DoBreathingExerciseAck;
struct DoBreathingExerciseAckDefaultTypeInternal;
MPROTOCOL_API extern DoBreathingExerciseAckDefaultTypeInternal _DoBreathingExerciseAck_default_instance_;
class DoBreathingExerciseReq;
struct DoBreathingExerciseReqDefaultTypeInternal;
MPROTOCOL_API extern DoBreathingExerciseReqDefaultTypeInternal _DoBreathingExerciseReq_default_instance_;
class DoGmCommand;
struct DoGmCommandDefaultTypeInternal;
MPROTOCOL_API extern DoGmCommandDefaultTypeInternal _DoGmCommand_default_instance_;
class DoQuestFightAck;
struct DoQuestFightAckDefaultTypeInternal;
MPROTOCOL_API extern DoQuestFightAckDefaultTypeInternal _DoQuestFightAck_default_instance_;
class DoQuestFightReq;
struct DoQuestFightReqDefaultTypeInternal;
MPROTOCOL_API extern DoQuestFightReqDefaultTypeInternal _DoQuestFightReq_default_instance_;
class DungeonKillAllChallengeAck;
struct DungeonKillAllChallengeAckDefaultTypeInternal;
MPROTOCOL_API extern DungeonKillAllChallengeAckDefaultTypeInternal _DungeonKillAllChallengeAck_default_instance_;
class DungeonKillAllChallengeReq;
struct DungeonKillAllChallengeReqDefaultTypeInternal;
MPROTOCOL_API extern DungeonKillAllChallengeReqDefaultTypeInternal _DungeonKillAllChallengeReq_default_instance_;
class DungeonKillAllDataAck;
struct DungeonKillAllDataAckDefaultTypeInternal;
MPROTOCOL_API extern DungeonKillAllDataAckDefaultTypeInternal _DungeonKillAllDataAck_default_instance_;
class DungeonKillAllDataReq;
struct DungeonKillAllDataReqDefaultTypeInternal;
MPROTOCOL_API extern DungeonKillAllDataReqDefaultTypeInternal _DungeonKillAllDataReq_default_instance_;
class DungeonKillAllQuickEndAck;
struct DungeonKillAllQuickEndAckDefaultTypeInternal;
MPROTOCOL_API extern DungeonKillAllQuickEndAckDefaultTypeInternal _DungeonKillAllQuickEndAck_default_instance_;
class DungeonKillAllQuickEndReq;
struct DungeonKillAllQuickEndReqDefaultTypeInternal;
MPROTOCOL_API extern DungeonKillAllQuickEndReqDefaultTypeInternal _DungeonKillAllQuickEndReq_default_instance_;
class DungeonSurviveChallengeAck;
struct DungeonSurviveChallengeAckDefaultTypeInternal;
MPROTOCOL_API extern DungeonSurviveChallengeAckDefaultTypeInternal _DungeonSurviveChallengeAck_default_instance_;
class DungeonSurviveChallengeReq;
struct DungeonSurviveChallengeReqDefaultTypeInternal;
MPROTOCOL_API extern DungeonSurviveChallengeReqDefaultTypeInternal _DungeonSurviveChallengeReq_default_instance_;
class DungeonSurviveDataAck;
struct DungeonSurviveDataAckDefaultTypeInternal;
MPROTOCOL_API extern DungeonSurviveDataAckDefaultTypeInternal _DungeonSurviveDataAck_default_instance_;
class DungeonSurviveDataReq;
struct DungeonSurviveDataReqDefaultTypeInternal;
MPROTOCOL_API extern DungeonSurviveDataReqDefaultTypeInternal _DungeonSurviveDataReq_default_instance_;
class DungeonSurviveQuickEndAck;
struct DungeonSurviveQuickEndAckDefaultTypeInternal;
MPROTOCOL_API extern DungeonSurviveQuickEndAckDefaultTypeInternal _DungeonSurviveQuickEndAck_default_instance_;
class DungeonSurviveQuickEndReq;
struct DungeonSurviveQuickEndReqDefaultTypeInternal;
MPROTOCOL_API extern DungeonSurviveQuickEndReqDefaultTypeInternal _DungeonSurviveQuickEndReq_default_instance_;
class EquipmentPutOnAck;
struct EquipmentPutOnAckDefaultTypeInternal;
MPROTOCOL_API extern EquipmentPutOnAckDefaultTypeInternal _EquipmentPutOnAck_default_instance_;
class EquipmentPutOnReq;
struct EquipmentPutOnReqDefaultTypeInternal;
MPROTOCOL_API extern EquipmentPutOnReqDefaultTypeInternal _EquipmentPutOnReq_default_instance_;
class EquipmentTakeOffAck;
struct EquipmentTakeOffAckDefaultTypeInternal;
MPROTOCOL_API extern EquipmentTakeOffAckDefaultTypeInternal _EquipmentTakeOffAck_default_instance_;
class EquipmentTakeOffReq;
struct EquipmentTakeOffReqDefaultTypeInternal;
MPROTOCOL_API extern EquipmentTakeOffReqDefaultTypeInternal _EquipmentTakeOffReq_default_instance_;
class ExchangeCommonItemAck;
struct ExchangeCommonItemAckDefaultTypeInternal;
MPROTOCOL_API extern ExchangeCommonItemAckDefaultTypeInternal _ExchangeCommonItemAck_default_instance_;
class ExchangeCommonItemReq;
struct ExchangeCommonItemReqDefaultTypeInternal;
MPROTOCOL_API extern ExchangeCommonItemReqDefaultTypeInternal _ExchangeCommonItemReq_default_instance_;
class ExtractTemporaryPackageItemsAck;
struct ExtractTemporaryPackageItemsAckDefaultTypeInternal;
MPROTOCOL_API extern ExtractTemporaryPackageItemsAckDefaultTypeInternal _ExtractTemporaryPackageItemsAck_default_instance_;
class ExtractTemporaryPackageItemsReq;
struct ExtractTemporaryPackageItemsReqDefaultTypeInternal;
MPROTOCOL_API extern ExtractTemporaryPackageItemsReqDefaultTypeInternal _ExtractTemporaryPackageItemsReq_default_instance_;
class FarmerRankUpAck;
struct FarmerRankUpAckDefaultTypeInternal;
MPROTOCOL_API extern FarmerRankUpAckDefaultTypeInternal _FarmerRankUpAck_default_instance_;
class FarmerRankUpReq;
struct FarmerRankUpReqDefaultTypeInternal;
MPROTOCOL_API extern FarmerRankUpReqDefaultTypeInternal _FarmerRankUpReq_default_instance_;
class FarmlandHarvestAck;
struct FarmlandHarvestAckDefaultTypeInternal;
MPROTOCOL_API extern FarmlandHarvestAckDefaultTypeInternal _FarmlandHarvestAck_default_instance_;
class FarmlandHarvestReq;
struct FarmlandHarvestReqDefaultTypeInternal;
MPROTOCOL_API extern FarmlandHarvestReqDefaultTypeInternal _FarmlandHarvestReq_default_instance_;
class FarmlandPlantSeedAck;
struct FarmlandPlantSeedAckDefaultTypeInternal;
MPROTOCOL_API extern FarmlandPlantSeedAckDefaultTypeInternal _FarmlandPlantSeedAck_default_instance_;
class FarmlandPlantSeedReq;
struct FarmlandPlantSeedReqDefaultTypeInternal;
MPROTOCOL_API extern FarmlandPlantSeedReqDefaultTypeInternal _FarmlandPlantSeedReq_default_instance_;
class FarmlandRipeningAck;
struct FarmlandRipeningAckDefaultTypeInternal;
MPROTOCOL_API extern FarmlandRipeningAckDefaultTypeInternal _FarmlandRipeningAck_default_instance_;
class FarmlandRipeningReq;
struct FarmlandRipeningReqDefaultTypeInternal;
MPROTOCOL_API extern FarmlandRipeningReqDefaultTypeInternal _FarmlandRipeningReq_default_instance_;
class FarmlandSetManagementAck;
struct FarmlandSetManagementAckDefaultTypeInternal;
MPROTOCOL_API extern FarmlandSetManagementAckDefaultTypeInternal _FarmlandSetManagementAck_default_instance_;
class FarmlandSetManagementReq;
struct FarmlandSetManagementReqDefaultTypeInternal;
MPROTOCOL_API extern FarmlandSetManagementReqDefaultTypeInternal _FarmlandSetManagementReq_default_instance_;
class FarmlandUnlockBlockAck;
struct FarmlandUnlockBlockAckDefaultTypeInternal;
MPROTOCOL_API extern FarmlandUnlockBlockAckDefaultTypeInternal _FarmlandUnlockBlockAck_default_instance_;
class FarmlandUnlockBlockReq;
struct FarmlandUnlockBlockReqDefaultTypeInternal;
MPROTOCOL_API extern FarmlandUnlockBlockReqDefaultTypeInternal _FarmlandUnlockBlockReq_default_instance_;
class FarmlandWateringAck;
struct FarmlandWateringAckDefaultTypeInternal;
MPROTOCOL_API extern FarmlandWateringAckDefaultTypeInternal _FarmlandWateringAck_default_instance_;
class FarmlandWateringReq;
struct FarmlandWateringReqDefaultTypeInternal;
MPROTOCOL_API extern FarmlandWateringReqDefaultTypeInternal _FarmlandWateringReq_default_instance_;
class ForgeDestroyAck;
struct ForgeDestroyAckDefaultTypeInternal;
MPROTOCOL_API extern ForgeDestroyAckDefaultTypeInternal _ForgeDestroyAck_default_instance_;
class ForgeDestroyReq;
struct ForgeDestroyReqDefaultTypeInternal;
MPROTOCOL_API extern ForgeDestroyReqDefaultTypeInternal _ForgeDestroyReq_default_instance_;
class ForgeFindBackAck;
struct ForgeFindBackAckDefaultTypeInternal;
MPROTOCOL_API extern ForgeFindBackAckDefaultTypeInternal _ForgeFindBackAck_default_instance_;
class ForgeFindBackReq;
struct ForgeFindBackReqDefaultTypeInternal;
MPROTOCOL_API extern ForgeFindBackReqDefaultTypeInternal _ForgeFindBackReq_default_instance_;
class ForgeRefineCancelAck;
struct ForgeRefineCancelAckDefaultTypeInternal;
MPROTOCOL_API extern ForgeRefineCancelAckDefaultTypeInternal _ForgeRefineCancelAck_default_instance_;
class ForgeRefineCancelReq;
struct ForgeRefineCancelReqDefaultTypeInternal;
MPROTOCOL_API extern ForgeRefineCancelReqDefaultTypeInternal _ForgeRefineCancelReq_default_instance_;
class ForgeRefineExtractAck;
struct ForgeRefineExtractAckDefaultTypeInternal;
MPROTOCOL_API extern ForgeRefineExtractAckDefaultTypeInternal _ForgeRefineExtractAck_default_instance_;
class ForgeRefineExtractReq;
struct ForgeRefineExtractReqDefaultTypeInternal;
MPROTOCOL_API extern ForgeRefineExtractReqDefaultTypeInternal _ForgeRefineExtractReq_default_instance_;
class ForgeRefineStartAck;
struct ForgeRefineStartAckDefaultTypeInternal;
MPROTOCOL_API extern ForgeRefineStartAckDefaultTypeInternal _ForgeRefineStartAck_default_instance_;
class ForgeRefineStartReq;
struct ForgeRefineStartReqDefaultTypeInternal;
MPROTOCOL_API extern ForgeRefineStartReqDefaultTypeInternal _ForgeRefineStartReq_default_instance_;
class FriendOpAck;
struct FriendOpAckDefaultTypeInternal;
MPROTOCOL_API extern FriendOpAckDefaultTypeInternal _FriendOpAck_default_instance_;
class FriendOpReq;
struct FriendOpReqDefaultTypeInternal;
MPROTOCOL_API extern FriendOpReqDefaultTypeInternal _FriendOpReq_default_instance_;
class FriendSearchRoleInfoAck;
struct FriendSearchRoleInfoAckDefaultTypeInternal;
MPROTOCOL_API extern FriendSearchRoleInfoAckDefaultTypeInternal _FriendSearchRoleInfoAck_default_instance_;
class FriendSearchRoleInfoReq;
struct FriendSearchRoleInfoReqDefaultTypeInternal;
MPROTOCOL_API extern FriendSearchRoleInfoReqDefaultTypeInternal _FriendSearchRoleInfoReq_default_instance_;
class GameSystemChatMessage;
struct GameSystemChatMessageDefaultTypeInternal;
MPROTOCOL_API extern GameSystemChatMessageDefaultTypeInternal _GameSystemChatMessage_default_instance_;
class GetAppearanceDataAck;
struct GetAppearanceDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetAppearanceDataAckDefaultTypeInternal _GetAppearanceDataAck_default_instance_;
class GetAppearanceDataReq;
struct GetAppearanceDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetAppearanceDataReqDefaultTypeInternal _GetAppearanceDataReq_default_instance_;
class GetArenaCheckListDataAck;
struct GetArenaCheckListDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetArenaCheckListDataAckDefaultTypeInternal _GetArenaCheckListDataAck_default_instance_;
class GetArenaCheckListDataReq;
struct GetArenaCheckListDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetArenaCheckListDataReqDefaultTypeInternal _GetArenaCheckListDataReq_default_instance_;
class GetArenaExplorationStatisticalDataAck;
struct GetArenaExplorationStatisticalDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetArenaExplorationStatisticalDataAckDefaultTypeInternal _GetArenaExplorationStatisticalDataAck_default_instance_;
class GetArenaExplorationStatisticalDataReq;
struct GetArenaExplorationStatisticalDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetArenaExplorationStatisticalDataReqDefaultTypeInternal _GetArenaExplorationStatisticalDataReq_default_instance_;
class GetBattleHistoryInfoAck;
struct GetBattleHistoryInfoAckDefaultTypeInternal;
MPROTOCOL_API extern GetBattleHistoryInfoAckDefaultTypeInternal _GetBattleHistoryInfoAck_default_instance_;
class GetBattleHistoryInfoReq;
struct GetBattleHistoryInfoReqDefaultTypeInternal;
MPROTOCOL_API extern GetBattleHistoryInfoReqDefaultTypeInternal _GetBattleHistoryInfoReq_default_instance_;
class GetBiographyEventDataAck;
struct GetBiographyEventDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetBiographyEventDataAckDefaultTypeInternal _GetBiographyEventDataAck_default_instance_;
class GetBiographyEventDataReq;
struct GetBiographyEventDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetBiographyEventDataReqDefaultTypeInternal _GetBiographyEventDataReq_default_instance_;
class GetChatRecordAck;
struct GetChatRecordAckDefaultTypeInternal;
MPROTOCOL_API extern GetChatRecordAckDefaultTypeInternal _GetChatRecordAck_default_instance_;
class GetChatRecordReq;
struct GetChatRecordReqDefaultTypeInternal;
MPROTOCOL_API extern GetChatRecordReqDefaultTypeInternal _GetChatRecordReq_default_instance_;
class GetChecklistDataAck;
struct GetChecklistDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetChecklistDataAckDefaultTypeInternal _GetChecklistDataAck_default_instance_;
class GetChecklistDataReq;
struct GetChecklistDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetChecklistDataReqDefaultTypeInternal _GetChecklistDataReq_default_instance_;
class GetCommonItemExchangeDataAck;
struct GetCommonItemExchangeDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetCommonItemExchangeDataAckDefaultTypeInternal _GetCommonItemExchangeDataAck_default_instance_;
class GetCommonItemExchangeDataReq;
struct GetCommonItemExchangeDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetCommonItemExchangeDataReqDefaultTypeInternal _GetCommonItemExchangeDataReq_default_instance_;
class GetFarmlandDataAck;
struct GetFarmlandDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetFarmlandDataAckDefaultTypeInternal _GetFarmlandDataAck_default_instance_;
class GetFarmlandDataReq;
struct GetFarmlandDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetFarmlandDataReqDefaultTypeInternal _GetFarmlandDataReq_default_instance_;
class GetForgeLostEquipmentDataAck;
struct GetForgeLostEquipmentDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetForgeLostEquipmentDataAckDefaultTypeInternal _GetForgeLostEquipmentDataAck_default_instance_;
class GetForgeLostEquipmentDataReq;
struct GetForgeLostEquipmentDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetForgeLostEquipmentDataReqDefaultTypeInternal _GetForgeLostEquipmentDataReq_default_instance_;
class GetFuZeRewardAck;
struct GetFuZeRewardAckDefaultTypeInternal;
MPROTOCOL_API extern GetFuZeRewardAckDefaultTypeInternal _GetFuZeRewardAck_default_instance_;
class GetFuZeRewardReq;
struct GetFuZeRewardReqDefaultTypeInternal;
MPROTOCOL_API extern GetFuZeRewardReqDefaultTypeInternal _GetFuZeRewardReq_default_instance_;
class GetGongFaDataAck;
struct GetGongFaDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetGongFaDataAckDefaultTypeInternal _GetGongFaDataAck_default_instance_;
class GetGongFaDataReq;
struct GetGongFaDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetGongFaDataReqDefaultTypeInternal _GetGongFaDataReq_default_instance_;
class GetInventoryDataAck;
struct GetInventoryDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetInventoryDataAckDefaultTypeInternal _GetInventoryDataAck_default_instance_;
class GetInventoryDataReq;
struct GetInventoryDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetInventoryDataReqDefaultTypeInternal _GetInventoryDataReq_default_instance_;
class GetLeaderboardDataAck;
struct GetLeaderboardDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetLeaderboardDataAckDefaultTypeInternal _GetLeaderboardDataAck_default_instance_;
class GetLeaderboardDataReq;
struct GetLeaderboardDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetLeaderboardDataReqDefaultTypeInternal _GetLeaderboardDataReq_default_instance_;
class GetLeaderboardPreviewAck;
struct GetLeaderboardPreviewAckDefaultTypeInternal;
MPROTOCOL_API extern GetLeaderboardPreviewAckDefaultTypeInternal _GetLeaderboardPreviewAck_default_instance_;
class GetLeaderboardPreviewReq;
struct GetLeaderboardPreviewReqDefaultTypeInternal;
MPROTOCOL_API extern GetLeaderboardPreviewReqDefaultTypeInternal _GetLeaderboardPreviewReq_default_instance_;
class GetLifeCounterDataAck;
struct GetLifeCounterDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetLifeCounterDataAckDefaultTypeInternal _GetLifeCounterDataAck_default_instance_;
class GetLifeCounterDataReq;
struct GetLifeCounterDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetLifeCounterDataReqDefaultTypeInternal _GetLifeCounterDataReq_default_instance_;
class GetMailAttachmentAck;
struct GetMailAttachmentAckDefaultTypeInternal;
MPROTOCOL_API extern GetMailAttachmentAckDefaultTypeInternal _GetMailAttachmentAck_default_instance_;
class GetMailAttachmentReq;
struct GetMailAttachmentReqDefaultTypeInternal;
MPROTOCOL_API extern GetMailAttachmentReqDefaultTypeInternal _GetMailAttachmentReq_default_instance_;
class GetMonsterTowerChallengeListAck;
struct GetMonsterTowerChallengeListAckDefaultTypeInternal;
MPROTOCOL_API extern GetMonsterTowerChallengeListAckDefaultTypeInternal _GetMonsterTowerChallengeListAck_default_instance_;
class GetMonsterTowerChallengeListReq;
struct GetMonsterTowerChallengeListReqDefaultTypeInternal;
MPROTOCOL_API extern GetMonsterTowerChallengeListReqDefaultTypeInternal _GetMonsterTowerChallengeListReq_default_instance_;
class GetMonsterTowerChallengeRewardAck;
struct GetMonsterTowerChallengeRewardAckDefaultTypeInternal;
MPROTOCOL_API extern GetMonsterTowerChallengeRewardAckDefaultTypeInternal _GetMonsterTowerChallengeRewardAck_default_instance_;
class GetMonsterTowerChallengeRewardReq;
struct GetMonsterTowerChallengeRewardReqDefaultTypeInternal;
MPROTOCOL_API extern GetMonsterTowerChallengeRewardReqDefaultTypeInternal _GetMonsterTowerChallengeRewardReq_default_instance_;
class GetOnePillElixirDataAck;
struct GetOnePillElixirDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetOnePillElixirDataAckDefaultTypeInternal _GetOnePillElixirDataAck_default_instance_;
class GetOnePillElixirDataReq;
struct GetOnePillElixirDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetOnePillElixirDataReqDefaultTypeInternal _GetOnePillElixirDataReq_default_instance_;
class GetQuestDataAck;
struct GetQuestDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetQuestDataAckDefaultTypeInternal _GetQuestDataAck_default_instance_;
class GetQuestDataReq;
struct GetQuestDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetQuestDataReqDefaultTypeInternal _GetQuestDataReq_default_instance_;
class GetRoleAllStatsAck;
struct GetRoleAllStatsAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleAllStatsAckDefaultTypeInternal _GetRoleAllStatsAck_default_instance_;
class GetRoleAllStatsReq;
struct GetRoleAllStatsReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleAllStatsReqDefaultTypeInternal _GetRoleAllStatsReq_default_instance_;
class GetRoleAvatarDataAck;
struct GetRoleAvatarDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleAvatarDataAckDefaultTypeInternal _GetRoleAvatarDataAck_default_instance_;
class GetRoleAvatarDataReq;
struct GetRoleAvatarDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleAvatarDataReqDefaultTypeInternal _GetRoleAvatarDataReq_default_instance_;
class GetRoleBiographyDataAck;
struct GetRoleBiographyDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleBiographyDataAckDefaultTypeInternal _GetRoleBiographyDataAck_default_instance_;
class GetRoleBiographyDataReq;
struct GetRoleBiographyDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleBiographyDataReqDefaultTypeInternal _GetRoleBiographyDataReq_default_instance_;
class GetRoleCollectionDataReq;
struct GetRoleCollectionDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleCollectionDataReqDefaultTypeInternal _GetRoleCollectionDataReq_default_instance_;
class GetRoleCollectionDataRsp;
struct GetRoleCollectionDataRspDefaultTypeInternal;
MPROTOCOL_API extern GetRoleCollectionDataRspDefaultTypeInternal _GetRoleCollectionDataRsp_default_instance_;
class GetRoleDeluxeShopDataAck;
struct GetRoleDeluxeShopDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleDeluxeShopDataAckDefaultTypeInternal _GetRoleDeluxeShopDataAck_default_instance_;
class GetRoleDeluxeShopDataReq;
struct GetRoleDeluxeShopDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleDeluxeShopDataReqDefaultTypeInternal _GetRoleDeluxeShopDataReq_default_instance_;
class GetRoleFriendDataAck;
struct GetRoleFriendDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleFriendDataAckDefaultTypeInternal _GetRoleFriendDataAck_default_instance_;
class GetRoleFriendDataReq;
struct GetRoleFriendDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleFriendDataReqDefaultTypeInternal _GetRoleFriendDataReq_default_instance_;
class GetRoleFuZengDataAck;
struct GetRoleFuZengDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleFuZengDataAckDefaultTypeInternal _GetRoleFuZengDataAck_default_instance_;
class GetRoleFuZengDataReq;
struct GetRoleFuZengDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleFuZengDataReqDefaultTypeInternal _GetRoleFuZengDataReq_default_instance_;
class GetRoleInfoAck;
struct GetRoleInfoAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleInfoAckDefaultTypeInternal _GetRoleInfoAck_default_instance_;
class GetRoleInfoCacheAck;
struct GetRoleInfoCacheAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleInfoCacheAckDefaultTypeInternal _GetRoleInfoCacheAck_default_instance_;
class GetRoleInfoCacheReq;
struct GetRoleInfoCacheReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleInfoCacheReqDefaultTypeInternal _GetRoleInfoCacheReq_default_instance_;
class GetRoleInfoReq;
struct GetRoleInfoReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleInfoReqDefaultTypeInternal _GetRoleInfoReq_default_instance_;
class GetRoleLeaderboardDataAck;
struct GetRoleLeaderboardDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleLeaderboardDataAckDefaultTypeInternal _GetRoleLeaderboardDataAck_default_instance_;
class GetRoleLeaderboardDataReq;
struct GetRoleLeaderboardDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleLeaderboardDataReqDefaultTypeInternal _GetRoleLeaderboardDataReq_default_instance_;
class GetRoleMailDataAck;
struct GetRoleMailDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleMailDataAckDefaultTypeInternal _GetRoleMailDataAck_default_instance_;
class GetRoleMailDataReq;
struct GetRoleMailDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleMailDataReqDefaultTypeInternal _GetRoleMailDataReq_default_instance_;
class GetRoleSeptQuestDataAck;
struct GetRoleSeptQuestDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleSeptQuestDataAckDefaultTypeInternal _GetRoleSeptQuestDataAck_default_instance_;
class GetRoleSeptQuestDataReq;
struct GetRoleSeptQuestDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleSeptQuestDataReqDefaultTypeInternal _GetRoleSeptQuestDataReq_default_instance_;
class GetRoleSeptShopDataAck;
struct GetRoleSeptShopDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleSeptShopDataAckDefaultTypeInternal _GetRoleSeptShopDataAck_default_instance_;
class GetRoleSeptShopDataReq;
struct GetRoleSeptShopDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleSeptShopDataReqDefaultTypeInternal _GetRoleSeptShopDataReq_default_instance_;
class GetRoleShopDataAck;
struct GetRoleShopDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleShopDataAckDefaultTypeInternal _GetRoleShopDataAck_default_instance_;
class GetRoleShopDataReq;
struct GetRoleShopDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleShopDataReqDefaultTypeInternal _GetRoleShopDataReq_default_instance_;
class GetRoleTreasuryDataAck;
struct GetRoleTreasuryDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleTreasuryDataAckDefaultTypeInternal _GetRoleTreasuryDataAck_default_instance_;
class GetRoleTreasuryDataReq;
struct GetRoleTreasuryDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleTreasuryDataReqDefaultTypeInternal _GetRoleTreasuryDataReq_default_instance_;
class GetRoleVipShopDataAck;
struct GetRoleVipShopDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetRoleVipShopDataAckDefaultTypeInternal _GetRoleVipShopDataAck_default_instance_;
class GetRoleVipShopDataReq;
struct GetRoleVipShopDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetRoleVipShopDataReqDefaultTypeInternal _GetRoleVipShopDataReq_default_instance_;
class GetShanhetuDataAck;
struct GetShanhetuDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetShanhetuDataAckDefaultTypeInternal _GetShanhetuDataAck_default_instance_;
class GetShanhetuDataReq;
struct GetShanhetuDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetShanhetuDataReqDefaultTypeInternal _GetShanhetuDataReq_default_instance_;
class GetShanhetuUseRecordAck;
struct GetShanhetuUseRecordAckDefaultTypeInternal;
MPROTOCOL_API extern GetShanhetuUseRecordAckDefaultTypeInternal _GetShanhetuUseRecordAck_default_instance_;
class GetShanhetuUseRecordReq;
struct GetShanhetuUseRecordReqDefaultTypeInternal;
MPROTOCOL_API extern GetShanhetuUseRecordReqDefaultTypeInternal _GetShanhetuUseRecordReq_default_instance_;
class GetShareItemDataReq;
struct GetShareItemDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetShareItemDataReqDefaultTypeInternal _GetShareItemDataReq_default_instance_;
class GetShareItemDataRsp;
struct GetShareItemDataRspDefaultTypeInternal;
MPROTOCOL_API extern GetShareItemDataRspDefaultTypeInternal _GetShareItemDataRsp_default_instance_;
class GetShareRoleCollectionDataReq;
struct GetShareRoleCollectionDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetShareRoleCollectionDataReqDefaultTypeInternal _GetShareRoleCollectionDataReq_default_instance_;
class GetShareRoleCollectionDataRsp;
struct GetShareRoleCollectionDataRspDefaultTypeInternal;
MPROTOCOL_API extern GetShareRoleCollectionDataRspDefaultTypeInternal _GetShareRoleCollectionDataRsp_default_instance_;
class GetSoloArenaHistoryListAck;
struct GetSoloArenaHistoryListAckDefaultTypeInternal;
MPROTOCOL_API extern GetSoloArenaHistoryListAckDefaultTypeInternal _GetSoloArenaHistoryListAck_default_instance_;
class GetSoloArenaHistoryListReq;
struct GetSoloArenaHistoryListReqDefaultTypeInternal;
MPROTOCOL_API extern GetSoloArenaHistoryListReqDefaultTypeInternal _GetSoloArenaHistoryListReq_default_instance_;
class GetTemporaryPackageDataAck;
struct GetTemporaryPackageDataAckDefaultTypeInternal;
MPROTOCOL_API extern GetTemporaryPackageDataAckDefaultTypeInternal _GetTemporaryPackageDataAck_default_instance_;
class GetTemporaryPackageDataReq;
struct GetTemporaryPackageDataReqDefaultTypeInternal;
MPROTOCOL_API extern GetTemporaryPackageDataReqDefaultTypeInternal _GetTemporaryPackageDataReq_default_instance_;
class GetUserVarReq;
struct GetUserVarReqDefaultTypeInternal;
MPROTOCOL_API extern GetUserVarReqDefaultTypeInternal _GetUserVarReq_default_instance_;
class GetUserVarRsp;
struct GetUserVarRspDefaultTypeInternal;
MPROTOCOL_API extern GetUserVarRspDefaultTypeInternal _GetUserVarRsp_default_instance_;
class GetUserVarsReq;
struct GetUserVarsReqDefaultTypeInternal;
MPROTOCOL_API extern GetUserVarsReqDefaultTypeInternal _GetUserVarsReq_default_instance_;
class GetUserVarsRsp;
struct GetUserVarsRspDefaultTypeInternal;
MPROTOCOL_API extern GetUserVarsRspDefaultTypeInternal _GetUserVarsRsp_default_instance_;
class GongFaOpAck;
struct GongFaOpAckDefaultTypeInternal;
MPROTOCOL_API extern GongFaOpAckDefaultTypeInternal _GongFaOpAck_default_instance_;
class GongFaOpReq;
struct GongFaOpReqDefaultTypeInternal;
MPROTOCOL_API extern GongFaOpReqDefaultTypeInternal _GongFaOpReq_default_instance_;
class InheritEquipmentAck;
struct InheritEquipmentAckDefaultTypeInternal;
MPROTOCOL_API extern InheritEquipmentAckDefaultTypeInternal _InheritEquipmentAck_default_instance_;
class InheritEquipmentReq;
struct InheritEquipmentReqDefaultTypeInternal;
MPROTOCOL_API extern InheritEquipmentReqDefaultTypeInternal _InheritEquipmentReq_default_instance_;
class LeaderboardClickLikeAck;
struct LeaderboardClickLikeAckDefaultTypeInternal;
MPROTOCOL_API extern LeaderboardClickLikeAckDefaultTypeInternal _LeaderboardClickLikeAck_default_instance_;
class LeaderboardClickLikeReq;
struct LeaderboardClickLikeReqDefaultTypeInternal;
MPROTOCOL_API extern LeaderboardClickLikeReqDefaultTypeInternal _LeaderboardClickLikeReq_default_instance_;
class LeaderboardUpdateMessageAck;
struct LeaderboardUpdateMessageAckDefaultTypeInternal;
MPROTOCOL_API extern LeaderboardUpdateMessageAckDefaultTypeInternal _LeaderboardUpdateMessageAck_default_instance_;
class LeaderboardUpdateMessageReq;
struct LeaderboardUpdateMessageReqDefaultTypeInternal;
MPROTOCOL_API extern LeaderboardUpdateMessageReqDefaultTypeInternal _LeaderboardUpdateMessageReq_default_instance_;
class LockItemAck;
struct LockItemAckDefaultTypeInternal;
MPROTOCOL_API extern LockItemAckDefaultTypeInternal _LockItemAck_default_instance_;
class LockItemReq;
struct LockItemReqDefaultTypeInternal;
MPROTOCOL_API extern LockItemReqDefaultTypeInternal _LockItemReq_default_instance_;
class LoginGameAck;
struct LoginGameAckDefaultTypeInternal;
MPROTOCOL_API extern LoginGameAckDefaultTypeInternal _LoginGameAck_default_instance_;
class LoginGameReq;
struct LoginGameReqDefaultTypeInternal;
MPROTOCOL_API extern LoginGameReqDefaultTypeInternal _LoginGameReq_default_instance_;
class MonsterTowerChallengeAck;
struct MonsterTowerChallengeAckDefaultTypeInternal;
MPROTOCOL_API extern MonsterTowerChallengeAckDefaultTypeInternal _MonsterTowerChallengeAck_default_instance_;
class MonsterTowerChallengeReq;
struct MonsterTowerChallengeReqDefaultTypeInternal;
MPROTOCOL_API extern MonsterTowerChallengeReqDefaultTypeInternal _MonsterTowerChallengeReq_default_instance_;
class MonsterTowerClosedDoorTrainingAck;
struct MonsterTowerClosedDoorTrainingAckDefaultTypeInternal;
MPROTOCOL_API extern MonsterTowerClosedDoorTrainingAckDefaultTypeInternal _MonsterTowerClosedDoorTrainingAck_default_instance_;
class MonsterTowerClosedDoorTrainingReq;
struct MonsterTowerClosedDoorTrainingReqDefaultTypeInternal;
MPROTOCOL_API extern MonsterTowerClosedDoorTrainingReqDefaultTypeInternal _MonsterTowerClosedDoorTrainingReq_default_instance_;
class MonsterTowerDrawIdleAwardAck;
struct MonsterTowerDrawIdleAwardAckDefaultTypeInternal;
MPROTOCOL_API extern MonsterTowerDrawIdleAwardAckDefaultTypeInternal _MonsterTowerDrawIdleAwardAck_default_instance_;
class MonsterTowerDrawIdleAwardReq;
struct MonsterTowerDrawIdleAwardReqDefaultTypeInternal;
MPROTOCOL_API extern MonsterTowerDrawIdleAwardReqDefaultTypeInternal _MonsterTowerDrawIdleAwardReq_default_instance_;
class MonsterTowerQuickEndAck;
struct MonsterTowerQuickEndAckDefaultTypeInternal;
MPROTOCOL_API extern MonsterTowerQuickEndAckDefaultTypeInternal _MonsterTowerQuickEndAck_default_instance_;
class MonsterTowerQuickEndReq;
struct MonsterTowerQuickEndReqDefaultTypeInternal;
MPROTOCOL_API extern MonsterTowerQuickEndReqDefaultTypeInternal _MonsterTowerQuickEndReq_default_instance_;
class NotifyAlchemyRefineResult;
struct NotifyAlchemyRefineResultDefaultTypeInternal;
MPROTOCOL_API extern NotifyAlchemyRefineResultDefaultTypeInternal _NotifyAlchemyRefineResult_default_instance_;
class NotifyAutoModeStatus;
struct NotifyAutoModeStatusDefaultTypeInternal;
MPROTOCOL_API extern NotifyAutoModeStatusDefaultTypeInternal _NotifyAutoModeStatus_default_instance_;
class NotifyBiographyMessage;
struct NotifyBiographyMessageDefaultTypeInternal;
MPROTOCOL_API extern NotifyBiographyMessageDefaultTypeInternal _NotifyBiographyMessage_default_instance_;
class NotifyChecklist;
struct NotifyChecklistDefaultTypeInternal;
MPROTOCOL_API extern NotifyChecklistDefaultTypeInternal _NotifyChecklist_default_instance_;
class NotifyCollectionActivatedSuit;
struct NotifyCollectionActivatedSuitDefaultTypeInternal;
MPROTOCOL_API extern NotifyCollectionActivatedSuitDefaultTypeInternal _NotifyCollectionActivatedSuit_default_instance_;
class NotifyCollectionZoneActiveAwards;
struct NotifyCollectionZoneActiveAwardsDefaultTypeInternal;
MPROTOCOL_API extern NotifyCollectionZoneActiveAwardsDefaultTypeInternal _NotifyCollectionZoneActiveAwards_default_instance_;
class NotifyCommonCollectionPieceData;
struct NotifyCommonCollectionPieceDataDefaultTypeInternal;
MPROTOCOL_API extern NotifyCommonCollectionPieceDataDefaultTypeInternal _NotifyCommonCollectionPieceData_default_instance_;
class NotifyDungeonKillAllChallengeCurWaveNum;
struct NotifyDungeonKillAllChallengeCurWaveNumDefaultTypeInternal;
MPROTOCOL_API extern NotifyDungeonKillAllChallengeCurWaveNumDefaultTypeInternal _NotifyDungeonKillAllChallengeCurWaveNum_default_instance_;
class NotifyDungeonKillAllChallengeOver;
struct NotifyDungeonKillAllChallengeOverDefaultTypeInternal;
MPROTOCOL_API extern NotifyDungeonKillAllChallengeOverDefaultTypeInternal _NotifyDungeonKillAllChallengeOver_default_instance_;
class NotifyDungeonSurviveChallengeCurWaveNum;
struct NotifyDungeonSurviveChallengeCurWaveNumDefaultTypeInternal;
MPROTOCOL_API extern NotifyDungeonSurviveChallengeCurWaveNumDefaultTypeInternal _NotifyDungeonSurviveChallengeCurWaveNum_default_instance_;
class NotifyDungeonSurviveChallengeOver;
struct NotifyDungeonSurviveChallengeOverDefaultTypeInternal;
MPROTOCOL_API extern NotifyDungeonSurviveChallengeOverDefaultTypeInternal _NotifyDungeonSurviveChallengeOver_default_instance_;
class NotifyEnterOpenClientWorld;
struct NotifyEnterOpenClientWorldDefaultTypeInternal;
MPROTOCOL_API extern NotifyEnterOpenClientWorldDefaultTypeInternal _NotifyEnterOpenClientWorld_default_instance_;
class NotifyFightModeData;
struct NotifyFightModeDataDefaultTypeInternal;
MPROTOCOL_API extern NotifyFightModeDataDefaultTypeInternal _NotifyFightModeData_default_instance_;
class NotifyForgeRefineResult;
struct NotifyForgeRefineResultDefaultTypeInternal;
MPROTOCOL_API extern NotifyForgeRefineResultDefaultTypeInternal _NotifyForgeRefineResult_default_instance_;
class NotifyFriendMessage;
struct NotifyFriendMessageDefaultTypeInternal;
MPROTOCOL_API extern NotifyFriendMessageDefaultTypeInternal _NotifyFriendMessage_default_instance_;
class NotifyFuZeng;
struct NotifyFuZengDefaultTypeInternal;
MPROTOCOL_API extern NotifyFuZengDefaultTypeInternal _NotifyFuZeng_default_instance_;
class NotifyInventoryFullMailItem;
struct NotifyInventoryFullMailItemDefaultTypeInternal;
MPROTOCOL_API extern NotifyInventoryFullMailItemDefaultTypeInternal _NotifyInventoryFullMailItem_default_instance_;
class NotifyInventorySpaceNum;
struct NotifyInventorySpaceNumDefaultTypeInternal;
MPROTOCOL_API extern NotifyInventorySpaceNumDefaultTypeInternal _NotifyInventorySpaceNum_default_instance_;
class NotifyMonsterTowerChallengeOver;
struct NotifyMonsterTowerChallengeOverDefaultTypeInternal;
MPROTOCOL_API extern NotifyMonsterTowerChallengeOverDefaultTypeInternal _NotifyMonsterTowerChallengeOver_default_instance_;
class NotifyMonsterTowerData;
struct NotifyMonsterTowerDataDefaultTypeInternal;
MPROTOCOL_API extern NotifyMonsterTowerDataDefaultTypeInternal _NotifyMonsterTowerData_default_instance_;
class NotifyQiCollectorRank;
struct NotifyQiCollectorRankDefaultTypeInternal;
MPROTOCOL_API extern NotifyQiCollectorRankDefaultTypeInternal _NotifyQiCollectorRank_default_instance_;
class NotifyQuestFightChallengeOver;
struct NotifyQuestFightChallengeOverDefaultTypeInternal;
MPROTOCOL_API extern NotifyQuestFightChallengeOverDefaultTypeInternal _NotifyQuestFightChallengeOver_default_instance_;
class NotifyRoleCollectionData;
struct NotifyRoleCollectionDataDefaultTypeInternal;
MPROTOCOL_API extern NotifyRoleCollectionDataDefaultTypeInternal _NotifyRoleCollectionData_default_instance_;
class NotifyRoleCollectionHistories;
struct NotifyRoleCollectionHistoriesDefaultTypeInternal;
MPROTOCOL_API extern NotifyRoleCollectionHistoriesDefaultTypeInternal _NotifyRoleCollectionHistories_default_instance_;
class NotifyRoleCollectionNextResetEnhanceTicks;
struct NotifyRoleCollectionNextResetEnhanceTicksDefaultTypeInternal;
MPROTOCOL_API extern NotifyRoleCollectionNextResetEnhanceTicksDefaultTypeInternal _NotifyRoleCollectionNextResetEnhanceTicks_default_instance_;
class NotifyRoleCombatPower;
struct NotifyRoleCombatPowerDefaultTypeInternal;
MPROTOCOL_API extern NotifyRoleCombatPowerDefaultTypeInternal _NotifyRoleCombatPower_default_instance_;
class NotifySoloArenaChallengeOver;
struct NotifySoloArenaChallengeOverDefaultTypeInternal;
MPROTOCOL_API extern NotifySoloArenaChallengeOverDefaultTypeInternal _NotifySoloArenaChallengeOver_default_instance_;
class NotifyUnlockArenaChallengeResult;
struct NotifyUnlockArenaChallengeResultDefaultTypeInternal;
MPROTOCOL_API extern NotifyUnlockArenaChallengeResultDefaultTypeInternal _NotifyUnlockArenaChallengeResult_default_instance_;
class NotifyUnlockedModuels;
struct NotifyUnlockedModuelsDefaultTypeInternal;
MPROTOCOL_API extern NotifyUnlockedModuelsDefaultTypeInternal _NotifyUnlockedModuels_default_instance_;
class OneClickDeleteMailAck;
struct OneClickDeleteMailAckDefaultTypeInternal;
MPROTOCOL_API extern OneClickDeleteMailAckDefaultTypeInternal _OneClickDeleteMailAck_default_instance_;
class OneClickDeleteMailReq;
struct OneClickDeleteMailReqDefaultTypeInternal;
MPROTOCOL_API extern OneClickDeleteMailReqDefaultTypeInternal _OneClickDeleteMailReq_default_instance_;
class OneClickGetMailAttachmentAck;
struct OneClickGetMailAttachmentAckDefaultTypeInternal;
MPROTOCOL_API extern OneClickGetMailAttachmentAckDefaultTypeInternal _OneClickGetMailAttachmentAck_default_instance_;
class OneClickGetMailAttachmentReq;
struct OneClickGetMailAttachmentReqDefaultTypeInternal;
MPROTOCOL_API extern OneClickGetMailAttachmentReqDefaultTypeInternal _OneClickGetMailAttachmentReq_default_instance_;
class OneClickMergeBreathingAck;
struct OneClickMergeBreathingAckDefaultTypeInternal;
MPROTOCOL_API extern OneClickMergeBreathingAckDefaultTypeInternal _OneClickMergeBreathingAck_default_instance_;
class OneClickMergeBreathingReq;
struct OneClickMergeBreathingReqDefaultTypeInternal;
MPROTOCOL_API extern OneClickMergeBreathingReqDefaultTypeInternal _OneClickMergeBreathingReq_default_instance_;
class OneClickOpenTreasuryChestAck;
struct OneClickOpenTreasuryChestAckDefaultTypeInternal;
MPROTOCOL_API extern OneClickOpenTreasuryChestAckDefaultTypeInternal _OneClickOpenTreasuryChestAck_default_instance_;
class OneClickOpenTreasuryChestReq;
struct OneClickOpenTreasuryChestReqDefaultTypeInternal;
MPROTOCOL_API extern OneClickOpenTreasuryChestReqDefaultTypeInternal _OneClickOpenTreasuryChestReq_default_instance_;
class OneClickReadMailAck;
struct OneClickReadMailAckDefaultTypeInternal;
MPROTOCOL_API extern OneClickReadMailAckDefaultTypeInternal _OneClickReadMailAck_default_instance_;
class OneClickReadMailReq;
struct OneClickReadMailReqDefaultTypeInternal;
MPROTOCOL_API extern OneClickReadMailReqDefaultTypeInternal _OneClickReadMailReq_default_instance_;
class OneClickUsePillElixirAck;
struct OneClickUsePillElixirAckDefaultTypeInternal;
MPROTOCOL_API extern OneClickUsePillElixirAckDefaultTypeInternal _OneClickUsePillElixirAck_default_instance_;
class OneClickUsePillElixirReq;
struct OneClickUsePillElixirReqDefaultTypeInternal;
MPROTOCOL_API extern OneClickUsePillElixirReqDefaultTypeInternal _OneClickUsePillElixirReq_default_instance_;
class OpenTreasuryChestAck;
struct OpenTreasuryChestAckDefaultTypeInternal;
MPROTOCOL_API extern OpenTreasuryChestAckDefaultTypeInternal _OpenTreasuryChestAck_default_instance_;
class OpenTreasuryChestReq;
struct OpenTreasuryChestReqDefaultTypeInternal;
MPROTOCOL_API extern OpenTreasuryChestReqDefaultTypeInternal _OpenTreasuryChestReq_default_instance_;
class OpenTreasuryGachaAck;
struct OpenTreasuryGachaAckDefaultTypeInternal;
MPROTOCOL_API extern OpenTreasuryGachaAckDefaultTypeInternal _OpenTreasuryGachaAck_default_instance_;
class OpenTreasuryGachaReq;
struct OpenTreasuryGachaReqDefaultTypeInternal;
MPROTOCOL_API extern OpenTreasuryGachaReqDefaultTypeInternal _OpenTreasuryGachaReq_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
MPROTOCOL_API extern PingDefaultTypeInternal _Ping_default_instance_;
class Pong;
struct PongDefaultTypeInternal;
MPROTOCOL_API extern PongDefaultTypeInternal _Pong_default_instance_;
class QiWenEquipmentAck;
struct QiWenEquipmentAckDefaultTypeInternal;
MPROTOCOL_API extern QiWenEquipmentAckDefaultTypeInternal _QiWenEquipmentAck_default_instance_;
class QiWenEquipmentReq;
struct QiWenEquipmentReqDefaultTypeInternal;
MPROTOCOL_API extern QiWenEquipmentReqDefaultTypeInternal _QiWenEquipmentReq_default_instance_;
class QuestFightQuickEndAck;
struct QuestFightQuickEndAckDefaultTypeInternal;
MPROTOCOL_API extern QuestFightQuickEndAckDefaultTypeInternal _QuestFightQuickEndAck_default_instance_;
class QuestFightQuickEndReq;
struct QuestFightQuickEndReqDefaultTypeInternal;
MPROTOCOL_API extern QuestFightQuickEndReqDefaultTypeInternal _QuestFightQuickEndReq_default_instance_;
class QuestOpAck;
struct QuestOpAckDefaultTypeInternal;
MPROTOCOL_API extern QuestOpAckDefaultTypeInternal _QuestOpAck_default_instance_;
class QuestOpReq;
struct QuestOpReqDefaultTypeInternal;
MPROTOCOL_API extern QuestOpReqDefaultTypeInternal _QuestOpReq_default_instance_;
class ReadMailAck;
struct ReadMailAckDefaultTypeInternal;
MPROTOCOL_API extern ReadMailAckDefaultTypeInternal _ReadMailAck_default_instance_;
class ReadMailReq;
struct ReadMailReqDefaultTypeInternal;
MPROTOCOL_API extern ReadMailReqDefaultTypeInternal _ReadMailReq_default_instance_;
class ReceiveAvatarTempPackageAck;
struct ReceiveAvatarTempPackageAckDefaultTypeInternal;
MPROTOCOL_API extern ReceiveAvatarTempPackageAckDefaultTypeInternal _ReceiveAvatarTempPackageAck_default_instance_;
class ReceiveAvatarTempPackageReq;
struct ReceiveAvatarTempPackageReqDefaultTypeInternal;
MPROTOCOL_API extern ReceiveAvatarTempPackageReqDefaultTypeInternal _ReceiveAvatarTempPackageReq_default_instance_;
class ReceiveBiographyEventItemAck;
struct ReceiveBiographyEventItemAckDefaultTypeInternal;
MPROTOCOL_API extern ReceiveBiographyEventItemAckDefaultTypeInternal _ReceiveBiographyEventItemAck_default_instance_;
class ReceiveBiographyEventItemReq;
struct ReceiveBiographyEventItemReqDefaultTypeInternal;
MPROTOCOL_API extern ReceiveBiographyEventItemReqDefaultTypeInternal _ReceiveBiographyEventItemReq_default_instance_;
class ReceiveBiographyItemAck;
struct ReceiveBiographyItemAckDefaultTypeInternal;
MPROTOCOL_API extern ReceiveBiographyItemAckDefaultTypeInternal _ReceiveBiographyItemAck_default_instance_;
class ReceiveBiographyItemReq;
struct ReceiveBiographyItemReqDefaultTypeInternal;
MPROTOCOL_API extern ReceiveBiographyItemReqDefaultTypeInternal _ReceiveBiographyItemReq_default_instance_;
class ReceiveBreathingExerciseRewardAck;
struct ReceiveBreathingExerciseRewardAckDefaultTypeInternal;
MPROTOCOL_API extern ReceiveBreathingExerciseRewardAckDefaultTypeInternal _ReceiveBreathingExerciseRewardAck_default_instance_;
class ReceiveBreathingExerciseRewardReq;
struct ReceiveBreathingExerciseRewardReqDefaultTypeInternal;
MPROTOCOL_API extern ReceiveBreathingExerciseRewardReqDefaultTypeInternal _ReceiveBreathingExerciseRewardReq_default_instance_;
class ReceiveFuZengRewardsAck;
struct ReceiveFuZengRewardsAckDefaultTypeInternal;
MPROTOCOL_API extern ReceiveFuZengRewardsAckDefaultTypeInternal _ReceiveFuZengRewardsAck_default_instance_;
class ReceiveFuZengRewardsReq;
struct ReceiveFuZengRewardsReqDefaultTypeInternal;
MPROTOCOL_API extern ReceiveFuZengRewardsReqDefaultTypeInternal _ReceiveFuZengRewardsReq_default_instance_;
class RefineEquipmentAck;
struct RefineEquipmentAckDefaultTypeInternal;
MPROTOCOL_API extern RefineEquipmentAckDefaultTypeInternal _RefineEquipmentAck_default_instance_;
class RefineEquipmentReq;
struct RefineEquipmentReqDefaultTypeInternal;
MPROTOCOL_API extern RefineEquipmentReqDefaultTypeInternal _RefineEquipmentReq_default_instance_;
class RefreshAlchemyData;
struct RefreshAlchemyDataDefaultTypeInternal;
MPROTOCOL_API extern RefreshAlchemyDataDefaultTypeInternal _RefreshAlchemyData_default_instance_;
class RefreshCultivationData;
struct RefreshCultivationDataDefaultTypeInternal;
MPROTOCOL_API extern RefreshCultivationDataDefaultTypeInternal _RefreshCultivationData_default_instance_;
class RefreshCultivationRankData;
struct RefreshCultivationRankDataDefaultTypeInternal;
MPROTOCOL_API extern RefreshCultivationRankDataDefaultTypeInternal _RefreshCultivationRankData_default_instance_;
class RefreshCurrencyData;
struct RefreshCurrencyDataDefaultTypeInternal;
MPROTOCOL_API extern RefreshCurrencyDataDefaultTypeInternal _RefreshCurrencyData_default_instance_;
class RefreshCurrentCultivationDirection;
struct RefreshCurrentCultivationDirectionDefaultTypeInternal;
MPROTOCOL_API extern RefreshCurrentCultivationDirectionDefaultTypeInternal _RefreshCurrentCultivationDirection_default_instance_;
class RefreshDailyCounterData;
struct RefreshDailyCounterDataDefaultTypeInternal;
MPROTOCOL_API extern RefreshDailyCounterDataDefaultTypeInternal _RefreshDailyCounterData_default_instance_;
class RefreshDeluxeShopAck;
struct RefreshDeluxeShopAckDefaultTypeInternal;
MPROTOCOL_API extern RefreshDeluxeShopAckDefaultTypeInternal _RefreshDeluxeShopAck_default_instance_;
class RefreshDeluxeShopReq;
struct RefreshDeluxeShopReqDefaultTypeInternal;
MPROTOCOL_API extern RefreshDeluxeShopReqDefaultTypeInternal _RefreshDeluxeShopReq_default_instance_;
class RefreshDeluxeShopUnlocked;
struct RefreshDeluxeShopUnlockedDefaultTypeInternal;
MPROTOCOL_API extern RefreshDeluxeShopUnlockedDefaultTypeInternal _RefreshDeluxeShopUnlocked_default_instance_;
class RefreshForgeData;
struct RefreshForgeDataDefaultTypeInternal;
MPROTOCOL_API extern RefreshForgeDataDefaultTypeInternal _RefreshForgeData_default_instance_;
class RefreshInventoryData;
struct RefreshInventoryDataDefaultTypeInternal;
MPROTOCOL_API extern RefreshInventoryDataDefaultTypeInternal _RefreshInventoryData_default_instance_;
class RefreshItems;
struct RefreshItemsDefaultTypeInternal;
MPROTOCOL_API extern RefreshItemsDefaultTypeInternal _RefreshItems_default_instance_;
class RefreshLastUnlockArenaId;
struct RefreshLastUnlockArenaIdDefaultTypeInternal;
MPROTOCOL_API extern RefreshLastUnlockArenaIdDefaultTypeInternal _RefreshLastUnlockArenaId_default_instance_;
class RefreshRoleNormalSetting;
struct RefreshRoleNormalSettingDefaultTypeInternal;
MPROTOCOL_API extern RefreshRoleNormalSettingDefaultTypeInternal _RefreshRoleNormalSetting_default_instance_;
class RefreshSeptQuestAck;
struct RefreshSeptQuestAckDefaultTypeInternal;
MPROTOCOL_API extern RefreshSeptQuestAckDefaultTypeInternal _RefreshSeptQuestAck_default_instance_;
class RefreshSeptQuestReq;
struct RefreshSeptQuestReqDefaultTypeInternal;
MPROTOCOL_API extern RefreshSeptQuestReqDefaultTypeInternal _RefreshSeptQuestReq_default_instance_;
class RefreshShopAck;
struct RefreshShopAckDefaultTypeInternal;
MPROTOCOL_API extern RefreshShopAckDefaultTypeInternal _RefreshShopAck_default_instance_;
class RefreshShopReq;
struct RefreshShopReqDefaultTypeInternal;
MPROTOCOL_API extern RefreshShopReqDefaultTypeInternal _RefreshShopReq_default_instance_;
class RefreshTemporaryPackageItems;
struct RefreshTemporaryPackageItemsDefaultTypeInternal;
MPROTOCOL_API extern RefreshTemporaryPackageItemsDefaultTypeInternal _RefreshTemporaryPackageItems_default_instance_;
class RefreshTreasuryShopAck;
struct RefreshTreasuryShopAckDefaultTypeInternal;
MPROTOCOL_API extern RefreshTreasuryShopAckDefaultTypeInternal _RefreshTreasuryShopAck_default_instance_;
class RefreshTreasuryShopReq;
struct RefreshTreasuryShopReqDefaultTypeInternal;
MPROTOCOL_API extern RefreshTreasuryShopReqDefaultTypeInternal _RefreshTreasuryShopReq_default_instance_;
class RefreshUnlockedEquipmentSlots;
struct RefreshUnlockedEquipmentSlotsDefaultTypeInternal;
MPROTOCOL_API extern RefreshUnlockedEquipmentSlotsDefaultTypeInternal _RefreshUnlockedEquipmentSlots_default_instance_;
class ReinforceEquipmentAck;
struct ReinforceEquipmentAckDefaultTypeInternal;
MPROTOCOL_API extern ReinforceEquipmentAckDefaultTypeInternal _ReinforceEquipmentAck_default_instance_;
class ReinforceEquipmentReq;
struct ReinforceEquipmentReqDefaultTypeInternal;
MPROTOCOL_API extern ReinforceEquipmentReqDefaultTypeInternal _ReinforceEquipmentReq_default_instance_;
class ReplaySoloArenaHistoryAck;
struct ReplaySoloArenaHistoryAckDefaultTypeInternal;
MPROTOCOL_API extern ReplaySoloArenaHistoryAckDefaultTypeInternal _ReplaySoloArenaHistoryAck_default_instance_;
class ReplaySoloArenaHistoryReq;
struct ReplaySoloArenaHistoryReqDefaultTypeInternal;
MPROTOCOL_API extern ReplaySoloArenaHistoryReqDefaultTypeInternal _ReplaySoloArenaHistoryReq_default_instance_;
class ReplicateQuestProgressChange;
struct ReplicateQuestProgressChangeDefaultTypeInternal;
MPROTOCOL_API extern ReplicateQuestProgressChangeDefaultTypeInternal _ReplicateQuestProgressChange_default_instance_;
class ReplyFriendRequestAck;
struct ReplyFriendRequestAckDefaultTypeInternal;
MPROTOCOL_API extern ReplyFriendRequestAckDefaultTypeInternal _ReplyFriendRequestAck_default_instance_;
class ReplyFriendRequestReq;
struct ReplyFriendRequestReqDefaultTypeInternal;
MPROTOCOL_API extern ReplyFriendRequestReqDefaultTypeInternal _ReplyFriendRequestReq_default_instance_;
class ReportError;
struct ReportErrorDefaultTypeInternal;
MPROTOCOL_API extern ReportErrorDefaultTypeInternal _ReportError_default_instance_;
class ReqRoleSeptQuestOpAck;
struct ReqRoleSeptQuestOpAckDefaultTypeInternal;
MPROTOCOL_API extern ReqRoleSeptQuestOpAckDefaultTypeInternal _ReqRoleSeptQuestOpAck_default_instance_;
class ReqRoleSeptQuestOpReq;
struct ReqRoleSeptQuestOpReqDefaultTypeInternal;
MPROTOCOL_API extern ReqRoleSeptQuestOpReqDefaultTypeInternal _ReqRoleSeptQuestOpReq_default_instance_;
class ReqSeptQuestRankUpAck;
struct ReqSeptQuestRankUpAckDefaultTypeInternal;
MPROTOCOL_API extern ReqSeptQuestRankUpAckDefaultTypeInternal _ReqSeptQuestRankUpAck_default_instance_;
class ReqSeptQuestRankUpReq;
struct ReqSeptQuestRankUpReqDefaultTypeInternal;
MPROTOCOL_API extern ReqSeptQuestRankUpReqDefaultTypeInternal _ReqSeptQuestRankUpReq_default_instance_;
class RequestCommonCultivationDataAck;
struct RequestCommonCultivationDataAckDefaultTypeInternal;
MPROTOCOL_API extern RequestCommonCultivationDataAckDefaultTypeInternal _RequestCommonCultivationDataAck_default_instance_;
class RequestCommonCultivationDataReq;
struct RequestCommonCultivationDataReqDefaultTypeInternal;
MPROTOCOL_API extern RequestCommonCultivationDataReqDefaultTypeInternal _RequestCommonCultivationDataReq_default_instance_;
class RequestEnterSeptDemonWorldAck;
struct RequestEnterSeptDemonWorldAckDefaultTypeInternal;
MPROTOCOL_API extern RequestEnterSeptDemonWorldAckDefaultTypeInternal _RequestEnterSeptDemonWorldAck_default_instance_;
class RequestEnterSeptDemonWorldReq;
struct RequestEnterSeptDemonWorldReqDefaultTypeInternal;
MPROTOCOL_API extern RequestEnterSeptDemonWorldReqDefaultTypeInternal _RequestEnterSeptDemonWorldReq_default_instance_;
class RequestInSeptDemonWorldEndTimeAck;
struct RequestInSeptDemonWorldEndTimeAckDefaultTypeInternal;
MPROTOCOL_API extern RequestInSeptDemonWorldEndTimeAckDefaultTypeInternal _RequestInSeptDemonWorldEndTimeAck_default_instance_;
class RequestInSeptDemonWorldEndTimeReq;
struct RequestInSeptDemonWorldEndTimeReqDefaultTypeInternal;
MPROTOCOL_API extern RequestInSeptDemonWorldEndTimeReqDefaultTypeInternal _RequestInSeptDemonWorldEndTimeReq_default_instance_;
class RequestLeaveSeptDemonWorldAck;
struct RequestLeaveSeptDemonWorldAckDefaultTypeInternal;
MPROTOCOL_API extern RequestLeaveSeptDemonWorldAckDefaultTypeInternal _RequestLeaveSeptDemonWorldAck_default_instance_;
class RequestLeaveSeptDemonWorldReq;
struct RequestLeaveSeptDemonWorldReqDefaultTypeInternal;
MPROTOCOL_API extern RequestLeaveSeptDemonWorldReqDefaultTypeInternal _RequestLeaveSeptDemonWorldReq_default_instance_;
class RequestModifyPillElixirFilterAck;
struct RequestModifyPillElixirFilterAckDefaultTypeInternal;
MPROTOCOL_API extern RequestModifyPillElixirFilterAckDefaultTypeInternal _RequestModifyPillElixirFilterAck_default_instance_;
class RequestModifyPillElixirFilterReq;
struct RequestModifyPillElixirFilterReqDefaultTypeInternal;
MPROTOCOL_API extern RequestModifyPillElixirFilterReqDefaultTypeInternal _RequestModifyPillElixirFilterReq_default_instance_;
class RequestPillElixirDataAck;
struct RequestPillElixirDataAckDefaultTypeInternal;
MPROTOCOL_API extern RequestPillElixirDataAckDefaultTypeInternal _RequestPillElixirDataAck_default_instance_;
class RequestPillElixirDataReq;
struct RequestPillElixirDataReqDefaultTypeInternal;
MPROTOCOL_API extern RequestPillElixirDataReqDefaultTypeInternal _RequestPillElixirDataReq_default_instance_;
class RequestRefreshRoleCombatPower;
struct RequestRefreshRoleCombatPowerDefaultTypeInternal;
MPROTOCOL_API extern RequestRefreshRoleCombatPowerDefaultTypeInternal _RequestRefreshRoleCombatPower_default_instance_;
class RequestSeptDemonWorldDataAck;
struct RequestSeptDemonWorldDataAckDefaultTypeInternal;
MPROTOCOL_API extern RequestSeptDemonWorldDataAckDefaultTypeInternal _RequestSeptDemonWorldDataAck_default_instance_;
class RequestSeptDemonWorldDataReq;
struct RequestSeptDemonWorldDataReqDefaultTypeInternal;
MPROTOCOL_API extern RequestSeptDemonWorldDataReqDefaultTypeInternal _RequestSeptDemonWorldDataReq_default_instance_;
class ResetEquipmentAck;
struct ResetEquipmentAckDefaultTypeInternal;
MPROTOCOL_API extern ResetEquipmentAckDefaultTypeInternal _ResetEquipmentAck_default_instance_;
class ResetEquipmentReq;
struct ResetEquipmentReqDefaultTypeInternal;
MPROTOCOL_API extern ResetEquipmentReqDefaultTypeInternal _ResetEquipmentReq_default_instance_;
class RoleBattleHistoryList;
struct RoleBattleHistoryListDefaultTypeInternal;
MPROTOCOL_API extern RoleBattleHistoryListDefaultTypeInternal _RoleBattleHistoryList_default_instance_;
class RoleCollectionOpAck;
struct RoleCollectionOpAckDefaultTypeInternal;
MPROTOCOL_API extern RoleCollectionOpAckDefaultTypeInternal _RoleCollectionOpAck_default_instance_;
class RoleCollectionOpReq;
struct RoleCollectionOpReqDefaultTypeInternal;
MPROTOCOL_API extern RoleCollectionOpReqDefaultTypeInternal _RoleCollectionOpReq_default_instance_;
class SellItemAck;
struct SellItemAckDefaultTypeInternal;
MPROTOCOL_API extern SellItemAckDefaultTypeInternal _SellItemAck_default_instance_;
class SellItemInfo;
struct SellItemInfoDefaultTypeInternal;
MPROTOCOL_API extern SellItemInfoDefaultTypeInternal _SellItemInfo_default_instance_;
class SellItemReq;
struct SellItemReqDefaultTypeInternal;
MPROTOCOL_API extern SellItemReqDefaultTypeInternal _SellItemReq_default_instance_;
class SendChatMessageAck;
struct SendChatMessageAckDefaultTypeInternal;
MPROTOCOL_API extern SendChatMessageAckDefaultTypeInternal _SendChatMessageAck_default_instance_;
class SendChatMessageReq;
struct SendChatMessageReqDefaultTypeInternal;
MPROTOCOL_API extern SendChatMessageReqDefaultTypeInternal _SendChatMessageReq_default_instance_;
class SetAttackLockTypeAck;
struct SetAttackLockTypeAckDefaultTypeInternal;
MPROTOCOL_API extern SetAttackLockTypeAckDefaultTypeInternal _SetAttackLockTypeAck_default_instance_;
class SetAttackLockTypeReq;
struct SetAttackLockTypeReqDefaultTypeInternal;
MPROTOCOL_API extern SetAttackLockTypeReqDefaultTypeInternal _SetAttackLockTypeReq_default_instance_;
class SetAttackUnlockTypeAck;
struct SetAttackUnlockTypeAckDefaultTypeInternal;
MPROTOCOL_API extern SetAttackUnlockTypeAckDefaultTypeInternal _SetAttackUnlockTypeAck_default_instance_;
class SetAttackUnlockTypeReq;
struct SetAttackUnlockTypeReqDefaultTypeInternal;
MPROTOCOL_API extern SetAttackUnlockTypeReqDefaultTypeInternal _SetAttackUnlockTypeReq_default_instance_;
class SetAutoMode;
struct SetAutoModeDefaultTypeInternal;
MPROTOCOL_API extern SetAutoModeDefaultTypeInternal _SetAutoMode_default_instance_;
class SetCurrentCultivationDirectionAck;
struct SetCurrentCultivationDirectionAckDefaultTypeInternal;
MPROTOCOL_API extern SetCurrentCultivationDirectionAckDefaultTypeInternal _SetCurrentCultivationDirectionAck_default_instance_;
class SetCurrentCultivationDirectionReq;
struct SetCurrentCultivationDirectionReqDefaultTypeInternal;
MPROTOCOL_API extern SetCurrentCultivationDirectionReqDefaultTypeInternal _SetCurrentCultivationDirectionReq_default_instance_;
class SetFightModeAck;
struct SetFightModeAckDefaultTypeInternal;
MPROTOCOL_API extern SetFightModeAckDefaultTypeInternal _SetFightModeAck_default_instance_;
class SetFightModeReq;
struct SetFightModeReqDefaultTypeInternal;
MPROTOCOL_API extern SetFightModeReqDefaultTypeInternal _SetFightModeReq_default_instance_;
class SetShanhetuUseConfigAck;
struct SetShanhetuUseConfigAckDefaultTypeInternal;
MPROTOCOL_API extern SetShanhetuUseConfigAckDefaultTypeInternal _SetShanhetuUseConfigAck_default_instance_;
class SetShanhetuUseConfigReq;
struct SetShanhetuUseConfigReqDefaultTypeInternal;
MPROTOCOL_API extern SetShanhetuUseConfigReqDefaultTypeInternal _SetShanhetuUseConfigReq_default_instance_;
class SetShowUnlockButtonAck;
struct SetShowUnlockButtonAckDefaultTypeInternal;
MPROTOCOL_API extern SetShowUnlockButtonAckDefaultTypeInternal _SetShowUnlockButtonAck_default_instance_;
class SetShowUnlockButtonReq;
struct SetShowUnlockButtonReqDefaultTypeInternal;
MPROTOCOL_API extern SetShowUnlockButtonReqDefaultTypeInternal _SetShowUnlockButtonReq_default_instance_;
class SetUserVar;
struct SetUserVarDefaultTypeInternal;
MPROTOCOL_API extern SetUserVarDefaultTypeInternal _SetUserVar_default_instance_;
class ShareSelfItemReq;
struct ShareSelfItemReqDefaultTypeInternal;
MPROTOCOL_API extern ShareSelfItemReqDefaultTypeInternal _ShareSelfItemReq_default_instance_;
class ShareSelfItemRsp;
struct ShareSelfItemRspDefaultTypeInternal;
MPROTOCOL_API extern ShareSelfItemRspDefaultTypeInternal _ShareSelfItemRsp_default_instance_;
class ShareSelfItemsReq;
struct ShareSelfItemsReqDefaultTypeInternal;
MPROTOCOL_API extern ShareSelfItemsReqDefaultTypeInternal _ShareSelfItemsReq_default_instance_;
class ShareSelfItemsRsp;
struct ShareSelfItemsRspDefaultTypeInternal;
MPROTOCOL_API extern ShareSelfItemsRspDefaultTypeInternal _ShareSelfItemsRsp_default_instance_;
class ShareSelfRoleCollectionReq;
struct ShareSelfRoleCollectionReqDefaultTypeInternal;
MPROTOCOL_API extern ShareSelfRoleCollectionReqDefaultTypeInternal _ShareSelfRoleCollectionReq_default_instance_;
class ShareSelfRoleCollectionRsp;
struct ShareSelfRoleCollectionRspDefaultTypeInternal;
MPROTOCOL_API extern ShareSelfRoleCollectionRspDefaultTypeInternal _ShareSelfRoleCollectionRsp_default_instance_;
class SoloArenaChallengeAck;
struct SoloArenaChallengeAckDefaultTypeInternal;
MPROTOCOL_API extern SoloArenaChallengeAckDefaultTypeInternal _SoloArenaChallengeAck_default_instance_;
class SoloArenaChallengeReq;
struct SoloArenaChallengeReqDefaultTypeInternal;
MPROTOCOL_API extern SoloArenaChallengeReqDefaultTypeInternal _SoloArenaChallengeReq_default_instance_;
class SoloArenaQuickEndAck;
struct SoloArenaQuickEndAckDefaultTypeInternal;
MPROTOCOL_API extern SoloArenaQuickEndAckDefaultTypeInternal _SoloArenaQuickEndAck_default_instance_;
class SoloArenaQuickEndReq;
struct SoloArenaQuickEndReqDefaultTypeInternal;
MPROTOCOL_API extern SoloArenaQuickEndReqDefaultTypeInternal _SoloArenaQuickEndReq_default_instance_;
class StepShanhetuAck;
struct StepShanhetuAckDefaultTypeInternal;
MPROTOCOL_API extern StepShanhetuAckDefaultTypeInternal _StepShanhetuAck_default_instance_;
class StepShanhetuReq;
struct StepShanhetuReqDefaultTypeInternal;
MPROTOCOL_API extern StepShanhetuReqDefaultTypeInternal _StepShanhetuReq_default_instance_;
class SynthesisCommonItemAck;
struct SynthesisCommonItemAckDefaultTypeInternal;
MPROTOCOL_API extern SynthesisCommonItemAckDefaultTypeInternal _SynthesisCommonItemAck_default_instance_;
class SynthesisCommonItemReq;
struct SynthesisCommonItemReqDefaultTypeInternal;
MPROTOCOL_API extern SynthesisCommonItemReqDefaultTypeInternal _SynthesisCommonItemReq_default_instance_;
class SystemNotice;
struct SystemNoticeDefaultTypeInternal;
MPROTOCOL_API extern SystemNoticeDefaultTypeInternal _SystemNotice_default_instance_;
class ThunderTestData;
struct ThunderTestDataDefaultTypeInternal;
MPROTOCOL_API extern ThunderTestDataDefaultTypeInternal _ThunderTestData_default_instance_;
class ThunderTestRoundData;
struct ThunderTestRoundDataDefaultTypeInternal;
MPROTOCOL_API extern ThunderTestRoundDataDefaultTypeInternal _ThunderTestRoundData_default_instance_;
class TradePillElixirAck;
struct TradePillElixirAckDefaultTypeInternal;
MPROTOCOL_API extern TradePillElixirAckDefaultTypeInternal _TradePillElixirAck_default_instance_;
class TradePillElixirReq;
struct TradePillElixirReqDefaultTypeInternal;
MPROTOCOL_API extern TradePillElixirReqDefaultTypeInternal _TradePillElixirReq_default_instance_;
class TreasuryShopBuyAck;
struct TreasuryShopBuyAckDefaultTypeInternal;
MPROTOCOL_API extern TreasuryShopBuyAckDefaultTypeInternal _TreasuryShopBuyAck_default_instance_;
class TreasuryShopBuyReq;
struct TreasuryShopBuyReqDefaultTypeInternal;
MPROTOCOL_API extern TreasuryShopBuyReqDefaultTypeInternal _TreasuryShopBuyReq_default_instance_;
class UnlockArenaAck;
struct UnlockArenaAckDefaultTypeInternal;
MPROTOCOL_API extern UnlockArenaAckDefaultTypeInternal _UnlockArenaAck_default_instance_;
class UnlockArenaReq;
struct UnlockArenaReqDefaultTypeInternal;
MPROTOCOL_API extern UnlockArenaReqDefaultTypeInternal _UnlockArenaReq_default_instance_;
class UnlockDeluxeShopAck;
struct UnlockDeluxeShopAckDefaultTypeInternal;
MPROTOCOL_API extern UnlockDeluxeShopAckDefaultTypeInternal _UnlockDeluxeShopAck_default_instance_;
class UnlockDeluxeShopReq;
struct UnlockDeluxeShopReqDefaultTypeInternal;
MPROTOCOL_API extern UnlockDeluxeShopReqDefaultTypeInternal _UnlockDeluxeShopReq_default_instance_;
class UnlockEquipmentSlotAck;
struct UnlockEquipmentSlotAckDefaultTypeInternal;
MPROTOCOL_API extern UnlockEquipmentSlotAckDefaultTypeInternal _UnlockEquipmentSlotAck_default_instance_;
class UnlockEquipmentSlotReq;
struct UnlockEquipmentSlotReqDefaultTypeInternal;
MPROTOCOL_API extern UnlockEquipmentSlotReqDefaultTypeInternal _UnlockEquipmentSlotReq_default_instance_;
class UnlockFunctionModuleAck;
struct UnlockFunctionModuleAckDefaultTypeInternal;
MPROTOCOL_API extern UnlockFunctionModuleAckDefaultTypeInternal _UnlockFunctionModuleAck_default_instance_;
class UnlockFunctionModuleReq;
struct UnlockFunctionModuleReqDefaultTypeInternal;
MPROTOCOL_API extern UnlockFunctionModuleReqDefaultTypeInternal _UnlockFunctionModuleReq_default_instance_;
class UpdateChat;
struct UpdateChatDefaultTypeInternal;
MPROTOCOL_API extern UpdateChatDefaultTypeInternal _UpdateChat_default_instance_;
class UpdateChecklistAck;
struct UpdateChecklistAckDefaultTypeInternal;
MPROTOCOL_API extern UpdateChecklistAckDefaultTypeInternal _UpdateChecklistAck_default_instance_;
class UpdateChecklistReq;
struct UpdateChecklistReqDefaultTypeInternal;
MPROTOCOL_API extern UpdateChecklistReqDefaultTypeInternal _UpdateChecklistReq_default_instance_;
class UpdateFarmlandStateAck;
struct UpdateFarmlandStateAckDefaultTypeInternal;
MPROTOCOL_API extern UpdateFarmlandStateAckDefaultTypeInternal _UpdateFarmlandStateAck_default_instance_;
class UpdateFarmlandStateReq;
struct UpdateFarmlandStateReqDefaultTypeInternal;
MPROTOCOL_API extern UpdateFarmlandStateReqDefaultTypeInternal _UpdateFarmlandStateReq_default_instance_;
class UpdateLifeCounter;
struct UpdateLifeCounterDefaultTypeInternal;
MPROTOCOL_API extern UpdateLifeCounterDefaultTypeInternal _UpdateLifeCounter_default_instance_;
class UpdateRoleMail;
struct UpdateRoleMailDefaultTypeInternal;
MPROTOCOL_API extern UpdateRoleMailDefaultTypeInternal _UpdateRoleMail_default_instance_;
class UpgradeQiCollectorAck;
struct UpgradeQiCollectorAckDefaultTypeInternal;
MPROTOCOL_API extern UpgradeQiCollectorAckDefaultTypeInternal _UpgradeQiCollectorAck_default_instance_;
class UpgradeQiCollectorReq;
struct UpgradeQiCollectorReqDefaultTypeInternal;
MPROTOCOL_API extern UpgradeQiCollectorReqDefaultTypeInternal _UpgradeQiCollectorReq_default_instance_;
class UseItemAck;
struct UseItemAckDefaultTypeInternal;
MPROTOCOL_API extern UseItemAckDefaultTypeInternal _UseItemAck_default_instance_;
class UseItemReq;
struct UseItemReqDefaultTypeInternal;
MPROTOCOL_API extern UseItemReqDefaultTypeInternal _UseItemReq_default_instance_;
class UsePillElixirAck;
struct UsePillElixirAckDefaultTypeInternal;
MPROTOCOL_API extern UsePillElixirAckDefaultTypeInternal _UsePillElixirAck_default_instance_;
class UsePillElixirReport;
struct UsePillElixirReportDefaultTypeInternal;
MPROTOCOL_API extern UsePillElixirReportDefaultTypeInternal _UsePillElixirReport_default_instance_;
class UsePillElixirReq;
struct UsePillElixirReqDefaultTypeInternal;
MPROTOCOL_API extern UsePillElixirReqDefaultTypeInternal _UsePillElixirReq_default_instance_;
class UseSelectGiftAck;
struct UseSelectGiftAckDefaultTypeInternal;
MPROTOCOL_API extern UseSelectGiftAckDefaultTypeInternal _UseSelectGiftAck_default_instance_;
class UseSelectGiftReq;
struct UseSelectGiftReqDefaultTypeInternal;
MPROTOCOL_API extern UseSelectGiftReqDefaultTypeInternal _UseSelectGiftReq_default_instance_;
class UseShanhetuAck;
struct UseShanhetuAckDefaultTypeInternal;
MPROTOCOL_API extern UseShanhetuAckDefaultTypeInternal _UseShanhetuAck_default_instance_;
class UseShanhetuReq;
struct UseShanhetuReqDefaultTypeInternal;
MPROTOCOL_API extern UseShanhetuReqDefaultTypeInternal _UseShanhetuReq_default_instance_;
class VipShopBuyAck;
struct VipShopBuyAckDefaultTypeInternal;
MPROTOCOL_API extern VipShopBuyAckDefaultTypeInternal _VipShopBuyAck_default_instance_;
class VipShopBuyReq;
struct VipShopBuyReqDefaultTypeInternal;
MPROTOCOL_API extern VipShopBuyReqDefaultTypeInternal _VipShopBuyReq_default_instance_;
}  // namespace idlepb
PROTOBUF_NAMESPACE_OPEN
template<> MPROTOCOL_API ::idlepb::ActivateGongFaMaxEffectAck* Arena::CreateMaybeMessage<::idlepb::ActivateGongFaMaxEffectAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ActivateGongFaMaxEffectReq* Arena::CreateMaybeMessage<::idlepb::ActivateGongFaMaxEffectReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::AddBiographyRoleLogAck* Arena::CreateMaybeMessage<::idlepb::AddBiographyRoleLogAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::AddBiographyRoleLogReq* Arena::CreateMaybeMessage<::idlepb::AddBiographyRoleLogReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::AlchemyRefineCancelAck* Arena::CreateMaybeMessage<::idlepb::AlchemyRefineCancelAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::AlchemyRefineCancelReq* Arena::CreateMaybeMessage<::idlepb::AlchemyRefineCancelReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::AlchemyRefineExtractAck* Arena::CreateMaybeMessage<::idlepb::AlchemyRefineExtractAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::AlchemyRefineExtractReq* Arena::CreateMaybeMessage<::idlepb::AlchemyRefineExtractReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::AlchemyRefineStartAck* Arena::CreateMaybeMessage<::idlepb::AlchemyRefineStartAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::AlchemyRefineStartReq* Arena::CreateMaybeMessage<::idlepb::AlchemyRefineStartReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::AppearanceActiveAck* Arena::CreateMaybeMessage<::idlepb::AppearanceActiveAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::AppearanceActiveReq* Arena::CreateMaybeMessage<::idlepb::AppearanceActiveReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::AppearanceAddAck* Arena::CreateMaybeMessage<::idlepb::AppearanceAddAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::AppearanceAddReq* Arena::CreateMaybeMessage<::idlepb::AppearanceAddReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::AppearanceBuyAck* Arena::CreateMaybeMessage<::idlepb::AppearanceBuyAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::AppearanceBuyReq* Arena::CreateMaybeMessage<::idlepb::AppearanceBuyReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::AppearanceChangeSkTypeAck* Arena::CreateMaybeMessage<::idlepb::AppearanceChangeSkTypeAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::AppearanceChangeSkTypeReq* Arena::CreateMaybeMessage<::idlepb::AppearanceChangeSkTypeReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::AppearanceWearAck* Arena::CreateMaybeMessage<::idlepb::AppearanceWearAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::AppearanceWearReq* Arena::CreateMaybeMessage<::idlepb::AppearanceWearReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ArenaCheckListRewardSubmitAck* Arena::CreateMaybeMessage<::idlepb::ArenaCheckListRewardSubmitAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ArenaCheckListRewardSubmitReq* Arena::CreateMaybeMessage<::idlepb::ArenaCheckListRewardSubmitReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ArenaCheckListSubmitAck* Arena::CreateMaybeMessage<::idlepb::ArenaCheckListSubmitAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ArenaCheckListSubmitReq* Arena::CreateMaybeMessage<::idlepb::ArenaCheckListSubmitReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::AvatarRankUpAck* Arena::CreateMaybeMessage<::idlepb::AvatarRankUpAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::AvatarRankUpReq* Arena::CreateMaybeMessage<::idlepb::AvatarRankUpReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::BuyDeluxeShopItemAck* Arena::CreateMaybeMessage<::idlepb::BuyDeluxeShopItemAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::BuyDeluxeShopItemReq* Arena::CreateMaybeMessage<::idlepb::BuyDeluxeShopItemReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::BuySeptShopItemAck* Arena::CreateMaybeMessage<::idlepb::BuySeptShopItemAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::BuySeptShopItemReq* Arena::CreateMaybeMessage<::idlepb::BuySeptShopItemReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::BuyShopItemAck* Arena::CreateMaybeMessage<::idlepb::BuyShopItemAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::BuyShopItemReq* Arena::CreateMaybeMessage<::idlepb::BuyShopItemReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ChecklistOpAck* Arena::CreateMaybeMessage<::idlepb::ChecklistOpAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ChecklistOpReq* Arena::CreateMaybeMessage<::idlepb::ChecklistOpReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ClearChatUnreadNumAck* Arena::CreateMaybeMessage<::idlepb::ClearChatUnreadNumAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ClearChatUnreadNumReq* Arena::CreateMaybeMessage<::idlepb::ClearChatUnreadNumReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::CollectionActivatedSuit* Arena::CreateMaybeMessage<::idlepb::CollectionActivatedSuit>(Arena*);
template<> MPROTOCOL_API ::idlepb::CreateCharacterAck* Arena::CreateMaybeMessage<::idlepb::CreateCharacterAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::CreateCharacterReq* Arena::CreateMaybeMessage<::idlepb::CreateCharacterReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::DelUserVar* Arena::CreateMaybeMessage<::idlepb::DelUserVar>(Arena*);
template<> MPROTOCOL_API ::idlepb::DeleteMailAck* Arena::CreateMaybeMessage<::idlepb::DeleteMailAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::DeleteMailReq* Arena::CreateMaybeMessage<::idlepb::DeleteMailReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::DeletePrivateChatRecordAck* Arena::CreateMaybeMessage<::idlepb::DeletePrivateChatRecordAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::DeletePrivateChatRecordReq* Arena::CreateMaybeMessage<::idlepb::DeletePrivateChatRecordReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::DispatchAvatarAck* Arena::CreateMaybeMessage<::idlepb::DispatchAvatarAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::DispatchAvatarReq* Arena::CreateMaybeMessage<::idlepb::DispatchAvatarReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::DoBreakthroughAck* Arena::CreateMaybeMessage<::idlepb::DoBreakthroughAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::DoBreakthroughReq* Arena::CreateMaybeMessage<::idlepb::DoBreakthroughReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::DoBreathingExerciseAck* Arena::CreateMaybeMessage<::idlepb::DoBreathingExerciseAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::DoBreathingExerciseReq* Arena::CreateMaybeMessage<::idlepb::DoBreathingExerciseReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::DoGmCommand* Arena::CreateMaybeMessage<::idlepb::DoGmCommand>(Arena*);
template<> MPROTOCOL_API ::idlepb::DoQuestFightAck* Arena::CreateMaybeMessage<::idlepb::DoQuestFightAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::DoQuestFightReq* Arena::CreateMaybeMessage<::idlepb::DoQuestFightReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::DungeonKillAllChallengeAck* Arena::CreateMaybeMessage<::idlepb::DungeonKillAllChallengeAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::DungeonKillAllChallengeReq* Arena::CreateMaybeMessage<::idlepb::DungeonKillAllChallengeReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::DungeonKillAllDataAck* Arena::CreateMaybeMessage<::idlepb::DungeonKillAllDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::DungeonKillAllDataReq* Arena::CreateMaybeMessage<::idlepb::DungeonKillAllDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::DungeonKillAllQuickEndAck* Arena::CreateMaybeMessage<::idlepb::DungeonKillAllQuickEndAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::DungeonKillAllQuickEndReq* Arena::CreateMaybeMessage<::idlepb::DungeonKillAllQuickEndReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::DungeonSurviveChallengeAck* Arena::CreateMaybeMessage<::idlepb::DungeonSurviveChallengeAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::DungeonSurviveChallengeReq* Arena::CreateMaybeMessage<::idlepb::DungeonSurviveChallengeReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::DungeonSurviveDataAck* Arena::CreateMaybeMessage<::idlepb::DungeonSurviveDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::DungeonSurviveDataReq* Arena::CreateMaybeMessage<::idlepb::DungeonSurviveDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::DungeonSurviveQuickEndAck* Arena::CreateMaybeMessage<::idlepb::DungeonSurviveQuickEndAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::DungeonSurviveQuickEndReq* Arena::CreateMaybeMessage<::idlepb::DungeonSurviveQuickEndReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::EquipmentPutOnAck* Arena::CreateMaybeMessage<::idlepb::EquipmentPutOnAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::EquipmentPutOnReq* Arena::CreateMaybeMessage<::idlepb::EquipmentPutOnReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::EquipmentTakeOffAck* Arena::CreateMaybeMessage<::idlepb::EquipmentTakeOffAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::EquipmentTakeOffReq* Arena::CreateMaybeMessage<::idlepb::EquipmentTakeOffReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ExchangeCommonItemAck* Arena::CreateMaybeMessage<::idlepb::ExchangeCommonItemAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ExchangeCommonItemReq* Arena::CreateMaybeMessage<::idlepb::ExchangeCommonItemReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ExtractTemporaryPackageItemsAck* Arena::CreateMaybeMessage<::idlepb::ExtractTemporaryPackageItemsAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ExtractTemporaryPackageItemsReq* Arena::CreateMaybeMessage<::idlepb::ExtractTemporaryPackageItemsReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmerRankUpAck* Arena::CreateMaybeMessage<::idlepb::FarmerRankUpAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmerRankUpReq* Arena::CreateMaybeMessage<::idlepb::FarmerRankUpReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmlandHarvestAck* Arena::CreateMaybeMessage<::idlepb::FarmlandHarvestAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmlandHarvestReq* Arena::CreateMaybeMessage<::idlepb::FarmlandHarvestReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmlandPlantSeedAck* Arena::CreateMaybeMessage<::idlepb::FarmlandPlantSeedAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmlandPlantSeedReq* Arena::CreateMaybeMessage<::idlepb::FarmlandPlantSeedReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmlandRipeningAck* Arena::CreateMaybeMessage<::idlepb::FarmlandRipeningAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmlandRipeningReq* Arena::CreateMaybeMessage<::idlepb::FarmlandRipeningReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmlandSetManagementAck* Arena::CreateMaybeMessage<::idlepb::FarmlandSetManagementAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmlandSetManagementReq* Arena::CreateMaybeMessage<::idlepb::FarmlandSetManagementReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmlandUnlockBlockAck* Arena::CreateMaybeMessage<::idlepb::FarmlandUnlockBlockAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmlandUnlockBlockReq* Arena::CreateMaybeMessage<::idlepb::FarmlandUnlockBlockReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmlandWateringAck* Arena::CreateMaybeMessage<::idlepb::FarmlandWateringAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::FarmlandWateringReq* Arena::CreateMaybeMessage<::idlepb::FarmlandWateringReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ForgeDestroyAck* Arena::CreateMaybeMessage<::idlepb::ForgeDestroyAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ForgeDestroyReq* Arena::CreateMaybeMessage<::idlepb::ForgeDestroyReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ForgeFindBackAck* Arena::CreateMaybeMessage<::idlepb::ForgeFindBackAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ForgeFindBackReq* Arena::CreateMaybeMessage<::idlepb::ForgeFindBackReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ForgeRefineCancelAck* Arena::CreateMaybeMessage<::idlepb::ForgeRefineCancelAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ForgeRefineCancelReq* Arena::CreateMaybeMessage<::idlepb::ForgeRefineCancelReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ForgeRefineExtractAck* Arena::CreateMaybeMessage<::idlepb::ForgeRefineExtractAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ForgeRefineExtractReq* Arena::CreateMaybeMessage<::idlepb::ForgeRefineExtractReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ForgeRefineStartAck* Arena::CreateMaybeMessage<::idlepb::ForgeRefineStartAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ForgeRefineStartReq* Arena::CreateMaybeMessage<::idlepb::ForgeRefineStartReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::FriendOpAck* Arena::CreateMaybeMessage<::idlepb::FriendOpAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::FriendOpReq* Arena::CreateMaybeMessage<::idlepb::FriendOpReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::FriendSearchRoleInfoAck* Arena::CreateMaybeMessage<::idlepb::FriendSearchRoleInfoAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::FriendSearchRoleInfoReq* Arena::CreateMaybeMessage<::idlepb::FriendSearchRoleInfoReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GameSystemChatMessage* Arena::CreateMaybeMessage<::idlepb::GameSystemChatMessage>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetAppearanceDataAck* Arena::CreateMaybeMessage<::idlepb::GetAppearanceDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetAppearanceDataReq* Arena::CreateMaybeMessage<::idlepb::GetAppearanceDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetArenaCheckListDataAck* Arena::CreateMaybeMessage<::idlepb::GetArenaCheckListDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetArenaCheckListDataReq* Arena::CreateMaybeMessage<::idlepb::GetArenaCheckListDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetArenaExplorationStatisticalDataAck* Arena::CreateMaybeMessage<::idlepb::GetArenaExplorationStatisticalDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetArenaExplorationStatisticalDataReq* Arena::CreateMaybeMessage<::idlepb::GetArenaExplorationStatisticalDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetBattleHistoryInfoAck* Arena::CreateMaybeMessage<::idlepb::GetBattleHistoryInfoAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetBattleHistoryInfoReq* Arena::CreateMaybeMessage<::idlepb::GetBattleHistoryInfoReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetBiographyEventDataAck* Arena::CreateMaybeMessage<::idlepb::GetBiographyEventDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetBiographyEventDataReq* Arena::CreateMaybeMessage<::idlepb::GetBiographyEventDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetChatRecordAck* Arena::CreateMaybeMessage<::idlepb::GetChatRecordAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetChatRecordReq* Arena::CreateMaybeMessage<::idlepb::GetChatRecordReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetChecklistDataAck* Arena::CreateMaybeMessage<::idlepb::GetChecklistDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetChecklistDataReq* Arena::CreateMaybeMessage<::idlepb::GetChecklistDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetCommonItemExchangeDataAck* Arena::CreateMaybeMessage<::idlepb::GetCommonItemExchangeDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetCommonItemExchangeDataReq* Arena::CreateMaybeMessage<::idlepb::GetCommonItemExchangeDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetFarmlandDataAck* Arena::CreateMaybeMessage<::idlepb::GetFarmlandDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetFarmlandDataReq* Arena::CreateMaybeMessage<::idlepb::GetFarmlandDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetForgeLostEquipmentDataAck* Arena::CreateMaybeMessage<::idlepb::GetForgeLostEquipmentDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetForgeLostEquipmentDataReq* Arena::CreateMaybeMessage<::idlepb::GetForgeLostEquipmentDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetFuZeRewardAck* Arena::CreateMaybeMessage<::idlepb::GetFuZeRewardAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetFuZeRewardReq* Arena::CreateMaybeMessage<::idlepb::GetFuZeRewardReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetGongFaDataAck* Arena::CreateMaybeMessage<::idlepb::GetGongFaDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetGongFaDataReq* Arena::CreateMaybeMessage<::idlepb::GetGongFaDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetInventoryDataAck* Arena::CreateMaybeMessage<::idlepb::GetInventoryDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetInventoryDataReq* Arena::CreateMaybeMessage<::idlepb::GetInventoryDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetLeaderboardDataAck* Arena::CreateMaybeMessage<::idlepb::GetLeaderboardDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetLeaderboardDataReq* Arena::CreateMaybeMessage<::idlepb::GetLeaderboardDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetLeaderboardPreviewAck* Arena::CreateMaybeMessage<::idlepb::GetLeaderboardPreviewAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetLeaderboardPreviewReq* Arena::CreateMaybeMessage<::idlepb::GetLeaderboardPreviewReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetLifeCounterDataAck* Arena::CreateMaybeMessage<::idlepb::GetLifeCounterDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetLifeCounterDataReq* Arena::CreateMaybeMessage<::idlepb::GetLifeCounterDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetMailAttachmentAck* Arena::CreateMaybeMessage<::idlepb::GetMailAttachmentAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetMailAttachmentReq* Arena::CreateMaybeMessage<::idlepb::GetMailAttachmentReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetMonsterTowerChallengeListAck* Arena::CreateMaybeMessage<::idlepb::GetMonsterTowerChallengeListAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetMonsterTowerChallengeListReq* Arena::CreateMaybeMessage<::idlepb::GetMonsterTowerChallengeListReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetMonsterTowerChallengeRewardAck* Arena::CreateMaybeMessage<::idlepb::GetMonsterTowerChallengeRewardAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetMonsterTowerChallengeRewardReq* Arena::CreateMaybeMessage<::idlepb::GetMonsterTowerChallengeRewardReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetOnePillElixirDataAck* Arena::CreateMaybeMessage<::idlepb::GetOnePillElixirDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetOnePillElixirDataReq* Arena::CreateMaybeMessage<::idlepb::GetOnePillElixirDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetQuestDataAck* Arena::CreateMaybeMessage<::idlepb::GetQuestDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetQuestDataReq* Arena::CreateMaybeMessage<::idlepb::GetQuestDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleAllStatsAck* Arena::CreateMaybeMessage<::idlepb::GetRoleAllStatsAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleAllStatsReq* Arena::CreateMaybeMessage<::idlepb::GetRoleAllStatsReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleAvatarDataAck* Arena::CreateMaybeMessage<::idlepb::GetRoleAvatarDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleAvatarDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleAvatarDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleBiographyDataAck* Arena::CreateMaybeMessage<::idlepb::GetRoleBiographyDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleBiographyDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleBiographyDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleCollectionDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleCollectionDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleCollectionDataRsp* Arena::CreateMaybeMessage<::idlepb::GetRoleCollectionDataRsp>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleDeluxeShopDataAck* Arena::CreateMaybeMessage<::idlepb::GetRoleDeluxeShopDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleDeluxeShopDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleDeluxeShopDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleFriendDataAck* Arena::CreateMaybeMessage<::idlepb::GetRoleFriendDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleFriendDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleFriendDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleFuZengDataAck* Arena::CreateMaybeMessage<::idlepb::GetRoleFuZengDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleFuZengDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleFuZengDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleInfoAck* Arena::CreateMaybeMessage<::idlepb::GetRoleInfoAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleInfoCacheAck* Arena::CreateMaybeMessage<::idlepb::GetRoleInfoCacheAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleInfoCacheReq* Arena::CreateMaybeMessage<::idlepb::GetRoleInfoCacheReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleInfoReq* Arena::CreateMaybeMessage<::idlepb::GetRoleInfoReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleLeaderboardDataAck* Arena::CreateMaybeMessage<::idlepb::GetRoleLeaderboardDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleLeaderboardDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleLeaderboardDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleMailDataAck* Arena::CreateMaybeMessage<::idlepb::GetRoleMailDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleMailDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleMailDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleSeptQuestDataAck* Arena::CreateMaybeMessage<::idlepb::GetRoleSeptQuestDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleSeptQuestDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleSeptQuestDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleSeptShopDataAck* Arena::CreateMaybeMessage<::idlepb::GetRoleSeptShopDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleSeptShopDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleSeptShopDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleShopDataAck* Arena::CreateMaybeMessage<::idlepb::GetRoleShopDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleShopDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleShopDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleTreasuryDataAck* Arena::CreateMaybeMessage<::idlepb::GetRoleTreasuryDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleTreasuryDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleTreasuryDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleVipShopDataAck* Arena::CreateMaybeMessage<::idlepb::GetRoleVipShopDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetRoleVipShopDataReq* Arena::CreateMaybeMessage<::idlepb::GetRoleVipShopDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetShanhetuDataAck* Arena::CreateMaybeMessage<::idlepb::GetShanhetuDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetShanhetuDataReq* Arena::CreateMaybeMessage<::idlepb::GetShanhetuDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetShanhetuUseRecordAck* Arena::CreateMaybeMessage<::idlepb::GetShanhetuUseRecordAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetShanhetuUseRecordReq* Arena::CreateMaybeMessage<::idlepb::GetShanhetuUseRecordReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetShareItemDataReq* Arena::CreateMaybeMessage<::idlepb::GetShareItemDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetShareItemDataRsp* Arena::CreateMaybeMessage<::idlepb::GetShareItemDataRsp>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetShareRoleCollectionDataReq* Arena::CreateMaybeMessage<::idlepb::GetShareRoleCollectionDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetShareRoleCollectionDataRsp* Arena::CreateMaybeMessage<::idlepb::GetShareRoleCollectionDataRsp>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetSoloArenaHistoryListAck* Arena::CreateMaybeMessage<::idlepb::GetSoloArenaHistoryListAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetSoloArenaHistoryListReq* Arena::CreateMaybeMessage<::idlepb::GetSoloArenaHistoryListReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetTemporaryPackageDataAck* Arena::CreateMaybeMessage<::idlepb::GetTemporaryPackageDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetTemporaryPackageDataReq* Arena::CreateMaybeMessage<::idlepb::GetTemporaryPackageDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetUserVarReq* Arena::CreateMaybeMessage<::idlepb::GetUserVarReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetUserVarRsp* Arena::CreateMaybeMessage<::idlepb::GetUserVarRsp>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetUserVarsReq* Arena::CreateMaybeMessage<::idlepb::GetUserVarsReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::GetUserVarsRsp* Arena::CreateMaybeMessage<::idlepb::GetUserVarsRsp>(Arena*);
template<> MPROTOCOL_API ::idlepb::GongFaOpAck* Arena::CreateMaybeMessage<::idlepb::GongFaOpAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::GongFaOpReq* Arena::CreateMaybeMessage<::idlepb::GongFaOpReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::InheritEquipmentAck* Arena::CreateMaybeMessage<::idlepb::InheritEquipmentAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::InheritEquipmentReq* Arena::CreateMaybeMessage<::idlepb::InheritEquipmentReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::LeaderboardClickLikeAck* Arena::CreateMaybeMessage<::idlepb::LeaderboardClickLikeAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::LeaderboardClickLikeReq* Arena::CreateMaybeMessage<::idlepb::LeaderboardClickLikeReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::LeaderboardUpdateMessageAck* Arena::CreateMaybeMessage<::idlepb::LeaderboardUpdateMessageAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::LeaderboardUpdateMessageReq* Arena::CreateMaybeMessage<::idlepb::LeaderboardUpdateMessageReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::LockItemAck* Arena::CreateMaybeMessage<::idlepb::LockItemAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::LockItemReq* Arena::CreateMaybeMessage<::idlepb::LockItemReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::LoginGameAck* Arena::CreateMaybeMessage<::idlepb::LoginGameAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::LoginGameReq* Arena::CreateMaybeMessage<::idlepb::LoginGameReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::MonsterTowerChallengeAck* Arena::CreateMaybeMessage<::idlepb::MonsterTowerChallengeAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::MonsterTowerChallengeReq* Arena::CreateMaybeMessage<::idlepb::MonsterTowerChallengeReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::MonsterTowerClosedDoorTrainingAck* Arena::CreateMaybeMessage<::idlepb::MonsterTowerClosedDoorTrainingAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::MonsterTowerClosedDoorTrainingReq* Arena::CreateMaybeMessage<::idlepb::MonsterTowerClosedDoorTrainingReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::MonsterTowerDrawIdleAwardAck* Arena::CreateMaybeMessage<::idlepb::MonsterTowerDrawIdleAwardAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::MonsterTowerDrawIdleAwardReq* Arena::CreateMaybeMessage<::idlepb::MonsterTowerDrawIdleAwardReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::MonsterTowerQuickEndAck* Arena::CreateMaybeMessage<::idlepb::MonsterTowerQuickEndAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::MonsterTowerQuickEndReq* Arena::CreateMaybeMessage<::idlepb::MonsterTowerQuickEndReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyAlchemyRefineResult* Arena::CreateMaybeMessage<::idlepb::NotifyAlchemyRefineResult>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyAutoModeStatus* Arena::CreateMaybeMessage<::idlepb::NotifyAutoModeStatus>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyBiographyMessage* Arena::CreateMaybeMessage<::idlepb::NotifyBiographyMessage>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyChecklist* Arena::CreateMaybeMessage<::idlepb::NotifyChecklist>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyCollectionActivatedSuit* Arena::CreateMaybeMessage<::idlepb::NotifyCollectionActivatedSuit>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyCollectionZoneActiveAwards* Arena::CreateMaybeMessage<::idlepb::NotifyCollectionZoneActiveAwards>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyCommonCollectionPieceData* Arena::CreateMaybeMessage<::idlepb::NotifyCommonCollectionPieceData>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyDungeonKillAllChallengeCurWaveNum* Arena::CreateMaybeMessage<::idlepb::NotifyDungeonKillAllChallengeCurWaveNum>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyDungeonKillAllChallengeOver* Arena::CreateMaybeMessage<::idlepb::NotifyDungeonKillAllChallengeOver>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyDungeonSurviveChallengeCurWaveNum* Arena::CreateMaybeMessage<::idlepb::NotifyDungeonSurviveChallengeCurWaveNum>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyDungeonSurviveChallengeOver* Arena::CreateMaybeMessage<::idlepb::NotifyDungeonSurviveChallengeOver>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyEnterOpenClientWorld* Arena::CreateMaybeMessage<::idlepb::NotifyEnterOpenClientWorld>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyFightModeData* Arena::CreateMaybeMessage<::idlepb::NotifyFightModeData>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyForgeRefineResult* Arena::CreateMaybeMessage<::idlepb::NotifyForgeRefineResult>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyFriendMessage* Arena::CreateMaybeMessage<::idlepb::NotifyFriendMessage>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyFuZeng* Arena::CreateMaybeMessage<::idlepb::NotifyFuZeng>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyInventoryFullMailItem* Arena::CreateMaybeMessage<::idlepb::NotifyInventoryFullMailItem>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyInventorySpaceNum* Arena::CreateMaybeMessage<::idlepb::NotifyInventorySpaceNum>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyMonsterTowerChallengeOver* Arena::CreateMaybeMessage<::idlepb::NotifyMonsterTowerChallengeOver>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyMonsterTowerData* Arena::CreateMaybeMessage<::idlepb::NotifyMonsterTowerData>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyQiCollectorRank* Arena::CreateMaybeMessage<::idlepb::NotifyQiCollectorRank>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyQuestFightChallengeOver* Arena::CreateMaybeMessage<::idlepb::NotifyQuestFightChallengeOver>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyRoleCollectionData* Arena::CreateMaybeMessage<::idlepb::NotifyRoleCollectionData>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyRoleCollectionHistories* Arena::CreateMaybeMessage<::idlepb::NotifyRoleCollectionHistories>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyRoleCollectionNextResetEnhanceTicks* Arena::CreateMaybeMessage<::idlepb::NotifyRoleCollectionNextResetEnhanceTicks>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyRoleCombatPower* Arena::CreateMaybeMessage<::idlepb::NotifyRoleCombatPower>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifySoloArenaChallengeOver* Arena::CreateMaybeMessage<::idlepb::NotifySoloArenaChallengeOver>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyUnlockArenaChallengeResult* Arena::CreateMaybeMessage<::idlepb::NotifyUnlockArenaChallengeResult>(Arena*);
template<> MPROTOCOL_API ::idlepb::NotifyUnlockedModuels* Arena::CreateMaybeMessage<::idlepb::NotifyUnlockedModuels>(Arena*);
template<> MPROTOCOL_API ::idlepb::OneClickDeleteMailAck* Arena::CreateMaybeMessage<::idlepb::OneClickDeleteMailAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::OneClickDeleteMailReq* Arena::CreateMaybeMessage<::idlepb::OneClickDeleteMailReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::OneClickGetMailAttachmentAck* Arena::CreateMaybeMessage<::idlepb::OneClickGetMailAttachmentAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::OneClickGetMailAttachmentReq* Arena::CreateMaybeMessage<::idlepb::OneClickGetMailAttachmentReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::OneClickMergeBreathingAck* Arena::CreateMaybeMessage<::idlepb::OneClickMergeBreathingAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::OneClickMergeBreathingReq* Arena::CreateMaybeMessage<::idlepb::OneClickMergeBreathingReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::OneClickOpenTreasuryChestAck* Arena::CreateMaybeMessage<::idlepb::OneClickOpenTreasuryChestAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::OneClickOpenTreasuryChestReq* Arena::CreateMaybeMessage<::idlepb::OneClickOpenTreasuryChestReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::OneClickReadMailAck* Arena::CreateMaybeMessage<::idlepb::OneClickReadMailAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::OneClickReadMailReq* Arena::CreateMaybeMessage<::idlepb::OneClickReadMailReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::OneClickUsePillElixirAck* Arena::CreateMaybeMessage<::idlepb::OneClickUsePillElixirAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::OneClickUsePillElixirReq* Arena::CreateMaybeMessage<::idlepb::OneClickUsePillElixirReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::OpenTreasuryChestAck* Arena::CreateMaybeMessage<::idlepb::OpenTreasuryChestAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::OpenTreasuryChestReq* Arena::CreateMaybeMessage<::idlepb::OpenTreasuryChestReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::OpenTreasuryGachaAck* Arena::CreateMaybeMessage<::idlepb::OpenTreasuryGachaAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::OpenTreasuryGachaReq* Arena::CreateMaybeMessage<::idlepb::OpenTreasuryGachaReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::Ping* Arena::CreateMaybeMessage<::idlepb::Ping>(Arena*);
template<> MPROTOCOL_API ::idlepb::Pong* Arena::CreateMaybeMessage<::idlepb::Pong>(Arena*);
template<> MPROTOCOL_API ::idlepb::QiWenEquipmentAck* Arena::CreateMaybeMessage<::idlepb::QiWenEquipmentAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::QiWenEquipmentReq* Arena::CreateMaybeMessage<::idlepb::QiWenEquipmentReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::QuestFightQuickEndAck* Arena::CreateMaybeMessage<::idlepb::QuestFightQuickEndAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::QuestFightQuickEndReq* Arena::CreateMaybeMessage<::idlepb::QuestFightQuickEndReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::QuestOpAck* Arena::CreateMaybeMessage<::idlepb::QuestOpAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::QuestOpReq* Arena::CreateMaybeMessage<::idlepb::QuestOpReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReadMailAck* Arena::CreateMaybeMessage<::idlepb::ReadMailAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReadMailReq* Arena::CreateMaybeMessage<::idlepb::ReadMailReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReceiveAvatarTempPackageAck* Arena::CreateMaybeMessage<::idlepb::ReceiveAvatarTempPackageAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReceiveAvatarTempPackageReq* Arena::CreateMaybeMessage<::idlepb::ReceiveAvatarTempPackageReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReceiveBiographyEventItemAck* Arena::CreateMaybeMessage<::idlepb::ReceiveBiographyEventItemAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReceiveBiographyEventItemReq* Arena::CreateMaybeMessage<::idlepb::ReceiveBiographyEventItemReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReceiveBiographyItemAck* Arena::CreateMaybeMessage<::idlepb::ReceiveBiographyItemAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReceiveBiographyItemReq* Arena::CreateMaybeMessage<::idlepb::ReceiveBiographyItemReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReceiveBreathingExerciseRewardAck* Arena::CreateMaybeMessage<::idlepb::ReceiveBreathingExerciseRewardAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReceiveBreathingExerciseRewardReq* Arena::CreateMaybeMessage<::idlepb::ReceiveBreathingExerciseRewardReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReceiveFuZengRewardsAck* Arena::CreateMaybeMessage<::idlepb::ReceiveFuZengRewardsAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReceiveFuZengRewardsReq* Arena::CreateMaybeMessage<::idlepb::ReceiveFuZengRewardsReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefineEquipmentAck* Arena::CreateMaybeMessage<::idlepb::RefineEquipmentAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefineEquipmentReq* Arena::CreateMaybeMessage<::idlepb::RefineEquipmentReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshAlchemyData* Arena::CreateMaybeMessage<::idlepb::RefreshAlchemyData>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshCultivationData* Arena::CreateMaybeMessage<::idlepb::RefreshCultivationData>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshCultivationRankData* Arena::CreateMaybeMessage<::idlepb::RefreshCultivationRankData>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshCurrencyData* Arena::CreateMaybeMessage<::idlepb::RefreshCurrencyData>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshCurrentCultivationDirection* Arena::CreateMaybeMessage<::idlepb::RefreshCurrentCultivationDirection>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshDailyCounterData* Arena::CreateMaybeMessage<::idlepb::RefreshDailyCounterData>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshDeluxeShopAck* Arena::CreateMaybeMessage<::idlepb::RefreshDeluxeShopAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshDeluxeShopReq* Arena::CreateMaybeMessage<::idlepb::RefreshDeluxeShopReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshDeluxeShopUnlocked* Arena::CreateMaybeMessage<::idlepb::RefreshDeluxeShopUnlocked>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshForgeData* Arena::CreateMaybeMessage<::idlepb::RefreshForgeData>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshInventoryData* Arena::CreateMaybeMessage<::idlepb::RefreshInventoryData>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshItems* Arena::CreateMaybeMessage<::idlepb::RefreshItems>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshLastUnlockArenaId* Arena::CreateMaybeMessage<::idlepb::RefreshLastUnlockArenaId>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshRoleNormalSetting* Arena::CreateMaybeMessage<::idlepb::RefreshRoleNormalSetting>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshSeptQuestAck* Arena::CreateMaybeMessage<::idlepb::RefreshSeptQuestAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshSeptQuestReq* Arena::CreateMaybeMessage<::idlepb::RefreshSeptQuestReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshShopAck* Arena::CreateMaybeMessage<::idlepb::RefreshShopAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshShopReq* Arena::CreateMaybeMessage<::idlepb::RefreshShopReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshTemporaryPackageItems* Arena::CreateMaybeMessage<::idlepb::RefreshTemporaryPackageItems>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshTreasuryShopAck* Arena::CreateMaybeMessage<::idlepb::RefreshTreasuryShopAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshTreasuryShopReq* Arena::CreateMaybeMessage<::idlepb::RefreshTreasuryShopReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RefreshUnlockedEquipmentSlots* Arena::CreateMaybeMessage<::idlepb::RefreshUnlockedEquipmentSlots>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReinforceEquipmentAck* Arena::CreateMaybeMessage<::idlepb::ReinforceEquipmentAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReinforceEquipmentReq* Arena::CreateMaybeMessage<::idlepb::ReinforceEquipmentReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReplaySoloArenaHistoryAck* Arena::CreateMaybeMessage<::idlepb::ReplaySoloArenaHistoryAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReplaySoloArenaHistoryReq* Arena::CreateMaybeMessage<::idlepb::ReplaySoloArenaHistoryReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReplicateQuestProgressChange* Arena::CreateMaybeMessage<::idlepb::ReplicateQuestProgressChange>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReplyFriendRequestAck* Arena::CreateMaybeMessage<::idlepb::ReplyFriendRequestAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReplyFriendRequestReq* Arena::CreateMaybeMessage<::idlepb::ReplyFriendRequestReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReportError* Arena::CreateMaybeMessage<::idlepb::ReportError>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReqRoleSeptQuestOpAck* Arena::CreateMaybeMessage<::idlepb::ReqRoleSeptQuestOpAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReqRoleSeptQuestOpReq* Arena::CreateMaybeMessage<::idlepb::ReqRoleSeptQuestOpReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReqSeptQuestRankUpAck* Arena::CreateMaybeMessage<::idlepb::ReqSeptQuestRankUpAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ReqSeptQuestRankUpReq* Arena::CreateMaybeMessage<::idlepb::ReqSeptQuestRankUpReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestCommonCultivationDataAck* Arena::CreateMaybeMessage<::idlepb::RequestCommonCultivationDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestCommonCultivationDataReq* Arena::CreateMaybeMessage<::idlepb::RequestCommonCultivationDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestEnterSeptDemonWorldAck* Arena::CreateMaybeMessage<::idlepb::RequestEnterSeptDemonWorldAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestEnterSeptDemonWorldReq* Arena::CreateMaybeMessage<::idlepb::RequestEnterSeptDemonWorldReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestInSeptDemonWorldEndTimeAck* Arena::CreateMaybeMessage<::idlepb::RequestInSeptDemonWorldEndTimeAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestInSeptDemonWorldEndTimeReq* Arena::CreateMaybeMessage<::idlepb::RequestInSeptDemonWorldEndTimeReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestLeaveSeptDemonWorldAck* Arena::CreateMaybeMessage<::idlepb::RequestLeaveSeptDemonWorldAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestLeaveSeptDemonWorldReq* Arena::CreateMaybeMessage<::idlepb::RequestLeaveSeptDemonWorldReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestModifyPillElixirFilterAck* Arena::CreateMaybeMessage<::idlepb::RequestModifyPillElixirFilterAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestModifyPillElixirFilterReq* Arena::CreateMaybeMessage<::idlepb::RequestModifyPillElixirFilterReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestPillElixirDataAck* Arena::CreateMaybeMessage<::idlepb::RequestPillElixirDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestPillElixirDataReq* Arena::CreateMaybeMessage<::idlepb::RequestPillElixirDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestRefreshRoleCombatPower* Arena::CreateMaybeMessage<::idlepb::RequestRefreshRoleCombatPower>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestSeptDemonWorldDataAck* Arena::CreateMaybeMessage<::idlepb::RequestSeptDemonWorldDataAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RequestSeptDemonWorldDataReq* Arena::CreateMaybeMessage<::idlepb::RequestSeptDemonWorldDataReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ResetEquipmentAck* Arena::CreateMaybeMessage<::idlepb::ResetEquipmentAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::ResetEquipmentReq* Arena::CreateMaybeMessage<::idlepb::ResetEquipmentReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::RoleBattleHistoryList* Arena::CreateMaybeMessage<::idlepb::RoleBattleHistoryList>(Arena*);
template<> MPROTOCOL_API ::idlepb::RoleCollectionOpAck* Arena::CreateMaybeMessage<::idlepb::RoleCollectionOpAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::RoleCollectionOpReq* Arena::CreateMaybeMessage<::idlepb::RoleCollectionOpReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::SellItemAck* Arena::CreateMaybeMessage<::idlepb::SellItemAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::SellItemInfo* Arena::CreateMaybeMessage<::idlepb::SellItemInfo>(Arena*);
template<> MPROTOCOL_API ::idlepb::SellItemReq* Arena::CreateMaybeMessage<::idlepb::SellItemReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::SendChatMessageAck* Arena::CreateMaybeMessage<::idlepb::SendChatMessageAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::SendChatMessageReq* Arena::CreateMaybeMessage<::idlepb::SendChatMessageReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetAttackLockTypeAck* Arena::CreateMaybeMessage<::idlepb::SetAttackLockTypeAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetAttackLockTypeReq* Arena::CreateMaybeMessage<::idlepb::SetAttackLockTypeReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetAttackUnlockTypeAck* Arena::CreateMaybeMessage<::idlepb::SetAttackUnlockTypeAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetAttackUnlockTypeReq* Arena::CreateMaybeMessage<::idlepb::SetAttackUnlockTypeReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetAutoMode* Arena::CreateMaybeMessage<::idlepb::SetAutoMode>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetCurrentCultivationDirectionAck* Arena::CreateMaybeMessage<::idlepb::SetCurrentCultivationDirectionAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetCurrentCultivationDirectionReq* Arena::CreateMaybeMessage<::idlepb::SetCurrentCultivationDirectionReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetFightModeAck* Arena::CreateMaybeMessage<::idlepb::SetFightModeAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetFightModeReq* Arena::CreateMaybeMessage<::idlepb::SetFightModeReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetShanhetuUseConfigAck* Arena::CreateMaybeMessage<::idlepb::SetShanhetuUseConfigAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetShanhetuUseConfigReq* Arena::CreateMaybeMessage<::idlepb::SetShanhetuUseConfigReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetShowUnlockButtonAck* Arena::CreateMaybeMessage<::idlepb::SetShowUnlockButtonAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetShowUnlockButtonReq* Arena::CreateMaybeMessage<::idlepb::SetShowUnlockButtonReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::SetUserVar* Arena::CreateMaybeMessage<::idlepb::SetUserVar>(Arena*);
template<> MPROTOCOL_API ::idlepb::ShareSelfItemReq* Arena::CreateMaybeMessage<::idlepb::ShareSelfItemReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ShareSelfItemRsp* Arena::CreateMaybeMessage<::idlepb::ShareSelfItemRsp>(Arena*);
template<> MPROTOCOL_API ::idlepb::ShareSelfItemsReq* Arena::CreateMaybeMessage<::idlepb::ShareSelfItemsReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ShareSelfItemsRsp* Arena::CreateMaybeMessage<::idlepb::ShareSelfItemsRsp>(Arena*);
template<> MPROTOCOL_API ::idlepb::ShareSelfRoleCollectionReq* Arena::CreateMaybeMessage<::idlepb::ShareSelfRoleCollectionReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::ShareSelfRoleCollectionRsp* Arena::CreateMaybeMessage<::idlepb::ShareSelfRoleCollectionRsp>(Arena*);
template<> MPROTOCOL_API ::idlepb::SoloArenaChallengeAck* Arena::CreateMaybeMessage<::idlepb::SoloArenaChallengeAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::SoloArenaChallengeReq* Arena::CreateMaybeMessage<::idlepb::SoloArenaChallengeReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::SoloArenaQuickEndAck* Arena::CreateMaybeMessage<::idlepb::SoloArenaQuickEndAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::SoloArenaQuickEndReq* Arena::CreateMaybeMessage<::idlepb::SoloArenaQuickEndReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::StepShanhetuAck* Arena::CreateMaybeMessage<::idlepb::StepShanhetuAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::StepShanhetuReq* Arena::CreateMaybeMessage<::idlepb::StepShanhetuReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::SynthesisCommonItemAck* Arena::CreateMaybeMessage<::idlepb::SynthesisCommonItemAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::SynthesisCommonItemReq* Arena::CreateMaybeMessage<::idlepb::SynthesisCommonItemReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::SystemNotice* Arena::CreateMaybeMessage<::idlepb::SystemNotice>(Arena*);
template<> MPROTOCOL_API ::idlepb::ThunderTestData* Arena::CreateMaybeMessage<::idlepb::ThunderTestData>(Arena*);
template<> MPROTOCOL_API ::idlepb::ThunderTestRoundData* Arena::CreateMaybeMessage<::idlepb::ThunderTestRoundData>(Arena*);
template<> MPROTOCOL_API ::idlepb::TradePillElixirAck* Arena::CreateMaybeMessage<::idlepb::TradePillElixirAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::TradePillElixirReq* Arena::CreateMaybeMessage<::idlepb::TradePillElixirReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::TreasuryShopBuyAck* Arena::CreateMaybeMessage<::idlepb::TreasuryShopBuyAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::TreasuryShopBuyReq* Arena::CreateMaybeMessage<::idlepb::TreasuryShopBuyReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::UnlockArenaAck* Arena::CreateMaybeMessage<::idlepb::UnlockArenaAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::UnlockArenaReq* Arena::CreateMaybeMessage<::idlepb::UnlockArenaReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::UnlockDeluxeShopAck* Arena::CreateMaybeMessage<::idlepb::UnlockDeluxeShopAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::UnlockDeluxeShopReq* Arena::CreateMaybeMessage<::idlepb::UnlockDeluxeShopReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::UnlockEquipmentSlotAck* Arena::CreateMaybeMessage<::idlepb::UnlockEquipmentSlotAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::UnlockEquipmentSlotReq* Arena::CreateMaybeMessage<::idlepb::UnlockEquipmentSlotReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::UnlockFunctionModuleAck* Arena::CreateMaybeMessage<::idlepb::UnlockFunctionModuleAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::UnlockFunctionModuleReq* Arena::CreateMaybeMessage<::idlepb::UnlockFunctionModuleReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::UpdateChat* Arena::CreateMaybeMessage<::idlepb::UpdateChat>(Arena*);
template<> MPROTOCOL_API ::idlepb::UpdateChecklistAck* Arena::CreateMaybeMessage<::idlepb::UpdateChecklistAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::UpdateChecklistReq* Arena::CreateMaybeMessage<::idlepb::UpdateChecklistReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::UpdateFarmlandStateAck* Arena::CreateMaybeMessage<::idlepb::UpdateFarmlandStateAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::UpdateFarmlandStateReq* Arena::CreateMaybeMessage<::idlepb::UpdateFarmlandStateReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::UpdateLifeCounter* Arena::CreateMaybeMessage<::idlepb::UpdateLifeCounter>(Arena*);
template<> MPROTOCOL_API ::idlepb::UpdateRoleMail* Arena::CreateMaybeMessage<::idlepb::UpdateRoleMail>(Arena*);
template<> MPROTOCOL_API ::idlepb::UpgradeQiCollectorAck* Arena::CreateMaybeMessage<::idlepb::UpgradeQiCollectorAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::UpgradeQiCollectorReq* Arena::CreateMaybeMessage<::idlepb::UpgradeQiCollectorReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::UseItemAck* Arena::CreateMaybeMessage<::idlepb::UseItemAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::UseItemReq* Arena::CreateMaybeMessage<::idlepb::UseItemReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::UsePillElixirAck* Arena::CreateMaybeMessage<::idlepb::UsePillElixirAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::UsePillElixirReport* Arena::CreateMaybeMessage<::idlepb::UsePillElixirReport>(Arena*);
template<> MPROTOCOL_API ::idlepb::UsePillElixirReq* Arena::CreateMaybeMessage<::idlepb::UsePillElixirReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::UseSelectGiftAck* Arena::CreateMaybeMessage<::idlepb::UseSelectGiftAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::UseSelectGiftReq* Arena::CreateMaybeMessage<::idlepb::UseSelectGiftReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::UseShanhetuAck* Arena::CreateMaybeMessage<::idlepb::UseShanhetuAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::UseShanhetuReq* Arena::CreateMaybeMessage<::idlepb::UseShanhetuReq>(Arena*);
template<> MPROTOCOL_API ::idlepb::VipShopBuyAck* Arena::CreateMaybeMessage<::idlepb::VipShopBuyAck>(Arena*);
template<> MPROTOCOL_API ::idlepb::VipShopBuyReq* Arena::CreateMaybeMessage<::idlepb::VipShopBuyReq>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace idlepb {

enum UseItemResult : int {
  UIR_Success = 0,
  UIR_UnKnown = 1,
  UIR_BadParam = 2,
  UIR_NotEnoughNum = 3,
  UIR_InventoryIsFull = 4,
  UIR_LowRank = 5,
  UIR_BadDir = 6,
  UIR_BadConfig = 7,
  UIR_UseNumIsFull = 8,
  UIR_BadTime = 9,
  UIR_BadData = 10,
  UIR_BadType = 11,
  UseItemResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UseItemResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool UseItemResult_IsValid(int value);
constexpr UseItemResult UseItemResult_MIN = UIR_Success;
constexpr UseItemResult UseItemResult_MAX = UIR_BadType;
constexpr int UseItemResult_ARRAYSIZE = UseItemResult_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UseItemResult_descriptor();
template<typename T>
inline const std::string& UseItemResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UseItemResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UseItemResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UseItemResult_descriptor(), enum_t_value);
}
inline bool UseItemResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UseItemResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UseItemResult>(
    UseItemResult_descriptor(), name, value);
}
enum RoleCollectionOpType : int {
  RCOT_PieceFusion = 0,
  RCOT_UpgradeLevel = 1,
  RCOT_UpgradeStar = 2,
  RCOT_DrawHistoryAward = 3,
  RCOT_DrawZoneActiveAward = 4,
  RCOT_ResetEnhance = 5,
  RoleCollectionOpType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RoleCollectionOpType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool RoleCollectionOpType_IsValid(int value);
constexpr RoleCollectionOpType RoleCollectionOpType_MIN = RCOT_PieceFusion;
constexpr RoleCollectionOpType RoleCollectionOpType_MAX = RCOT_ResetEnhance;
constexpr int RoleCollectionOpType_ARRAYSIZE = RoleCollectionOpType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoleCollectionOpType_descriptor();
template<typename T>
inline const std::string& RoleCollectionOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoleCollectionOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoleCollectionOpType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoleCollectionOpType_descriptor(), enum_t_value);
}
inline bool RoleCollectionOpType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoleCollectionOpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoleCollectionOpType>(
    RoleCollectionOpType_descriptor(), name, value);
}
enum SetFightModeAckErrorCode : int {
  SetFightModeAckErrorCode_Ok = 0,
  SetFightModeAckErrorCode_Other = 1,
  SetFightModeAckErrorCode_RankInvalid = 2,
  SetFightModeAckErrorCode_ModeInvalid = 3,
  SetFightModeAckErrorCode_FightTime = 4,
  SetFightModeAckErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SetFightModeAckErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool SetFightModeAckErrorCode_IsValid(int value);
constexpr SetFightModeAckErrorCode SetFightModeAckErrorCode_MIN = SetFightModeAckErrorCode_Ok;
constexpr SetFightModeAckErrorCode SetFightModeAckErrorCode_MAX = SetFightModeAckErrorCode_FightTime;
constexpr int SetFightModeAckErrorCode_ARRAYSIZE = SetFightModeAckErrorCode_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SetFightModeAckErrorCode_descriptor();
template<typename T>
inline const std::string& SetFightModeAckErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SetFightModeAckErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SetFightModeAckErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SetFightModeAckErrorCode_descriptor(), enum_t_value);
}
inline bool SetFightModeAckErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SetFightModeAckErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SetFightModeAckErrorCode>(
    SetFightModeAckErrorCode_descriptor(), name, value);
}
// ===================================================================

class MPROTOCOL_API Ping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() override;
  explicit PROTOBUF_CONSTEXPR Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ping& from) {
    Ping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqTicksFieldNumber = 1,
  };
  // int64 req_ticks = 1;
  void clear_req_ticks();
  int64_t req_ticks() const;
  void set_req_ticks(int64_t value);
  private:
  int64_t _internal_req_ticks() const;
  void _internal_set_req_ticks(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t req_ticks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API Pong final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}
  ~Pong() override;
  explicit PROTOBUF_CONSTEXPR Pong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pong(const Pong& from);
  Pong(Pong&& from) noexcept
    : Pong() {
    *this = ::std::move(from);
  }

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
               &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Pong& a, Pong& b) {
    a.Swap(&b);
  }
  inline void Swap(Pong* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pong>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pong& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pong& from) {
    Pong::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pong* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.Pong";
  }
  protected:
  explicit Pong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqTicksFieldNumber = 1,
    kRspTicksFieldNumber = 2,
  };
  // int64 req_ticks = 1;
  void clear_req_ticks();
  int64_t req_ticks() const;
  void set_req_ticks(int64_t value);
  private:
  int64_t _internal_req_ticks() const;
  void _internal_set_req_ticks(int64_t value);
  public:

  // int64 rsp_ticks = 2;
  void clear_rsp_ticks();
  int64_t rsp_ticks() const;
  void set_rsp_ticks(int64_t value);
  private:
  int64_t _internal_rsp_ticks() const;
  void _internal_set_rsp_ticks(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.Pong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t req_ticks_;
    int64_t rsp_ticks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DoGmCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DoGmCommand) */ {
 public:
  inline DoGmCommand() : DoGmCommand(nullptr) {}
  ~DoGmCommand() override;
  explicit PROTOBUF_CONSTEXPR DoGmCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoGmCommand(const DoGmCommand& from);
  DoGmCommand(DoGmCommand&& from) noexcept
    : DoGmCommand() {
    *this = ::std::move(from);
  }

  inline DoGmCommand& operator=(const DoGmCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoGmCommand& operator=(DoGmCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoGmCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoGmCommand* internal_default_instance() {
    return reinterpret_cast<const DoGmCommand*>(
               &_DoGmCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DoGmCommand& a, DoGmCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(DoGmCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoGmCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoGmCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoGmCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoGmCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoGmCommand& from) {
    DoGmCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoGmCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DoGmCommand";
  }
  protected:
  explicit DoGmCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
  };
  // string command = 1;
  void clear_command();
  const std::string& command() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_command(ArgT0&& arg0, ArgT... args);
  std::string* mutable_command();
  PROTOBUF_NODISCARD std::string* release_command();
  void set_allocated_command(std::string* command);
  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DoGmCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReportError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReportError) */ {
 public:
  inline ReportError() : ReportError(nullptr) {}
  ~ReportError() override;
  explicit PROTOBUF_CONSTEXPR ReportError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportError(const ReportError& from);
  ReportError(ReportError&& from) noexcept
    : ReportError() {
    *this = ::std::move(from);
  }

  inline ReportError& operator=(const ReportError& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportError& operator=(ReportError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportError& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportError* internal_default_instance() {
    return reinterpret_cast<const ReportError*>(
               &_ReportError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ReportError& a, ReportError& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReportError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReportError& from) {
    ReportError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReportError";
  }
  protected:
  explicit ReportError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReportError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API LoginGameReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.LoginGameReq) */ {
 public:
  inline LoginGameReq() : LoginGameReq(nullptr) {}
  ~LoginGameReq() override;
  explicit PROTOBUF_CONSTEXPR LoginGameReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginGameReq(const LoginGameReq& from);
  LoginGameReq(LoginGameReq&& from) noexcept
    : LoginGameReq() {
    *this = ::std::move(from);
  }

  inline LoginGameReq& operator=(const LoginGameReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginGameReq& operator=(LoginGameReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginGameReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginGameReq* internal_default_instance() {
    return reinterpret_cast<const LoginGameReq*>(
               &_LoginGameReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginGameReq& a, LoginGameReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginGameReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginGameReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginGameReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginGameReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginGameReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginGameReq& from) {
    LoginGameReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginGameReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.LoginGameReq";
  }
  protected:
  explicit LoginGameReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kClientVersionFieldNumber = 2,
  };
  // string account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string client_version = 2;
  void clear_client_version();
  const std::string& client_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* client_version);
  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(const std::string& value);
  std::string* _internal_mutable_client_version();
  public:

  // @@protoc_insertion_point(class_scope:idlepb.LoginGameReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API LoginGameAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.LoginGameAck) */ {
 public:
  inline LoginGameAck() : LoginGameAck(nullptr) {}
  ~LoginGameAck() override;
  explicit PROTOBUF_CONSTEXPR LoginGameAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginGameAck(const LoginGameAck& from);
  LoginGameAck(LoginGameAck&& from) noexcept
    : LoginGameAck() {
    *this = ::std::move(from);
  }

  inline LoginGameAck& operator=(const LoginGameAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginGameAck& operator=(LoginGameAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginGameAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginGameAck* internal_default_instance() {
    return reinterpret_cast<const LoginGameAck*>(
               &_LoginGameAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginGameAck& a, LoginGameAck& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginGameAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginGameAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginGameAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginGameAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginGameAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginGameAck& from) {
    LoginGameAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginGameAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.LoginGameAck";
  }
  protected:
  explicit LoginGameAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleDataFieldNumber = 2,
    kOfflineAwardSummaryFieldNumber = 4,
    kSeptInfoFieldNumber = 5,
    kRetFieldNumber = 1,
    kIsReloginFieldNumber = 3,
  };
  // .idlepb.RoleData role_data = 2;
  bool has_role_data() const;
  private:
  bool _internal_has_role_data() const;
  public:
  void clear_role_data();
  const ::idlepb::RoleData& role_data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleData* release_role_data();
  ::idlepb::RoleData* mutable_role_data();
  void set_allocated_role_data(::idlepb::RoleData* role_data);
  private:
  const ::idlepb::RoleData& _internal_role_data() const;
  ::idlepb::RoleData* _internal_mutable_role_data();
  public:
  void unsafe_arena_set_allocated_role_data(
      ::idlepb::RoleData* role_data);
  ::idlepb::RoleData* unsafe_arena_release_role_data();

  // .idlepb.OfflineAwardSummary offline_award_summary = 4;
  bool has_offline_award_summary() const;
  private:
  bool _internal_has_offline_award_summary() const;
  public:
  void clear_offline_award_summary();
  const ::idlepb::OfflineAwardSummary& offline_award_summary() const;
  PROTOBUF_NODISCARD ::idlepb::OfflineAwardSummary* release_offline_award_summary();
  ::idlepb::OfflineAwardSummary* mutable_offline_award_summary();
  void set_allocated_offline_award_summary(::idlepb::OfflineAwardSummary* offline_award_summary);
  private:
  const ::idlepb::OfflineAwardSummary& _internal_offline_award_summary() const;
  ::idlepb::OfflineAwardSummary* _internal_mutable_offline_award_summary();
  public:
  void unsafe_arena_set_allocated_offline_award_summary(
      ::idlepb::OfflineAwardSummary* offline_award_summary);
  ::idlepb::OfflineAwardSummary* unsafe_arena_release_offline_award_summary();

  // .idlepb.SelfSeptInfo sept_info = 5;
  bool has_sept_info() const;
  private:
  bool _internal_has_sept_info() const;
  public:
  void clear_sept_info();
  const ::idlepb::SelfSeptInfo& sept_info() const;
  PROTOBUF_NODISCARD ::idlepb::SelfSeptInfo* release_sept_info();
  ::idlepb::SelfSeptInfo* mutable_sept_info();
  void set_allocated_sept_info(::idlepb::SelfSeptInfo* sept_info);
  private:
  const ::idlepb::SelfSeptInfo& _internal_sept_info() const;
  ::idlepb::SelfSeptInfo* _internal_mutable_sept_info();
  public:
  void unsafe_arena_set_allocated_sept_info(
      ::idlepb::SelfSeptInfo* sept_info);
  ::idlepb::SelfSeptInfo* unsafe_arena_release_sept_info();

  // .idlepb.LoginGameRetCode ret = 1;
  void clear_ret();
  ::idlepb::LoginGameRetCode ret() const;
  void set_ret(::idlepb::LoginGameRetCode value);
  private:
  ::idlepb::LoginGameRetCode _internal_ret() const;
  void _internal_set_ret(::idlepb::LoginGameRetCode value);
  public:

  // bool is_relogin = 3;
  void clear_is_relogin();
  bool is_relogin() const;
  void set_is_relogin(bool value);
  private:
  bool _internal_is_relogin() const;
  void _internal_set_is_relogin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.LoginGameAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleData* role_data_;
    ::idlepb::OfflineAwardSummary* offline_award_summary_;
    ::idlepb::SelfSeptInfo* sept_info_;
    int ret_;
    bool is_relogin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshInventoryData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshInventoryData) */ {
 public:
  inline RefreshInventoryData() : RefreshInventoryData(nullptr) {}
  ~RefreshInventoryData() override;
  explicit PROTOBUF_CONSTEXPR RefreshInventoryData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshInventoryData(const RefreshInventoryData& from);
  RefreshInventoryData(RefreshInventoryData&& from) noexcept
    : RefreshInventoryData() {
    *this = ::std::move(from);
  }

  inline RefreshInventoryData& operator=(const RefreshInventoryData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshInventoryData& operator=(RefreshInventoryData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshInventoryData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshInventoryData* internal_default_instance() {
    return reinterpret_cast<const RefreshInventoryData*>(
               &_RefreshInventoryData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RefreshInventoryData& a, RefreshInventoryData& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshInventoryData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshInventoryData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshInventoryData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshInventoryData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshInventoryData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshInventoryData& from) {
    RefreshInventoryData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshInventoryData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshInventoryData";
  }
  protected:
  explicit RefreshInventoryData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .idlepb.ItemData items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::ItemData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >*
      mutable_items();
  private:
  const ::idlepb::ItemData& _internal_items(int index) const;
  ::idlepb::ItemData* _internal_add_items();
  public:
  const ::idlepb::ItemData& items(int index) const;
  ::idlepb::ItemData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >&
      items() const;

  // @@protoc_insertion_point(class_scope:idlepb.RefreshInventoryData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetCurrentCultivationDirectionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetCurrentCultivationDirectionReq) */ {
 public:
  inline SetCurrentCultivationDirectionReq() : SetCurrentCultivationDirectionReq(nullptr) {}
  ~SetCurrentCultivationDirectionReq() override;
  explicit PROTOBUF_CONSTEXPR SetCurrentCultivationDirectionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetCurrentCultivationDirectionReq(const SetCurrentCultivationDirectionReq& from);
  SetCurrentCultivationDirectionReq(SetCurrentCultivationDirectionReq&& from) noexcept
    : SetCurrentCultivationDirectionReq() {
    *this = ::std::move(from);
  }

  inline SetCurrentCultivationDirectionReq& operator=(const SetCurrentCultivationDirectionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetCurrentCultivationDirectionReq& operator=(SetCurrentCultivationDirectionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetCurrentCultivationDirectionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetCurrentCultivationDirectionReq* internal_default_instance() {
    return reinterpret_cast<const SetCurrentCultivationDirectionReq*>(
               &_SetCurrentCultivationDirectionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SetCurrentCultivationDirectionReq& a, SetCurrentCultivationDirectionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetCurrentCultivationDirectionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetCurrentCultivationDirectionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetCurrentCultivationDirectionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetCurrentCultivationDirectionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetCurrentCultivationDirectionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetCurrentCultivationDirectionReq& from) {
    SetCurrentCultivationDirectionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetCurrentCultivationDirectionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetCurrentCultivationDirectionReq";
  }
  protected:
  explicit SetCurrentCultivationDirectionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirFieldNumber = 1,
  };
  // .idlepb.CultivationDirection dir = 1;
  void clear_dir();
  ::idlepb::CultivationDirection dir() const;
  void set_dir(::idlepb::CultivationDirection value);
  private:
  ::idlepb::CultivationDirection _internal_dir() const;
  void _internal_set_dir(::idlepb::CultivationDirection value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetCurrentCultivationDirectionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetCurrentCultivationDirectionAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetCurrentCultivationDirectionAck) */ {
 public:
  inline SetCurrentCultivationDirectionAck() : SetCurrentCultivationDirectionAck(nullptr) {}
  ~SetCurrentCultivationDirectionAck() override;
  explicit PROTOBUF_CONSTEXPR SetCurrentCultivationDirectionAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetCurrentCultivationDirectionAck(const SetCurrentCultivationDirectionAck& from);
  SetCurrentCultivationDirectionAck(SetCurrentCultivationDirectionAck&& from) noexcept
    : SetCurrentCultivationDirectionAck() {
    *this = ::std::move(from);
  }

  inline SetCurrentCultivationDirectionAck& operator=(const SetCurrentCultivationDirectionAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetCurrentCultivationDirectionAck& operator=(SetCurrentCultivationDirectionAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetCurrentCultivationDirectionAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetCurrentCultivationDirectionAck* internal_default_instance() {
    return reinterpret_cast<const SetCurrentCultivationDirectionAck*>(
               &_SetCurrentCultivationDirectionAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SetCurrentCultivationDirectionAck& a, SetCurrentCultivationDirectionAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SetCurrentCultivationDirectionAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetCurrentCultivationDirectionAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetCurrentCultivationDirectionAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetCurrentCultivationDirectionAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetCurrentCultivationDirectionAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetCurrentCultivationDirectionAck& from) {
    SetCurrentCultivationDirectionAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetCurrentCultivationDirectionAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetCurrentCultivationDirectionAck";
  }
  protected:
  explicit SetCurrentCultivationDirectionAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirFieldNumber = 1,
  };
  // .idlepb.CultivationDirection dir = 1;
  void clear_dir();
  ::idlepb::CultivationDirection dir() const;
  void set_dir(::idlepb::CultivationDirection value);
  private:
  ::idlepb::CultivationDirection _internal_dir() const;
  void _internal_set_dir(::idlepb::CultivationDirection value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetCurrentCultivationDirectionAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshCurrentCultivationDirection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshCurrentCultivationDirection) */ {
 public:
  inline RefreshCurrentCultivationDirection() : RefreshCurrentCultivationDirection(nullptr) {}
  ~RefreshCurrentCultivationDirection() override;
  explicit PROTOBUF_CONSTEXPR RefreshCurrentCultivationDirection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshCurrentCultivationDirection(const RefreshCurrentCultivationDirection& from);
  RefreshCurrentCultivationDirection(RefreshCurrentCultivationDirection&& from) noexcept
    : RefreshCurrentCultivationDirection() {
    *this = ::std::move(from);
  }

  inline RefreshCurrentCultivationDirection& operator=(const RefreshCurrentCultivationDirection& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshCurrentCultivationDirection& operator=(RefreshCurrentCultivationDirection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshCurrentCultivationDirection& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshCurrentCultivationDirection* internal_default_instance() {
    return reinterpret_cast<const RefreshCurrentCultivationDirection*>(
               &_RefreshCurrentCultivationDirection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RefreshCurrentCultivationDirection& a, RefreshCurrentCultivationDirection& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshCurrentCultivationDirection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshCurrentCultivationDirection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshCurrentCultivationDirection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshCurrentCultivationDirection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshCurrentCultivationDirection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshCurrentCultivationDirection& from) {
    RefreshCurrentCultivationDirection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshCurrentCultivationDirection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshCurrentCultivationDirection";
  }
  protected:
  explicit RefreshCurrentCultivationDirection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirFieldNumber = 1,
  };
  // .idlepb.CultivationDirection dir = 1;
  void clear_dir();
  ::idlepb::CultivationDirection dir() const;
  void set_dir(::idlepb::CultivationDirection value);
  private:
  ::idlepb::CultivationDirection _internal_dir() const;
  void _internal_set_dir(::idlepb::CultivationDirection value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RefreshCurrentCultivationDirection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshCultivationRankData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshCultivationRankData) */ {
 public:
  inline RefreshCultivationRankData() : RefreshCultivationRankData(nullptr) {}
  ~RefreshCultivationRankData() override;
  explicit PROTOBUF_CONSTEXPR RefreshCultivationRankData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshCultivationRankData(const RefreshCultivationRankData& from);
  RefreshCultivationRankData(RefreshCultivationRankData&& from) noexcept
    : RefreshCultivationRankData() {
    *this = ::std::move(from);
  }

  inline RefreshCultivationRankData& operator=(const RefreshCultivationRankData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshCultivationRankData& operator=(RefreshCultivationRankData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshCultivationRankData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshCultivationRankData* internal_default_instance() {
    return reinterpret_cast<const RefreshCultivationRankData*>(
               &_RefreshCultivationRankData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RefreshCultivationRankData& a, RefreshCultivationRankData& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshCultivationRankData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshCultivationRankData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshCultivationRankData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshCultivationRankData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshCultivationRankData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshCultivationRankData& from) {
    RefreshCultivationRankData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshCultivationRankData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshCultivationRankData";
  }
  protected:
  explicit RefreshCultivationRankData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRankDataFieldNumber = 1,
    kLastExpCycleTimestampFieldNumber = 3,
    kDirFieldNumber = 2,
  };
  // .idlepb.RankData rank_data = 1;
  bool has_rank_data() const;
  private:
  bool _internal_has_rank_data() const;
  public:
  void clear_rank_data();
  const ::idlepb::RankData& rank_data() const;
  PROTOBUF_NODISCARD ::idlepb::RankData* release_rank_data();
  ::idlepb::RankData* mutable_rank_data();
  void set_allocated_rank_data(::idlepb::RankData* rank_data);
  private:
  const ::idlepb::RankData& _internal_rank_data() const;
  ::idlepb::RankData* _internal_mutable_rank_data();
  public:
  void unsafe_arena_set_allocated_rank_data(
      ::idlepb::RankData* rank_data);
  ::idlepb::RankData* unsafe_arena_release_rank_data();

  // int64 last_exp_cycle_timestamp = 3;
  void clear_last_exp_cycle_timestamp();
  int64_t last_exp_cycle_timestamp() const;
  void set_last_exp_cycle_timestamp(int64_t value);
  private:
  int64_t _internal_last_exp_cycle_timestamp() const;
  void _internal_set_last_exp_cycle_timestamp(int64_t value);
  public:

  // .idlepb.CultivationDirection dir = 2;
  void clear_dir();
  ::idlepb::CultivationDirection dir() const;
  void set_dir(::idlepb::CultivationDirection value);
  private:
  ::idlepb::CultivationDirection _internal_dir() const;
  void _internal_set_dir(::idlepb::CultivationDirection value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RefreshCultivationRankData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RankData* rank_data_;
    int64_t last_exp_cycle_timestamp_;
    int dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshCultivationData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshCultivationData) */ {
 public:
  inline RefreshCultivationData() : RefreshCultivationData(nullptr) {}
  ~RefreshCultivationData() override;
  explicit PROTOBUF_CONSTEXPR RefreshCultivationData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshCultivationData(const RefreshCultivationData& from);
  RefreshCultivationData(RefreshCultivationData&& from) noexcept
    : RefreshCultivationData() {
    *this = ::std::move(from);
  }

  inline RefreshCultivationData& operator=(const RefreshCultivationData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshCultivationData& operator=(RefreshCultivationData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshCultivationData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshCultivationData* internal_default_instance() {
    return reinterpret_cast<const RefreshCultivationData*>(
               &_RefreshCultivationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RefreshCultivationData& a, RefreshCultivationData& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshCultivationData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshCultivationData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshCultivationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshCultivationData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshCultivationData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshCultivationData& from) {
    RefreshCultivationData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshCultivationData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshCultivationData";
  }
  protected:
  explicit RefreshCultivationData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCultivationDataFieldNumber = 1,
    kDirFieldNumber = 2,
  };
  // .idlepb.CultivationData cultivation_data = 1;
  bool has_cultivation_data() const;
  private:
  bool _internal_has_cultivation_data() const;
  public:
  void clear_cultivation_data();
  const ::idlepb::CultivationData& cultivation_data() const;
  PROTOBUF_NODISCARD ::idlepb::CultivationData* release_cultivation_data();
  ::idlepb::CultivationData* mutable_cultivation_data();
  void set_allocated_cultivation_data(::idlepb::CultivationData* cultivation_data);
  private:
  const ::idlepb::CultivationData& _internal_cultivation_data() const;
  ::idlepb::CultivationData* _internal_mutable_cultivation_data();
  public:
  void unsafe_arena_set_allocated_cultivation_data(
      ::idlepb::CultivationData* cultivation_data);
  ::idlepb::CultivationData* unsafe_arena_release_cultivation_data();

  // .idlepb.CultivationDirection dir = 2;
  void clear_dir();
  ::idlepb::CultivationDirection dir() const;
  void set_dir(::idlepb::CultivationDirection value);
  private:
  ::idlepb::CultivationDirection _internal_dir() const;
  void _internal_set_dir(::idlepb::CultivationDirection value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RefreshCultivationData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::CultivationData* cultivation_data_;
    int dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshCurrencyData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshCurrencyData) */ {
 public:
  inline RefreshCurrencyData() : RefreshCurrencyData(nullptr) {}
  ~RefreshCurrencyData() override;
  explicit PROTOBUF_CONSTEXPR RefreshCurrencyData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshCurrencyData(const RefreshCurrencyData& from);
  RefreshCurrencyData(RefreshCurrencyData&& from) noexcept
    : RefreshCurrencyData() {
    *this = ::std::move(from);
  }

  inline RefreshCurrencyData& operator=(const RefreshCurrencyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshCurrencyData& operator=(RefreshCurrencyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshCurrencyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshCurrencyData* internal_default_instance() {
    return reinterpret_cast<const RefreshCurrencyData*>(
               &_RefreshCurrencyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RefreshCurrencyData& a, RefreshCurrencyData& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshCurrencyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshCurrencyData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshCurrencyData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshCurrencyData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshCurrencyData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshCurrencyData& from) {
    RefreshCurrencyData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshCurrencyData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshCurrencyData";
  }
  protected:
  explicit RefreshCurrencyData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.CurrencyData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::CurrencyData& data() const;
  PROTOBUF_NODISCARD ::idlepb::CurrencyData* release_data();
  ::idlepb::CurrencyData* mutable_data();
  void set_allocated_data(::idlepb::CurrencyData* data);
  private:
  const ::idlepb::CurrencyData& _internal_data() const;
  ::idlepb::CurrencyData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::CurrencyData* data);
  ::idlepb::CurrencyData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.RefreshCurrencyData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::CurrencyData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshDailyCounterData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshDailyCounterData) */ {
 public:
  inline RefreshDailyCounterData() : RefreshDailyCounterData(nullptr) {}
  ~RefreshDailyCounterData() override;
  explicit PROTOBUF_CONSTEXPR RefreshDailyCounterData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshDailyCounterData(const RefreshDailyCounterData& from);
  RefreshDailyCounterData(RefreshDailyCounterData&& from) noexcept
    : RefreshDailyCounterData() {
    *this = ::std::move(from);
  }

  inline RefreshDailyCounterData& operator=(const RefreshDailyCounterData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshDailyCounterData& operator=(RefreshDailyCounterData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshDailyCounterData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshDailyCounterData* internal_default_instance() {
    return reinterpret_cast<const RefreshDailyCounterData*>(
               &_RefreshDailyCounterData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RefreshDailyCounterData& a, RefreshDailyCounterData& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshDailyCounterData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshDailyCounterData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshDailyCounterData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshDailyCounterData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshDailyCounterData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshDailyCounterData& from) {
    RefreshDailyCounterData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshDailyCounterData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshDailyCounterData";
  }
  protected:
  explicit RefreshDailyCounterData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDailyCounterFieldNumber = 1,
    kWeeklyCounterFieldNumber = 2,
  };
  // .idlepb.RoleDailyCounter daily_counter = 1;
  bool has_daily_counter() const;
  private:
  bool _internal_has_daily_counter() const;
  public:
  void clear_daily_counter();
  const ::idlepb::RoleDailyCounter& daily_counter() const;
  PROTOBUF_NODISCARD ::idlepb::RoleDailyCounter* release_daily_counter();
  ::idlepb::RoleDailyCounter* mutable_daily_counter();
  void set_allocated_daily_counter(::idlepb::RoleDailyCounter* daily_counter);
  private:
  const ::idlepb::RoleDailyCounter& _internal_daily_counter() const;
  ::idlepb::RoleDailyCounter* _internal_mutable_daily_counter();
  public:
  void unsafe_arena_set_allocated_daily_counter(
      ::idlepb::RoleDailyCounter* daily_counter);
  ::idlepb::RoleDailyCounter* unsafe_arena_release_daily_counter();

  // .idlepb.RoleWeeklyCounter weekly_counter = 2;
  bool has_weekly_counter() const;
  private:
  bool _internal_has_weekly_counter() const;
  public:
  void clear_weekly_counter();
  const ::idlepb::RoleWeeklyCounter& weekly_counter() const;
  PROTOBUF_NODISCARD ::idlepb::RoleWeeklyCounter* release_weekly_counter();
  ::idlepb::RoleWeeklyCounter* mutable_weekly_counter();
  void set_allocated_weekly_counter(::idlepb::RoleWeeklyCounter* weekly_counter);
  private:
  const ::idlepb::RoleWeeklyCounter& _internal_weekly_counter() const;
  ::idlepb::RoleWeeklyCounter* _internal_mutable_weekly_counter();
  public:
  void unsafe_arena_set_allocated_weekly_counter(
      ::idlepb::RoleWeeklyCounter* weekly_counter);
  ::idlepb::RoleWeeklyCounter* unsafe_arena_release_weekly_counter();

  // @@protoc_insertion_point(class_scope:idlepb.RefreshDailyCounterData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleDailyCounter* daily_counter_;
    ::idlepb::RoleWeeklyCounter* weekly_counter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshLastUnlockArenaId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshLastUnlockArenaId) */ {
 public:
  inline RefreshLastUnlockArenaId() : RefreshLastUnlockArenaId(nullptr) {}
  ~RefreshLastUnlockArenaId() override;
  explicit PROTOBUF_CONSTEXPR RefreshLastUnlockArenaId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshLastUnlockArenaId(const RefreshLastUnlockArenaId& from);
  RefreshLastUnlockArenaId(RefreshLastUnlockArenaId&& from) noexcept
    : RefreshLastUnlockArenaId() {
    *this = ::std::move(from);
  }

  inline RefreshLastUnlockArenaId& operator=(const RefreshLastUnlockArenaId& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshLastUnlockArenaId& operator=(RefreshLastUnlockArenaId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshLastUnlockArenaId& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshLastUnlockArenaId* internal_default_instance() {
    return reinterpret_cast<const RefreshLastUnlockArenaId*>(
               &_RefreshLastUnlockArenaId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RefreshLastUnlockArenaId& a, RefreshLastUnlockArenaId& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshLastUnlockArenaId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshLastUnlockArenaId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshLastUnlockArenaId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshLastUnlockArenaId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshLastUnlockArenaId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshLastUnlockArenaId& from) {
    RefreshLastUnlockArenaId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshLastUnlockArenaId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshLastUnlockArenaId";
  }
  protected:
  explicit RefreshLastUnlockArenaId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastUnlockArenaIdFieldNumber = 1,
  };
  // int32 last_unlock_arena_id = 1;
  void clear_last_unlock_arena_id();
  int32_t last_unlock_arena_id() const;
  void set_last_unlock_arena_id(int32_t value);
  private:
  int32_t _internal_last_unlock_arena_id() const;
  void _internal_set_last_unlock_arena_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RefreshLastUnlockArenaId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t last_unlock_arena_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshUnlockedEquipmentSlots final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshUnlockedEquipmentSlots) */ {
 public:
  inline RefreshUnlockedEquipmentSlots() : RefreshUnlockedEquipmentSlots(nullptr) {}
  ~RefreshUnlockedEquipmentSlots() override;
  explicit PROTOBUF_CONSTEXPR RefreshUnlockedEquipmentSlots(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshUnlockedEquipmentSlots(const RefreshUnlockedEquipmentSlots& from);
  RefreshUnlockedEquipmentSlots(RefreshUnlockedEquipmentSlots&& from) noexcept
    : RefreshUnlockedEquipmentSlots() {
    *this = ::std::move(from);
  }

  inline RefreshUnlockedEquipmentSlots& operator=(const RefreshUnlockedEquipmentSlots& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshUnlockedEquipmentSlots& operator=(RefreshUnlockedEquipmentSlots&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshUnlockedEquipmentSlots& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshUnlockedEquipmentSlots* internal_default_instance() {
    return reinterpret_cast<const RefreshUnlockedEquipmentSlots*>(
               &_RefreshUnlockedEquipmentSlots_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RefreshUnlockedEquipmentSlots& a, RefreshUnlockedEquipmentSlots& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshUnlockedEquipmentSlots* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshUnlockedEquipmentSlots* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshUnlockedEquipmentSlots* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshUnlockedEquipmentSlots>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshUnlockedEquipmentSlots& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshUnlockedEquipmentSlots& from) {
    RefreshUnlockedEquipmentSlots::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshUnlockedEquipmentSlots* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshUnlockedEquipmentSlots";
  }
  protected:
  explicit RefreshUnlockedEquipmentSlots(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotsFieldNumber = 1,
  };
  // repeated int32 slots = 1;
  int slots_size() const;
  private:
  int _internal_slots_size() const;
  public:
  void clear_slots();
  private:
  int32_t _internal_slots(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_slots() const;
  void _internal_add_slots(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_slots();
  public:
  int32_t slots(int index) const;
  void set_slots(int index, int32_t value);
  void add_slots(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      slots() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_slots();

  // @@protoc_insertion_point(class_scope:idlepb.RefreshUnlockedEquipmentSlots)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > slots_;
    mutable std::atomic<int> _slots_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UnlockEquipmentSlotReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UnlockEquipmentSlotReq) */ {
 public:
  inline UnlockEquipmentSlotReq() : UnlockEquipmentSlotReq(nullptr) {}
  ~UnlockEquipmentSlotReq() override;
  explicit PROTOBUF_CONSTEXPR UnlockEquipmentSlotReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockEquipmentSlotReq(const UnlockEquipmentSlotReq& from);
  UnlockEquipmentSlotReq(UnlockEquipmentSlotReq&& from) noexcept
    : UnlockEquipmentSlotReq() {
    *this = ::std::move(from);
  }

  inline UnlockEquipmentSlotReq& operator=(const UnlockEquipmentSlotReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockEquipmentSlotReq& operator=(UnlockEquipmentSlotReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockEquipmentSlotReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockEquipmentSlotReq* internal_default_instance() {
    return reinterpret_cast<const UnlockEquipmentSlotReq*>(
               &_UnlockEquipmentSlotReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UnlockEquipmentSlotReq& a, UnlockEquipmentSlotReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockEquipmentSlotReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockEquipmentSlotReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockEquipmentSlotReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockEquipmentSlotReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockEquipmentSlotReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnlockEquipmentSlotReq& from) {
    UnlockEquipmentSlotReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockEquipmentSlotReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UnlockEquipmentSlotReq";
  }
  protected:
  explicit UnlockEquipmentSlotReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UnlockEquipmentSlotReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UnlockEquipmentSlotAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UnlockEquipmentSlotAck) */ {
 public:
  inline UnlockEquipmentSlotAck() : UnlockEquipmentSlotAck(nullptr) {}
  ~UnlockEquipmentSlotAck() override;
  explicit PROTOBUF_CONSTEXPR UnlockEquipmentSlotAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockEquipmentSlotAck(const UnlockEquipmentSlotAck& from);
  UnlockEquipmentSlotAck(UnlockEquipmentSlotAck&& from) noexcept
    : UnlockEquipmentSlotAck() {
    *this = ::std::move(from);
  }

  inline UnlockEquipmentSlotAck& operator=(const UnlockEquipmentSlotAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockEquipmentSlotAck& operator=(UnlockEquipmentSlotAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockEquipmentSlotAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockEquipmentSlotAck* internal_default_instance() {
    return reinterpret_cast<const UnlockEquipmentSlotAck*>(
               &_UnlockEquipmentSlotAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UnlockEquipmentSlotAck& a, UnlockEquipmentSlotAck& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockEquipmentSlotAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockEquipmentSlotAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockEquipmentSlotAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockEquipmentSlotAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockEquipmentSlotAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnlockEquipmentSlotAck& from) {
    UnlockEquipmentSlotAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockEquipmentSlotAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UnlockEquipmentSlotAck";
  }
  protected:
  explicit UnlockEquipmentSlotAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UnlockEquipmentSlotAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ThunderTestRoundData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ThunderTestRoundData) */ {
 public:
  inline ThunderTestRoundData() : ThunderTestRoundData(nullptr) {}
  ~ThunderTestRoundData() override;
  explicit PROTOBUF_CONSTEXPR ThunderTestRoundData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThunderTestRoundData(const ThunderTestRoundData& from);
  ThunderTestRoundData(ThunderTestRoundData&& from) noexcept
    : ThunderTestRoundData() {
    *this = ::std::move(from);
  }

  inline ThunderTestRoundData& operator=(const ThunderTestRoundData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThunderTestRoundData& operator=(ThunderTestRoundData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThunderTestRoundData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThunderTestRoundData* internal_default_instance() {
    return reinterpret_cast<const ThunderTestRoundData*>(
               &_ThunderTestRoundData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ThunderTestRoundData& a, ThunderTestRoundData& b) {
    a.Swap(&b);
  }
  inline void Swap(ThunderTestRoundData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThunderTestRoundData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThunderTestRoundData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThunderTestRoundData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThunderTestRoundData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ThunderTestRoundData& from) {
    ThunderTestRoundData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThunderTestRoundData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ThunderTestRoundData";
  }
  protected:
  explicit ThunderTestRoundData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoundFieldNumber = 1,
    kDamageFieldNumber = 2,
    kHpFieldNumber = 3,
    kMpFieldNumber = 4,
  };
  // int32 round = 1;
  void clear_round();
  int32_t round() const;
  void set_round(int32_t value);
  private:
  int32_t _internal_round() const;
  void _internal_set_round(int32_t value);
  public:

  // float damage = 2;
  void clear_damage();
  float damage() const;
  void set_damage(float value);
  private:
  float _internal_damage() const;
  void _internal_set_damage(float value);
  public:

  // float hp = 3;
  void clear_hp();
  float hp() const;
  void set_hp(float value);
  private:
  float _internal_hp() const;
  void _internal_set_hp(float value);
  public:

  // float mp = 4;
  void clear_mp();
  float mp() const;
  void set_mp(float value);
  private:
  float _internal_mp() const;
  void _internal_set_mp(float value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ThunderTestRoundData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t round_;
    float damage_;
    float hp_;
    float mp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ThunderTestData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ThunderTestData) */ {
 public:
  inline ThunderTestData() : ThunderTestData(nullptr) {}
  ~ThunderTestData() override;
  explicit PROTOBUF_CONSTEXPR ThunderTestData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThunderTestData(const ThunderTestData& from);
  ThunderTestData(ThunderTestData&& from) noexcept
    : ThunderTestData() {
    *this = ::std::move(from);
  }

  inline ThunderTestData& operator=(const ThunderTestData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThunderTestData& operator=(ThunderTestData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThunderTestData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThunderTestData* internal_default_instance() {
    return reinterpret_cast<const ThunderTestData*>(
               &_ThunderTestData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ThunderTestData& a, ThunderTestData& b) {
    a.Swap(&b);
  }
  inline void Swap(ThunderTestData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThunderTestData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThunderTestData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThunderTestData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThunderTestData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ThunderTestData& from) {
    ThunderTestData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThunderTestData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ThunderTestData";
  }
  protected:
  explicit ThunderTestData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoundsFieldNumber = 3,
    kHpFieldNumber = 1,
    kMpFieldNumber = 2,
  };
  // repeated .idlepb.ThunderTestRoundData rounds = 3;
  int rounds_size() const;
  private:
  int _internal_rounds_size() const;
  public:
  void clear_rounds();
  ::idlepb::ThunderTestRoundData* mutable_rounds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ThunderTestRoundData >*
      mutable_rounds();
  private:
  const ::idlepb::ThunderTestRoundData& _internal_rounds(int index) const;
  ::idlepb::ThunderTestRoundData* _internal_add_rounds();
  public:
  const ::idlepb::ThunderTestRoundData& rounds(int index) const;
  ::idlepb::ThunderTestRoundData* add_rounds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ThunderTestRoundData >&
      rounds() const;

  // float hp = 1;
  void clear_hp();
  float hp() const;
  void set_hp(float value);
  private:
  float _internal_hp() const;
  void _internal_set_hp(float value);
  public:

  // float mp = 2;
  void clear_mp();
  float mp() const;
  void set_mp(float value);
  private:
  float _internal_mp() const;
  void _internal_set_mp(float value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ThunderTestData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ThunderTestRoundData > rounds_;
    float hp_;
    float mp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DoBreakthroughReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DoBreakthroughReq) */ {
 public:
  inline DoBreakthroughReq() : DoBreakthroughReq(nullptr) {}
  ~DoBreakthroughReq() override;
  explicit PROTOBUF_CONSTEXPR DoBreakthroughReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoBreakthroughReq(const DoBreakthroughReq& from);
  DoBreakthroughReq(DoBreakthroughReq&& from) noexcept
    : DoBreakthroughReq() {
    *this = ::std::move(from);
  }

  inline DoBreakthroughReq& operator=(const DoBreakthroughReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoBreakthroughReq& operator=(DoBreakthroughReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoBreakthroughReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoBreakthroughReq* internal_default_instance() {
    return reinterpret_cast<const DoBreakthroughReq*>(
               &_DoBreakthroughReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DoBreakthroughReq& a, DoBreakthroughReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DoBreakthroughReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoBreakthroughReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoBreakthroughReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoBreakthroughReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoBreakthroughReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoBreakthroughReq& from) {
    DoBreakthroughReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoBreakthroughReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DoBreakthroughReq";
  }
  protected:
  explicit DoBreakthroughReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // int64 item_id = 1;
  void clear_item_id();
  int64_t item_id() const;
  void set_item_id(int64_t value);
  private:
  int64_t _internal_item_id() const;
  void _internal_set_item_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DoBreakthroughReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t item_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DoBreakthroughAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DoBreakthroughAck) */ {
 public:
  inline DoBreakthroughAck() : DoBreakthroughAck(nullptr) {}
  ~DoBreakthroughAck() override;
  explicit PROTOBUF_CONSTEXPR DoBreakthroughAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoBreakthroughAck(const DoBreakthroughAck& from);
  DoBreakthroughAck(DoBreakthroughAck&& from) noexcept
    : DoBreakthroughAck() {
    *this = ::std::move(from);
  }

  inline DoBreakthroughAck& operator=(const DoBreakthroughAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoBreakthroughAck& operator=(DoBreakthroughAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoBreakthroughAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoBreakthroughAck* internal_default_instance() {
    return reinterpret_cast<const DoBreakthroughAck*>(
               &_DoBreakthroughAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DoBreakthroughAck& a, DoBreakthroughAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DoBreakthroughAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoBreakthroughAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoBreakthroughAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoBreakthroughAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoBreakthroughAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoBreakthroughAck& from) {
    DoBreakthroughAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoBreakthroughAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DoBreakthroughAck";
  }
  protected:
  explicit DoBreakthroughAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThunderTestDataFieldNumber = 5,
    kOldTypeFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kIsBottleneckFieldNumber = 4,
    kNewTypeFieldNumber = 3,
  };
  // .idlepb.ThunderTestData thunder_test_data = 5;
  bool has_thunder_test_data() const;
  private:
  bool _internal_has_thunder_test_data() const;
  public:
  void clear_thunder_test_data();
  const ::idlepb::ThunderTestData& thunder_test_data() const;
  PROTOBUF_NODISCARD ::idlepb::ThunderTestData* release_thunder_test_data();
  ::idlepb::ThunderTestData* mutable_thunder_test_data();
  void set_allocated_thunder_test_data(::idlepb::ThunderTestData* thunder_test_data);
  private:
  const ::idlepb::ThunderTestData& _internal_thunder_test_data() const;
  ::idlepb::ThunderTestData* _internal_mutable_thunder_test_data();
  public:
  void unsafe_arena_set_allocated_thunder_test_data(
      ::idlepb::ThunderTestData* thunder_test_data);
  ::idlepb::ThunderTestData* unsafe_arena_release_thunder_test_data();

  // .idlepb.BreakthroughType old_type = 2;
  void clear_old_type();
  ::idlepb::BreakthroughType old_type() const;
  void set_old_type(::idlepb::BreakthroughType value);
  private:
  ::idlepb::BreakthroughType _internal_old_type() const;
  void _internal_set_old_type(::idlepb::BreakthroughType value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // bool is_bottleneck = 4;
  void clear_is_bottleneck();
  bool is_bottleneck() const;
  void set_is_bottleneck(bool value);
  private:
  bool _internal_is_bottleneck() const;
  void _internal_set_is_bottleneck(bool value);
  public:

  // .idlepb.BreakthroughType new_type = 3;
  void clear_new_type();
  ::idlepb::BreakthroughType new_type() const;
  void set_new_type(::idlepb::BreakthroughType value);
  private:
  ::idlepb::BreakthroughType _internal_new_type() const;
  void _internal_set_new_type(::idlepb::BreakthroughType value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DoBreakthroughAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::ThunderTestData* thunder_test_data_;
    int old_type_;
    bool success_;
    bool is_bottleneck_;
    int new_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshItems) */ {
 public:
  inline RefreshItems() : RefreshItems(nullptr) {}
  ~RefreshItems() override;
  explicit PROTOBUF_CONSTEXPR RefreshItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshItems(const RefreshItems& from);
  RefreshItems(RefreshItems&& from) noexcept
    : RefreshItems() {
    *this = ::std::move(from);
  }

  inline RefreshItems& operator=(const RefreshItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshItems& operator=(RefreshItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshItems* internal_default_instance() {
    return reinterpret_cast<const RefreshItems*>(
               &_RefreshItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RefreshItems& a, RefreshItems& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshItems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshItems& from) {
    RefreshItems::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshItems* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshItems";
  }
  protected:
  explicit RefreshItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kJunksFieldNumber = 2,
    kOthersFieldNumber = 3,
    kQuietItemsFieldNumber = 4,
  };
  // repeated .idlepb.ItemData items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::ItemData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >*
      mutable_items();
  private:
  const ::idlepb::ItemData& _internal_items(int index) const;
  ::idlepb::ItemData* _internal_add_items();
  public:
  const ::idlepb::ItemData& items(int index) const;
  ::idlepb::ItemData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >&
      items() const;

  // repeated int64 junks = 2;
  int junks_size() const;
  private:
  int _internal_junks_size() const;
  public:
  void clear_junks();
  private:
  int64_t _internal_junks(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_junks() const;
  void _internal_add_junks(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_junks();
  public:
  int64_t junks(int index) const;
  void set_junks(int index, int64_t value);
  void add_junks(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      junks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_junks();

  // repeated .idlepb.SimpleItemData others = 3;
  int others_size() const;
  private:
  int _internal_others_size() const;
  public:
  void clear_others();
  ::idlepb::SimpleItemData* mutable_others(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
      mutable_others();
  private:
  const ::idlepb::SimpleItemData& _internal_others(int index) const;
  ::idlepb::SimpleItemData* _internal_add_others();
  public:
  const ::idlepb::SimpleItemData& others(int index) const;
  ::idlepb::SimpleItemData* add_others();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
      others() const;

  // repeated .idlepb.ItemData quiet_items = 4;
  int quiet_items_size() const;
  private:
  int _internal_quiet_items_size() const;
  public:
  void clear_quiet_items();
  ::idlepb::ItemData* mutable_quiet_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >*
      mutable_quiet_items();
  private:
  const ::idlepb::ItemData& _internal_quiet_items(int index) const;
  ::idlepb::ItemData* _internal_add_quiet_items();
  public:
  const ::idlepb::ItemData& quiet_items(int index) const;
  ::idlepb::ItemData* add_quiet_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >&
      quiet_items() const;

  // @@protoc_insertion_point(class_scope:idlepb.RefreshItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData > items_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > junks_;
    mutable std::atomic<int> _junks_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData > others_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData > quiet_items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshTemporaryPackageItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshTemporaryPackageItems) */ {
 public:
  inline RefreshTemporaryPackageItems() : RefreshTemporaryPackageItems(nullptr) {}
  ~RefreshTemporaryPackageItems() override;
  explicit PROTOBUF_CONSTEXPR RefreshTemporaryPackageItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshTemporaryPackageItems(const RefreshTemporaryPackageItems& from);
  RefreshTemporaryPackageItems(RefreshTemporaryPackageItems&& from) noexcept
    : RefreshTemporaryPackageItems() {
    *this = ::std::move(from);
  }

  inline RefreshTemporaryPackageItems& operator=(const RefreshTemporaryPackageItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshTemporaryPackageItems& operator=(RefreshTemporaryPackageItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshTemporaryPackageItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshTemporaryPackageItems* internal_default_instance() {
    return reinterpret_cast<const RefreshTemporaryPackageItems*>(
               &_RefreshTemporaryPackageItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RefreshTemporaryPackageItems& a, RefreshTemporaryPackageItems& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshTemporaryPackageItems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshTemporaryPackageItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshTemporaryPackageItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshTemporaryPackageItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshTemporaryPackageItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshTemporaryPackageItems& from) {
    RefreshTemporaryPackageItems::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshTemporaryPackageItems* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshTemporaryPackageItems";
  }
  protected:
  explicit RefreshTemporaryPackageItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kLastExtractTimeFieldNumber = 3,
    kTotalNumFieldNumber = 2,
  };
  // repeated .idlepb.TemporaryPackageItem items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::TemporaryPackageItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TemporaryPackageItem >*
      mutable_items();
  private:
  const ::idlepb::TemporaryPackageItem& _internal_items(int index) const;
  ::idlepb::TemporaryPackageItem* _internal_add_items();
  public:
  const ::idlepb::TemporaryPackageItem& items(int index) const;
  ::idlepb::TemporaryPackageItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TemporaryPackageItem >&
      items() const;

  // int64 last_extract_time = 3;
  void clear_last_extract_time();
  int64_t last_extract_time() const;
  void set_last_extract_time(int64_t value);
  private:
  int64_t _internal_last_extract_time() const;
  void _internal_set_last_extract_time(int64_t value);
  public:

  // int32 total_num = 2;
  void clear_total_num();
  int32_t total_num() const;
  void set_total_num(int32_t value);
  private:
  int32_t _internal_total_num() const;
  void _internal_set_total_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RefreshTemporaryPackageItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TemporaryPackageItem > items_;
    int64_t last_extract_time_;
    int32_t total_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ExtractTemporaryPackageItemsReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.ExtractTemporaryPackageItemsReq) */ {
 public:
  inline ExtractTemporaryPackageItemsReq() : ExtractTemporaryPackageItemsReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ExtractTemporaryPackageItemsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtractTemporaryPackageItemsReq(const ExtractTemporaryPackageItemsReq& from);
  ExtractTemporaryPackageItemsReq(ExtractTemporaryPackageItemsReq&& from) noexcept
    : ExtractTemporaryPackageItemsReq() {
    *this = ::std::move(from);
  }

  inline ExtractTemporaryPackageItemsReq& operator=(const ExtractTemporaryPackageItemsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtractTemporaryPackageItemsReq& operator=(ExtractTemporaryPackageItemsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtractTemporaryPackageItemsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtractTemporaryPackageItemsReq* internal_default_instance() {
    return reinterpret_cast<const ExtractTemporaryPackageItemsReq*>(
               &_ExtractTemporaryPackageItemsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ExtractTemporaryPackageItemsReq& a, ExtractTemporaryPackageItemsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtractTemporaryPackageItemsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtractTemporaryPackageItemsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtractTemporaryPackageItemsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtractTemporaryPackageItemsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ExtractTemporaryPackageItemsReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ExtractTemporaryPackageItemsReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ExtractTemporaryPackageItemsReq";
  }
  protected:
  explicit ExtractTemporaryPackageItemsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.ExtractTemporaryPackageItemsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ExtractTemporaryPackageItemsAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.ExtractTemporaryPackageItemsAck) */ {
 public:
  inline ExtractTemporaryPackageItemsAck() : ExtractTemporaryPackageItemsAck(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ExtractTemporaryPackageItemsAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtractTemporaryPackageItemsAck(const ExtractTemporaryPackageItemsAck& from);
  ExtractTemporaryPackageItemsAck(ExtractTemporaryPackageItemsAck&& from) noexcept
    : ExtractTemporaryPackageItemsAck() {
    *this = ::std::move(from);
  }

  inline ExtractTemporaryPackageItemsAck& operator=(const ExtractTemporaryPackageItemsAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtractTemporaryPackageItemsAck& operator=(ExtractTemporaryPackageItemsAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtractTemporaryPackageItemsAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtractTemporaryPackageItemsAck* internal_default_instance() {
    return reinterpret_cast<const ExtractTemporaryPackageItemsAck*>(
               &_ExtractTemporaryPackageItemsAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ExtractTemporaryPackageItemsAck& a, ExtractTemporaryPackageItemsAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtractTemporaryPackageItemsAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtractTemporaryPackageItemsAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtractTemporaryPackageItemsAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtractTemporaryPackageItemsAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ExtractTemporaryPackageItemsAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ExtractTemporaryPackageItemsAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ExtractTemporaryPackageItemsAck";
  }
  protected:
  explicit ExtractTemporaryPackageItemsAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.ExtractTemporaryPackageItemsAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetTemporaryPackageDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetTemporaryPackageDataReq) */ {
 public:
  inline GetTemporaryPackageDataReq() : GetTemporaryPackageDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetTemporaryPackageDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTemporaryPackageDataReq(const GetTemporaryPackageDataReq& from);
  GetTemporaryPackageDataReq(GetTemporaryPackageDataReq&& from) noexcept
    : GetTemporaryPackageDataReq() {
    *this = ::std::move(from);
  }

  inline GetTemporaryPackageDataReq& operator=(const GetTemporaryPackageDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTemporaryPackageDataReq& operator=(GetTemporaryPackageDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTemporaryPackageDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTemporaryPackageDataReq* internal_default_instance() {
    return reinterpret_cast<const GetTemporaryPackageDataReq*>(
               &_GetTemporaryPackageDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetTemporaryPackageDataReq& a, GetTemporaryPackageDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTemporaryPackageDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTemporaryPackageDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTemporaryPackageDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTemporaryPackageDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetTemporaryPackageDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetTemporaryPackageDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetTemporaryPackageDataReq";
  }
  protected:
  explicit GetTemporaryPackageDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetTemporaryPackageDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetTemporaryPackageDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetTemporaryPackageDataAck) */ {
 public:
  inline GetTemporaryPackageDataAck() : GetTemporaryPackageDataAck(nullptr) {}
  ~GetTemporaryPackageDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetTemporaryPackageDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTemporaryPackageDataAck(const GetTemporaryPackageDataAck& from);
  GetTemporaryPackageDataAck(GetTemporaryPackageDataAck&& from) noexcept
    : GetTemporaryPackageDataAck() {
    *this = ::std::move(from);
  }

  inline GetTemporaryPackageDataAck& operator=(const GetTemporaryPackageDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTemporaryPackageDataAck& operator=(GetTemporaryPackageDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTemporaryPackageDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTemporaryPackageDataAck* internal_default_instance() {
    return reinterpret_cast<const GetTemporaryPackageDataAck*>(
               &_GetTemporaryPackageDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetTemporaryPackageDataAck& a, GetTemporaryPackageDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTemporaryPackageDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTemporaryPackageDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTemporaryPackageDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTemporaryPackageDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTemporaryPackageDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTemporaryPackageDataAck& from) {
    GetTemporaryPackageDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTemporaryPackageDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetTemporaryPackageDataAck";
  }
  protected:
  explicit GetTemporaryPackageDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kLastExtractTimeFieldNumber = 2,
  };
  // repeated .idlepb.TemporaryPackageItem items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::TemporaryPackageItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TemporaryPackageItem >*
      mutable_items();
  private:
  const ::idlepb::TemporaryPackageItem& _internal_items(int index) const;
  ::idlepb::TemporaryPackageItem* _internal_add_items();
  public:
  const ::idlepb::TemporaryPackageItem& items(int index) const;
  ::idlepb::TemporaryPackageItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TemporaryPackageItem >&
      items() const;

  // int64 last_extract_time = 2;
  void clear_last_extract_time();
  int64_t last_extract_time() const;
  void set_last_extract_time(int64_t value);
  private:
  int64_t _internal_last_extract_time() const;
  void _internal_set_last_extract_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetTemporaryPackageDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TemporaryPackageItem > items_;
    int64_t last_extract_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetArenaExplorationStatisticalDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetArenaExplorationStatisticalDataReq) */ {
 public:
  inline GetArenaExplorationStatisticalDataReq() : GetArenaExplorationStatisticalDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetArenaExplorationStatisticalDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArenaExplorationStatisticalDataReq(const GetArenaExplorationStatisticalDataReq& from);
  GetArenaExplorationStatisticalDataReq(GetArenaExplorationStatisticalDataReq&& from) noexcept
    : GetArenaExplorationStatisticalDataReq() {
    *this = ::std::move(from);
  }

  inline GetArenaExplorationStatisticalDataReq& operator=(const GetArenaExplorationStatisticalDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArenaExplorationStatisticalDataReq& operator=(GetArenaExplorationStatisticalDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArenaExplorationStatisticalDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArenaExplorationStatisticalDataReq* internal_default_instance() {
    return reinterpret_cast<const GetArenaExplorationStatisticalDataReq*>(
               &_GetArenaExplorationStatisticalDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetArenaExplorationStatisticalDataReq& a, GetArenaExplorationStatisticalDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArenaExplorationStatisticalDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArenaExplorationStatisticalDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArenaExplorationStatisticalDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArenaExplorationStatisticalDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetArenaExplorationStatisticalDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetArenaExplorationStatisticalDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetArenaExplorationStatisticalDataReq";
  }
  protected:
  explicit GetArenaExplorationStatisticalDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetArenaExplorationStatisticalDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetArenaExplorationStatisticalDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetArenaExplorationStatisticalDataAck) */ {
 public:
  inline GetArenaExplorationStatisticalDataAck() : GetArenaExplorationStatisticalDataAck(nullptr) {}
  ~GetArenaExplorationStatisticalDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetArenaExplorationStatisticalDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArenaExplorationStatisticalDataAck(const GetArenaExplorationStatisticalDataAck& from);
  GetArenaExplorationStatisticalDataAck(GetArenaExplorationStatisticalDataAck&& from) noexcept
    : GetArenaExplorationStatisticalDataAck() {
    *this = ::std::move(from);
  }

  inline GetArenaExplorationStatisticalDataAck& operator=(const GetArenaExplorationStatisticalDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArenaExplorationStatisticalDataAck& operator=(GetArenaExplorationStatisticalDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArenaExplorationStatisticalDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArenaExplorationStatisticalDataAck* internal_default_instance() {
    return reinterpret_cast<const GetArenaExplorationStatisticalDataAck*>(
               &_GetArenaExplorationStatisticalDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GetArenaExplorationStatisticalDataAck& a, GetArenaExplorationStatisticalDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArenaExplorationStatisticalDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArenaExplorationStatisticalDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArenaExplorationStatisticalDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArenaExplorationStatisticalDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetArenaExplorationStatisticalDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetArenaExplorationStatisticalDataAck& from) {
    GetArenaExplorationStatisticalDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArenaExplorationStatisticalDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetArenaExplorationStatisticalDataAck";
  }
  protected:
  explicit GetArenaExplorationStatisticalDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleArenaExplorationStatisticalData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleArenaExplorationStatisticalData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleArenaExplorationStatisticalData* release_data();
  ::idlepb::RoleArenaExplorationStatisticalData* mutable_data();
  void set_allocated_data(::idlepb::RoleArenaExplorationStatisticalData* data);
  private:
  const ::idlepb::RoleArenaExplorationStatisticalData& _internal_data() const;
  ::idlepb::RoleArenaExplorationStatisticalData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleArenaExplorationStatisticalData* data);
  ::idlepb::RoleArenaExplorationStatisticalData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetArenaExplorationStatisticalDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleArenaExplorationStatisticalData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DoBreathingExerciseReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DoBreathingExerciseReq) */ {
 public:
  inline DoBreathingExerciseReq() : DoBreathingExerciseReq(nullptr) {}
  ~DoBreathingExerciseReq() override;
  explicit PROTOBUF_CONSTEXPR DoBreathingExerciseReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoBreathingExerciseReq(const DoBreathingExerciseReq& from);
  DoBreathingExerciseReq(DoBreathingExerciseReq&& from) noexcept
    : DoBreathingExerciseReq() {
    *this = ::std::move(from);
  }

  inline DoBreathingExerciseReq& operator=(const DoBreathingExerciseReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoBreathingExerciseReq& operator=(DoBreathingExerciseReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoBreathingExerciseReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoBreathingExerciseReq* internal_default_instance() {
    return reinterpret_cast<const DoBreathingExerciseReq*>(
               &_DoBreathingExerciseReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(DoBreathingExerciseReq& a, DoBreathingExerciseReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DoBreathingExerciseReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoBreathingExerciseReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoBreathingExerciseReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoBreathingExerciseReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoBreathingExerciseReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoBreathingExerciseReq& from) {
    DoBreathingExerciseReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoBreathingExerciseReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DoBreathingExerciseReq";
  }
  protected:
  explicit DoBreathingExerciseReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPercetFieldNumber = 1,
  };
  // float percet = 1;
  void clear_percet();
  float percet() const;
  void set_percet(float value);
  private:
  float _internal_percet() const;
  void _internal_set_percet(float value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DoBreathingExerciseReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float percet_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DoBreathingExerciseAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DoBreathingExerciseAck) */ {
 public:
  inline DoBreathingExerciseAck() : DoBreathingExerciseAck(nullptr) {}
  ~DoBreathingExerciseAck() override;
  explicit PROTOBUF_CONSTEXPR DoBreathingExerciseAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoBreathingExerciseAck(const DoBreathingExerciseAck& from);
  DoBreathingExerciseAck(DoBreathingExerciseAck&& from) noexcept
    : DoBreathingExerciseAck() {
    *this = ::std::move(from);
  }

  inline DoBreathingExerciseAck& operator=(const DoBreathingExerciseAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoBreathingExerciseAck& operator=(DoBreathingExerciseAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoBreathingExerciseAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoBreathingExerciseAck* internal_default_instance() {
    return reinterpret_cast<const DoBreathingExerciseAck*>(
               &_DoBreathingExerciseAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(DoBreathingExerciseAck& a, DoBreathingExerciseAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DoBreathingExerciseAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoBreathingExerciseAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoBreathingExerciseAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoBreathingExerciseAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoBreathingExerciseAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoBreathingExerciseAck& from) {
    DoBreathingExerciseAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoBreathingExerciseAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DoBreathingExerciseAck";
  }
  protected:
  explicit DoBreathingExerciseAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .idlepb.DoBreathingExerciseResult result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::idlepb::DoBreathingExerciseResult& result() const;
  PROTOBUF_NODISCARD ::idlepb::DoBreathingExerciseResult* release_result();
  ::idlepb::DoBreathingExerciseResult* mutable_result();
  void set_allocated_result(::idlepb::DoBreathingExerciseResult* result);
  private:
  const ::idlepb::DoBreathingExerciseResult& _internal_result() const;
  ::idlepb::DoBreathingExerciseResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::idlepb::DoBreathingExerciseResult* result);
  ::idlepb::DoBreathingExerciseResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:idlepb.DoBreathingExerciseAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::DoBreathingExerciseResult* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OneClickMergeBreathingReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.OneClickMergeBreathingReq) */ {
 public:
  inline OneClickMergeBreathingReq() : OneClickMergeBreathingReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OneClickMergeBreathingReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneClickMergeBreathingReq(const OneClickMergeBreathingReq& from);
  OneClickMergeBreathingReq(OneClickMergeBreathingReq&& from) noexcept
    : OneClickMergeBreathingReq() {
    *this = ::std::move(from);
  }

  inline OneClickMergeBreathingReq& operator=(const OneClickMergeBreathingReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneClickMergeBreathingReq& operator=(OneClickMergeBreathingReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneClickMergeBreathingReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneClickMergeBreathingReq* internal_default_instance() {
    return reinterpret_cast<const OneClickMergeBreathingReq*>(
               &_OneClickMergeBreathingReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(OneClickMergeBreathingReq& a, OneClickMergeBreathingReq& b) {
    a.Swap(&b);
  }
  inline void Swap(OneClickMergeBreathingReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneClickMergeBreathingReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneClickMergeBreathingReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneClickMergeBreathingReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OneClickMergeBreathingReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OneClickMergeBreathingReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OneClickMergeBreathingReq";
  }
  protected:
  explicit OneClickMergeBreathingReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.OneClickMergeBreathingReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OneClickMergeBreathingAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.OneClickMergeBreathingAck) */ {
 public:
  inline OneClickMergeBreathingAck() : OneClickMergeBreathingAck(nullptr) {}
  ~OneClickMergeBreathingAck() override;
  explicit PROTOBUF_CONSTEXPR OneClickMergeBreathingAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneClickMergeBreathingAck(const OneClickMergeBreathingAck& from);
  OneClickMergeBreathingAck(OneClickMergeBreathingAck&& from) noexcept
    : OneClickMergeBreathingAck() {
    *this = ::std::move(from);
  }

  inline OneClickMergeBreathingAck& operator=(const OneClickMergeBreathingAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneClickMergeBreathingAck& operator=(OneClickMergeBreathingAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneClickMergeBreathingAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneClickMergeBreathingAck* internal_default_instance() {
    return reinterpret_cast<const OneClickMergeBreathingAck*>(
               &_OneClickMergeBreathingAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(OneClickMergeBreathingAck& a, OneClickMergeBreathingAck& b) {
    a.Swap(&b);
  }
  inline void Swap(OneClickMergeBreathingAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneClickMergeBreathingAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneClickMergeBreathingAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneClickMergeBreathingAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OneClickMergeBreathingAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OneClickMergeBreathingAck& from) {
    OneClickMergeBreathingAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneClickMergeBreathingAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OneClickMergeBreathingAck";
  }
  protected:
  explicit OneClickMergeBreathingAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  // repeated float exp = 1;
  int exp_size() const;
  private:
  int _internal_exp_size() const;
  public:
  void clear_exp();
  private:
  float _internal_exp(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_exp() const;
  void _internal_add_exp(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_exp();
  public:
  float exp(int index) const;
  void set_exp(int index, float value);
  void add_exp(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      exp() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_exp();

  // repeated float ret = 2;
  int ret_size() const;
  private:
  int _internal_ret_size() const;
  public:
  void clear_ret();
  private:
  float _internal_ret(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_ret() const;
  void _internal_add_ret(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_ret();
  public:
  float ret(int index) const;
  void set_ret(int index, float value);
  void add_ret(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      ret() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_ret();

  // @@protoc_insertion_point(class_scope:idlepb.OneClickMergeBreathingAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > exp_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > ret_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestCommonCultivationDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.RequestCommonCultivationDataReq) */ {
 public:
  inline RequestCommonCultivationDataReq() : RequestCommonCultivationDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RequestCommonCultivationDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestCommonCultivationDataReq(const RequestCommonCultivationDataReq& from);
  RequestCommonCultivationDataReq(RequestCommonCultivationDataReq&& from) noexcept
    : RequestCommonCultivationDataReq() {
    *this = ::std::move(from);
  }

  inline RequestCommonCultivationDataReq& operator=(const RequestCommonCultivationDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestCommonCultivationDataReq& operator=(RequestCommonCultivationDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestCommonCultivationDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestCommonCultivationDataReq* internal_default_instance() {
    return reinterpret_cast<const RequestCommonCultivationDataReq*>(
               &_RequestCommonCultivationDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(RequestCommonCultivationDataReq& a, RequestCommonCultivationDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestCommonCultivationDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestCommonCultivationDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestCommonCultivationDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestCommonCultivationDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RequestCommonCultivationDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RequestCommonCultivationDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestCommonCultivationDataReq";
  }
  protected:
  explicit RequestCommonCultivationDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.RequestCommonCultivationDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestCommonCultivationDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RequestCommonCultivationDataAck) */ {
 public:
  inline RequestCommonCultivationDataAck() : RequestCommonCultivationDataAck(nullptr) {}
  ~RequestCommonCultivationDataAck() override;
  explicit PROTOBUF_CONSTEXPR RequestCommonCultivationDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestCommonCultivationDataAck(const RequestCommonCultivationDataAck& from);
  RequestCommonCultivationDataAck(RequestCommonCultivationDataAck&& from) noexcept
    : RequestCommonCultivationDataAck() {
    *this = ::std::move(from);
  }

  inline RequestCommonCultivationDataAck& operator=(const RequestCommonCultivationDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestCommonCultivationDataAck& operator=(RequestCommonCultivationDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestCommonCultivationDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestCommonCultivationDataAck* internal_default_instance() {
    return reinterpret_cast<const RequestCommonCultivationDataAck*>(
               &_RequestCommonCultivationDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(RequestCommonCultivationDataAck& a, RequestCommonCultivationDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestCommonCultivationDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestCommonCultivationDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestCommonCultivationDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestCommonCultivationDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestCommonCultivationDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestCommonCultivationDataAck& from) {
    RequestCommonCultivationDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestCommonCultivationDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestCommonCultivationDataAck";
  }
  protected:
  explicit RequestCommonCultivationDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.CommonCultivationData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::CommonCultivationData& data() const;
  PROTOBUF_NODISCARD ::idlepb::CommonCultivationData* release_data();
  ::idlepb::CommonCultivationData* mutable_data();
  void set_allocated_data(::idlepb::CommonCultivationData* data);
  private:
  const ::idlepb::CommonCultivationData& _internal_data() const;
  ::idlepb::CommonCultivationData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::CommonCultivationData* data);
  ::idlepb::CommonCultivationData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.RequestCommonCultivationDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::CommonCultivationData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReceiveBreathingExerciseRewardReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReceiveBreathingExerciseRewardReq) */ {
 public:
  inline ReceiveBreathingExerciseRewardReq() : ReceiveBreathingExerciseRewardReq(nullptr) {}
  ~ReceiveBreathingExerciseRewardReq() override;
  explicit PROTOBUF_CONSTEXPR ReceiveBreathingExerciseRewardReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveBreathingExerciseRewardReq(const ReceiveBreathingExerciseRewardReq& from);
  ReceiveBreathingExerciseRewardReq(ReceiveBreathingExerciseRewardReq&& from) noexcept
    : ReceiveBreathingExerciseRewardReq() {
    *this = ::std::move(from);
  }

  inline ReceiveBreathingExerciseRewardReq& operator=(const ReceiveBreathingExerciseRewardReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveBreathingExerciseRewardReq& operator=(ReceiveBreathingExerciseRewardReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveBreathingExerciseRewardReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveBreathingExerciseRewardReq* internal_default_instance() {
    return reinterpret_cast<const ReceiveBreathingExerciseRewardReq*>(
               &_ReceiveBreathingExerciseRewardReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ReceiveBreathingExerciseRewardReq& a, ReceiveBreathingExerciseRewardReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveBreathingExerciseRewardReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveBreathingExerciseRewardReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveBreathingExerciseRewardReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveBreathingExerciseRewardReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveBreathingExerciseRewardReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiveBreathingExerciseRewardReq& from) {
    ReceiveBreathingExerciseRewardReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveBreathingExerciseRewardReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReceiveBreathingExerciseRewardReq";
  }
  protected:
  explicit ReceiveBreathingExerciseRewardReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReceiveBreathingExerciseRewardReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReceiveBreathingExerciseRewardAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReceiveBreathingExerciseRewardAck) */ {
 public:
  inline ReceiveBreathingExerciseRewardAck() : ReceiveBreathingExerciseRewardAck(nullptr) {}
  ~ReceiveBreathingExerciseRewardAck() override;
  explicit PROTOBUF_CONSTEXPR ReceiveBreathingExerciseRewardAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveBreathingExerciseRewardAck(const ReceiveBreathingExerciseRewardAck& from);
  ReceiveBreathingExerciseRewardAck(ReceiveBreathingExerciseRewardAck&& from) noexcept
    : ReceiveBreathingExerciseRewardAck() {
    *this = ::std::move(from);
  }

  inline ReceiveBreathingExerciseRewardAck& operator=(const ReceiveBreathingExerciseRewardAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveBreathingExerciseRewardAck& operator=(ReceiveBreathingExerciseRewardAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveBreathingExerciseRewardAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveBreathingExerciseRewardAck* internal_default_instance() {
    return reinterpret_cast<const ReceiveBreathingExerciseRewardAck*>(
               &_ReceiveBreathingExerciseRewardAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ReceiveBreathingExerciseRewardAck& a, ReceiveBreathingExerciseRewardAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveBreathingExerciseRewardAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveBreathingExerciseRewardAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveBreathingExerciseRewardAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveBreathingExerciseRewardAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveBreathingExerciseRewardAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiveBreathingExerciseRewardAck& from) {
    ReceiveBreathingExerciseRewardAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveBreathingExerciseRewardAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReceiveBreathingExerciseRewardAck";
  }
  protected:
  explicit ReceiveBreathingExerciseRewardAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReceiveBreathingExerciseRewardAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UseItemReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UseItemReq) */ {
 public:
  inline UseItemReq() : UseItemReq(nullptr) {}
  ~UseItemReq() override;
  explicit PROTOBUF_CONSTEXPR UseItemReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UseItemReq(const UseItemReq& from);
  UseItemReq(UseItemReq&& from) noexcept
    : UseItemReq() {
    *this = ::std::move(from);
  }

  inline UseItemReq& operator=(const UseItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseItemReq& operator=(UseItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseItemReq* internal_default_instance() {
    return reinterpret_cast<const UseItemReq*>(
               &_UseItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(UseItemReq& a, UseItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UseItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseItemReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseItemReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseItemReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UseItemReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UseItemReq& from) {
    UseItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UseItemReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UseItemReq";
  }
  protected:
  explicit UseItemReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCfgIdFieldNumber = 2,
    kNumFieldNumber = 3,
  };
  // int64 id = 1;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // int32 cfg_id = 2;
  void clear_cfg_id();
  int32_t cfg_id() const;
  void set_cfg_id(int32_t value);
  private:
  int32_t _internal_cfg_id() const;
  void _internal_set_cfg_id(int32_t value);
  public:

  // int32 num = 3;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UseItemReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t id_;
    int32_t cfg_id_;
    int32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UseItemAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UseItemAck) */ {
 public:
  inline UseItemAck() : UseItemAck(nullptr) {}
  ~UseItemAck() override;
  explicit PROTOBUF_CONSTEXPR UseItemAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UseItemAck(const UseItemAck& from);
  UseItemAck(UseItemAck&& from) noexcept
    : UseItemAck() {
    *this = ::std::move(from);
  }

  inline UseItemAck& operator=(const UseItemAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseItemAck& operator=(UseItemAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseItemAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseItemAck* internal_default_instance() {
    return reinterpret_cast<const UseItemAck*>(
               &_UseItemAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(UseItemAck& a, UseItemAck& b) {
    a.Swap(&b);
  }
  inline void Swap(UseItemAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseItemAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseItemAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseItemAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UseItemAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UseItemAck& from) {
    UseItemAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UseItemAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UseItemAck";
  }
  protected:
  explicit UseItemAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 11,
  };
  // .idlepb.UseItemResult error_code = 11;
  void clear_error_code();
  ::idlepb::UseItemResult error_code() const;
  void set_error_code(::idlepb::UseItemResult value);
  private:
  ::idlepb::UseItemResult _internal_error_code() const;
  void _internal_set_error_code(::idlepb::UseItemResult value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UseItemAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UseSelectGiftReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UseSelectGiftReq) */ {
 public:
  inline UseSelectGiftReq() : UseSelectGiftReq(nullptr) {}
  ~UseSelectGiftReq() override;
  explicit PROTOBUF_CONSTEXPR UseSelectGiftReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UseSelectGiftReq(const UseSelectGiftReq& from);
  UseSelectGiftReq(UseSelectGiftReq&& from) noexcept
    : UseSelectGiftReq() {
    *this = ::std::move(from);
  }

  inline UseSelectGiftReq& operator=(const UseSelectGiftReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseSelectGiftReq& operator=(UseSelectGiftReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseSelectGiftReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseSelectGiftReq* internal_default_instance() {
    return reinterpret_cast<const UseSelectGiftReq*>(
               &_UseSelectGiftReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(UseSelectGiftReq& a, UseSelectGiftReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UseSelectGiftReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseSelectGiftReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseSelectGiftReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseSelectGiftReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UseSelectGiftReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UseSelectGiftReq& from) {
    UseSelectGiftReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UseSelectGiftReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UseSelectGiftReq";
  }
  protected:
  explicit UseSelectGiftReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kChooseIdFieldNumber = 2,
    kNumFieldNumber = 3,
  };
  // int64 uid = 1;
  void clear_uid();
  int64_t uid() const;
  void set_uid(int64_t value);
  private:
  int64_t _internal_uid() const;
  void _internal_set_uid(int64_t value);
  public:

  // int32 choose_id = 2;
  void clear_choose_id();
  int32_t choose_id() const;
  void set_choose_id(int32_t value);
  private:
  int32_t _internal_choose_id() const;
  void _internal_set_choose_id(int32_t value);
  public:

  // int32 num = 3;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UseSelectGiftReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t uid_;
    int32_t choose_id_;
    int32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UseSelectGiftAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UseSelectGiftAck) */ {
 public:
  inline UseSelectGiftAck() : UseSelectGiftAck(nullptr) {}
  ~UseSelectGiftAck() override;
  explicit PROTOBUF_CONSTEXPR UseSelectGiftAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UseSelectGiftAck(const UseSelectGiftAck& from);
  UseSelectGiftAck(UseSelectGiftAck&& from) noexcept
    : UseSelectGiftAck() {
    *this = ::std::move(from);
  }

  inline UseSelectGiftAck& operator=(const UseSelectGiftAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseSelectGiftAck& operator=(UseSelectGiftAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseSelectGiftAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseSelectGiftAck* internal_default_instance() {
    return reinterpret_cast<const UseSelectGiftAck*>(
               &_UseSelectGiftAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(UseSelectGiftAck& a, UseSelectGiftAck& b) {
    a.Swap(&b);
  }
  inline void Swap(UseSelectGiftAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseSelectGiftAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseSelectGiftAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseSelectGiftAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UseSelectGiftAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UseSelectGiftAck& from) {
    UseSelectGiftAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UseSelectGiftAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UseSelectGiftAck";
  }
  protected:
  explicit UseSelectGiftAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 11,
  };
  // .idlepb.UseItemResult error_code = 11;
  void clear_error_code();
  ::idlepb::UseItemResult error_code() const;
  void set_error_code(::idlepb::UseItemResult value);
  private:
  ::idlepb::UseItemResult _internal_error_code() const;
  void _internal_set_error_code(::idlepb::UseItemResult value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UseSelectGiftAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SellItemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SellItemInfo) */ {
 public:
  inline SellItemInfo() : SellItemInfo(nullptr) {}
  ~SellItemInfo() override;
  explicit PROTOBUF_CONSTEXPR SellItemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SellItemInfo(const SellItemInfo& from);
  SellItemInfo(SellItemInfo&& from) noexcept
    : SellItemInfo() {
    *this = ::std::move(from);
  }

  inline SellItemInfo& operator=(const SellItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SellItemInfo& operator=(SellItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SellItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SellItemInfo* internal_default_instance() {
    return reinterpret_cast<const SellItemInfo*>(
               &_SellItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(SellItemInfo& a, SellItemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SellItemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SellItemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SellItemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SellItemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SellItemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SellItemInfo& from) {
    SellItemInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellItemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SellItemInfo";
  }
  protected:
  explicit SellItemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kNumFieldNumber = 2,
    kOkFieldNumber = 3,
  };
  // int64 item_id = 1;
  void clear_item_id();
  int64_t item_id() const;
  void set_item_id(int64_t value);
  private:
  int64_t _internal_item_id() const;
  void _internal_set_item_id(int64_t value);
  public:

  // int32 num = 2;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // bool ok = 3;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SellItemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t item_id_;
    int32_t num_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SellItemReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SellItemReq) */ {
 public:
  inline SellItemReq() : SellItemReq(nullptr) {}
  ~SellItemReq() override;
  explicit PROTOBUF_CONSTEXPR SellItemReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SellItemReq(const SellItemReq& from);
  SellItemReq(SellItemReq&& from) noexcept
    : SellItemReq() {
    *this = ::std::move(from);
  }

  inline SellItemReq& operator=(const SellItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SellItemReq& operator=(SellItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SellItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SellItemReq* internal_default_instance() {
    return reinterpret_cast<const SellItemReq*>(
               &_SellItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SellItemReq& a, SellItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SellItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SellItemReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SellItemReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SellItemReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SellItemReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SellItemReq& from) {
    SellItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellItemReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SellItemReq";
  }
  protected:
  explicit SellItemReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .idlepb.SellItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::SellItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SellItemInfo >*
      mutable_items();
  private:
  const ::idlepb::SellItemInfo& _internal_items(int index) const;
  ::idlepb::SellItemInfo* _internal_add_items();
  public:
  const ::idlepb::SellItemInfo& items(int index) const;
  ::idlepb::SellItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SellItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:idlepb.SellItemReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SellItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SellItemAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SellItemAck) */ {
 public:
  inline SellItemAck() : SellItemAck(nullptr) {}
  ~SellItemAck() override;
  explicit PROTOBUF_CONSTEXPR SellItemAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SellItemAck(const SellItemAck& from);
  SellItemAck(SellItemAck&& from) noexcept
    : SellItemAck() {
    *this = ::std::move(from);
  }

  inline SellItemAck& operator=(const SellItemAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SellItemAck& operator=(SellItemAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SellItemAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SellItemAck* internal_default_instance() {
    return reinterpret_cast<const SellItemAck*>(
               &_SellItemAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(SellItemAck& a, SellItemAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SellItemAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SellItemAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SellItemAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SellItemAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SellItemAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SellItemAck& from) {
    SellItemAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SellItemAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SellItemAck";
  }
  protected:
  explicit SellItemAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .idlepb.SellItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::SellItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SellItemInfo >*
      mutable_items();
  private:
  const ::idlepb::SellItemInfo& _internal_items(int index) const;
  ::idlepb::SellItemInfo* _internal_add_items();
  public:
  const ::idlepb::SellItemInfo& items(int index) const;
  ::idlepb::SellItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SellItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:idlepb.SellItemAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SellItemInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshAlchemyData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshAlchemyData) */ {
 public:
  inline RefreshAlchemyData() : RefreshAlchemyData(nullptr) {}
  ~RefreshAlchemyData() override;
  explicit PROTOBUF_CONSTEXPR RefreshAlchemyData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshAlchemyData(const RefreshAlchemyData& from);
  RefreshAlchemyData(RefreshAlchemyData&& from) noexcept
    : RefreshAlchemyData() {
    *this = ::std::move(from);
  }

  inline RefreshAlchemyData& operator=(const RefreshAlchemyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshAlchemyData& operator=(RefreshAlchemyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshAlchemyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshAlchemyData* internal_default_instance() {
    return reinterpret_cast<const RefreshAlchemyData*>(
               &_RefreshAlchemyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(RefreshAlchemyData& a, RefreshAlchemyData& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshAlchemyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshAlchemyData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshAlchemyData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshAlchemyData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshAlchemyData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshAlchemyData& from) {
    RefreshAlchemyData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshAlchemyData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshAlchemyData";
  }
  protected:
  explicit RefreshAlchemyData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleAlchemyData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleAlchemyData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleAlchemyData* release_data();
  ::idlepb::RoleAlchemyData* mutable_data();
  void set_allocated_data(::idlepb::RoleAlchemyData* data);
  private:
  const ::idlepb::RoleAlchemyData& _internal_data() const;
  ::idlepb::RoleAlchemyData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleAlchemyData* data);
  ::idlepb::RoleAlchemyData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.RefreshAlchemyData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleAlchemyData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyAlchemyRefineResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyAlchemyRefineResult) */ {
 public:
  inline NotifyAlchemyRefineResult() : NotifyAlchemyRefineResult(nullptr) {}
  ~NotifyAlchemyRefineResult() override;
  explicit PROTOBUF_CONSTEXPR NotifyAlchemyRefineResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyAlchemyRefineResult(const NotifyAlchemyRefineResult& from);
  NotifyAlchemyRefineResult(NotifyAlchemyRefineResult&& from) noexcept
    : NotifyAlchemyRefineResult() {
    *this = ::std::move(from);
  }

  inline NotifyAlchemyRefineResult& operator=(const NotifyAlchemyRefineResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyAlchemyRefineResult& operator=(NotifyAlchemyRefineResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyAlchemyRefineResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyAlchemyRefineResult* internal_default_instance() {
    return reinterpret_cast<const NotifyAlchemyRefineResult*>(
               &_NotifyAlchemyRefineResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(NotifyAlchemyRefineResult& a, NotifyAlchemyRefineResult& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyAlchemyRefineResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyAlchemyRefineResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyAlchemyRefineResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyAlchemyRefineResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyAlchemyRefineResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyAlchemyRefineResult& from) {
    NotifyAlchemyRefineResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyAlchemyRefineResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyAlchemyRefineResult";
  }
  protected:
  explicit NotifyAlchemyRefineResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualityFieldNumber = 1,
    kItemCfgIdFieldNumber = 2,
    kItemNumFieldNumber = 3,
    kExpFieldNumber = 4,
    kChanceTypeFieldNumber = 5,
  };
  // .idlepb.ItemQuality quality = 1;
  void clear_quality();
  ::idlepb::ItemQuality quality() const;
  void set_quality(::idlepb::ItemQuality value);
  private:
  ::idlepb::ItemQuality _internal_quality() const;
  void _internal_set_quality(::idlepb::ItemQuality value);
  public:

  // int32 item_cfg_id = 2;
  void clear_item_cfg_id();
  int32_t item_cfg_id() const;
  void set_item_cfg_id(int32_t value);
  private:
  int32_t _internal_item_cfg_id() const;
  void _internal_set_item_cfg_id(int32_t value);
  public:

  // int32 item_num = 3;
  void clear_item_num();
  int32_t item_num() const;
  void set_item_num(int32_t value);
  private:
  int32_t _internal_item_num() const;
  void _internal_set_item_num(int32_t value);
  public:

  // int32 exp = 4;
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // .idlepb.AlchemyChanceType chance_type = 5;
  void clear_chance_type();
  ::idlepb::AlchemyChanceType chance_type() const;
  void set_chance_type(::idlepb::AlchemyChanceType value);
  private:
  ::idlepb::AlchemyChanceType _internal_chance_type() const;
  void _internal_set_chance_type(::idlepb::AlchemyChanceType value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyAlchemyRefineResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int quality_;
    int32_t item_cfg_id_;
    int32_t item_num_;
    int32_t exp_;
    int chance_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshForgeData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshForgeData) */ {
 public:
  inline RefreshForgeData() : RefreshForgeData(nullptr) {}
  ~RefreshForgeData() override;
  explicit PROTOBUF_CONSTEXPR RefreshForgeData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshForgeData(const RefreshForgeData& from);
  RefreshForgeData(RefreshForgeData&& from) noexcept
    : RefreshForgeData() {
    *this = ::std::move(from);
  }

  inline RefreshForgeData& operator=(const RefreshForgeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshForgeData& operator=(RefreshForgeData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshForgeData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshForgeData* internal_default_instance() {
    return reinterpret_cast<const RefreshForgeData*>(
               &_RefreshForgeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(RefreshForgeData& a, RefreshForgeData& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshForgeData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshForgeData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshForgeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshForgeData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshForgeData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshForgeData& from) {
    RefreshForgeData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshForgeData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshForgeData";
  }
  protected:
  explicit RefreshForgeData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleForgeData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleForgeData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleForgeData* release_data();
  ::idlepb::RoleForgeData* mutable_data();
  void set_allocated_data(::idlepb::RoleForgeData* data);
  private:
  const ::idlepb::RoleForgeData& _internal_data() const;
  ::idlepb::RoleForgeData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleForgeData* data);
  ::idlepb::RoleForgeData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.RefreshForgeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleForgeData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyForgeRefineResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyForgeRefineResult) */ {
 public:
  inline NotifyForgeRefineResult() : NotifyForgeRefineResult(nullptr) {}
  ~NotifyForgeRefineResult() override;
  explicit PROTOBUF_CONSTEXPR NotifyForgeRefineResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyForgeRefineResult(const NotifyForgeRefineResult& from);
  NotifyForgeRefineResult(NotifyForgeRefineResult&& from) noexcept
    : NotifyForgeRefineResult() {
    *this = ::std::move(from);
  }

  inline NotifyForgeRefineResult& operator=(const NotifyForgeRefineResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyForgeRefineResult& operator=(NotifyForgeRefineResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyForgeRefineResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyForgeRefineResult* internal_default_instance() {
    return reinterpret_cast<const NotifyForgeRefineResult*>(
               &_NotifyForgeRefineResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(NotifyForgeRefineResult& a, NotifyForgeRefineResult& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyForgeRefineResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyForgeRefineResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyForgeRefineResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyForgeRefineResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyForgeRefineResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyForgeRefineResult& from) {
    NotifyForgeRefineResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyForgeRefineResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyForgeRefineResult";
  }
  protected:
  explicit NotifyForgeRefineResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualityFieldNumber = 1,
    kItemCfgIdFieldNumber = 2,
    kItemNumFieldNumber = 3,
    kExpFieldNumber = 4,
    kChanceTypeFieldNumber = 5,
  };
  // .idlepb.ItemQuality quality = 1;
  void clear_quality();
  ::idlepb::ItemQuality quality() const;
  void set_quality(::idlepb::ItemQuality value);
  private:
  ::idlepb::ItemQuality _internal_quality() const;
  void _internal_set_quality(::idlepb::ItemQuality value);
  public:

  // int32 item_cfg_id = 2;
  void clear_item_cfg_id();
  int32_t item_cfg_id() const;
  void set_item_cfg_id(int32_t value);
  private:
  int32_t _internal_item_cfg_id() const;
  void _internal_set_item_cfg_id(int32_t value);
  public:

  // int32 item_num = 3;
  void clear_item_num();
  int32_t item_num() const;
  void set_item_num(int32_t value);
  private:
  int32_t _internal_item_num() const;
  void _internal_set_item_num(int32_t value);
  public:

  // int32 exp = 4;
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // .idlepb.ForgeChanceType chance_type = 5;
  void clear_chance_type();
  ::idlepb::ForgeChanceType chance_type() const;
  void set_chance_type(::idlepb::ForgeChanceType value);
  private:
  ::idlepb::ForgeChanceType _internal_chance_type() const;
  void _internal_set_chance_type(::idlepb::ForgeChanceType value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyForgeRefineResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int quality_;
    int32_t item_cfg_id_;
    int32_t item_num_;
    int32_t exp_;
    int chance_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API EquipmentPutOnReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.EquipmentPutOnReq) */ {
 public:
  inline EquipmentPutOnReq() : EquipmentPutOnReq(nullptr) {}
  ~EquipmentPutOnReq() override;
  explicit PROTOBUF_CONSTEXPR EquipmentPutOnReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EquipmentPutOnReq(const EquipmentPutOnReq& from);
  EquipmentPutOnReq(EquipmentPutOnReq&& from) noexcept
    : EquipmentPutOnReq() {
    *this = ::std::move(from);
  }

  inline EquipmentPutOnReq& operator=(const EquipmentPutOnReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentPutOnReq& operator=(EquipmentPutOnReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentPutOnReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EquipmentPutOnReq* internal_default_instance() {
    return reinterpret_cast<const EquipmentPutOnReq*>(
               &_EquipmentPutOnReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(EquipmentPutOnReq& a, EquipmentPutOnReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EquipmentPutOnReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentPutOnReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentPutOnReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EquipmentPutOnReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EquipmentPutOnReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EquipmentPutOnReq& from) {
    EquipmentPutOnReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EquipmentPutOnReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.EquipmentPutOnReq";
  }
  protected:
  explicit EquipmentPutOnReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 2,
    kSlotIdxFieldNumber = 1,
  };
  // uint64 item_id = 2;
  void clear_item_id();
  uint64_t item_id() const;
  void set_item_id(uint64_t value);
  private:
  uint64_t _internal_item_id() const;
  void _internal_set_item_id(uint64_t value);
  public:

  // int32 slot_idx = 1;
  void clear_slot_idx();
  int32_t slot_idx() const;
  void set_slot_idx(int32_t value);
  private:
  int32_t _internal_slot_idx() const;
  void _internal_set_slot_idx(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.EquipmentPutOnReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t item_id_;
    int32_t slot_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API EquipmentPutOnAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.EquipmentPutOnAck) */ {
 public:
  inline EquipmentPutOnAck() : EquipmentPutOnAck(nullptr) {}
  ~EquipmentPutOnAck() override;
  explicit PROTOBUF_CONSTEXPR EquipmentPutOnAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EquipmentPutOnAck(const EquipmentPutOnAck& from);
  EquipmentPutOnAck(EquipmentPutOnAck&& from) noexcept
    : EquipmentPutOnAck() {
    *this = ::std::move(from);
  }

  inline EquipmentPutOnAck& operator=(const EquipmentPutOnAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentPutOnAck& operator=(EquipmentPutOnAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentPutOnAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const EquipmentPutOnAck* internal_default_instance() {
    return reinterpret_cast<const EquipmentPutOnAck*>(
               &_EquipmentPutOnAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(EquipmentPutOnAck& a, EquipmentPutOnAck& b) {
    a.Swap(&b);
  }
  inline void Swap(EquipmentPutOnAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentPutOnAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentPutOnAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EquipmentPutOnAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EquipmentPutOnAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EquipmentPutOnAck& from) {
    EquipmentPutOnAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EquipmentPutOnAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.EquipmentPutOnAck";
  }
  protected:
  explicit EquipmentPutOnAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.EquipmentPutOnAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API EquipmentTakeOffReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.EquipmentTakeOffReq) */ {
 public:
  inline EquipmentTakeOffReq() : EquipmentTakeOffReq(nullptr) {}
  ~EquipmentTakeOffReq() override;
  explicit PROTOBUF_CONSTEXPR EquipmentTakeOffReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EquipmentTakeOffReq(const EquipmentTakeOffReq& from);
  EquipmentTakeOffReq(EquipmentTakeOffReq&& from) noexcept
    : EquipmentTakeOffReq() {
    *this = ::std::move(from);
  }

  inline EquipmentTakeOffReq& operator=(const EquipmentTakeOffReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentTakeOffReq& operator=(EquipmentTakeOffReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentTakeOffReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EquipmentTakeOffReq* internal_default_instance() {
    return reinterpret_cast<const EquipmentTakeOffReq*>(
               &_EquipmentTakeOffReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(EquipmentTakeOffReq& a, EquipmentTakeOffReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EquipmentTakeOffReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentTakeOffReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentTakeOffReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EquipmentTakeOffReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EquipmentTakeOffReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EquipmentTakeOffReq& from) {
    EquipmentTakeOffReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EquipmentTakeOffReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.EquipmentTakeOffReq";
  }
  protected:
  explicit EquipmentTakeOffReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotIdxFieldNumber = 1,
  };
  // int32 slot_idx = 1;
  void clear_slot_idx();
  int32_t slot_idx() const;
  void set_slot_idx(int32_t value);
  private:
  int32_t _internal_slot_idx() const;
  void _internal_set_slot_idx(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.EquipmentTakeOffReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t slot_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API EquipmentTakeOffAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.EquipmentTakeOffAck) */ {
 public:
  inline EquipmentTakeOffAck() : EquipmentTakeOffAck(nullptr) {}
  ~EquipmentTakeOffAck() override;
  explicit PROTOBUF_CONSTEXPR EquipmentTakeOffAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EquipmentTakeOffAck(const EquipmentTakeOffAck& from);
  EquipmentTakeOffAck(EquipmentTakeOffAck&& from) noexcept
    : EquipmentTakeOffAck() {
    *this = ::std::move(from);
  }

  inline EquipmentTakeOffAck& operator=(const EquipmentTakeOffAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentTakeOffAck& operator=(EquipmentTakeOffAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentTakeOffAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const EquipmentTakeOffAck* internal_default_instance() {
    return reinterpret_cast<const EquipmentTakeOffAck*>(
               &_EquipmentTakeOffAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(EquipmentTakeOffAck& a, EquipmentTakeOffAck& b) {
    a.Swap(&b);
  }
  inline void Swap(EquipmentTakeOffAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentTakeOffAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentTakeOffAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EquipmentTakeOffAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EquipmentTakeOffAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EquipmentTakeOffAck& from) {
    EquipmentTakeOffAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EquipmentTakeOffAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.EquipmentTakeOffAck";
  }
  protected:
  explicit EquipmentTakeOffAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.EquipmentTakeOffAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetInventoryDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetInventoryDataReq) */ {
 public:
  inline GetInventoryDataReq() : GetInventoryDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetInventoryDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInventoryDataReq(const GetInventoryDataReq& from);
  GetInventoryDataReq(GetInventoryDataReq&& from) noexcept
    : GetInventoryDataReq() {
    *this = ::std::move(from);
  }

  inline GetInventoryDataReq& operator=(const GetInventoryDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInventoryDataReq& operator=(GetInventoryDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInventoryDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInventoryDataReq* internal_default_instance() {
    return reinterpret_cast<const GetInventoryDataReq*>(
               &_GetInventoryDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(GetInventoryDataReq& a, GetInventoryDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInventoryDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInventoryDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInventoryDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInventoryDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetInventoryDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetInventoryDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetInventoryDataReq";
  }
  protected:
  explicit GetInventoryDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetInventoryDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetInventoryDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetInventoryDataAck) */ {
 public:
  inline GetInventoryDataAck() : GetInventoryDataAck(nullptr) {}
  ~GetInventoryDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetInventoryDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInventoryDataAck(const GetInventoryDataAck& from);
  GetInventoryDataAck(GetInventoryDataAck&& from) noexcept
    : GetInventoryDataAck() {
    *this = ::std::move(from);
  }

  inline GetInventoryDataAck& operator=(const GetInventoryDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInventoryDataAck& operator=(GetInventoryDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInventoryDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInventoryDataAck* internal_default_instance() {
    return reinterpret_cast<const GetInventoryDataAck*>(
               &_GetInventoryDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(GetInventoryDataAck& a, GetInventoryDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInventoryDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInventoryDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInventoryDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInventoryDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetInventoryDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetInventoryDataAck& from) {
    GetInventoryDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInventoryDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetInventoryDataAck";
  }
  protected:
  explicit GetInventoryDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kUnlockedEquipmentSlotsFieldNumber = 2,
    kInventorySpaceNumFieldNumber = 3,
  };
  // repeated .idlepb.ItemData items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::ItemData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >*
      mutable_items();
  private:
  const ::idlepb::ItemData& _internal_items(int index) const;
  ::idlepb::ItemData* _internal_add_items();
  public:
  const ::idlepb::ItemData& items(int index) const;
  ::idlepb::ItemData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >&
      items() const;

  // repeated int32 unlocked_equipment_slots = 2;
  int unlocked_equipment_slots_size() const;
  private:
  int _internal_unlocked_equipment_slots_size() const;
  public:
  void clear_unlocked_equipment_slots();
  private:
  int32_t _internal_unlocked_equipment_slots(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_unlocked_equipment_slots() const;
  void _internal_add_unlocked_equipment_slots(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_unlocked_equipment_slots();
  public:
  int32_t unlocked_equipment_slots(int index) const;
  void set_unlocked_equipment_slots(int index, int32_t value);
  void add_unlocked_equipment_slots(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      unlocked_equipment_slots() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_unlocked_equipment_slots();

  // int32 inventory_space_num = 3;
  void clear_inventory_space_num();
  int32_t inventory_space_num() const;
  void set_inventory_space_num(int32_t value);
  private:
  int32_t _internal_inventory_space_num() const;
  void _internal_set_inventory_space_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetInventoryDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData > items_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > unlocked_equipment_slots_;
    mutable std::atomic<int> _unlocked_equipment_slots_cached_byte_size_;
    int32_t inventory_space_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AlchemyRefineStartReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AlchemyRefineStartReq) */ {
 public:
  inline AlchemyRefineStartReq() : AlchemyRefineStartReq(nullptr) {}
  ~AlchemyRefineStartReq() override;
  explicit PROTOBUF_CONSTEXPR AlchemyRefineStartReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlchemyRefineStartReq(const AlchemyRefineStartReq& from);
  AlchemyRefineStartReq(AlchemyRefineStartReq&& from) noexcept
    : AlchemyRefineStartReq() {
    *this = ::std::move(from);
  }

  inline AlchemyRefineStartReq& operator=(const AlchemyRefineStartReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlchemyRefineStartReq& operator=(AlchemyRefineStartReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlchemyRefineStartReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlchemyRefineStartReq* internal_default_instance() {
    return reinterpret_cast<const AlchemyRefineStartReq*>(
               &_AlchemyRefineStartReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(AlchemyRefineStartReq& a, AlchemyRefineStartReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AlchemyRefineStartReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlchemyRefineStartReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlchemyRefineStartReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlchemyRefineStartReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlchemyRefineStartReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlchemyRefineStartReq& from) {
    AlchemyRefineStartReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlchemyRefineStartReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AlchemyRefineStartReq";
  }
  protected:
  explicit AlchemyRefineStartReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipeIdFieldNumber = 1,
    kMaterialIdFieldNumber = 2,
    kTargetNumFieldNumber = 3,
  };
  // int32 recipe_id = 1;
  void clear_recipe_id();
  int32_t recipe_id() const;
  void set_recipe_id(int32_t value);
  private:
  int32_t _internal_recipe_id() const;
  void _internal_set_recipe_id(int32_t value);
  public:

  // int32 material_id = 2;
  void clear_material_id();
  int32_t material_id() const;
  void set_material_id(int32_t value);
  private:
  int32_t _internal_material_id() const;
  void _internal_set_material_id(int32_t value);
  public:

  // int32 target_num = 3;
  void clear_target_num();
  int32_t target_num() const;
  void set_target_num(int32_t value);
  private:
  int32_t _internal_target_num() const;
  void _internal_set_target_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AlchemyRefineStartReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t recipe_id_;
    int32_t material_id_;
    int32_t target_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AlchemyRefineStartAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AlchemyRefineStartAck) */ {
 public:
  inline AlchemyRefineStartAck() : AlchemyRefineStartAck(nullptr) {}
  ~AlchemyRefineStartAck() override;
  explicit PROTOBUF_CONSTEXPR AlchemyRefineStartAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlchemyRefineStartAck(const AlchemyRefineStartAck& from);
  AlchemyRefineStartAck(AlchemyRefineStartAck&& from) noexcept
    : AlchemyRefineStartAck() {
    *this = ::std::move(from);
  }

  inline AlchemyRefineStartAck& operator=(const AlchemyRefineStartAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlchemyRefineStartAck& operator=(AlchemyRefineStartAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlchemyRefineStartAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlchemyRefineStartAck* internal_default_instance() {
    return reinterpret_cast<const AlchemyRefineStartAck*>(
               &_AlchemyRefineStartAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(AlchemyRefineStartAck& a, AlchemyRefineStartAck& b) {
    a.Swap(&b);
  }
  inline void Swap(AlchemyRefineStartAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlchemyRefineStartAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlchemyRefineStartAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlchemyRefineStartAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlchemyRefineStartAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlchemyRefineStartAck& from) {
    AlchemyRefineStartAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlchemyRefineStartAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AlchemyRefineStartAck";
  }
  protected:
  explicit AlchemyRefineStartAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AlchemyRefineStartAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AlchemyRefineCancelReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.AlchemyRefineCancelReq) */ {
 public:
  inline AlchemyRefineCancelReq() : AlchemyRefineCancelReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AlchemyRefineCancelReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlchemyRefineCancelReq(const AlchemyRefineCancelReq& from);
  AlchemyRefineCancelReq(AlchemyRefineCancelReq&& from) noexcept
    : AlchemyRefineCancelReq() {
    *this = ::std::move(from);
  }

  inline AlchemyRefineCancelReq& operator=(const AlchemyRefineCancelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlchemyRefineCancelReq& operator=(AlchemyRefineCancelReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlchemyRefineCancelReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlchemyRefineCancelReq* internal_default_instance() {
    return reinterpret_cast<const AlchemyRefineCancelReq*>(
               &_AlchemyRefineCancelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(AlchemyRefineCancelReq& a, AlchemyRefineCancelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AlchemyRefineCancelReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlchemyRefineCancelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlchemyRefineCancelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlchemyRefineCancelReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AlchemyRefineCancelReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AlchemyRefineCancelReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AlchemyRefineCancelReq";
  }
  protected:
  explicit AlchemyRefineCancelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.AlchemyRefineCancelReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AlchemyRefineCancelAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AlchemyRefineCancelAck) */ {
 public:
  inline AlchemyRefineCancelAck() : AlchemyRefineCancelAck(nullptr) {}
  ~AlchemyRefineCancelAck() override;
  explicit PROTOBUF_CONSTEXPR AlchemyRefineCancelAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlchemyRefineCancelAck(const AlchemyRefineCancelAck& from);
  AlchemyRefineCancelAck(AlchemyRefineCancelAck&& from) noexcept
    : AlchemyRefineCancelAck() {
    *this = ::std::move(from);
  }

  inline AlchemyRefineCancelAck& operator=(const AlchemyRefineCancelAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlchemyRefineCancelAck& operator=(AlchemyRefineCancelAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlchemyRefineCancelAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlchemyRefineCancelAck* internal_default_instance() {
    return reinterpret_cast<const AlchemyRefineCancelAck*>(
               &_AlchemyRefineCancelAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(AlchemyRefineCancelAck& a, AlchemyRefineCancelAck& b) {
    a.Swap(&b);
  }
  inline void Swap(AlchemyRefineCancelAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlchemyRefineCancelAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlchemyRefineCancelAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlchemyRefineCancelAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlchemyRefineCancelAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlchemyRefineCancelAck& from) {
    AlchemyRefineCancelAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlchemyRefineCancelAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AlchemyRefineCancelAck";
  }
  protected:
  explicit AlchemyRefineCancelAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AlchemyRefineCancelAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AlchemyRefineExtractReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.AlchemyRefineExtractReq) */ {
 public:
  inline AlchemyRefineExtractReq() : AlchemyRefineExtractReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AlchemyRefineExtractReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlchemyRefineExtractReq(const AlchemyRefineExtractReq& from);
  AlchemyRefineExtractReq(AlchemyRefineExtractReq&& from) noexcept
    : AlchemyRefineExtractReq() {
    *this = ::std::move(from);
  }

  inline AlchemyRefineExtractReq& operator=(const AlchemyRefineExtractReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlchemyRefineExtractReq& operator=(AlchemyRefineExtractReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlchemyRefineExtractReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlchemyRefineExtractReq* internal_default_instance() {
    return reinterpret_cast<const AlchemyRefineExtractReq*>(
               &_AlchemyRefineExtractReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(AlchemyRefineExtractReq& a, AlchemyRefineExtractReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AlchemyRefineExtractReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlchemyRefineExtractReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlchemyRefineExtractReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlchemyRefineExtractReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AlchemyRefineExtractReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AlchemyRefineExtractReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AlchemyRefineExtractReq";
  }
  protected:
  explicit AlchemyRefineExtractReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.AlchemyRefineExtractReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AlchemyRefineExtractAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AlchemyRefineExtractAck) */ {
 public:
  inline AlchemyRefineExtractAck() : AlchemyRefineExtractAck(nullptr) {}
  ~AlchemyRefineExtractAck() override;
  explicit PROTOBUF_CONSTEXPR AlchemyRefineExtractAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlchemyRefineExtractAck(const AlchemyRefineExtractAck& from);
  AlchemyRefineExtractAck(AlchemyRefineExtractAck&& from) noexcept
    : AlchemyRefineExtractAck() {
    *this = ::std::move(from);
  }

  inline AlchemyRefineExtractAck& operator=(const AlchemyRefineExtractAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlchemyRefineExtractAck& operator=(AlchemyRefineExtractAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlchemyRefineExtractAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlchemyRefineExtractAck* internal_default_instance() {
    return reinterpret_cast<const AlchemyRefineExtractAck*>(
               &_AlchemyRefineExtractAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(AlchemyRefineExtractAck& a, AlchemyRefineExtractAck& b) {
    a.Swap(&b);
  }
  inline void Swap(AlchemyRefineExtractAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlchemyRefineExtractAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlchemyRefineExtractAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlchemyRefineExtractAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlchemyRefineExtractAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlchemyRefineExtractAck& from) {
    AlchemyRefineExtractAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlchemyRefineExtractAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AlchemyRefineExtractAck";
  }
  protected:
  explicit AlchemyRefineExtractAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AlchemyRefineExtractAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API CreateCharacterReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.CreateCharacterReq) */ {
 public:
  inline CreateCharacterReq() : CreateCharacterReq(nullptr) {}
  ~CreateCharacterReq() override;
  explicit PROTOBUF_CONSTEXPR CreateCharacterReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCharacterReq(const CreateCharacterReq& from);
  CreateCharacterReq(CreateCharacterReq&& from) noexcept
    : CreateCharacterReq() {
    *this = ::std::move(from);
  }

  inline CreateCharacterReq& operator=(const CreateCharacterReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCharacterReq& operator=(CreateCharacterReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCharacterReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCharacterReq* internal_default_instance() {
    return reinterpret_cast<const CreateCharacterReq*>(
               &_CreateCharacterReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(CreateCharacterReq& a, CreateCharacterReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCharacterReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCharacterReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCharacterReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateCharacterReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCharacterReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateCharacterReq& from) {
    CreateCharacterReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCharacterReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.CreateCharacterReq";
  }
  protected:
  explicit CreateCharacterReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelDataFieldNumber = 7,
    kHeroNameFieldNumber = 1,
    kDataFieldNumber = 2,
    kSkeletonTypeFieldNumber = 6,
  };
  // repeated int32 model_data = 7;
  int model_data_size() const;
  private:
  int _internal_model_data_size() const;
  public:
  void clear_model_data();
  private:
  int32_t _internal_model_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_model_data() const;
  void _internal_add_model_data(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_model_data();
  public:
  int32_t model_data(int index) const;
  void set_model_data(int index, int32_t value);
  void add_model_data(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      model_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_model_data();

  // string hero_name = 1;
  void clear_hero_name();
  const std::string& hero_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hero_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hero_name();
  PROTOBUF_NODISCARD std::string* release_hero_name();
  void set_allocated_hero_name(std::string* hero_name);
  private:
  const std::string& _internal_hero_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hero_name(const std::string& value);
  std::string* _internal_mutable_hero_name();
  public:

  // .idlepb.CharacterModelConfig data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::CharacterModelConfig& data() const;
  PROTOBUF_NODISCARD ::idlepb::CharacterModelConfig* release_data();
  ::idlepb::CharacterModelConfig* mutable_data();
  void set_allocated_data(::idlepb::CharacterModelConfig* data);
  private:
  const ::idlepb::CharacterModelConfig& _internal_data() const;
  ::idlepb::CharacterModelConfig* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::CharacterModelConfig* data);
  ::idlepb::CharacterModelConfig* unsafe_arena_release_data();

  // int32 skeleton_type = 6;
  void clear_skeleton_type();
  int32_t skeleton_type() const;
  void set_skeleton_type(int32_t value);
  private:
  int32_t _internal_skeleton_type() const;
  void _internal_set_skeleton_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.CreateCharacterReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > model_data_;
    mutable std::atomic<int> _model_data_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hero_name_;
    ::idlepb::CharacterModelConfig* data_;
    int32_t skeleton_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API CreateCharacterAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.CreateCharacterAck) */ {
 public:
  inline CreateCharacterAck() : CreateCharacterAck(nullptr) {}
  ~CreateCharacterAck() override;
  explicit PROTOBUF_CONSTEXPR CreateCharacterAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCharacterAck(const CreateCharacterAck& from);
  CreateCharacterAck(CreateCharacterAck&& from) noexcept
    : CreateCharacterAck() {
    *this = ::std::move(from);
  }

  inline CreateCharacterAck& operator=(const CreateCharacterAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCharacterAck& operator=(CreateCharacterAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCharacterAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCharacterAck* internal_default_instance() {
    return reinterpret_cast<const CreateCharacterAck*>(
               &_CreateCharacterAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(CreateCharacterAck& a, CreateCharacterAck& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCharacterAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCharacterAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCharacterAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateCharacterAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCharacterAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateCharacterAck& from) {
    CreateCharacterAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCharacterAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.CreateCharacterAck";
  }
  protected:
  explicit CreateCharacterAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.CreateCharacterAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SystemNotice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SystemNotice) */ {
 public:
  inline SystemNotice() : SystemNotice(nullptr) {}
  ~SystemNotice() override;
  explicit PROTOBUF_CONSTEXPR SystemNotice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemNotice(const SystemNotice& from);
  SystemNotice(SystemNotice&& from) noexcept
    : SystemNotice() {
    *this = ::std::move(from);
  }

  inline SystemNotice& operator=(const SystemNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemNotice& operator=(SystemNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemNotice* internal_default_instance() {
    return reinterpret_cast<const SystemNotice*>(
               &_SystemNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(SystemNotice& a, SystemNotice& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemNotice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemNotice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemNotice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemNotice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemNotice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemNotice& from) {
    SystemNotice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemNotice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SystemNotice";
  }
  protected:
  explicit SystemNotice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kS1FieldNumber = 10,
    kS2FieldNumber = 11,
    kS3FieldNumber = 12,
    kN1FieldNumber = 20,
    kN2FieldNumber = 21,
    kN3FieldNumber = 22,
    kStyleFieldNumber = 1,
  };
  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string s1 = 10;
  void clear_s1();
  const std::string& s1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s1();
  PROTOBUF_NODISCARD std::string* release_s1();
  void set_allocated_s1(std::string* s1);
  private:
  const std::string& _internal_s1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s1(const std::string& value);
  std::string* _internal_mutable_s1();
  public:

  // string s2 = 11;
  void clear_s2();
  const std::string& s2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s2();
  PROTOBUF_NODISCARD std::string* release_s2();
  void set_allocated_s2(std::string* s2);
  private:
  const std::string& _internal_s2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s2(const std::string& value);
  std::string* _internal_mutable_s2();
  public:

  // string s3 = 12;
  void clear_s3();
  const std::string& s3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s3();
  PROTOBUF_NODISCARD std::string* release_s3();
  void set_allocated_s3(std::string* s3);
  private:
  const std::string& _internal_s3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s3(const std::string& value);
  std::string* _internal_mutable_s3();
  public:

  // int64 n1 = 20;
  void clear_n1();
  int64_t n1() const;
  void set_n1(int64_t value);
  private:
  int64_t _internal_n1() const;
  void _internal_set_n1(int64_t value);
  public:

  // int64 n2 = 21;
  void clear_n2();
  int64_t n2() const;
  void set_n2(int64_t value);
  private:
  int64_t _internal_n2() const;
  void _internal_set_n2(int64_t value);
  public:

  // int64 n3 = 22;
  void clear_n3();
  int64_t n3() const;
  void set_n3(int64_t value);
  private:
  int64_t _internal_n3() const;
  void _internal_set_n3(int64_t value);
  public:

  // int32 style = 1;
  void clear_style();
  int32_t style() const;
  void set_style(int32_t value);
  private:
  int32_t _internal_style() const;
  void _internal_set_style(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SystemNotice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s2_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s3_;
    int64_t n1_;
    int64_t n2_;
    int64_t n3_;
    int32_t style_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleShopDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetRoleShopDataReq) */ {
 public:
  inline GetRoleShopDataReq() : GetRoleShopDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetRoleShopDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleShopDataReq(const GetRoleShopDataReq& from);
  GetRoleShopDataReq(GetRoleShopDataReq&& from) noexcept
    : GetRoleShopDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleShopDataReq& operator=(const GetRoleShopDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleShopDataReq& operator=(GetRoleShopDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleShopDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleShopDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleShopDataReq*>(
               &_GetRoleShopDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(GetRoleShopDataReq& a, GetRoleShopDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleShopDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleShopDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleShopDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleShopDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetRoleShopDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetRoleShopDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleShopDataReq";
  }
  protected:
  explicit GetRoleShopDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleShopDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleShopDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleShopDataAck) */ {
 public:
  inline GetRoleShopDataAck() : GetRoleShopDataAck(nullptr) {}
  ~GetRoleShopDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleShopDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleShopDataAck(const GetRoleShopDataAck& from);
  GetRoleShopDataAck(GetRoleShopDataAck&& from) noexcept
    : GetRoleShopDataAck() {
    *this = ::std::move(from);
  }

  inline GetRoleShopDataAck& operator=(const GetRoleShopDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleShopDataAck& operator=(GetRoleShopDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleShopDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleShopDataAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleShopDataAck*>(
               &_GetRoleShopDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(GetRoleShopDataAck& a, GetRoleShopDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleShopDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleShopDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleShopDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleShopDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleShopDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleShopDataAck& from) {
    GetRoleShopDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleShopDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleShopDataAck";
  }
  protected:
  explicit GetRoleShopDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleShopData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleShopData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleShopData* release_data();
  ::idlepb::RoleShopData* mutable_data();
  void set_allocated_data(::idlepb::RoleShopData* data);
  private:
  const ::idlepb::RoleShopData& _internal_data() const;
  ::idlepb::RoleShopData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleShopData* data);
  ::idlepb::RoleShopData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleShopDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleShopData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshShopReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.RefreshShopReq) */ {
 public:
  inline RefreshShopReq() : RefreshShopReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RefreshShopReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshShopReq(const RefreshShopReq& from);
  RefreshShopReq(RefreshShopReq&& from) noexcept
    : RefreshShopReq() {
    *this = ::std::move(from);
  }

  inline RefreshShopReq& operator=(const RefreshShopReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshShopReq& operator=(RefreshShopReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshShopReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshShopReq* internal_default_instance() {
    return reinterpret_cast<const RefreshShopReq*>(
               &_RefreshShopReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(RefreshShopReq& a, RefreshShopReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshShopReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshShopReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshShopReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshShopReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RefreshShopReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RefreshShopReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshShopReq";
  }
  protected:
  explicit RefreshShopReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.RefreshShopReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshShopAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshShopAck) */ {
 public:
  inline RefreshShopAck() : RefreshShopAck(nullptr) {}
  ~RefreshShopAck() override;
  explicit PROTOBUF_CONSTEXPR RefreshShopAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshShopAck(const RefreshShopAck& from);
  RefreshShopAck(RefreshShopAck&& from) noexcept
    : RefreshShopAck() {
    *this = ::std::move(from);
  }

  inline RefreshShopAck& operator=(const RefreshShopAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshShopAck& operator=(RefreshShopAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshShopAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshShopAck* internal_default_instance() {
    return reinterpret_cast<const RefreshShopAck*>(
               &_RefreshShopAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(RefreshShopAck& a, RefreshShopAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshShopAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshShopAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshShopAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshShopAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshShopAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshShopAck& from) {
    RefreshShopAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshShopAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshShopAck";
  }
  protected:
  explicit RefreshShopAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.RoleShopData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleShopData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleShopData* release_data();
  ::idlepb::RoleShopData* mutable_data();
  void set_allocated_data(::idlepb::RoleShopData* data);
  private:
  const ::idlepb::RoleShopData& _internal_data() const;
  ::idlepb::RoleShopData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleShopData* data);
  ::idlepb::RoleShopData* unsafe_arena_release_data();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RefreshShopAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleShopData* data_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API BuyShopItemReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.BuyShopItemReq) */ {
 public:
  inline BuyShopItemReq() : BuyShopItemReq(nullptr) {}
  ~BuyShopItemReq() override;
  explicit PROTOBUF_CONSTEXPR BuyShopItemReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuyShopItemReq(const BuyShopItemReq& from);
  BuyShopItemReq(BuyShopItemReq&& from) noexcept
    : BuyShopItemReq() {
    *this = ::std::move(from);
  }

  inline BuyShopItemReq& operator=(const BuyShopItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyShopItemReq& operator=(BuyShopItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyShopItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyShopItemReq* internal_default_instance() {
    return reinterpret_cast<const BuyShopItemReq*>(
               &_BuyShopItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(BuyShopItemReq& a, BuyShopItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(BuyShopItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyShopItemReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyShopItemReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuyShopItemReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuyShopItemReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BuyShopItemReq& from) {
    BuyShopItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyShopItemReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.BuyShopItemReq";
  }
  protected:
  explicit BuyShopItemReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.BuyShopItemReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API BuyShopItemAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.BuyShopItemAck) */ {
 public:
  inline BuyShopItemAck() : BuyShopItemAck(nullptr) {}
  ~BuyShopItemAck() override;
  explicit PROTOBUF_CONSTEXPR BuyShopItemAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuyShopItemAck(const BuyShopItemAck& from);
  BuyShopItemAck(BuyShopItemAck&& from) noexcept
    : BuyShopItemAck() {
    *this = ::std::move(from);
  }

  inline BuyShopItemAck& operator=(const BuyShopItemAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyShopItemAck& operator=(BuyShopItemAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyShopItemAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyShopItemAck* internal_default_instance() {
    return reinterpret_cast<const BuyShopItemAck*>(
               &_BuyShopItemAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(BuyShopItemAck& a, BuyShopItemAck& b) {
    a.Swap(&b);
  }
  inline void Swap(BuyShopItemAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyShopItemAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyShopItemAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuyShopItemAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuyShopItemAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BuyShopItemAck& from) {
    BuyShopItemAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyShopItemAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.BuyShopItemAck";
  }
  protected:
  explicit BuyShopItemAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.BuyShopItemAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleDeluxeShopDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetRoleDeluxeShopDataReq) */ {
 public:
  inline GetRoleDeluxeShopDataReq() : GetRoleDeluxeShopDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetRoleDeluxeShopDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleDeluxeShopDataReq(const GetRoleDeluxeShopDataReq& from);
  GetRoleDeluxeShopDataReq(GetRoleDeluxeShopDataReq&& from) noexcept
    : GetRoleDeluxeShopDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleDeluxeShopDataReq& operator=(const GetRoleDeluxeShopDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleDeluxeShopDataReq& operator=(GetRoleDeluxeShopDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleDeluxeShopDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleDeluxeShopDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleDeluxeShopDataReq*>(
               &_GetRoleDeluxeShopDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(GetRoleDeluxeShopDataReq& a, GetRoleDeluxeShopDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleDeluxeShopDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleDeluxeShopDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleDeluxeShopDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleDeluxeShopDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetRoleDeluxeShopDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetRoleDeluxeShopDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleDeluxeShopDataReq";
  }
  protected:
  explicit GetRoleDeluxeShopDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleDeluxeShopDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleDeluxeShopDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleDeluxeShopDataAck) */ {
 public:
  inline GetRoleDeluxeShopDataAck() : GetRoleDeluxeShopDataAck(nullptr) {}
  ~GetRoleDeluxeShopDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleDeluxeShopDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleDeluxeShopDataAck(const GetRoleDeluxeShopDataAck& from);
  GetRoleDeluxeShopDataAck(GetRoleDeluxeShopDataAck&& from) noexcept
    : GetRoleDeluxeShopDataAck() {
    *this = ::std::move(from);
  }

  inline GetRoleDeluxeShopDataAck& operator=(const GetRoleDeluxeShopDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleDeluxeShopDataAck& operator=(GetRoleDeluxeShopDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleDeluxeShopDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleDeluxeShopDataAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleDeluxeShopDataAck*>(
               &_GetRoleDeluxeShopDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(GetRoleDeluxeShopDataAck& a, GetRoleDeluxeShopDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleDeluxeShopDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleDeluxeShopDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleDeluxeShopDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleDeluxeShopDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleDeluxeShopDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleDeluxeShopDataAck& from) {
    GetRoleDeluxeShopDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleDeluxeShopDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleDeluxeShopDataAck";
  }
  protected:
  explicit GetRoleDeluxeShopDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleDeluxeShopData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleDeluxeShopData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleDeluxeShopData* release_data();
  ::idlepb::RoleDeluxeShopData* mutable_data();
  void set_allocated_data(::idlepb::RoleDeluxeShopData* data);
  private:
  const ::idlepb::RoleDeluxeShopData& _internal_data() const;
  ::idlepb::RoleDeluxeShopData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleDeluxeShopData* data);
  ::idlepb::RoleDeluxeShopData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleDeluxeShopDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleDeluxeShopData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshDeluxeShopReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.RefreshDeluxeShopReq) */ {
 public:
  inline RefreshDeluxeShopReq() : RefreshDeluxeShopReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RefreshDeluxeShopReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshDeluxeShopReq(const RefreshDeluxeShopReq& from);
  RefreshDeluxeShopReq(RefreshDeluxeShopReq&& from) noexcept
    : RefreshDeluxeShopReq() {
    *this = ::std::move(from);
  }

  inline RefreshDeluxeShopReq& operator=(const RefreshDeluxeShopReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshDeluxeShopReq& operator=(RefreshDeluxeShopReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshDeluxeShopReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshDeluxeShopReq* internal_default_instance() {
    return reinterpret_cast<const RefreshDeluxeShopReq*>(
               &_RefreshDeluxeShopReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(RefreshDeluxeShopReq& a, RefreshDeluxeShopReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshDeluxeShopReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshDeluxeShopReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshDeluxeShopReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshDeluxeShopReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RefreshDeluxeShopReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RefreshDeluxeShopReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshDeluxeShopReq";
  }
  protected:
  explicit RefreshDeluxeShopReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.RefreshDeluxeShopReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshDeluxeShopAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshDeluxeShopAck) */ {
 public:
  inline RefreshDeluxeShopAck() : RefreshDeluxeShopAck(nullptr) {}
  ~RefreshDeluxeShopAck() override;
  explicit PROTOBUF_CONSTEXPR RefreshDeluxeShopAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshDeluxeShopAck(const RefreshDeluxeShopAck& from);
  RefreshDeluxeShopAck(RefreshDeluxeShopAck&& from) noexcept
    : RefreshDeluxeShopAck() {
    *this = ::std::move(from);
  }

  inline RefreshDeluxeShopAck& operator=(const RefreshDeluxeShopAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshDeluxeShopAck& operator=(RefreshDeluxeShopAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshDeluxeShopAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshDeluxeShopAck* internal_default_instance() {
    return reinterpret_cast<const RefreshDeluxeShopAck*>(
               &_RefreshDeluxeShopAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(RefreshDeluxeShopAck& a, RefreshDeluxeShopAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshDeluxeShopAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshDeluxeShopAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshDeluxeShopAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshDeluxeShopAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshDeluxeShopAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshDeluxeShopAck& from) {
    RefreshDeluxeShopAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshDeluxeShopAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshDeluxeShopAck";
  }
  protected:
  explicit RefreshDeluxeShopAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.RoleDeluxeShopData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleDeluxeShopData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleDeluxeShopData* release_data();
  ::idlepb::RoleDeluxeShopData* mutable_data();
  void set_allocated_data(::idlepb::RoleDeluxeShopData* data);
  private:
  const ::idlepb::RoleDeluxeShopData& _internal_data() const;
  ::idlepb::RoleDeluxeShopData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleDeluxeShopData* data);
  ::idlepb::RoleDeluxeShopData* unsafe_arena_release_data();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RefreshDeluxeShopAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleDeluxeShopData* data_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API BuyDeluxeShopItemReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.BuyDeluxeShopItemReq) */ {
 public:
  inline BuyDeluxeShopItemReq() : BuyDeluxeShopItemReq(nullptr) {}
  ~BuyDeluxeShopItemReq() override;
  explicit PROTOBUF_CONSTEXPR BuyDeluxeShopItemReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuyDeluxeShopItemReq(const BuyDeluxeShopItemReq& from);
  BuyDeluxeShopItemReq(BuyDeluxeShopItemReq&& from) noexcept
    : BuyDeluxeShopItemReq() {
    *this = ::std::move(from);
  }

  inline BuyDeluxeShopItemReq& operator=(const BuyDeluxeShopItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyDeluxeShopItemReq& operator=(BuyDeluxeShopItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyDeluxeShopItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyDeluxeShopItemReq* internal_default_instance() {
    return reinterpret_cast<const BuyDeluxeShopItemReq*>(
               &_BuyDeluxeShopItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(BuyDeluxeShopItemReq& a, BuyDeluxeShopItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(BuyDeluxeShopItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyDeluxeShopItemReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyDeluxeShopItemReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuyDeluxeShopItemReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuyDeluxeShopItemReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BuyDeluxeShopItemReq& from) {
    BuyDeluxeShopItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyDeluxeShopItemReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.BuyDeluxeShopItemReq";
  }
  protected:
  explicit BuyDeluxeShopItemReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.BuyDeluxeShopItemReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API BuyDeluxeShopItemAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.BuyDeluxeShopItemAck) */ {
 public:
  inline BuyDeluxeShopItemAck() : BuyDeluxeShopItemAck(nullptr) {}
  ~BuyDeluxeShopItemAck() override;
  explicit PROTOBUF_CONSTEXPR BuyDeluxeShopItemAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuyDeluxeShopItemAck(const BuyDeluxeShopItemAck& from);
  BuyDeluxeShopItemAck(BuyDeluxeShopItemAck&& from) noexcept
    : BuyDeluxeShopItemAck() {
    *this = ::std::move(from);
  }

  inline BuyDeluxeShopItemAck& operator=(const BuyDeluxeShopItemAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyDeluxeShopItemAck& operator=(BuyDeluxeShopItemAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyDeluxeShopItemAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyDeluxeShopItemAck* internal_default_instance() {
    return reinterpret_cast<const BuyDeluxeShopItemAck*>(
               &_BuyDeluxeShopItemAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(BuyDeluxeShopItemAck& a, BuyDeluxeShopItemAck& b) {
    a.Swap(&b);
  }
  inline void Swap(BuyDeluxeShopItemAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyDeluxeShopItemAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyDeluxeShopItemAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuyDeluxeShopItemAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuyDeluxeShopItemAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BuyDeluxeShopItemAck& from) {
    BuyDeluxeShopItemAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuyDeluxeShopItemAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.BuyDeluxeShopItemAck";
  }
  protected:
  explicit BuyDeluxeShopItemAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.BuyDeluxeShopItemAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UnlockDeluxeShopReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.UnlockDeluxeShopReq) */ {
 public:
  inline UnlockDeluxeShopReq() : UnlockDeluxeShopReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UnlockDeluxeShopReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockDeluxeShopReq(const UnlockDeluxeShopReq& from);
  UnlockDeluxeShopReq(UnlockDeluxeShopReq&& from) noexcept
    : UnlockDeluxeShopReq() {
    *this = ::std::move(from);
  }

  inline UnlockDeluxeShopReq& operator=(const UnlockDeluxeShopReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockDeluxeShopReq& operator=(UnlockDeluxeShopReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockDeluxeShopReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockDeluxeShopReq* internal_default_instance() {
    return reinterpret_cast<const UnlockDeluxeShopReq*>(
               &_UnlockDeluxeShopReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(UnlockDeluxeShopReq& a, UnlockDeluxeShopReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockDeluxeShopReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockDeluxeShopReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockDeluxeShopReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockDeluxeShopReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UnlockDeluxeShopReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UnlockDeluxeShopReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UnlockDeluxeShopReq";
  }
  protected:
  explicit UnlockDeluxeShopReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.UnlockDeluxeShopReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UnlockDeluxeShopAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UnlockDeluxeShopAck) */ {
 public:
  inline UnlockDeluxeShopAck() : UnlockDeluxeShopAck(nullptr) {}
  ~UnlockDeluxeShopAck() override;
  explicit PROTOBUF_CONSTEXPR UnlockDeluxeShopAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockDeluxeShopAck(const UnlockDeluxeShopAck& from);
  UnlockDeluxeShopAck(UnlockDeluxeShopAck&& from) noexcept
    : UnlockDeluxeShopAck() {
    *this = ::std::move(from);
  }

  inline UnlockDeluxeShopAck& operator=(const UnlockDeluxeShopAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockDeluxeShopAck& operator=(UnlockDeluxeShopAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockDeluxeShopAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockDeluxeShopAck* internal_default_instance() {
    return reinterpret_cast<const UnlockDeluxeShopAck*>(
               &_UnlockDeluxeShopAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(UnlockDeluxeShopAck& a, UnlockDeluxeShopAck& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockDeluxeShopAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockDeluxeShopAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockDeluxeShopAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockDeluxeShopAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockDeluxeShopAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnlockDeluxeShopAck& from) {
    UnlockDeluxeShopAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockDeluxeShopAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UnlockDeluxeShopAck";
  }
  protected:
  explicit UnlockDeluxeShopAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.RoleDeluxeShopData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleDeluxeShopData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleDeluxeShopData* release_data();
  ::idlepb::RoleDeluxeShopData* mutable_data();
  void set_allocated_data(::idlepb::RoleDeluxeShopData* data);
  private:
  const ::idlepb::RoleDeluxeShopData& _internal_data() const;
  ::idlepb::RoleDeluxeShopData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleDeluxeShopData* data);
  ::idlepb::RoleDeluxeShopData* unsafe_arena_release_data();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UnlockDeluxeShopAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleDeluxeShopData* data_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshDeluxeShopUnlocked final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshDeluxeShopUnlocked) */ {
 public:
  inline RefreshDeluxeShopUnlocked() : RefreshDeluxeShopUnlocked(nullptr) {}
  ~RefreshDeluxeShopUnlocked() override;
  explicit PROTOBUF_CONSTEXPR RefreshDeluxeShopUnlocked(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshDeluxeShopUnlocked(const RefreshDeluxeShopUnlocked& from);
  RefreshDeluxeShopUnlocked(RefreshDeluxeShopUnlocked&& from) noexcept
    : RefreshDeluxeShopUnlocked() {
    *this = ::std::move(from);
  }

  inline RefreshDeluxeShopUnlocked& operator=(const RefreshDeluxeShopUnlocked& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshDeluxeShopUnlocked& operator=(RefreshDeluxeShopUnlocked&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshDeluxeShopUnlocked& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshDeluxeShopUnlocked* internal_default_instance() {
    return reinterpret_cast<const RefreshDeluxeShopUnlocked*>(
               &_RefreshDeluxeShopUnlocked_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(RefreshDeluxeShopUnlocked& a, RefreshDeluxeShopUnlocked& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshDeluxeShopUnlocked* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshDeluxeShopUnlocked* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshDeluxeShopUnlocked* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshDeluxeShopUnlocked>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshDeluxeShopUnlocked& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshDeluxeShopUnlocked& from) {
    RefreshDeluxeShopUnlocked::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshDeluxeShopUnlocked* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshDeluxeShopUnlocked";
  }
  protected:
  explicit RefreshDeluxeShopUnlocked(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsUnlockedFieldNumber = 1,
  };
  // bool is_unlocked = 1;
  void clear_is_unlocked();
  bool is_unlocked() const;
  void set_is_unlocked(bool value);
  private:
  bool _internal_is_unlocked() const;
  void _internal_set_is_unlocked(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RefreshDeluxeShopUnlocked)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_unlocked_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UnlockArenaReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UnlockArenaReq) */ {
 public:
  inline UnlockArenaReq() : UnlockArenaReq(nullptr) {}
  ~UnlockArenaReq() override;
  explicit PROTOBUF_CONSTEXPR UnlockArenaReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockArenaReq(const UnlockArenaReq& from);
  UnlockArenaReq(UnlockArenaReq&& from) noexcept
    : UnlockArenaReq() {
    *this = ::std::move(from);
  }

  inline UnlockArenaReq& operator=(const UnlockArenaReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockArenaReq& operator=(UnlockArenaReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockArenaReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockArenaReq* internal_default_instance() {
    return reinterpret_cast<const UnlockArenaReq*>(
               &_UnlockArenaReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(UnlockArenaReq& a, UnlockArenaReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockArenaReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockArenaReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockArenaReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockArenaReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockArenaReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnlockArenaReq& from) {
    UnlockArenaReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockArenaReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UnlockArenaReq";
  }
  protected:
  explicit UnlockArenaReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArenaIdFieldNumber = 1,
  };
  // int32 arena_id = 1;
  void clear_arena_id();
  int32_t arena_id() const;
  void set_arena_id(int32_t value);
  private:
  int32_t _internal_arena_id() const;
  void _internal_set_arena_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UnlockArenaReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t arena_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UnlockArenaAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UnlockArenaAck) */ {
 public:
  inline UnlockArenaAck() : UnlockArenaAck(nullptr) {}
  ~UnlockArenaAck() override;
  explicit PROTOBUF_CONSTEXPR UnlockArenaAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockArenaAck(const UnlockArenaAck& from);
  UnlockArenaAck(UnlockArenaAck&& from) noexcept
    : UnlockArenaAck() {
    *this = ::std::move(from);
  }

  inline UnlockArenaAck& operator=(const UnlockArenaAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockArenaAck& operator=(UnlockArenaAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockArenaAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockArenaAck* internal_default_instance() {
    return reinterpret_cast<const UnlockArenaAck*>(
               &_UnlockArenaAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(UnlockArenaAck& a, UnlockArenaAck& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockArenaAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockArenaAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockArenaAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockArenaAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockArenaAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnlockArenaAck& from) {
    UnlockArenaAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockArenaAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UnlockArenaAck";
  }
  protected:
  explicit UnlockArenaAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UnlockArenaAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyUnlockArenaChallengeResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyUnlockArenaChallengeResult) */ {
 public:
  inline NotifyUnlockArenaChallengeResult() : NotifyUnlockArenaChallengeResult(nullptr) {}
  ~NotifyUnlockArenaChallengeResult() override;
  explicit PROTOBUF_CONSTEXPR NotifyUnlockArenaChallengeResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyUnlockArenaChallengeResult(const NotifyUnlockArenaChallengeResult& from);
  NotifyUnlockArenaChallengeResult(NotifyUnlockArenaChallengeResult&& from) noexcept
    : NotifyUnlockArenaChallengeResult() {
    *this = ::std::move(from);
  }

  inline NotifyUnlockArenaChallengeResult& operator=(const NotifyUnlockArenaChallengeResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyUnlockArenaChallengeResult& operator=(NotifyUnlockArenaChallengeResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyUnlockArenaChallengeResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyUnlockArenaChallengeResult* internal_default_instance() {
    return reinterpret_cast<const NotifyUnlockArenaChallengeResult*>(
               &_NotifyUnlockArenaChallengeResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(NotifyUnlockArenaChallengeResult& a, NotifyUnlockArenaChallengeResult& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyUnlockArenaChallengeResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyUnlockArenaChallengeResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyUnlockArenaChallengeResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyUnlockArenaChallengeResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyUnlockArenaChallengeResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyUnlockArenaChallengeResult& from) {
    NotifyUnlockArenaChallengeResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyUnlockArenaChallengeResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyUnlockArenaChallengeResult";
  }
  protected:
  explicit NotifyUnlockArenaChallengeResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArenaIdFieldNumber = 1,
    kDoorIdFieldNumber = 2,
    kOkFieldNumber = 3,
  };
  // int32 arena_id = 1;
  void clear_arena_id();
  int32_t arena_id() const;
  void set_arena_id(int32_t value);
  private:
  int32_t _internal_arena_id() const;
  void _internal_set_arena_id(int32_t value);
  public:

  // int32 door_id = 2;
  void clear_door_id();
  int32_t door_id() const;
  void set_door_id(int32_t value);
  private:
  int32_t _internal_door_id() const;
  void _internal_set_door_id(int32_t value);
  public:

  // bool ok = 3;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyUnlockArenaChallengeResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t arena_id_;
    int32_t door_id_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestRefreshRoleCombatPower final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.RequestRefreshRoleCombatPower) */ {
 public:
  inline RequestRefreshRoleCombatPower() : RequestRefreshRoleCombatPower(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RequestRefreshRoleCombatPower(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestRefreshRoleCombatPower(const RequestRefreshRoleCombatPower& from);
  RequestRefreshRoleCombatPower(RequestRefreshRoleCombatPower&& from) noexcept
    : RequestRefreshRoleCombatPower() {
    *this = ::std::move(from);
  }

  inline RequestRefreshRoleCombatPower& operator=(const RequestRefreshRoleCombatPower& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestRefreshRoleCombatPower& operator=(RequestRefreshRoleCombatPower&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestRefreshRoleCombatPower& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestRefreshRoleCombatPower* internal_default_instance() {
    return reinterpret_cast<const RequestRefreshRoleCombatPower*>(
               &_RequestRefreshRoleCombatPower_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(RequestRefreshRoleCombatPower& a, RequestRefreshRoleCombatPower& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestRefreshRoleCombatPower* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestRefreshRoleCombatPower* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestRefreshRoleCombatPower* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestRefreshRoleCombatPower>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RequestRefreshRoleCombatPower& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RequestRefreshRoleCombatPower& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestRefreshRoleCombatPower";
  }
  protected:
  explicit RequestRefreshRoleCombatPower(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.RequestRefreshRoleCombatPower)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyRoleCombatPower final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyRoleCombatPower) */ {
 public:
  inline NotifyRoleCombatPower() : NotifyRoleCombatPower(nullptr) {}
  ~NotifyRoleCombatPower() override;
  explicit PROTOBUF_CONSTEXPR NotifyRoleCombatPower(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyRoleCombatPower(const NotifyRoleCombatPower& from);
  NotifyRoleCombatPower(NotifyRoleCombatPower&& from) noexcept
    : NotifyRoleCombatPower() {
    *this = ::std::move(from);
  }

  inline NotifyRoleCombatPower& operator=(const NotifyRoleCombatPower& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyRoleCombatPower& operator=(NotifyRoleCombatPower&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyRoleCombatPower& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyRoleCombatPower* internal_default_instance() {
    return reinterpret_cast<const NotifyRoleCombatPower*>(
               &_NotifyRoleCombatPower_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(NotifyRoleCombatPower& a, NotifyRoleCombatPower& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyRoleCombatPower* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyRoleCombatPower* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyRoleCombatPower* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyRoleCombatPower>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyRoleCombatPower& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyRoleCombatPower& from) {
    NotifyRoleCombatPower::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyRoleCombatPower* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyRoleCombatPower";
  }
  protected:
  explicit NotifyRoleCombatPower(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldValueFieldNumber = 1,
    kNewValueFieldNumber = 2,
    kShowNoticeFieldNumber = 3,
  };
  // int64 old_value = 1;
  void clear_old_value();
  int64_t old_value() const;
  void set_old_value(int64_t value);
  private:
  int64_t _internal_old_value() const;
  void _internal_set_old_value(int64_t value);
  public:

  // int64 new_value = 2;
  void clear_new_value();
  int64_t new_value() const;
  void set_new_value(int64_t value);
  private:
  int64_t _internal_new_value() const;
  void _internal_set_new_value(int64_t value);
  public:

  // bool show_notice = 3;
  void clear_show_notice();
  bool show_notice() const;
  void set_show_notice(bool value);
  private:
  bool _internal_show_notice() const;
  void _internal_set_show_notice(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyRoleCombatPower)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t old_value_;
    int64_t new_value_;
    bool show_notice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GameSystemChatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GameSystemChatMessage) */ {
 public:
  inline GameSystemChatMessage() : GameSystemChatMessage(nullptr) {}
  ~GameSystemChatMessage() override;
  explicit PROTOBUF_CONSTEXPR GameSystemChatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameSystemChatMessage(const GameSystemChatMessage& from);
  GameSystemChatMessage(GameSystemChatMessage&& from) noexcept
    : GameSystemChatMessage() {
    *this = ::std::move(from);
  }

  inline GameSystemChatMessage& operator=(const GameSystemChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameSystemChatMessage& operator=(GameSystemChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameSystemChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameSystemChatMessage* internal_default_instance() {
    return reinterpret_cast<const GameSystemChatMessage*>(
               &_GameSystemChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(GameSystemChatMessage& a, GameSystemChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameSystemChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameSystemChatMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameSystemChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameSystemChatMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameSystemChatMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameSystemChatMessage& from) {
    GameSystemChatMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameSystemChatMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GameSystemChatMessage";
  }
  protected:
  explicit GameSystemChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatContentFieldNumber = 10,
    kChatTypeFieldNumber = 1,
  };
  // bytes chat_content = 10;
  void clear_chat_content();
  const std::string& chat_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_content();
  PROTOBUF_NODISCARD std::string* release_chat_content();
  void set_allocated_chat_content(std::string* chat_content);
  private:
  const std::string& _internal_chat_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_content(const std::string& value);
  std::string* _internal_mutable_chat_content();
  public:

  // int32 chat_type = 1;
  void clear_chat_type();
  int32_t chat_type() const;
  void set_chat_type(int32_t value);
  private:
  int32_t _internal_chat_type() const;
  void _internal_set_chat_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GameSystemChatMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_content_;
    int32_t chat_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReplicateQuestProgressChange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReplicateQuestProgressChange) */ {
 public:
  inline ReplicateQuestProgressChange() : ReplicateQuestProgressChange(nullptr) {}
  ~ReplicateQuestProgressChange() override;
  explicit PROTOBUF_CONSTEXPR ReplicateQuestProgressChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplicateQuestProgressChange(const ReplicateQuestProgressChange& from);
  ReplicateQuestProgressChange(ReplicateQuestProgressChange&& from) noexcept
    : ReplicateQuestProgressChange() {
    *this = ::std::move(from);
  }

  inline ReplicateQuestProgressChange& operator=(const ReplicateQuestProgressChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicateQuestProgressChange& operator=(ReplicateQuestProgressChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicateQuestProgressChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicateQuestProgressChange* internal_default_instance() {
    return reinterpret_cast<const ReplicateQuestProgressChange*>(
               &_ReplicateQuestProgressChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(ReplicateQuestProgressChange& a, ReplicateQuestProgressChange& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplicateQuestProgressChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicateQuestProgressChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplicateQuestProgressChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplicateQuestProgressChange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplicateQuestProgressChange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplicateQuestProgressChange& from) {
    ReplicateQuestProgressChange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplicateQuestProgressChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReplicateQuestProgressChange";
  }
  protected:
  explicit ReplicateQuestProgressChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kTargetIdFieldNumber = 3,
    kAmountFieldNumber = 4,
  };
  // int32 quest_id = 1;
  void clear_quest_id();
  int32_t quest_id() const;
  void set_quest_id(int32_t value);
  private:
  int32_t _internal_quest_id() const;
  void _internal_set_quest_id(int32_t value);
  public:

  // .idlepb.QuestRequirementType type = 2;
  void clear_type();
  ::idlepb::QuestRequirementType type() const;
  void set_type(::idlepb::QuestRequirementType value);
  private:
  ::idlepb::QuestRequirementType _internal_type() const;
  void _internal_set_type(::idlepb::QuestRequirementType value);
  public:

  // int32 target_id = 3;
  void clear_target_id();
  int32_t target_id() const;
  void set_target_id(int32_t value);
  private:
  int32_t _internal_target_id() const;
  void _internal_set_target_id(int32_t value);
  public:

  // int32 amount = 4;
  void clear_amount();
  int32_t amount() const;
  void set_amount(int32_t value);
  private:
  int32_t _internal_amount() const;
  void _internal_set_amount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReplicateQuestProgressChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t quest_id_;
    int type_;
    int32_t target_id_;
    int32_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API QuestOpReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.QuestOpReq) */ {
 public:
  inline QuestOpReq() : QuestOpReq(nullptr) {}
  ~QuestOpReq() override;
  explicit PROTOBUF_CONSTEXPR QuestOpReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuestOpReq(const QuestOpReq& from);
  QuestOpReq(QuestOpReq&& from) noexcept
    : QuestOpReq() {
    *this = ::std::move(from);
  }

  inline QuestOpReq& operator=(const QuestOpReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestOpReq& operator=(QuestOpReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestOpReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestOpReq* internal_default_instance() {
    return reinterpret_cast<const QuestOpReq*>(
               &_QuestOpReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(QuestOpReq& a, QuestOpReq& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestOpReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestOpReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestOpReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestOpReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuestOpReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuestOpReq& from) {
    QuestOpReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuestOpReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.QuestOpReq";
  }
  protected:
  explicit QuestOpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationFieldNumber = 1,
    kQuestIdFieldNumber = 2,
  };
  // .idlepb.QuestOpType operation = 1;
  void clear_operation();
  ::idlepb::QuestOpType operation() const;
  void set_operation(::idlepb::QuestOpType value);
  private:
  ::idlepb::QuestOpType _internal_operation() const;
  void _internal_set_operation(::idlepb::QuestOpType value);
  public:

  // int32 quest_id = 2;
  void clear_quest_id();
  int32_t quest_id() const;
  void set_quest_id(int32_t value);
  private:
  int32_t _internal_quest_id() const;
  void _internal_set_quest_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.QuestOpReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int operation_;
    int32_t quest_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API QuestOpAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.QuestOpAck) */ {
 public:
  inline QuestOpAck() : QuestOpAck(nullptr) {}
  ~QuestOpAck() override;
  explicit PROTOBUF_CONSTEXPR QuestOpAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuestOpAck(const QuestOpAck& from);
  QuestOpAck(QuestOpAck&& from) noexcept
    : QuestOpAck() {
    *this = ::std::move(from);
  }

  inline QuestOpAck& operator=(const QuestOpAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestOpAck& operator=(QuestOpAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestOpAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestOpAck* internal_default_instance() {
    return reinterpret_cast<const QuestOpAck*>(
               &_QuestOpAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(QuestOpAck& a, QuestOpAck& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestOpAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestOpAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestOpAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestOpAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuestOpAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuestOpAck& from) {
    QuestOpAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuestOpAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.QuestOpAck";
  }
  protected:
  explicit QuestOpAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitProgressFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // repeated .idlepb.ReplicateQuestProgressChange init_progress = 2;
  int init_progress_size() const;
  private:
  int _internal_init_progress_size() const;
  public:
  void clear_init_progress();
  ::idlepb::ReplicateQuestProgressChange* mutable_init_progress(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ReplicateQuestProgressChange >*
      mutable_init_progress();
  private:
  const ::idlepb::ReplicateQuestProgressChange& _internal_init_progress(int index) const;
  ::idlepb::ReplicateQuestProgressChange* _internal_add_init_progress();
  public:
  const ::idlepb::ReplicateQuestProgressChange& init_progress(int index) const;
  ::idlepb::ReplicateQuestProgressChange* add_init_progress();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ReplicateQuestProgressChange >&
      init_progress() const;

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.QuestOpAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ReplicateQuestProgressChange > init_progress_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetQuestDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetQuestDataReq) */ {
 public:
  inline GetQuestDataReq() : GetQuestDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetQuestDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetQuestDataReq(const GetQuestDataReq& from);
  GetQuestDataReq(GetQuestDataReq&& from) noexcept
    : GetQuestDataReq() {
    *this = ::std::move(from);
  }

  inline GetQuestDataReq& operator=(const GetQuestDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQuestDataReq& operator=(GetQuestDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQuestDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQuestDataReq* internal_default_instance() {
    return reinterpret_cast<const GetQuestDataReq*>(
               &_GetQuestDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(GetQuestDataReq& a, GetQuestDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetQuestDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQuestDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQuestDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetQuestDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetQuestDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetQuestDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetQuestDataReq";
  }
  protected:
  explicit GetQuestDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetQuestDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetQuestDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetQuestDataAck) */ {
 public:
  inline GetQuestDataAck() : GetQuestDataAck(nullptr) {}
  ~GetQuestDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetQuestDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetQuestDataAck(const GetQuestDataAck& from);
  GetQuestDataAck(GetQuestDataAck&& from) noexcept
    : GetQuestDataAck() {
    *this = ::std::move(from);
  }

  inline GetQuestDataAck& operator=(const GetQuestDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQuestDataAck& operator=(GetQuestDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQuestDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQuestDataAck* internal_default_instance() {
    return reinterpret_cast<const GetQuestDataAck*>(
               &_GetQuestDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(GetQuestDataAck& a, GetQuestDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetQuestDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQuestDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQuestDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetQuestDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetQuestDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetQuestDataAck& from) {
    GetQuestDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetQuestDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetQuestDataAck";
  }
  protected:
  explicit GetQuestDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleQuestData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleQuestData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleQuestData* release_data();
  ::idlepb::RoleQuestData* mutable_data();
  void set_allocated_data(::idlepb::RoleQuestData* data);
  private:
  const ::idlepb::RoleQuestData& _internal_data() const;
  ::idlepb::RoleQuestData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleQuestData* data);
  ::idlepb::RoleQuestData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetQuestDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleQuestData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleLeaderboardDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleLeaderboardDataReq) */ {
 public:
  inline GetRoleLeaderboardDataReq() : GetRoleLeaderboardDataReq(nullptr) {}
  ~GetRoleLeaderboardDataReq() override;
  explicit PROTOBUF_CONSTEXPR GetRoleLeaderboardDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleLeaderboardDataReq(const GetRoleLeaderboardDataReq& from);
  GetRoleLeaderboardDataReq(GetRoleLeaderboardDataReq&& from) noexcept
    : GetRoleLeaderboardDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleLeaderboardDataReq& operator=(const GetRoleLeaderboardDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleLeaderboardDataReq& operator=(GetRoleLeaderboardDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleLeaderboardDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleLeaderboardDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleLeaderboardDataReq*>(
               &_GetRoleLeaderboardDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(GetRoleLeaderboardDataReq& a, GetRoleLeaderboardDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleLeaderboardDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleLeaderboardDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleLeaderboardDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleLeaderboardDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleLeaderboardDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleLeaderboardDataReq& from) {
    GetRoleLeaderboardDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleLeaderboardDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleLeaderboardDataReq";
  }
  protected:
  explicit GetRoleLeaderboardDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
  };
  // int64 role_id = 1;
  void clear_role_id();
  int64_t role_id() const;
  void set_role_id(int64_t value);
  private:
  int64_t _internal_role_id() const;
  void _internal_set_role_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleLeaderboardDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t role_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleLeaderboardDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleLeaderboardDataAck) */ {
 public:
  inline GetRoleLeaderboardDataAck() : GetRoleLeaderboardDataAck(nullptr) {}
  ~GetRoleLeaderboardDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleLeaderboardDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleLeaderboardDataAck(const GetRoleLeaderboardDataAck& from);
  GetRoleLeaderboardDataAck(GetRoleLeaderboardDataAck&& from) noexcept
    : GetRoleLeaderboardDataAck() {
    *this = ::std::move(from);
  }

  inline GetRoleLeaderboardDataAck& operator=(const GetRoleLeaderboardDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleLeaderboardDataAck& operator=(GetRoleLeaderboardDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleLeaderboardDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleLeaderboardDataAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleLeaderboardDataAck*>(
               &_GetRoleLeaderboardDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(GetRoleLeaderboardDataAck& a, GetRoleLeaderboardDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleLeaderboardDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleLeaderboardDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleLeaderboardDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleLeaderboardDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleLeaderboardDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleLeaderboardDataAck& from) {
    GetRoleLeaderboardDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleLeaderboardDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleLeaderboardDataAck";
  }
  protected:
  explicit GetRoleLeaderboardDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderboardRankFieldNumber = 12,
    kDataFieldNumber = 1,
    kParamN1FieldNumber = 11,
  };
  // repeated int32 leaderboard_rank = 12;
  int leaderboard_rank_size() const;
  private:
  int _internal_leaderboard_rank_size() const;
  public:
  void clear_leaderboard_rank();
  private:
  int32_t _internal_leaderboard_rank(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_leaderboard_rank() const;
  void _internal_add_leaderboard_rank(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_leaderboard_rank();
  public:
  int32_t leaderboard_rank(int index) const;
  void set_leaderboard_rank(int index, int32_t value);
  void add_leaderboard_rank(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      leaderboard_rank() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_leaderboard_rank();

  // .idlepb.RoleLeaderboardData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleLeaderboardData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleLeaderboardData* release_data();
  ::idlepb::RoleLeaderboardData* mutable_data();
  void set_allocated_data(::idlepb::RoleLeaderboardData* data);
  private:
  const ::idlepb::RoleLeaderboardData& _internal_data() const;
  ::idlepb::RoleLeaderboardData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleLeaderboardData* data);
  ::idlepb::RoleLeaderboardData* unsafe_arena_release_data();

  // int64 param_n1 = 11;
  void clear_param_n1();
  int64_t param_n1() const;
  void set_param_n1(int64_t value);
  private:
  int64_t _internal_param_n1() const;
  void _internal_set_param_n1(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleLeaderboardDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > leaderboard_rank_;
    mutable std::atomic<int> _leaderboard_rank_cached_byte_size_;
    ::idlepb::RoleLeaderboardData* data_;
    int64_t param_n1_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetLeaderboardPreviewReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetLeaderboardPreviewReq) */ {
 public:
  inline GetLeaderboardPreviewReq() : GetLeaderboardPreviewReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetLeaderboardPreviewReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLeaderboardPreviewReq(const GetLeaderboardPreviewReq& from);
  GetLeaderboardPreviewReq(GetLeaderboardPreviewReq&& from) noexcept
    : GetLeaderboardPreviewReq() {
    *this = ::std::move(from);
  }

  inline GetLeaderboardPreviewReq& operator=(const GetLeaderboardPreviewReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLeaderboardPreviewReq& operator=(GetLeaderboardPreviewReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLeaderboardPreviewReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLeaderboardPreviewReq* internal_default_instance() {
    return reinterpret_cast<const GetLeaderboardPreviewReq*>(
               &_GetLeaderboardPreviewReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(GetLeaderboardPreviewReq& a, GetLeaderboardPreviewReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLeaderboardPreviewReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLeaderboardPreviewReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLeaderboardPreviewReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLeaderboardPreviewReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetLeaderboardPreviewReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetLeaderboardPreviewReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetLeaderboardPreviewReq";
  }
  protected:
  explicit GetLeaderboardPreviewReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetLeaderboardPreviewReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetLeaderboardPreviewAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetLeaderboardPreviewAck) */ {
 public:
  inline GetLeaderboardPreviewAck() : GetLeaderboardPreviewAck(nullptr) {}
  ~GetLeaderboardPreviewAck() override;
  explicit PROTOBUF_CONSTEXPR GetLeaderboardPreviewAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLeaderboardPreviewAck(const GetLeaderboardPreviewAck& from);
  GetLeaderboardPreviewAck(GetLeaderboardPreviewAck&& from) noexcept
    : GetLeaderboardPreviewAck() {
    *this = ::std::move(from);
  }

  inline GetLeaderboardPreviewAck& operator=(const GetLeaderboardPreviewAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLeaderboardPreviewAck& operator=(GetLeaderboardPreviewAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLeaderboardPreviewAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLeaderboardPreviewAck* internal_default_instance() {
    return reinterpret_cast<const GetLeaderboardPreviewAck*>(
               &_GetLeaderboardPreviewAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(GetLeaderboardPreviewAck& a, GetLeaderboardPreviewAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLeaderboardPreviewAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLeaderboardPreviewAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLeaderboardPreviewAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLeaderboardPreviewAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLeaderboardPreviewAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLeaderboardPreviewAck& from) {
    GetLeaderboardPreviewAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLeaderboardPreviewAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetLeaderboardPreviewAck";
  }
  protected:
  explicit GetLeaderboardPreviewAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChampionsFieldNumber = 1,
    kRoleModelConfigsFieldNumber = 2,
    kEquipmentsFieldNumber = 4,
    kMyDataFieldNumber = 3,
    kSeptFieldNumber = 5,
    kLastRefreshTimeFieldNumber = 6,
  };
  // repeated .idlepb.LeaderboardListItem champions = 1;
  int champions_size() const;
  private:
  int _internal_champions_size() const;
  public:
  void clear_champions();
  ::idlepb::LeaderboardListItem* mutable_champions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem >*
      mutable_champions();
  private:
  const ::idlepb::LeaderboardListItem& _internal_champions(int index) const;
  ::idlepb::LeaderboardListItem* _internal_add_champions();
  public:
  const ::idlepb::LeaderboardListItem& champions(int index) const;
  ::idlepb::LeaderboardListItem* add_champions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem >&
      champions() const;

  // repeated .idlepb.CharacterModelConfig role_model_configs = 2;
  int role_model_configs_size() const;
  private:
  int _internal_role_model_configs_size() const;
  public:
  void clear_role_model_configs();
  ::idlepb::CharacterModelConfig* mutable_role_model_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig >*
      mutable_role_model_configs();
  private:
  const ::idlepb::CharacterModelConfig& _internal_role_model_configs(int index) const;
  ::idlepb::CharacterModelConfig* _internal_add_role_model_configs();
  public:
  const ::idlepb::CharacterModelConfig& role_model_configs(int index) const;
  ::idlepb::CharacterModelConfig* add_role_model_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig >&
      role_model_configs() const;

  // repeated .idlepb.ItemData equipments = 4;
  int equipments_size() const;
  private:
  int _internal_equipments_size() const;
  public:
  void clear_equipments();
  ::idlepb::ItemData* mutable_equipments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >*
      mutable_equipments();
  private:
  const ::idlepb::ItemData& _internal_equipments(int index) const;
  ::idlepb::ItemData* _internal_add_equipments();
  public:
  const ::idlepb::ItemData& equipments(int index) const;
  ::idlepb::ItemData* add_equipments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >&
      equipments() const;

  // .idlepb.RoleLeaderboardData my_data = 3;
  bool has_my_data() const;
  private:
  bool _internal_has_my_data() const;
  public:
  void clear_my_data();
  const ::idlepb::RoleLeaderboardData& my_data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleLeaderboardData* release_my_data();
  ::idlepb::RoleLeaderboardData* mutable_my_data();
  void set_allocated_my_data(::idlepb::RoleLeaderboardData* my_data);
  private:
  const ::idlepb::RoleLeaderboardData& _internal_my_data() const;
  ::idlepb::RoleLeaderboardData* _internal_mutable_my_data();
  public:
  void unsafe_arena_set_allocated_my_data(
      ::idlepb::RoleLeaderboardData* my_data);
  ::idlepb::RoleLeaderboardData* unsafe_arena_release_my_data();

  // .idlepb.SeptDataOnLeaderboard sept = 5;
  bool has_sept() const;
  private:
  bool _internal_has_sept() const;
  public:
  void clear_sept();
  const ::idlepb::SeptDataOnLeaderboard& sept() const;
  PROTOBUF_NODISCARD ::idlepb::SeptDataOnLeaderboard* release_sept();
  ::idlepb::SeptDataOnLeaderboard* mutable_sept();
  void set_allocated_sept(::idlepb::SeptDataOnLeaderboard* sept);
  private:
  const ::idlepb::SeptDataOnLeaderboard& _internal_sept() const;
  ::idlepb::SeptDataOnLeaderboard* _internal_mutable_sept();
  public:
  void unsafe_arena_set_allocated_sept(
      ::idlepb::SeptDataOnLeaderboard* sept);
  ::idlepb::SeptDataOnLeaderboard* unsafe_arena_release_sept();

  // int64 last_refresh_time = 6;
  void clear_last_refresh_time();
  int64_t last_refresh_time() const;
  void set_last_refresh_time(int64_t value);
  private:
  int64_t _internal_last_refresh_time() const;
  void _internal_set_last_refresh_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetLeaderboardPreviewAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem > champions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig > role_model_configs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData > equipments_;
    ::idlepb::RoleLeaderboardData* my_data_;
    ::idlepb::SeptDataOnLeaderboard* sept_;
    int64_t last_refresh_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetLeaderboardDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetLeaderboardDataReq) */ {
 public:
  inline GetLeaderboardDataReq() : GetLeaderboardDataReq(nullptr) {}
  ~GetLeaderboardDataReq() override;
  explicit PROTOBUF_CONSTEXPR GetLeaderboardDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLeaderboardDataReq(const GetLeaderboardDataReq& from);
  GetLeaderboardDataReq(GetLeaderboardDataReq&& from) noexcept
    : GetLeaderboardDataReq() {
    *this = ::std::move(from);
  }

  inline GetLeaderboardDataReq& operator=(const GetLeaderboardDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLeaderboardDataReq& operator=(GetLeaderboardDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLeaderboardDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLeaderboardDataReq* internal_default_instance() {
    return reinterpret_cast<const GetLeaderboardDataReq*>(
               &_GetLeaderboardDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(GetLeaderboardDataReq& a, GetLeaderboardDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLeaderboardDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLeaderboardDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLeaderboardDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLeaderboardDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLeaderboardDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLeaderboardDataReq& from) {
    GetLeaderboardDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLeaderboardDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetLeaderboardDataReq";
  }
  protected:
  explicit GetLeaderboardDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .idlepb.LeaderboardType type = 1;
  void clear_type();
  ::idlepb::LeaderboardType type() const;
  void set_type(::idlepb::LeaderboardType value);
  private:
  ::idlepb::LeaderboardType _internal_type() const;
  void _internal_set_type(::idlepb::LeaderboardType value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetLeaderboardDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetLeaderboardDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetLeaderboardDataAck) */ {
 public:
  inline GetLeaderboardDataAck() : GetLeaderboardDataAck(nullptr) {}
  ~GetLeaderboardDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetLeaderboardDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLeaderboardDataAck(const GetLeaderboardDataAck& from);
  GetLeaderboardDataAck(GetLeaderboardDataAck&& from) noexcept
    : GetLeaderboardDataAck() {
    *this = ::std::move(from);
  }

  inline GetLeaderboardDataAck& operator=(const GetLeaderboardDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLeaderboardDataAck& operator=(GetLeaderboardDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLeaderboardDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLeaderboardDataAck* internal_default_instance() {
    return reinterpret_cast<const GetLeaderboardDataAck*>(
               &_GetLeaderboardDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(GetLeaderboardDataAck& a, GetLeaderboardDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLeaderboardDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLeaderboardDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLeaderboardDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLeaderboardDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLeaderboardDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLeaderboardDataAck& from) {
    GetLeaderboardDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLeaderboardDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetLeaderboardDataAck";
  }
  protected:
  explicit GetLeaderboardDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kRoleModelConfigsFieldNumber = 9,
    kEquipmentsFieldNumber = 10,
    kShanghetuRecordsFieldNumber = 11,
    kTop3ClicklikeNumFieldNumber = 12,
    kSeptsFieldNumber = 13,
    kRank1MessageFieldNumber = 7,
    kLastRefreshTimeFieldNumber = 1,
    kMyRankFieldNumber = 6,
  };
  // repeated .idlepb.LeaderboardListItem data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::idlepb::LeaderboardListItem* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem >*
      mutable_data();
  private:
  const ::idlepb::LeaderboardListItem& _internal_data(int index) const;
  ::idlepb::LeaderboardListItem* _internal_add_data();
  public:
  const ::idlepb::LeaderboardListItem& data(int index) const;
  ::idlepb::LeaderboardListItem* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem >&
      data() const;

  // repeated .idlepb.CharacterModelConfig role_model_configs = 9;
  int role_model_configs_size() const;
  private:
  int _internal_role_model_configs_size() const;
  public:
  void clear_role_model_configs();
  ::idlepb::CharacterModelConfig* mutable_role_model_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig >*
      mutable_role_model_configs();
  private:
  const ::idlepb::CharacterModelConfig& _internal_role_model_configs(int index) const;
  ::idlepb::CharacterModelConfig* _internal_add_role_model_configs();
  public:
  const ::idlepb::CharacterModelConfig& role_model_configs(int index) const;
  ::idlepb::CharacterModelConfig* add_role_model_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig >&
      role_model_configs() const;

  // repeated .idlepb.ItemData equipments = 10;
  int equipments_size() const;
  private:
  int _internal_equipments_size() const;
  public:
  void clear_equipments();
  ::idlepb::ItemData* mutable_equipments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >*
      mutable_equipments();
  private:
  const ::idlepb::ItemData& _internal_equipments(int index) const;
  ::idlepb::ItemData* _internal_add_equipments();
  public:
  const ::idlepb::ItemData& equipments(int index) const;
  ::idlepb::ItemData* add_equipments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >&
      equipments() const;

  // repeated .idlepb.ShanhetuRecord shanghetu_records = 11;
  int shanghetu_records_size() const;
  private:
  int _internal_shanghetu_records_size() const;
  public:
  void clear_shanghetu_records();
  ::idlepb::ShanhetuRecord* mutable_shanghetu_records(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ShanhetuRecord >*
      mutable_shanghetu_records();
  private:
  const ::idlepb::ShanhetuRecord& _internal_shanghetu_records(int index) const;
  ::idlepb::ShanhetuRecord* _internal_add_shanghetu_records();
  public:
  const ::idlepb::ShanhetuRecord& shanghetu_records(int index) const;
  ::idlepb::ShanhetuRecord* add_shanghetu_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ShanhetuRecord >&
      shanghetu_records() const;

  // repeated int32 top3_clicklike_num = 12;
  int top3_clicklike_num_size() const;
  private:
  int _internal_top3_clicklike_num_size() const;
  public:
  void clear_top3_clicklike_num();
  private:
  int32_t _internal_top3_clicklike_num(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_top3_clicklike_num() const;
  void _internal_add_top3_clicklike_num(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_top3_clicklike_num();
  public:
  int32_t top3_clicklike_num(int index) const;
  void set_top3_clicklike_num(int index, int32_t value);
  void add_top3_clicklike_num(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      top3_clicklike_num() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_top3_clicklike_num();

  // repeated .idlepb.SeptDataOnLeaderboard septs = 13;
  int septs_size() const;
  private:
  int _internal_septs_size() const;
  public:
  void clear_septs();
  ::idlepb::SeptDataOnLeaderboard* mutable_septs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SeptDataOnLeaderboard >*
      mutable_septs();
  private:
  const ::idlepb::SeptDataOnLeaderboard& _internal_septs(int index) const;
  ::idlepb::SeptDataOnLeaderboard* _internal_add_septs();
  public:
  const ::idlepb::SeptDataOnLeaderboard& septs(int index) const;
  ::idlepb::SeptDataOnLeaderboard* add_septs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SeptDataOnLeaderboard >&
      septs() const;

  // string rank1_message = 7;
  void clear_rank1_message();
  const std::string& rank1_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rank1_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rank1_message();
  PROTOBUF_NODISCARD std::string* release_rank1_message();
  void set_allocated_rank1_message(std::string* rank1_message);
  private:
  const std::string& _internal_rank1_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rank1_message(const std::string& value);
  std::string* _internal_mutable_rank1_message();
  public:

  // int64 last_refresh_time = 1;
  void clear_last_refresh_time();
  int64_t last_refresh_time() const;
  void set_last_refresh_time(int64_t value);
  private:
  int64_t _internal_last_refresh_time() const;
  void _internal_set_last_refresh_time(int64_t value);
  public:

  // int32 my_rank = 6;
  void clear_my_rank();
  int32_t my_rank() const;
  void set_my_rank(int32_t value);
  private:
  int32_t _internal_my_rank() const;
  void _internal_set_my_rank(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetLeaderboardDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem > data_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig > role_model_configs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData > equipments_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ShanhetuRecord > shanghetu_records_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > top3_clicklike_num_;
    mutable std::atomic<int> _top3_clicklike_num_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SeptDataOnLeaderboard > septs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rank1_message_;
    int64_t last_refresh_time_;
    int32_t my_rank_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API LeaderboardClickLikeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.LeaderboardClickLikeReq) */ {
 public:
  inline LeaderboardClickLikeReq() : LeaderboardClickLikeReq(nullptr) {}
  ~LeaderboardClickLikeReq() override;
  explicit PROTOBUF_CONSTEXPR LeaderboardClickLikeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaderboardClickLikeReq(const LeaderboardClickLikeReq& from);
  LeaderboardClickLikeReq(LeaderboardClickLikeReq&& from) noexcept
    : LeaderboardClickLikeReq() {
    *this = ::std::move(from);
  }

  inline LeaderboardClickLikeReq& operator=(const LeaderboardClickLikeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaderboardClickLikeReq& operator=(LeaderboardClickLikeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaderboardClickLikeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaderboardClickLikeReq* internal_default_instance() {
    return reinterpret_cast<const LeaderboardClickLikeReq*>(
               &_LeaderboardClickLikeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(LeaderboardClickLikeReq& a, LeaderboardClickLikeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaderboardClickLikeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaderboardClickLikeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaderboardClickLikeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaderboardClickLikeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaderboardClickLikeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaderboardClickLikeReq& from) {
    LeaderboardClickLikeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaderboardClickLikeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.LeaderboardClickLikeReq";
  }
  protected:
  explicit LeaderboardClickLikeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // int64 role_id = 1;
  void clear_role_id();
  int64_t role_id() const;
  void set_role_id(int64_t value);
  private:
  int64_t _internal_role_id() const;
  void _internal_set_role_id(int64_t value);
  public:

  // .idlepb.LeaderboardType type = 2;
  void clear_type();
  ::idlepb::LeaderboardType type() const;
  void set_type(::idlepb::LeaderboardType value);
  private:
  ::idlepb::LeaderboardType _internal_type() const;
  void _internal_set_type(::idlepb::LeaderboardType value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.LeaderboardClickLikeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t role_id_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API LeaderboardClickLikeAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.LeaderboardClickLikeAck) */ {
 public:
  inline LeaderboardClickLikeAck() : LeaderboardClickLikeAck(nullptr) {}
  ~LeaderboardClickLikeAck() override;
  explicit PROTOBUF_CONSTEXPR LeaderboardClickLikeAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaderboardClickLikeAck(const LeaderboardClickLikeAck& from);
  LeaderboardClickLikeAck(LeaderboardClickLikeAck&& from) noexcept
    : LeaderboardClickLikeAck() {
    *this = ::std::move(from);
  }

  inline LeaderboardClickLikeAck& operator=(const LeaderboardClickLikeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaderboardClickLikeAck& operator=(LeaderboardClickLikeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaderboardClickLikeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaderboardClickLikeAck* internal_default_instance() {
    return reinterpret_cast<const LeaderboardClickLikeAck*>(
               &_LeaderboardClickLikeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(LeaderboardClickLikeAck& a, LeaderboardClickLikeAck& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaderboardClickLikeAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaderboardClickLikeAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaderboardClickLikeAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaderboardClickLikeAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaderboardClickLikeAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaderboardClickLikeAck& from) {
    LeaderboardClickLikeAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaderboardClickLikeAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.LeaderboardClickLikeAck";
  }
  protected:
  explicit LeaderboardClickLikeAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.LeaderboardClickLikeAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API LeaderboardUpdateMessageReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.LeaderboardUpdateMessageReq) */ {
 public:
  inline LeaderboardUpdateMessageReq() : LeaderboardUpdateMessageReq(nullptr) {}
  ~LeaderboardUpdateMessageReq() override;
  explicit PROTOBUF_CONSTEXPR LeaderboardUpdateMessageReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaderboardUpdateMessageReq(const LeaderboardUpdateMessageReq& from);
  LeaderboardUpdateMessageReq(LeaderboardUpdateMessageReq&& from) noexcept
    : LeaderboardUpdateMessageReq() {
    *this = ::std::move(from);
  }

  inline LeaderboardUpdateMessageReq& operator=(const LeaderboardUpdateMessageReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaderboardUpdateMessageReq& operator=(LeaderboardUpdateMessageReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaderboardUpdateMessageReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaderboardUpdateMessageReq* internal_default_instance() {
    return reinterpret_cast<const LeaderboardUpdateMessageReq*>(
               &_LeaderboardUpdateMessageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(LeaderboardUpdateMessageReq& a, LeaderboardUpdateMessageReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaderboardUpdateMessageReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaderboardUpdateMessageReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaderboardUpdateMessageReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaderboardUpdateMessageReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaderboardUpdateMessageReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaderboardUpdateMessageReq& from) {
    LeaderboardUpdateMessageReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaderboardUpdateMessageReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.LeaderboardUpdateMessageReq";
  }
  protected:
  explicit LeaderboardUpdateMessageReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewMessageFieldNumber = 1,
  };
  // string new_message = 1;
  void clear_new_message();
  const std::string& new_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_message();
  PROTOBUF_NODISCARD std::string* release_new_message();
  void set_allocated_new_message(std::string* new_message);
  private:
  const std::string& _internal_new_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_message(const std::string& value);
  std::string* _internal_mutable_new_message();
  public:

  // @@protoc_insertion_point(class_scope:idlepb.LeaderboardUpdateMessageReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API LeaderboardUpdateMessageAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.LeaderboardUpdateMessageAck) */ {
 public:
  inline LeaderboardUpdateMessageAck() : LeaderboardUpdateMessageAck(nullptr) {}
  ~LeaderboardUpdateMessageAck() override;
  explicit PROTOBUF_CONSTEXPR LeaderboardUpdateMessageAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaderboardUpdateMessageAck(const LeaderboardUpdateMessageAck& from);
  LeaderboardUpdateMessageAck(LeaderboardUpdateMessageAck&& from) noexcept
    : LeaderboardUpdateMessageAck() {
    *this = ::std::move(from);
  }

  inline LeaderboardUpdateMessageAck& operator=(const LeaderboardUpdateMessageAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaderboardUpdateMessageAck& operator=(LeaderboardUpdateMessageAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaderboardUpdateMessageAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaderboardUpdateMessageAck* internal_default_instance() {
    return reinterpret_cast<const LeaderboardUpdateMessageAck*>(
               &_LeaderboardUpdateMessageAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(LeaderboardUpdateMessageAck& a, LeaderboardUpdateMessageAck& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaderboardUpdateMessageAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaderboardUpdateMessageAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaderboardUpdateMessageAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaderboardUpdateMessageAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaderboardUpdateMessageAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaderboardUpdateMessageAck& from) {
    LeaderboardUpdateMessageAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaderboardUpdateMessageAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.LeaderboardUpdateMessageAck";
  }
  protected:
  explicit LeaderboardUpdateMessageAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.LeaderboardUpdateMessageAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetMonsterTowerChallengeListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetMonsterTowerChallengeListReq) */ {
 public:
  inline GetMonsterTowerChallengeListReq() : GetMonsterTowerChallengeListReq(nullptr) {}
  ~GetMonsterTowerChallengeListReq() override;
  explicit PROTOBUF_CONSTEXPR GetMonsterTowerChallengeListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMonsterTowerChallengeListReq(const GetMonsterTowerChallengeListReq& from);
  GetMonsterTowerChallengeListReq(GetMonsterTowerChallengeListReq&& from) noexcept
    : GetMonsterTowerChallengeListReq() {
    *this = ::std::move(from);
  }

  inline GetMonsterTowerChallengeListReq& operator=(const GetMonsterTowerChallengeListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMonsterTowerChallengeListReq& operator=(GetMonsterTowerChallengeListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMonsterTowerChallengeListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMonsterTowerChallengeListReq* internal_default_instance() {
    return reinterpret_cast<const GetMonsterTowerChallengeListReq*>(
               &_GetMonsterTowerChallengeListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(GetMonsterTowerChallengeListReq& a, GetMonsterTowerChallengeListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMonsterTowerChallengeListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMonsterTowerChallengeListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMonsterTowerChallengeListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMonsterTowerChallengeListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMonsterTowerChallengeListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMonsterTowerChallengeListReq& from) {
    GetMonsterTowerChallengeListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMonsterTowerChallengeListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetMonsterTowerChallengeListReq";
  }
  protected:
  explicit GetMonsterTowerChallengeListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChallengeIdFieldNumber = 1,
  };
  // int32 challenge_id = 1;
  void clear_challenge_id();
  int32_t challenge_id() const;
  void set_challenge_id(int32_t value);
  private:
  int32_t _internal_challenge_id() const;
  void _internal_set_challenge_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetMonsterTowerChallengeListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t challenge_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetMonsterTowerChallengeListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetMonsterTowerChallengeListAck) */ {
 public:
  inline GetMonsterTowerChallengeListAck() : GetMonsterTowerChallengeListAck(nullptr) {}
  ~GetMonsterTowerChallengeListAck() override;
  explicit PROTOBUF_CONSTEXPR GetMonsterTowerChallengeListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMonsterTowerChallengeListAck(const GetMonsterTowerChallengeListAck& from);
  GetMonsterTowerChallengeListAck(GetMonsterTowerChallengeListAck&& from) noexcept
    : GetMonsterTowerChallengeListAck() {
    *this = ::std::move(from);
  }

  inline GetMonsterTowerChallengeListAck& operator=(const GetMonsterTowerChallengeListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMonsterTowerChallengeListAck& operator=(GetMonsterTowerChallengeListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMonsterTowerChallengeListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMonsterTowerChallengeListAck* internal_default_instance() {
    return reinterpret_cast<const GetMonsterTowerChallengeListAck*>(
               &_GetMonsterTowerChallengeListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(GetMonsterTowerChallengeListAck& a, GetMonsterTowerChallengeListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMonsterTowerChallengeListAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMonsterTowerChallengeListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMonsterTowerChallengeListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMonsterTowerChallengeListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMonsterTowerChallengeListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMonsterTowerChallengeListAck& from) {
    GetMonsterTowerChallengeListAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMonsterTowerChallengeListAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetMonsterTowerChallengeListAck";
  }
  protected:
  explicit GetMonsterTowerChallengeListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kModelConfigsFieldNumber = 2,
    kAllListProgressFieldNumber = 3,
  };
  // repeated .idlepb.LeaderboardListItem data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::idlepb::LeaderboardListItem* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem >*
      mutable_data();
  private:
  const ::idlepb::LeaderboardListItem& _internal_data(int index) const;
  ::idlepb::LeaderboardListItem* _internal_add_data();
  public:
  const ::idlepb::LeaderboardListItem& data(int index) const;
  ::idlepb::LeaderboardListItem* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem >&
      data() const;

  // repeated .idlepb.CharacterModelConfig model_configs = 2;
  int model_configs_size() const;
  private:
  int _internal_model_configs_size() const;
  public:
  void clear_model_configs();
  ::idlepb::CharacterModelConfig* mutable_model_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig >*
      mutable_model_configs();
  private:
  const ::idlepb::CharacterModelConfig& _internal_model_configs(int index) const;
  ::idlepb::CharacterModelConfig* _internal_add_model_configs();
  public:
  const ::idlepb::CharacterModelConfig& model_configs(int index) const;
  ::idlepb::CharacterModelConfig* add_model_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig >&
      model_configs() const;

  // repeated int32 all_list_progress = 3;
  int all_list_progress_size() const;
  private:
  int _internal_all_list_progress_size() const;
  public:
  void clear_all_list_progress();
  private:
  int32_t _internal_all_list_progress(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_all_list_progress() const;
  void _internal_add_all_list_progress(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_all_list_progress();
  public:
  int32_t all_list_progress(int index) const;
  void set_all_list_progress(int index, int32_t value);
  void add_all_list_progress(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      all_list_progress() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_all_list_progress();

  // @@protoc_insertion_point(class_scope:idlepb.GetMonsterTowerChallengeListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem > data_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig > model_configs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > all_list_progress_;
    mutable std::atomic<int> _all_list_progress_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetMonsterTowerChallengeRewardReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetMonsterTowerChallengeRewardReq) */ {
 public:
  inline GetMonsterTowerChallengeRewardReq() : GetMonsterTowerChallengeRewardReq(nullptr) {}
  ~GetMonsterTowerChallengeRewardReq() override;
  explicit PROTOBUF_CONSTEXPR GetMonsterTowerChallengeRewardReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMonsterTowerChallengeRewardReq(const GetMonsterTowerChallengeRewardReq& from);
  GetMonsterTowerChallengeRewardReq(GetMonsterTowerChallengeRewardReq&& from) noexcept
    : GetMonsterTowerChallengeRewardReq() {
    *this = ::std::move(from);
  }

  inline GetMonsterTowerChallengeRewardReq& operator=(const GetMonsterTowerChallengeRewardReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMonsterTowerChallengeRewardReq& operator=(GetMonsterTowerChallengeRewardReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMonsterTowerChallengeRewardReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMonsterTowerChallengeRewardReq* internal_default_instance() {
    return reinterpret_cast<const GetMonsterTowerChallengeRewardReq*>(
               &_GetMonsterTowerChallengeRewardReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(GetMonsterTowerChallengeRewardReq& a, GetMonsterTowerChallengeRewardReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMonsterTowerChallengeRewardReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMonsterTowerChallengeRewardReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMonsterTowerChallengeRewardReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMonsterTowerChallengeRewardReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMonsterTowerChallengeRewardReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMonsterTowerChallengeRewardReq& from) {
    GetMonsterTowerChallengeRewardReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMonsterTowerChallengeRewardReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetMonsterTowerChallengeRewardReq";
  }
  protected:
  explicit GetMonsterTowerChallengeRewardReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChallengeIdFieldNumber = 1,
  };
  // int32 challenge_id = 1;
  void clear_challenge_id();
  int32_t challenge_id() const;
  void set_challenge_id(int32_t value);
  private:
  int32_t _internal_challenge_id() const;
  void _internal_set_challenge_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetMonsterTowerChallengeRewardReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t challenge_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetMonsterTowerChallengeRewardAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetMonsterTowerChallengeRewardAck) */ {
 public:
  inline GetMonsterTowerChallengeRewardAck() : GetMonsterTowerChallengeRewardAck(nullptr) {}
  ~GetMonsterTowerChallengeRewardAck() override;
  explicit PROTOBUF_CONSTEXPR GetMonsterTowerChallengeRewardAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMonsterTowerChallengeRewardAck(const GetMonsterTowerChallengeRewardAck& from);
  GetMonsterTowerChallengeRewardAck(GetMonsterTowerChallengeRewardAck&& from) noexcept
    : GetMonsterTowerChallengeRewardAck() {
    *this = ::std::move(from);
  }

  inline GetMonsterTowerChallengeRewardAck& operator=(const GetMonsterTowerChallengeRewardAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMonsterTowerChallengeRewardAck& operator=(GetMonsterTowerChallengeRewardAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMonsterTowerChallengeRewardAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMonsterTowerChallengeRewardAck* internal_default_instance() {
    return reinterpret_cast<const GetMonsterTowerChallengeRewardAck*>(
               &_GetMonsterTowerChallengeRewardAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(GetMonsterTowerChallengeRewardAck& a, GetMonsterTowerChallengeRewardAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMonsterTowerChallengeRewardAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMonsterTowerChallengeRewardAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMonsterTowerChallengeRewardAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMonsterTowerChallengeRewardAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMonsterTowerChallengeRewardAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMonsterTowerChallengeRewardAck& from) {
    GetMonsterTowerChallengeRewardAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMonsterTowerChallengeRewardAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetMonsterTowerChallengeRewardAck";
  }
  protected:
  explicit GetMonsterTowerChallengeRewardAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetMonsterTowerChallengeRewardAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetFuZeRewardReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetFuZeRewardReq) */ {
 public:
  inline GetFuZeRewardReq() : GetFuZeRewardReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetFuZeRewardReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFuZeRewardReq(const GetFuZeRewardReq& from);
  GetFuZeRewardReq(GetFuZeRewardReq&& from) noexcept
    : GetFuZeRewardReq() {
    *this = ::std::move(from);
  }

  inline GetFuZeRewardReq& operator=(const GetFuZeRewardReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFuZeRewardReq& operator=(GetFuZeRewardReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFuZeRewardReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFuZeRewardReq* internal_default_instance() {
    return reinterpret_cast<const GetFuZeRewardReq*>(
               &_GetFuZeRewardReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(GetFuZeRewardReq& a, GetFuZeRewardReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFuZeRewardReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFuZeRewardReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFuZeRewardReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFuZeRewardReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetFuZeRewardReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetFuZeRewardReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetFuZeRewardReq";
  }
  protected:
  explicit GetFuZeRewardReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetFuZeRewardReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetFuZeRewardAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetFuZeRewardAck) */ {
 public:
  inline GetFuZeRewardAck() : GetFuZeRewardAck(nullptr) {}
  ~GetFuZeRewardAck() override;
  explicit PROTOBUF_CONSTEXPR GetFuZeRewardAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFuZeRewardAck(const GetFuZeRewardAck& from);
  GetFuZeRewardAck(GetFuZeRewardAck&& from) noexcept
    : GetFuZeRewardAck() {
    *this = ::std::move(from);
  }

  inline GetFuZeRewardAck& operator=(const GetFuZeRewardAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFuZeRewardAck& operator=(GetFuZeRewardAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFuZeRewardAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFuZeRewardAck* internal_default_instance() {
    return reinterpret_cast<const GetFuZeRewardAck*>(
               &_GetFuZeRewardAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(GetFuZeRewardAck& a, GetFuZeRewardAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFuZeRewardAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFuZeRewardAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFuZeRewardAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFuZeRewardAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFuZeRewardAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFuZeRewardAck& from) {
    GetFuZeRewardAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFuZeRewardAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetFuZeRewardAck";
  }
  protected:
  explicit GetFuZeRewardAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetFuZeRewardAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleMailDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleMailDataReq) */ {
 public:
  inline GetRoleMailDataReq() : GetRoleMailDataReq(nullptr) {}
  ~GetRoleMailDataReq() override;
  explicit PROTOBUF_CONSTEXPR GetRoleMailDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleMailDataReq(const GetRoleMailDataReq& from);
  GetRoleMailDataReq(GetRoleMailDataReq&& from) noexcept
    : GetRoleMailDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleMailDataReq& operator=(const GetRoleMailDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleMailDataReq& operator=(GetRoleMailDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleMailDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleMailDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleMailDataReq*>(
               &_GetRoleMailDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(GetRoleMailDataReq& a, GetRoleMailDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleMailDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleMailDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleMailDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleMailDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleMailDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleMailDataReq& from) {
    GetRoleMailDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleMailDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleMailDataReq";
  }
  protected:
  explicit GetRoleMailDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnlyNumFieldNumber = 1,
  };
  // bool only_num = 1;
  void clear_only_num();
  bool only_num() const;
  void set_only_num(bool value);
  private:
  bool _internal_only_num() const;
  void _internal_set_only_num(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleMailDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool only_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleMailDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleMailDataAck) */ {
 public:
  inline GetRoleMailDataAck() : GetRoleMailDataAck(nullptr) {}
  ~GetRoleMailDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleMailDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleMailDataAck(const GetRoleMailDataAck& from);
  GetRoleMailDataAck(GetRoleMailDataAck&& from) noexcept
    : GetRoleMailDataAck() {
    *this = ::std::move(from);
  }

  inline GetRoleMailDataAck& operator=(const GetRoleMailDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleMailDataAck& operator=(GetRoleMailDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleMailDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleMailDataAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleMailDataAck*>(
               &_GetRoleMailDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(GetRoleMailDataAck& a, GetRoleMailDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleMailDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleMailDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleMailDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleMailDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleMailDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleMailDataAck& from) {
    GetRoleMailDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleMailDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleMailDataAck";
  }
  protected:
  explicit GetRoleMailDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailBoxFieldNumber = 2,
    kUnreadMailNumFieldNumber = 1,
  };
  // repeated .idlepb.Mail mail_box = 2;
  int mail_box_size() const;
  private:
  int _internal_mail_box_size() const;
  public:
  void clear_mail_box();
  ::idlepb::Mail* mutable_mail_box(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Mail >*
      mutable_mail_box();
  private:
  const ::idlepb::Mail& _internal_mail_box(int index) const;
  ::idlepb::Mail* _internal_add_mail_box();
  public:
  const ::idlepb::Mail& mail_box(int index) const;
  ::idlepb::Mail* add_mail_box();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Mail >&
      mail_box() const;

  // int32 unread_mail_num = 1;
  void clear_unread_mail_num();
  int32_t unread_mail_num() const;
  void set_unread_mail_num(int32_t value);
  private:
  int32_t _internal_unread_mail_num() const;
  void _internal_set_unread_mail_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleMailDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Mail > mail_box_;
    int32_t unread_mail_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UpdateRoleMail final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.UpdateRoleMail) */ {
 public:
  inline UpdateRoleMail() : UpdateRoleMail(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateRoleMail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRoleMail(const UpdateRoleMail& from);
  UpdateRoleMail(UpdateRoleMail&& from) noexcept
    : UpdateRoleMail() {
    *this = ::std::move(from);
  }

  inline UpdateRoleMail& operator=(const UpdateRoleMail& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRoleMail& operator=(UpdateRoleMail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRoleMail& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRoleMail* internal_default_instance() {
    return reinterpret_cast<const UpdateRoleMail*>(
               &_UpdateRoleMail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(UpdateRoleMail& a, UpdateRoleMail& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRoleMail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRoleMail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRoleMail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRoleMail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateRoleMail& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateRoleMail& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UpdateRoleMail";
  }
  protected:
  explicit UpdateRoleMail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.UpdateRoleMail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReadMailReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReadMailReq) */ {
 public:
  inline ReadMailReq() : ReadMailReq(nullptr) {}
  ~ReadMailReq() override;
  explicit PROTOBUF_CONSTEXPR ReadMailReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadMailReq(const ReadMailReq& from);
  ReadMailReq(ReadMailReq&& from) noexcept
    : ReadMailReq() {
    *this = ::std::move(from);
  }

  inline ReadMailReq& operator=(const ReadMailReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadMailReq& operator=(ReadMailReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadMailReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadMailReq* internal_default_instance() {
    return reinterpret_cast<const ReadMailReq*>(
               &_ReadMailReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(ReadMailReq& a, ReadMailReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadMailReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadMailReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadMailReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadMailReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadMailReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadMailReq& from) {
    ReadMailReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadMailReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReadMailReq";
  }
  protected:
  explicit ReadMailReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReadMailReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReadMailAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReadMailAck) */ {
 public:
  inline ReadMailAck() : ReadMailAck(nullptr) {}
  ~ReadMailAck() override;
  explicit PROTOBUF_CONSTEXPR ReadMailAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadMailAck(const ReadMailAck& from);
  ReadMailAck(ReadMailAck&& from) noexcept
    : ReadMailAck() {
    *this = ::std::move(from);
  }

  inline ReadMailAck& operator=(const ReadMailAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadMailAck& operator=(ReadMailAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadMailAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadMailAck* internal_default_instance() {
    return reinterpret_cast<const ReadMailAck*>(
               &_ReadMailAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(ReadMailAck& a, ReadMailAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadMailAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadMailAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadMailAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadMailAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadMailAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadMailAck& from) {
    ReadMailAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadMailAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReadMailAck";
  }
  protected:
  explicit ReadMailAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.Mail mail = 2;
  bool has_mail() const;
  private:
  bool _internal_has_mail() const;
  public:
  void clear_mail();
  const ::idlepb::Mail& mail() const;
  PROTOBUF_NODISCARD ::idlepb::Mail* release_mail();
  ::idlepb::Mail* mutable_mail();
  void set_allocated_mail(::idlepb::Mail* mail);
  private:
  const ::idlepb::Mail& _internal_mail() const;
  ::idlepb::Mail* _internal_mutable_mail();
  public:
  void unsafe_arena_set_allocated_mail(
      ::idlepb::Mail* mail);
  ::idlepb::Mail* unsafe_arena_release_mail();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReadMailAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::Mail* mail_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetMailAttachmentReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetMailAttachmentReq) */ {
 public:
  inline GetMailAttachmentReq() : GetMailAttachmentReq(nullptr) {}
  ~GetMailAttachmentReq() override;
  explicit PROTOBUF_CONSTEXPR GetMailAttachmentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMailAttachmentReq(const GetMailAttachmentReq& from);
  GetMailAttachmentReq(GetMailAttachmentReq&& from) noexcept
    : GetMailAttachmentReq() {
    *this = ::std::move(from);
  }

  inline GetMailAttachmentReq& operator=(const GetMailAttachmentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMailAttachmentReq& operator=(GetMailAttachmentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMailAttachmentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMailAttachmentReq* internal_default_instance() {
    return reinterpret_cast<const GetMailAttachmentReq*>(
               &_GetMailAttachmentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(GetMailAttachmentReq& a, GetMailAttachmentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMailAttachmentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMailAttachmentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMailAttachmentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMailAttachmentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMailAttachmentReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMailAttachmentReq& from) {
    GetMailAttachmentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMailAttachmentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetMailAttachmentReq";
  }
  protected:
  explicit GetMailAttachmentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetMailAttachmentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetMailAttachmentAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetMailAttachmentAck) */ {
 public:
  inline GetMailAttachmentAck() : GetMailAttachmentAck(nullptr) {}
  ~GetMailAttachmentAck() override;
  explicit PROTOBUF_CONSTEXPR GetMailAttachmentAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMailAttachmentAck(const GetMailAttachmentAck& from);
  GetMailAttachmentAck(GetMailAttachmentAck&& from) noexcept
    : GetMailAttachmentAck() {
    *this = ::std::move(from);
  }

  inline GetMailAttachmentAck& operator=(const GetMailAttachmentAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMailAttachmentAck& operator=(GetMailAttachmentAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMailAttachmentAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMailAttachmentAck* internal_default_instance() {
    return reinterpret_cast<const GetMailAttachmentAck*>(
               &_GetMailAttachmentAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(GetMailAttachmentAck& a, GetMailAttachmentAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMailAttachmentAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMailAttachmentAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMailAttachmentAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMailAttachmentAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMailAttachmentAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMailAttachmentAck& from) {
    GetMailAttachmentAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMailAttachmentAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetMailAttachmentAck";
  }
  protected:
  explicit GetMailAttachmentAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailDataFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .idlepb.Mail mail_data = 2;
  bool has_mail_data() const;
  private:
  bool _internal_has_mail_data() const;
  public:
  void clear_mail_data();
  const ::idlepb::Mail& mail_data() const;
  PROTOBUF_NODISCARD ::idlepb::Mail* release_mail_data();
  ::idlepb::Mail* mutable_mail_data();
  void set_allocated_mail_data(::idlepb::Mail* mail_data);
  private:
  const ::idlepb::Mail& _internal_mail_data() const;
  ::idlepb::Mail* _internal_mutable_mail_data();
  public:
  void unsafe_arena_set_allocated_mail_data(
      ::idlepb::Mail* mail_data);
  ::idlepb::Mail* unsafe_arena_release_mail_data();

  // .idlepb.MailOperation result = 1;
  void clear_result();
  ::idlepb::MailOperation result() const;
  void set_result(::idlepb::MailOperation value);
  private:
  ::idlepb::MailOperation _internal_result() const;
  void _internal_set_result(::idlepb::MailOperation value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetMailAttachmentAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::Mail* mail_data_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DeleteMailReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DeleteMailReq) */ {
 public:
  inline DeleteMailReq() : DeleteMailReq(nullptr) {}
  ~DeleteMailReq() override;
  explicit PROTOBUF_CONSTEXPR DeleteMailReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteMailReq(const DeleteMailReq& from);
  DeleteMailReq(DeleteMailReq&& from) noexcept
    : DeleteMailReq() {
    *this = ::std::move(from);
  }

  inline DeleteMailReq& operator=(const DeleteMailReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteMailReq& operator=(DeleteMailReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteMailReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteMailReq* internal_default_instance() {
    return reinterpret_cast<const DeleteMailReq*>(
               &_DeleteMailReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(DeleteMailReq& a, DeleteMailReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteMailReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteMailReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteMailReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteMailReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteMailReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteMailReq& from) {
    DeleteMailReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteMailReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DeleteMailReq";
  }
  protected:
  explicit DeleteMailReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DeleteMailReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DeleteMailAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DeleteMailAck) */ {
 public:
  inline DeleteMailAck() : DeleteMailAck(nullptr) {}
  ~DeleteMailAck() override;
  explicit PROTOBUF_CONSTEXPR DeleteMailAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteMailAck(const DeleteMailAck& from);
  DeleteMailAck(DeleteMailAck&& from) noexcept
    : DeleteMailAck() {
    *this = ::std::move(from);
  }

  inline DeleteMailAck& operator=(const DeleteMailAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteMailAck& operator=(DeleteMailAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteMailAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteMailAck* internal_default_instance() {
    return reinterpret_cast<const DeleteMailAck*>(
               &_DeleteMailAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(DeleteMailAck& a, DeleteMailAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteMailAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteMailAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteMailAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteMailAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteMailAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteMailAck& from) {
    DeleteMailAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteMailAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DeleteMailAck";
  }
  protected:
  explicit DeleteMailAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DeleteMailAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OneClickGetMailAttachmentReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.OneClickGetMailAttachmentReq) */ {
 public:
  inline OneClickGetMailAttachmentReq() : OneClickGetMailAttachmentReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OneClickGetMailAttachmentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneClickGetMailAttachmentReq(const OneClickGetMailAttachmentReq& from);
  OneClickGetMailAttachmentReq(OneClickGetMailAttachmentReq&& from) noexcept
    : OneClickGetMailAttachmentReq() {
    *this = ::std::move(from);
  }

  inline OneClickGetMailAttachmentReq& operator=(const OneClickGetMailAttachmentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneClickGetMailAttachmentReq& operator=(OneClickGetMailAttachmentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneClickGetMailAttachmentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneClickGetMailAttachmentReq* internal_default_instance() {
    return reinterpret_cast<const OneClickGetMailAttachmentReq*>(
               &_OneClickGetMailAttachmentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(OneClickGetMailAttachmentReq& a, OneClickGetMailAttachmentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(OneClickGetMailAttachmentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneClickGetMailAttachmentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneClickGetMailAttachmentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneClickGetMailAttachmentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OneClickGetMailAttachmentReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OneClickGetMailAttachmentReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OneClickGetMailAttachmentReq";
  }
  protected:
  explicit OneClickGetMailAttachmentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.OneClickGetMailAttachmentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OneClickGetMailAttachmentAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.OneClickGetMailAttachmentAck) */ {
 public:
  inline OneClickGetMailAttachmentAck() : OneClickGetMailAttachmentAck(nullptr) {}
  ~OneClickGetMailAttachmentAck() override;
  explicit PROTOBUF_CONSTEXPR OneClickGetMailAttachmentAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneClickGetMailAttachmentAck(const OneClickGetMailAttachmentAck& from);
  OneClickGetMailAttachmentAck(OneClickGetMailAttachmentAck&& from) noexcept
    : OneClickGetMailAttachmentAck() {
    *this = ::std::move(from);
  }

  inline OneClickGetMailAttachmentAck& operator=(const OneClickGetMailAttachmentAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneClickGetMailAttachmentAck& operator=(OneClickGetMailAttachmentAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneClickGetMailAttachmentAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneClickGetMailAttachmentAck* internal_default_instance() {
    return reinterpret_cast<const OneClickGetMailAttachmentAck*>(
               &_OneClickGetMailAttachmentAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(OneClickGetMailAttachmentAck& a, OneClickGetMailAttachmentAck& b) {
    a.Swap(&b);
  }
  inline void Swap(OneClickGetMailAttachmentAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneClickGetMailAttachmentAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneClickGetMailAttachmentAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneClickGetMailAttachmentAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OneClickGetMailAttachmentAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OneClickGetMailAttachmentAck& from) {
    OneClickGetMailAttachmentAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneClickGetMailAttachmentAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OneClickGetMailAttachmentAck";
  }
  protected:
  explicit OneClickGetMailAttachmentAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailBoxFieldNumber = 3,
    kResultFieldNumber = 1,
    kUnreadMailNumFieldNumber = 2,
  };
  // repeated .idlepb.Mail mail_box = 3;
  int mail_box_size() const;
  private:
  int _internal_mail_box_size() const;
  public:
  void clear_mail_box();
  ::idlepb::Mail* mutable_mail_box(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Mail >*
      mutable_mail_box();
  private:
  const ::idlepb::Mail& _internal_mail_box(int index) const;
  ::idlepb::Mail* _internal_add_mail_box();
  public:
  const ::idlepb::Mail& mail_box(int index) const;
  ::idlepb::Mail* add_mail_box();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Mail >&
      mail_box() const;

  // .idlepb.MailOperation result = 1;
  void clear_result();
  ::idlepb::MailOperation result() const;
  void set_result(::idlepb::MailOperation value);
  private:
  ::idlepb::MailOperation _internal_result() const;
  void _internal_set_result(::idlepb::MailOperation value);
  public:

  // int32 unread_mail_num = 2;
  void clear_unread_mail_num();
  int32_t unread_mail_num() const;
  void set_unread_mail_num(int32_t value);
  private:
  int32_t _internal_unread_mail_num() const;
  void _internal_set_unread_mail_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.OneClickGetMailAttachmentAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Mail > mail_box_;
    int result_;
    int32_t unread_mail_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OneClickReadMailReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.OneClickReadMailReq) */ {
 public:
  inline OneClickReadMailReq() : OneClickReadMailReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OneClickReadMailReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneClickReadMailReq(const OneClickReadMailReq& from);
  OneClickReadMailReq(OneClickReadMailReq&& from) noexcept
    : OneClickReadMailReq() {
    *this = ::std::move(from);
  }

  inline OneClickReadMailReq& operator=(const OneClickReadMailReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneClickReadMailReq& operator=(OneClickReadMailReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneClickReadMailReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneClickReadMailReq* internal_default_instance() {
    return reinterpret_cast<const OneClickReadMailReq*>(
               &_OneClickReadMailReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(OneClickReadMailReq& a, OneClickReadMailReq& b) {
    a.Swap(&b);
  }
  inline void Swap(OneClickReadMailReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneClickReadMailReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneClickReadMailReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneClickReadMailReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OneClickReadMailReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OneClickReadMailReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OneClickReadMailReq";
  }
  protected:
  explicit OneClickReadMailReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.OneClickReadMailReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OneClickReadMailAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.OneClickReadMailAck) */ {
 public:
  inline OneClickReadMailAck() : OneClickReadMailAck(nullptr) {}
  ~OneClickReadMailAck() override;
  explicit PROTOBUF_CONSTEXPR OneClickReadMailAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneClickReadMailAck(const OneClickReadMailAck& from);
  OneClickReadMailAck(OneClickReadMailAck&& from) noexcept
    : OneClickReadMailAck() {
    *this = ::std::move(from);
  }

  inline OneClickReadMailAck& operator=(const OneClickReadMailAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneClickReadMailAck& operator=(OneClickReadMailAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneClickReadMailAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneClickReadMailAck* internal_default_instance() {
    return reinterpret_cast<const OneClickReadMailAck*>(
               &_OneClickReadMailAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(OneClickReadMailAck& a, OneClickReadMailAck& b) {
    a.Swap(&b);
  }
  inline void Swap(OneClickReadMailAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneClickReadMailAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneClickReadMailAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneClickReadMailAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OneClickReadMailAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OneClickReadMailAck& from) {
    OneClickReadMailAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneClickReadMailAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OneClickReadMailAck";
  }
  protected:
  explicit OneClickReadMailAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.OneClickReadMailAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OneClickDeleteMailReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.OneClickDeleteMailReq) */ {
 public:
  inline OneClickDeleteMailReq() : OneClickDeleteMailReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OneClickDeleteMailReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneClickDeleteMailReq(const OneClickDeleteMailReq& from);
  OneClickDeleteMailReq(OneClickDeleteMailReq&& from) noexcept
    : OneClickDeleteMailReq() {
    *this = ::std::move(from);
  }

  inline OneClickDeleteMailReq& operator=(const OneClickDeleteMailReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneClickDeleteMailReq& operator=(OneClickDeleteMailReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneClickDeleteMailReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneClickDeleteMailReq* internal_default_instance() {
    return reinterpret_cast<const OneClickDeleteMailReq*>(
               &_OneClickDeleteMailReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(OneClickDeleteMailReq& a, OneClickDeleteMailReq& b) {
    a.Swap(&b);
  }
  inline void Swap(OneClickDeleteMailReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneClickDeleteMailReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneClickDeleteMailReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneClickDeleteMailReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OneClickDeleteMailReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OneClickDeleteMailReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OneClickDeleteMailReq";
  }
  protected:
  explicit OneClickDeleteMailReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.OneClickDeleteMailReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OneClickDeleteMailAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.OneClickDeleteMailAck) */ {
 public:
  inline OneClickDeleteMailAck() : OneClickDeleteMailAck(nullptr) {}
  ~OneClickDeleteMailAck() override;
  explicit PROTOBUF_CONSTEXPR OneClickDeleteMailAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneClickDeleteMailAck(const OneClickDeleteMailAck& from);
  OneClickDeleteMailAck(OneClickDeleteMailAck&& from) noexcept
    : OneClickDeleteMailAck() {
    *this = ::std::move(from);
  }

  inline OneClickDeleteMailAck& operator=(const OneClickDeleteMailAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneClickDeleteMailAck& operator=(OneClickDeleteMailAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneClickDeleteMailAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneClickDeleteMailAck* internal_default_instance() {
    return reinterpret_cast<const OneClickDeleteMailAck*>(
               &_OneClickDeleteMailAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(OneClickDeleteMailAck& a, OneClickDeleteMailAck& b) {
    a.Swap(&b);
  }
  inline void Swap(OneClickDeleteMailAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneClickDeleteMailAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneClickDeleteMailAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneClickDeleteMailAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OneClickDeleteMailAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OneClickDeleteMailAck& from) {
    OneClickDeleteMailAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneClickDeleteMailAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OneClickDeleteMailAck";
  }
  protected:
  explicit OneClickDeleteMailAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeletedIndexFieldNumber = 1,
  };
  // repeated int32 deleted_index = 1;
  int deleted_index_size() const;
  private:
  int _internal_deleted_index_size() const;
  public:
  void clear_deleted_index();
  private:
  int32_t _internal_deleted_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_deleted_index() const;
  void _internal_add_deleted_index(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_deleted_index();
  public:
  int32_t deleted_index(int index) const;
  void set_deleted_index(int index, int32_t value);
  void add_deleted_index(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      deleted_index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_deleted_index();

  // @@protoc_insertion_point(class_scope:idlepb.OneClickDeleteMailAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > deleted_index_;
    mutable std::atomic<int> _deleted_index_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UnlockFunctionModuleReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UnlockFunctionModuleReq) */ {
 public:
  inline UnlockFunctionModuleReq() : UnlockFunctionModuleReq(nullptr) {}
  ~UnlockFunctionModuleReq() override;
  explicit PROTOBUF_CONSTEXPR UnlockFunctionModuleReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockFunctionModuleReq(const UnlockFunctionModuleReq& from);
  UnlockFunctionModuleReq(UnlockFunctionModuleReq&& from) noexcept
    : UnlockFunctionModuleReq() {
    *this = ::std::move(from);
  }

  inline UnlockFunctionModuleReq& operator=(const UnlockFunctionModuleReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockFunctionModuleReq& operator=(UnlockFunctionModuleReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockFunctionModuleReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockFunctionModuleReq* internal_default_instance() {
    return reinterpret_cast<const UnlockFunctionModuleReq*>(
               &_UnlockFunctionModuleReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(UnlockFunctionModuleReq& a, UnlockFunctionModuleReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockFunctionModuleReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockFunctionModuleReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockFunctionModuleReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockFunctionModuleReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockFunctionModuleReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnlockFunctionModuleReq& from) {
    UnlockFunctionModuleReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockFunctionModuleReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UnlockFunctionModuleReq";
  }
  protected:
  explicit UnlockFunctionModuleReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .idlepb.FunctionModuleType type = 1;
  void clear_type();
  ::idlepb::FunctionModuleType type() const;
  void set_type(::idlepb::FunctionModuleType value);
  private:
  ::idlepb::FunctionModuleType _internal_type() const;
  void _internal_set_type(::idlepb::FunctionModuleType value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UnlockFunctionModuleReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UnlockFunctionModuleAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UnlockFunctionModuleAck) */ {
 public:
  inline UnlockFunctionModuleAck() : UnlockFunctionModuleAck(nullptr) {}
  ~UnlockFunctionModuleAck() override;
  explicit PROTOBUF_CONSTEXPR UnlockFunctionModuleAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockFunctionModuleAck(const UnlockFunctionModuleAck& from);
  UnlockFunctionModuleAck(UnlockFunctionModuleAck&& from) noexcept
    : UnlockFunctionModuleAck() {
    *this = ::std::move(from);
  }

  inline UnlockFunctionModuleAck& operator=(const UnlockFunctionModuleAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockFunctionModuleAck& operator=(UnlockFunctionModuleAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockFunctionModuleAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockFunctionModuleAck* internal_default_instance() {
    return reinterpret_cast<const UnlockFunctionModuleAck*>(
               &_UnlockFunctionModuleAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(UnlockFunctionModuleAck& a, UnlockFunctionModuleAck& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockFunctionModuleAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockFunctionModuleAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockFunctionModuleAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockFunctionModuleAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockFunctionModuleAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnlockFunctionModuleAck& from) {
    UnlockFunctionModuleAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockFunctionModuleAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UnlockFunctionModuleAck";
  }
  protected:
  explicit UnlockFunctionModuleAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UnlockFunctionModuleAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyUnlockedModuels final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyUnlockedModuels) */ {
 public:
  inline NotifyUnlockedModuels() : NotifyUnlockedModuels(nullptr) {}
  ~NotifyUnlockedModuels() override;
  explicit PROTOBUF_CONSTEXPR NotifyUnlockedModuels(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyUnlockedModuels(const NotifyUnlockedModuels& from);
  NotifyUnlockedModuels(NotifyUnlockedModuels&& from) noexcept
    : NotifyUnlockedModuels() {
    *this = ::std::move(from);
  }

  inline NotifyUnlockedModuels& operator=(const NotifyUnlockedModuels& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyUnlockedModuels& operator=(NotifyUnlockedModuels&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyUnlockedModuels& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyUnlockedModuels* internal_default_instance() {
    return reinterpret_cast<const NotifyUnlockedModuels*>(
               &_NotifyUnlockedModuels_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(NotifyUnlockedModuels& a, NotifyUnlockedModuels& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyUnlockedModuels* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyUnlockedModuels* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyUnlockedModuels* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyUnlockedModuels>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyUnlockedModuels& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyUnlockedModuels& from) {
    NotifyUnlockedModuels::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyUnlockedModuels* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyUnlockedModuels";
  }
  protected:
  explicit NotifyUnlockedModuels(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnlockedModulesFieldNumber = 1,
  };
  // repeated int32 unlocked_modules = 1;
  int unlocked_modules_size() const;
  private:
  int _internal_unlocked_modules_size() const;
  public:
  void clear_unlocked_modules();
  private:
  int32_t _internal_unlocked_modules(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_unlocked_modules() const;
  void _internal_add_unlocked_modules(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_unlocked_modules();
  public:
  int32_t unlocked_modules(int index) const;
  void set_unlocked_modules(int index, int32_t value);
  void add_unlocked_modules(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      unlocked_modules() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_unlocked_modules();

  // @@protoc_insertion_point(class_scope:idlepb.NotifyUnlockedModuels)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > unlocked_modules_;
    mutable std::atomic<int> _unlocked_modules_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UpdateChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UpdateChat) */ {
 public:
  inline UpdateChat() : UpdateChat(nullptr) {}
  ~UpdateChat() override;
  explicit PROTOBUF_CONSTEXPR UpdateChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateChat(const UpdateChat& from);
  UpdateChat(UpdateChat&& from) noexcept
    : UpdateChat() {
    *this = ::std::move(from);
  }

  inline UpdateChat& operator=(const UpdateChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateChat& operator=(UpdateChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateChat* internal_default_instance() {
    return reinterpret_cast<const UpdateChat*>(
               &_UpdateChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(UpdateChat& a, UpdateChat& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateChat& from) {
    UpdateChat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UpdateChat";
  }
  protected:
  explicit UpdateChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatMessageFieldNumber = 2,
    kChannelFieldNumber = 1,
  };
  // .idlepb.ChatMessage chat_message = 2;
  bool has_chat_message() const;
  private:
  bool _internal_has_chat_message() const;
  public:
  void clear_chat_message();
  const ::idlepb::ChatMessage& chat_message() const;
  PROTOBUF_NODISCARD ::idlepb::ChatMessage* release_chat_message();
  ::idlepb::ChatMessage* mutable_chat_message();
  void set_allocated_chat_message(::idlepb::ChatMessage* chat_message);
  private:
  const ::idlepb::ChatMessage& _internal_chat_message() const;
  ::idlepb::ChatMessage* _internal_mutable_chat_message();
  public:
  void unsafe_arena_set_allocated_chat_message(
      ::idlepb::ChatMessage* chat_message);
  ::idlepb::ChatMessage* unsafe_arena_release_chat_message();

  // .idlepb.ChatMessageChannel channel = 1;
  void clear_channel();
  ::idlepb::ChatMessageChannel channel() const;
  void set_channel(::idlepb::ChatMessageChannel value);
  private:
  ::idlepb::ChatMessageChannel _internal_channel() const;
  void _internal_set_channel(::idlepb::ChatMessageChannel value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UpdateChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::ChatMessage* chat_message_;
    int channel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SendChatMessageReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SendChatMessageReq) */ {
 public:
  inline SendChatMessageReq() : SendChatMessageReq(nullptr) {}
  ~SendChatMessageReq() override;
  explicit PROTOBUF_CONSTEXPR SendChatMessageReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendChatMessageReq(const SendChatMessageReq& from);
  SendChatMessageReq(SendChatMessageReq&& from) noexcept
    : SendChatMessageReq() {
    *this = ::std::move(from);
  }

  inline SendChatMessageReq& operator=(const SendChatMessageReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendChatMessageReq& operator=(SendChatMessageReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendChatMessageReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendChatMessageReq* internal_default_instance() {
    return reinterpret_cast<const SendChatMessageReq*>(
               &_SendChatMessageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(SendChatMessageReq& a, SendChatMessageReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SendChatMessageReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendChatMessageReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendChatMessageReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendChatMessageReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendChatMessageReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendChatMessageReq& from) {
    SendChatMessageReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendChatMessageReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SendChatMessageReq";
  }
  protected:
  explicit SendChatMessageReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 3,
    kRoleIdFieldNumber = 1,
    kChannelFieldNumber = 2,
    kTypeFieldNumber = 4,
  };
  // string text = 3;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // uint64 role_id = 1;
  void clear_role_id();
  uint64_t role_id() const;
  void set_role_id(uint64_t value);
  private:
  uint64_t _internal_role_id() const;
  void _internal_set_role_id(uint64_t value);
  public:

  // .idlepb.ChatMessageChannel channel = 2;
  void clear_channel();
  ::idlepb::ChatMessageChannel channel() const;
  void set_channel(::idlepb::ChatMessageChannel value);
  private:
  ::idlepb::ChatMessageChannel _internal_channel() const;
  void _internal_set_channel(::idlepb::ChatMessageChannel value);
  public:

  // .idlepb.ChatMessageType type = 4;
  void clear_type();
  ::idlepb::ChatMessageType type() const;
  void set_type(::idlepb::ChatMessageType value);
  private:
  ::idlepb::ChatMessageType _internal_type() const;
  void _internal_set_type(::idlepb::ChatMessageType value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SendChatMessageReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    uint64_t role_id_;
    int channel_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SendChatMessageAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SendChatMessageAck) */ {
 public:
  inline SendChatMessageAck() : SendChatMessageAck(nullptr) {}
  ~SendChatMessageAck() override;
  explicit PROTOBUF_CONSTEXPR SendChatMessageAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendChatMessageAck(const SendChatMessageAck& from);
  SendChatMessageAck(SendChatMessageAck&& from) noexcept
    : SendChatMessageAck() {
    *this = ::std::move(from);
  }

  inline SendChatMessageAck& operator=(const SendChatMessageAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendChatMessageAck& operator=(SendChatMessageAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendChatMessageAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendChatMessageAck* internal_default_instance() {
    return reinterpret_cast<const SendChatMessageAck*>(
               &_SendChatMessageAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    126;

  friend void swap(SendChatMessageAck& a, SendChatMessageAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SendChatMessageAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendChatMessageAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendChatMessageAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendChatMessageAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendChatMessageAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendChatMessageAck& from) {
    SendChatMessageAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendChatMessageAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SendChatMessageAck";
  }
  protected:
  explicit SendChatMessageAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SendChatMessageAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetChatRecordReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetChatRecordReq) */ {
 public:
  inline GetChatRecordReq() : GetChatRecordReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetChatRecordReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetChatRecordReq(const GetChatRecordReq& from);
  GetChatRecordReq(GetChatRecordReq&& from) noexcept
    : GetChatRecordReq() {
    *this = ::std::move(from);
  }

  inline GetChatRecordReq& operator=(const GetChatRecordReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetChatRecordReq& operator=(GetChatRecordReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetChatRecordReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetChatRecordReq* internal_default_instance() {
    return reinterpret_cast<const GetChatRecordReq*>(
               &_GetChatRecordReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(GetChatRecordReq& a, GetChatRecordReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetChatRecordReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetChatRecordReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetChatRecordReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetChatRecordReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetChatRecordReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetChatRecordReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetChatRecordReq";
  }
  protected:
  explicit GetChatRecordReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetChatRecordReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetChatRecordAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetChatRecordAck) */ {
 public:
  inline GetChatRecordAck() : GetChatRecordAck(nullptr) {}
  ~GetChatRecordAck() override;
  explicit PROTOBUF_CONSTEXPR GetChatRecordAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetChatRecordAck(const GetChatRecordAck& from);
  GetChatRecordAck(GetChatRecordAck&& from) noexcept
    : GetChatRecordAck() {
    *this = ::std::move(from);
  }

  inline GetChatRecordAck& operator=(const GetChatRecordAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetChatRecordAck& operator=(GetChatRecordAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetChatRecordAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetChatRecordAck* internal_default_instance() {
    return reinterpret_cast<const GetChatRecordAck*>(
               &_GetChatRecordAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(GetChatRecordAck& a, GetChatRecordAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetChatRecordAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetChatRecordAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetChatRecordAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetChatRecordAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetChatRecordAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetChatRecordAck& from) {
    GetChatRecordAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetChatRecordAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetChatRecordAck";
  }
  protected:
  explicit GetChatRecordAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeptRecordFieldNumber = 3,
    kPublicChatRecordFieldNumber = 1,
    kPrivateChatRecordFieldNumber = 2,
  };
  // repeated .idlepb.ChatMessage sept_record = 3;
  int sept_record_size() const;
  private:
  int _internal_sept_record_size() const;
  public:
  void clear_sept_record();
  ::idlepb::ChatMessage* mutable_sept_record(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ChatMessage >*
      mutable_sept_record();
  private:
  const ::idlepb::ChatMessage& _internal_sept_record(int index) const;
  ::idlepb::ChatMessage* _internal_add_sept_record();
  public:
  const ::idlepb::ChatMessage& sept_record(int index) const;
  ::idlepb::ChatMessage* add_sept_record();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ChatMessage >&
      sept_record() const;

  // .idlepb.ChatData public_chat_record = 1;
  bool has_public_chat_record() const;
  private:
  bool _internal_has_public_chat_record() const;
  public:
  void clear_public_chat_record();
  const ::idlepb::ChatData& public_chat_record() const;
  PROTOBUF_NODISCARD ::idlepb::ChatData* release_public_chat_record();
  ::idlepb::ChatData* mutable_public_chat_record();
  void set_allocated_public_chat_record(::idlepb::ChatData* public_chat_record);
  private:
  const ::idlepb::ChatData& _internal_public_chat_record() const;
  ::idlepb::ChatData* _internal_mutable_public_chat_record();
  public:
  void unsafe_arena_set_allocated_public_chat_record(
      ::idlepb::ChatData* public_chat_record);
  ::idlepb::ChatData* unsafe_arena_release_public_chat_record();

  // .idlepb.RolePrivateChatRecord private_chat_record = 2;
  bool has_private_chat_record() const;
  private:
  bool _internal_has_private_chat_record() const;
  public:
  void clear_private_chat_record();
  const ::idlepb::RolePrivateChatRecord& private_chat_record() const;
  PROTOBUF_NODISCARD ::idlepb::RolePrivateChatRecord* release_private_chat_record();
  ::idlepb::RolePrivateChatRecord* mutable_private_chat_record();
  void set_allocated_private_chat_record(::idlepb::RolePrivateChatRecord* private_chat_record);
  private:
  const ::idlepb::RolePrivateChatRecord& _internal_private_chat_record() const;
  ::idlepb::RolePrivateChatRecord* _internal_mutable_private_chat_record();
  public:
  void unsafe_arena_set_allocated_private_chat_record(
      ::idlepb::RolePrivateChatRecord* private_chat_record);
  ::idlepb::RolePrivateChatRecord* unsafe_arena_release_private_chat_record();

  // @@protoc_insertion_point(class_scope:idlepb.GetChatRecordAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ChatMessage > sept_record_;
    ::idlepb::ChatData* public_chat_record_;
    ::idlepb::RolePrivateChatRecord* private_chat_record_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DeletePrivateChatRecordReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DeletePrivateChatRecordReq) */ {
 public:
  inline DeletePrivateChatRecordReq() : DeletePrivateChatRecordReq(nullptr) {}
  ~DeletePrivateChatRecordReq() override;
  explicit PROTOBUF_CONSTEXPR DeletePrivateChatRecordReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePrivateChatRecordReq(const DeletePrivateChatRecordReq& from);
  DeletePrivateChatRecordReq(DeletePrivateChatRecordReq&& from) noexcept
    : DeletePrivateChatRecordReq() {
    *this = ::std::move(from);
  }

  inline DeletePrivateChatRecordReq& operator=(const DeletePrivateChatRecordReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePrivateChatRecordReq& operator=(DeletePrivateChatRecordReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePrivateChatRecordReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePrivateChatRecordReq* internal_default_instance() {
    return reinterpret_cast<const DeletePrivateChatRecordReq*>(
               &_DeletePrivateChatRecordReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    129;

  friend void swap(DeletePrivateChatRecordReq& a, DeletePrivateChatRecordReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePrivateChatRecordReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePrivateChatRecordReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePrivateChatRecordReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeletePrivateChatRecordReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePrivateChatRecordReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeletePrivateChatRecordReq& from) {
    DeletePrivateChatRecordReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePrivateChatRecordReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DeletePrivateChatRecordReq";
  }
  protected:
  explicit DeletePrivateChatRecordReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
  };
  // uint64 role_id = 1;
  void clear_role_id();
  uint64_t role_id() const;
  void set_role_id(uint64_t value);
  private:
  uint64_t _internal_role_id() const;
  void _internal_set_role_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DeletePrivateChatRecordReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t role_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DeletePrivateChatRecordAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DeletePrivateChatRecordAck) */ {
 public:
  inline DeletePrivateChatRecordAck() : DeletePrivateChatRecordAck(nullptr) {}
  ~DeletePrivateChatRecordAck() override;
  explicit PROTOBUF_CONSTEXPR DeletePrivateChatRecordAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeletePrivateChatRecordAck(const DeletePrivateChatRecordAck& from);
  DeletePrivateChatRecordAck(DeletePrivateChatRecordAck&& from) noexcept
    : DeletePrivateChatRecordAck() {
    *this = ::std::move(from);
  }

  inline DeletePrivateChatRecordAck& operator=(const DeletePrivateChatRecordAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeletePrivateChatRecordAck& operator=(DeletePrivateChatRecordAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeletePrivateChatRecordAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeletePrivateChatRecordAck* internal_default_instance() {
    return reinterpret_cast<const DeletePrivateChatRecordAck*>(
               &_DeletePrivateChatRecordAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    130;

  friend void swap(DeletePrivateChatRecordAck& a, DeletePrivateChatRecordAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DeletePrivateChatRecordAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeletePrivateChatRecordAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeletePrivateChatRecordAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeletePrivateChatRecordAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeletePrivateChatRecordAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeletePrivateChatRecordAck& from) {
    DeletePrivateChatRecordAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePrivateChatRecordAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DeletePrivateChatRecordAck";
  }
  protected:
  explicit DeletePrivateChatRecordAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DeletePrivateChatRecordAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ClearChatUnreadNumReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ClearChatUnreadNumReq) */ {
 public:
  inline ClearChatUnreadNumReq() : ClearChatUnreadNumReq(nullptr) {}
  ~ClearChatUnreadNumReq() override;
  explicit PROTOBUF_CONSTEXPR ClearChatUnreadNumReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearChatUnreadNumReq(const ClearChatUnreadNumReq& from);
  ClearChatUnreadNumReq(ClearChatUnreadNumReq&& from) noexcept
    : ClearChatUnreadNumReq() {
    *this = ::std::move(from);
  }

  inline ClearChatUnreadNumReq& operator=(const ClearChatUnreadNumReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearChatUnreadNumReq& operator=(ClearChatUnreadNumReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearChatUnreadNumReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearChatUnreadNumReq* internal_default_instance() {
    return reinterpret_cast<const ClearChatUnreadNumReq*>(
               &_ClearChatUnreadNumReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(ClearChatUnreadNumReq& a, ClearChatUnreadNumReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearChatUnreadNumReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearChatUnreadNumReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearChatUnreadNumReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearChatUnreadNumReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearChatUnreadNumReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearChatUnreadNumReq& from) {
    ClearChatUnreadNumReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearChatUnreadNumReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ClearChatUnreadNumReq";
  }
  protected:
  explicit ClearChatUnreadNumReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
  };
  // uint64 role_id = 1;
  void clear_role_id();
  uint64_t role_id() const;
  void set_role_id(uint64_t value);
  private:
  uint64_t _internal_role_id() const;
  void _internal_set_role_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ClearChatUnreadNumReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t role_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ClearChatUnreadNumAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.ClearChatUnreadNumAck) */ {
 public:
  inline ClearChatUnreadNumAck() : ClearChatUnreadNumAck(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ClearChatUnreadNumAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearChatUnreadNumAck(const ClearChatUnreadNumAck& from);
  ClearChatUnreadNumAck(ClearChatUnreadNumAck&& from) noexcept
    : ClearChatUnreadNumAck() {
    *this = ::std::move(from);
  }

  inline ClearChatUnreadNumAck& operator=(const ClearChatUnreadNumAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearChatUnreadNumAck& operator=(ClearChatUnreadNumAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearChatUnreadNumAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearChatUnreadNumAck* internal_default_instance() {
    return reinterpret_cast<const ClearChatUnreadNumAck*>(
               &_ClearChatUnreadNumAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(ClearChatUnreadNumAck& a, ClearChatUnreadNumAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearChatUnreadNumAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearChatUnreadNumAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearChatUnreadNumAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearChatUnreadNumAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ClearChatUnreadNumAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ClearChatUnreadNumAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ClearChatUnreadNumAck";
  }
  protected:
  explicit ClearChatUnreadNumAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.ClearChatUnreadNumAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleInfoCacheReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleInfoCacheReq) */ {
 public:
  inline GetRoleInfoCacheReq() : GetRoleInfoCacheReq(nullptr) {}
  ~GetRoleInfoCacheReq() override;
  explicit PROTOBUF_CONSTEXPR GetRoleInfoCacheReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleInfoCacheReq(const GetRoleInfoCacheReq& from);
  GetRoleInfoCacheReq(GetRoleInfoCacheReq&& from) noexcept
    : GetRoleInfoCacheReq() {
    *this = ::std::move(from);
  }

  inline GetRoleInfoCacheReq& operator=(const GetRoleInfoCacheReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleInfoCacheReq& operator=(GetRoleInfoCacheReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleInfoCacheReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleInfoCacheReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleInfoCacheReq*>(
               &_GetRoleInfoCacheReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(GetRoleInfoCacheReq& a, GetRoleInfoCacheReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleInfoCacheReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleInfoCacheReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleInfoCacheReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleInfoCacheReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleInfoCacheReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleInfoCacheReq& from) {
    GetRoleInfoCacheReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleInfoCacheReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleInfoCacheReq";
  }
  protected:
  explicit GetRoleInfoCacheReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdsFieldNumber = 1,
  };
  // repeated uint64 role_ids = 1;
  int role_ids_size() const;
  private:
  int _internal_role_ids_size() const;
  public:
  void clear_role_ids();
  private:
  uint64_t _internal_role_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_role_ids() const;
  void _internal_add_role_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_role_ids();
  public:
  uint64_t role_ids(int index) const;
  void set_role_ids(int index, uint64_t value);
  void add_role_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      role_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_role_ids();

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleInfoCacheReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > role_ids_;
    mutable std::atomic<int> _role_ids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleInfoCacheAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleInfoCacheAck) */ {
 public:
  inline GetRoleInfoCacheAck() : GetRoleInfoCacheAck(nullptr) {}
  ~GetRoleInfoCacheAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleInfoCacheAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleInfoCacheAck(const GetRoleInfoCacheAck& from);
  GetRoleInfoCacheAck(GetRoleInfoCacheAck&& from) noexcept
    : GetRoleInfoCacheAck() {
    *this = ::std::move(from);
  }

  inline GetRoleInfoCacheAck& operator=(const GetRoleInfoCacheAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleInfoCacheAck& operator=(GetRoleInfoCacheAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleInfoCacheAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleInfoCacheAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleInfoCacheAck*>(
               &_GetRoleInfoCacheAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(GetRoleInfoCacheAck& a, GetRoleInfoCacheAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleInfoCacheAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleInfoCacheAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleInfoCacheAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleInfoCacheAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleInfoCacheAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleInfoCacheAck& from) {
    GetRoleInfoCacheAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleInfoCacheAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleInfoCacheAck";
  }
  protected:
  explicit GetRoleInfoCacheAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleInfosFieldNumber = 1,
  };
  // repeated .idlepb.SimpleRoleInfo role_infos = 1;
  int role_infos_size() const;
  private:
  int _internal_role_infos_size() const;
  public:
  void clear_role_infos();
  ::idlepb::SimpleRoleInfo* mutable_role_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo >*
      mutable_role_infos();
  private:
  const ::idlepb::SimpleRoleInfo& _internal_role_infos(int index) const;
  ::idlepb::SimpleRoleInfo* _internal_add_role_infos();
  public:
  const ::idlepb::SimpleRoleInfo& role_infos(int index) const;
  ::idlepb::SimpleRoleInfo* add_role_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo >&
      role_infos() const;

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleInfoCacheAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo > role_infos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ForgeRefineStartReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ForgeRefineStartReq) */ {
 public:
  inline ForgeRefineStartReq() : ForgeRefineStartReq(nullptr) {}
  ~ForgeRefineStartReq() override;
  explicit PROTOBUF_CONSTEXPR ForgeRefineStartReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForgeRefineStartReq(const ForgeRefineStartReq& from);
  ForgeRefineStartReq(ForgeRefineStartReq&& from) noexcept
    : ForgeRefineStartReq() {
    *this = ::std::move(from);
  }

  inline ForgeRefineStartReq& operator=(const ForgeRefineStartReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForgeRefineStartReq& operator=(ForgeRefineStartReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForgeRefineStartReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForgeRefineStartReq* internal_default_instance() {
    return reinterpret_cast<const ForgeRefineStartReq*>(
               &_ForgeRefineStartReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(ForgeRefineStartReq& a, ForgeRefineStartReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ForgeRefineStartReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForgeRefineStartReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForgeRefineStartReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForgeRefineStartReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForgeRefineStartReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForgeRefineStartReq& from) {
    ForgeRefineStartReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForgeRefineStartReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ForgeRefineStartReq";
  }
  protected:
  explicit ForgeRefineStartReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecipeIdFieldNumber = 1,
    kMaterialIdFieldNumber = 2,
    kExtMaterialIdFieldNumber = 3,
    kTargetNumFieldNumber = 4,
    kAutoSellPoorFieldNumber = 5,
    kAutoSellMiddleFieldNumber = 6,
  };
  // int32 recipe_id = 1;
  void clear_recipe_id();
  int32_t recipe_id() const;
  void set_recipe_id(int32_t value);
  private:
  int32_t _internal_recipe_id() const;
  void _internal_set_recipe_id(int32_t value);
  public:

  // int32 material_id = 2;
  void clear_material_id();
  int32_t material_id() const;
  void set_material_id(int32_t value);
  private:
  int32_t _internal_material_id() const;
  void _internal_set_material_id(int32_t value);
  public:

  // int32 ext_material_id = 3;
  void clear_ext_material_id();
  int32_t ext_material_id() const;
  void set_ext_material_id(int32_t value);
  private:
  int32_t _internal_ext_material_id() const;
  void _internal_set_ext_material_id(int32_t value);
  public:

  // int32 target_num = 4;
  void clear_target_num();
  int32_t target_num() const;
  void set_target_num(int32_t value);
  private:
  int32_t _internal_target_num() const;
  void _internal_set_target_num(int32_t value);
  public:

  // bool auto_sell_poor = 5;
  void clear_auto_sell_poor();
  bool auto_sell_poor() const;
  void set_auto_sell_poor(bool value);
  private:
  bool _internal_auto_sell_poor() const;
  void _internal_set_auto_sell_poor(bool value);
  public:

  // bool auto_sell_middle = 6;
  void clear_auto_sell_middle();
  bool auto_sell_middle() const;
  void set_auto_sell_middle(bool value);
  private:
  bool _internal_auto_sell_middle() const;
  void _internal_set_auto_sell_middle(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ForgeRefineStartReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t recipe_id_;
    int32_t material_id_;
    int32_t ext_material_id_;
    int32_t target_num_;
    bool auto_sell_poor_;
    bool auto_sell_middle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ForgeRefineStartAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ForgeRefineStartAck) */ {
 public:
  inline ForgeRefineStartAck() : ForgeRefineStartAck(nullptr) {}
  ~ForgeRefineStartAck() override;
  explicit PROTOBUF_CONSTEXPR ForgeRefineStartAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForgeRefineStartAck(const ForgeRefineStartAck& from);
  ForgeRefineStartAck(ForgeRefineStartAck&& from) noexcept
    : ForgeRefineStartAck() {
    *this = ::std::move(from);
  }

  inline ForgeRefineStartAck& operator=(const ForgeRefineStartAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForgeRefineStartAck& operator=(ForgeRefineStartAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForgeRefineStartAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForgeRefineStartAck* internal_default_instance() {
    return reinterpret_cast<const ForgeRefineStartAck*>(
               &_ForgeRefineStartAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  friend void swap(ForgeRefineStartAck& a, ForgeRefineStartAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ForgeRefineStartAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForgeRefineStartAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForgeRefineStartAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForgeRefineStartAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForgeRefineStartAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForgeRefineStartAck& from) {
    ForgeRefineStartAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForgeRefineStartAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ForgeRefineStartAck";
  }
  protected:
  explicit ForgeRefineStartAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ForgeRefineStartAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ForgeRefineCancelReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.ForgeRefineCancelReq) */ {
 public:
  inline ForgeRefineCancelReq() : ForgeRefineCancelReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ForgeRefineCancelReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForgeRefineCancelReq(const ForgeRefineCancelReq& from);
  ForgeRefineCancelReq(ForgeRefineCancelReq&& from) noexcept
    : ForgeRefineCancelReq() {
    *this = ::std::move(from);
  }

  inline ForgeRefineCancelReq& operator=(const ForgeRefineCancelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForgeRefineCancelReq& operator=(ForgeRefineCancelReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForgeRefineCancelReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForgeRefineCancelReq* internal_default_instance() {
    return reinterpret_cast<const ForgeRefineCancelReq*>(
               &_ForgeRefineCancelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  friend void swap(ForgeRefineCancelReq& a, ForgeRefineCancelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ForgeRefineCancelReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForgeRefineCancelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForgeRefineCancelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForgeRefineCancelReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ForgeRefineCancelReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ForgeRefineCancelReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ForgeRefineCancelReq";
  }
  protected:
  explicit ForgeRefineCancelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.ForgeRefineCancelReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ForgeRefineCancelAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ForgeRefineCancelAck) */ {
 public:
  inline ForgeRefineCancelAck() : ForgeRefineCancelAck(nullptr) {}
  ~ForgeRefineCancelAck() override;
  explicit PROTOBUF_CONSTEXPR ForgeRefineCancelAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForgeRefineCancelAck(const ForgeRefineCancelAck& from);
  ForgeRefineCancelAck(ForgeRefineCancelAck&& from) noexcept
    : ForgeRefineCancelAck() {
    *this = ::std::move(from);
  }

  inline ForgeRefineCancelAck& operator=(const ForgeRefineCancelAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForgeRefineCancelAck& operator=(ForgeRefineCancelAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForgeRefineCancelAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForgeRefineCancelAck* internal_default_instance() {
    return reinterpret_cast<const ForgeRefineCancelAck*>(
               &_ForgeRefineCancelAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  friend void swap(ForgeRefineCancelAck& a, ForgeRefineCancelAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ForgeRefineCancelAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForgeRefineCancelAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForgeRefineCancelAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForgeRefineCancelAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForgeRefineCancelAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForgeRefineCancelAck& from) {
    ForgeRefineCancelAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForgeRefineCancelAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ForgeRefineCancelAck";
  }
  protected:
  explicit ForgeRefineCancelAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ForgeRefineCancelAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ForgeRefineExtractReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.ForgeRefineExtractReq) */ {
 public:
  inline ForgeRefineExtractReq() : ForgeRefineExtractReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ForgeRefineExtractReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForgeRefineExtractReq(const ForgeRefineExtractReq& from);
  ForgeRefineExtractReq(ForgeRefineExtractReq&& from) noexcept
    : ForgeRefineExtractReq() {
    *this = ::std::move(from);
  }

  inline ForgeRefineExtractReq& operator=(const ForgeRefineExtractReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForgeRefineExtractReq& operator=(ForgeRefineExtractReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForgeRefineExtractReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForgeRefineExtractReq* internal_default_instance() {
    return reinterpret_cast<const ForgeRefineExtractReq*>(
               &_ForgeRefineExtractReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    139;

  friend void swap(ForgeRefineExtractReq& a, ForgeRefineExtractReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ForgeRefineExtractReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForgeRefineExtractReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForgeRefineExtractReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForgeRefineExtractReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ForgeRefineExtractReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ForgeRefineExtractReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ForgeRefineExtractReq";
  }
  protected:
  explicit ForgeRefineExtractReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.ForgeRefineExtractReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ForgeRefineExtractAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ForgeRefineExtractAck) */ {
 public:
  inline ForgeRefineExtractAck() : ForgeRefineExtractAck(nullptr) {}
  ~ForgeRefineExtractAck() override;
  explicit PROTOBUF_CONSTEXPR ForgeRefineExtractAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForgeRefineExtractAck(const ForgeRefineExtractAck& from);
  ForgeRefineExtractAck(ForgeRefineExtractAck&& from) noexcept
    : ForgeRefineExtractAck() {
    *this = ::std::move(from);
  }

  inline ForgeRefineExtractAck& operator=(const ForgeRefineExtractAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForgeRefineExtractAck& operator=(ForgeRefineExtractAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForgeRefineExtractAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForgeRefineExtractAck* internal_default_instance() {
    return reinterpret_cast<const ForgeRefineExtractAck*>(
               &_ForgeRefineExtractAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    140;

  friend void swap(ForgeRefineExtractAck& a, ForgeRefineExtractAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ForgeRefineExtractAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForgeRefineExtractAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForgeRefineExtractAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForgeRefineExtractAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForgeRefineExtractAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForgeRefineExtractAck& from) {
    ForgeRefineExtractAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForgeRefineExtractAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ForgeRefineExtractAck";
  }
  protected:
  explicit ForgeRefineExtractAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // repeated int64 items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  private:
  int64_t _internal_items(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_items() const;
  void _internal_add_items(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_items();
  public:
  int64_t items(int index) const;
  void set_items(int index, int64_t value);
  void add_items(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      items() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_items();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ForgeRefineExtractAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > items_;
    mutable std::atomic<int> _items_cached_byte_size_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetForgeLostEquipmentDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetForgeLostEquipmentDataReq) */ {
 public:
  inline GetForgeLostEquipmentDataReq() : GetForgeLostEquipmentDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetForgeLostEquipmentDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetForgeLostEquipmentDataReq(const GetForgeLostEquipmentDataReq& from);
  GetForgeLostEquipmentDataReq(GetForgeLostEquipmentDataReq&& from) noexcept
    : GetForgeLostEquipmentDataReq() {
    *this = ::std::move(from);
  }

  inline GetForgeLostEquipmentDataReq& operator=(const GetForgeLostEquipmentDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetForgeLostEquipmentDataReq& operator=(GetForgeLostEquipmentDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetForgeLostEquipmentDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetForgeLostEquipmentDataReq* internal_default_instance() {
    return reinterpret_cast<const GetForgeLostEquipmentDataReq*>(
               &_GetForgeLostEquipmentDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    141;

  friend void swap(GetForgeLostEquipmentDataReq& a, GetForgeLostEquipmentDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetForgeLostEquipmentDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetForgeLostEquipmentDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetForgeLostEquipmentDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetForgeLostEquipmentDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetForgeLostEquipmentDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetForgeLostEquipmentDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetForgeLostEquipmentDataReq";
  }
  protected:
  explicit GetForgeLostEquipmentDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetForgeLostEquipmentDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetForgeLostEquipmentDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetForgeLostEquipmentDataAck) */ {
 public:
  inline GetForgeLostEquipmentDataAck() : GetForgeLostEquipmentDataAck(nullptr) {}
  ~GetForgeLostEquipmentDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetForgeLostEquipmentDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetForgeLostEquipmentDataAck(const GetForgeLostEquipmentDataAck& from);
  GetForgeLostEquipmentDataAck(GetForgeLostEquipmentDataAck&& from) noexcept
    : GetForgeLostEquipmentDataAck() {
    *this = ::std::move(from);
  }

  inline GetForgeLostEquipmentDataAck& operator=(const GetForgeLostEquipmentDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetForgeLostEquipmentDataAck& operator=(GetForgeLostEquipmentDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetForgeLostEquipmentDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetForgeLostEquipmentDataAck* internal_default_instance() {
    return reinterpret_cast<const GetForgeLostEquipmentDataAck*>(
               &_GetForgeLostEquipmentDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    142;

  friend void swap(GetForgeLostEquipmentDataAck& a, GetForgeLostEquipmentDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetForgeLostEquipmentDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetForgeLostEquipmentDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetForgeLostEquipmentDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetForgeLostEquipmentDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetForgeLostEquipmentDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetForgeLostEquipmentDataAck& from) {
    GetForgeLostEquipmentDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetForgeLostEquipmentDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetForgeLostEquipmentDataAck";
  }
  protected:
  explicit GetForgeLostEquipmentDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .idlepb.LostEquipmentData data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::idlepb::LostEquipmentData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LostEquipmentData >*
      mutable_data();
  private:
  const ::idlepb::LostEquipmentData& _internal_data(int index) const;
  ::idlepb::LostEquipmentData* _internal_add_data();
  public:
  const ::idlepb::LostEquipmentData& data(int index) const;
  ::idlepb::LostEquipmentData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LostEquipmentData >&
      data() const;

  // @@protoc_insertion_point(class_scope:idlepb.GetForgeLostEquipmentDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LostEquipmentData > data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ForgeDestroyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ForgeDestroyReq) */ {
 public:
  inline ForgeDestroyReq() : ForgeDestroyReq(nullptr) {}
  ~ForgeDestroyReq() override;
  explicit PROTOBUF_CONSTEXPR ForgeDestroyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForgeDestroyReq(const ForgeDestroyReq& from);
  ForgeDestroyReq(ForgeDestroyReq&& from) noexcept
    : ForgeDestroyReq() {
    *this = ::std::move(from);
  }

  inline ForgeDestroyReq& operator=(const ForgeDestroyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForgeDestroyReq& operator=(ForgeDestroyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForgeDestroyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForgeDestroyReq* internal_default_instance() {
    return reinterpret_cast<const ForgeDestroyReq*>(
               &_ForgeDestroyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    143;

  friend void swap(ForgeDestroyReq& a, ForgeDestroyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ForgeDestroyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForgeDestroyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForgeDestroyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForgeDestroyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForgeDestroyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForgeDestroyReq& from) {
    ForgeDestroyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForgeDestroyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ForgeDestroyReq";
  }
  protected:
  explicit ForgeDestroyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // int64 uid = 1;
  void clear_uid();
  int64_t uid() const;
  void set_uid(int64_t value);
  private:
  int64_t _internal_uid() const;
  void _internal_set_uid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ForgeDestroyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ForgeDestroyAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ForgeDestroyAck) */ {
 public:
  inline ForgeDestroyAck() : ForgeDestroyAck(nullptr) {}
  ~ForgeDestroyAck() override;
  explicit PROTOBUF_CONSTEXPR ForgeDestroyAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForgeDestroyAck(const ForgeDestroyAck& from);
  ForgeDestroyAck(ForgeDestroyAck&& from) noexcept
    : ForgeDestroyAck() {
    *this = ::std::move(from);
  }

  inline ForgeDestroyAck& operator=(const ForgeDestroyAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForgeDestroyAck& operator=(ForgeDestroyAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForgeDestroyAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForgeDestroyAck* internal_default_instance() {
    return reinterpret_cast<const ForgeDestroyAck*>(
               &_ForgeDestroyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    144;

  friend void swap(ForgeDestroyAck& a, ForgeDestroyAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ForgeDestroyAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForgeDestroyAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForgeDestroyAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForgeDestroyAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForgeDestroyAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForgeDestroyAck& from) {
    ForgeDestroyAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForgeDestroyAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ForgeDestroyAck";
  }
  protected:
  explicit ForgeDestroyAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ForgeDestroyAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ForgeFindBackReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ForgeFindBackReq) */ {
 public:
  inline ForgeFindBackReq() : ForgeFindBackReq(nullptr) {}
  ~ForgeFindBackReq() override;
  explicit PROTOBUF_CONSTEXPR ForgeFindBackReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForgeFindBackReq(const ForgeFindBackReq& from);
  ForgeFindBackReq(ForgeFindBackReq&& from) noexcept
    : ForgeFindBackReq() {
    *this = ::std::move(from);
  }

  inline ForgeFindBackReq& operator=(const ForgeFindBackReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForgeFindBackReq& operator=(ForgeFindBackReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForgeFindBackReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForgeFindBackReq* internal_default_instance() {
    return reinterpret_cast<const ForgeFindBackReq*>(
               &_ForgeFindBackReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    145;

  friend void swap(ForgeFindBackReq& a, ForgeFindBackReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ForgeFindBackReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForgeFindBackReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForgeFindBackReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForgeFindBackReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForgeFindBackReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForgeFindBackReq& from) {
    ForgeFindBackReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForgeFindBackReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ForgeFindBackReq";
  }
  protected:
  explicit ForgeFindBackReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ForgeFindBackReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ForgeFindBackAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ForgeFindBackAck) */ {
 public:
  inline ForgeFindBackAck() : ForgeFindBackAck(nullptr) {}
  ~ForgeFindBackAck() override;
  explicit PROTOBUF_CONSTEXPR ForgeFindBackAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForgeFindBackAck(const ForgeFindBackAck& from);
  ForgeFindBackAck(ForgeFindBackAck&& from) noexcept
    : ForgeFindBackAck() {
    *this = ::std::move(from);
  }

  inline ForgeFindBackAck& operator=(const ForgeFindBackAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForgeFindBackAck& operator=(ForgeFindBackAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForgeFindBackAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForgeFindBackAck* internal_default_instance() {
    return reinterpret_cast<const ForgeFindBackAck*>(
               &_ForgeFindBackAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    146;

  friend void swap(ForgeFindBackAck& a, ForgeFindBackAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ForgeFindBackAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForgeFindBackAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForgeFindBackAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForgeFindBackAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForgeFindBackAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForgeFindBackAck& from) {
    ForgeFindBackAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForgeFindBackAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ForgeFindBackAck";
  }
  protected:
  explicit ForgeFindBackAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ForgeFindBackAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestPillElixirDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.RequestPillElixirDataReq) */ {
 public:
  inline RequestPillElixirDataReq() : RequestPillElixirDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RequestPillElixirDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestPillElixirDataReq(const RequestPillElixirDataReq& from);
  RequestPillElixirDataReq(RequestPillElixirDataReq&& from) noexcept
    : RequestPillElixirDataReq() {
    *this = ::std::move(from);
  }

  inline RequestPillElixirDataReq& operator=(const RequestPillElixirDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestPillElixirDataReq& operator=(RequestPillElixirDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestPillElixirDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestPillElixirDataReq* internal_default_instance() {
    return reinterpret_cast<const RequestPillElixirDataReq*>(
               &_RequestPillElixirDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    147;

  friend void swap(RequestPillElixirDataReq& a, RequestPillElixirDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestPillElixirDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestPillElixirDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestPillElixirDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestPillElixirDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RequestPillElixirDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RequestPillElixirDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestPillElixirDataReq";
  }
  protected:
  explicit RequestPillElixirDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.RequestPillElixirDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestPillElixirDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RequestPillElixirDataAck) */ {
 public:
  inline RequestPillElixirDataAck() : RequestPillElixirDataAck(nullptr) {}
  ~RequestPillElixirDataAck() override;
  explicit PROTOBUF_CONSTEXPR RequestPillElixirDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestPillElixirDataAck(const RequestPillElixirDataAck& from);
  RequestPillElixirDataAck(RequestPillElixirDataAck&& from) noexcept
    : RequestPillElixirDataAck() {
    *this = ::std::move(from);
  }

  inline RequestPillElixirDataAck& operator=(const RequestPillElixirDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestPillElixirDataAck& operator=(RequestPillElixirDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestPillElixirDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestPillElixirDataAck* internal_default_instance() {
    return reinterpret_cast<const RequestPillElixirDataAck*>(
               &_RequestPillElixirDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    148;

  friend void swap(RequestPillElixirDataAck& a, RequestPillElixirDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestPillElixirDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestPillElixirDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestPillElixirDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestPillElixirDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestPillElixirDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestPillElixirDataAck& from) {
    RequestPillElixirDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestPillElixirDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestPillElixirDataAck";
  }
  protected:
  explicit RequestPillElixirDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RolePillElixirData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RolePillElixirData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RolePillElixirData* release_data();
  ::idlepb::RolePillElixirData* mutable_data();
  void set_allocated_data(::idlepb::RolePillElixirData* data);
  private:
  const ::idlepb::RolePillElixirData& _internal_data() const;
  ::idlepb::RolePillElixirData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RolePillElixirData* data);
  ::idlepb::RolePillElixirData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.RequestPillElixirDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RolePillElixirData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetOnePillElixirDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetOnePillElixirDataReq) */ {
 public:
  inline GetOnePillElixirDataReq() : GetOnePillElixirDataReq(nullptr) {}
  ~GetOnePillElixirDataReq() override;
  explicit PROTOBUF_CONSTEXPR GetOnePillElixirDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOnePillElixirDataReq(const GetOnePillElixirDataReq& from);
  GetOnePillElixirDataReq(GetOnePillElixirDataReq&& from) noexcept
    : GetOnePillElixirDataReq() {
    *this = ::std::move(from);
  }

  inline GetOnePillElixirDataReq& operator=(const GetOnePillElixirDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOnePillElixirDataReq& operator=(GetOnePillElixirDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOnePillElixirDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOnePillElixirDataReq* internal_default_instance() {
    return reinterpret_cast<const GetOnePillElixirDataReq*>(
               &_GetOnePillElixirDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    149;

  friend void swap(GetOnePillElixirDataReq& a, GetOnePillElixirDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOnePillElixirDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOnePillElixirDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOnePillElixirDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOnePillElixirDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOnePillElixirDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetOnePillElixirDataReq& from) {
    GetOnePillElixirDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOnePillElixirDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetOnePillElixirDataReq";
  }
  protected:
  explicit GetOnePillElixirDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemCfgIdFieldNumber = 1,
  };
  // int32 item_cfg_id = 1;
  void clear_item_cfg_id();
  int32_t item_cfg_id() const;
  void set_item_cfg_id(int32_t value);
  private:
  int32_t _internal_item_cfg_id() const;
  void _internal_set_item_cfg_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetOnePillElixirDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t item_cfg_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetOnePillElixirDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetOnePillElixirDataAck) */ {
 public:
  inline GetOnePillElixirDataAck() : GetOnePillElixirDataAck(nullptr) {}
  ~GetOnePillElixirDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetOnePillElixirDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOnePillElixirDataAck(const GetOnePillElixirDataAck& from);
  GetOnePillElixirDataAck(GetOnePillElixirDataAck&& from) noexcept
    : GetOnePillElixirDataAck() {
    *this = ::std::move(from);
  }

  inline GetOnePillElixirDataAck& operator=(const GetOnePillElixirDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOnePillElixirDataAck& operator=(GetOnePillElixirDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOnePillElixirDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOnePillElixirDataAck* internal_default_instance() {
    return reinterpret_cast<const GetOnePillElixirDataAck*>(
               &_GetOnePillElixirDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    150;

  friend void swap(GetOnePillElixirDataAck& a, GetOnePillElixirDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOnePillElixirDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOnePillElixirDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOnePillElixirDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOnePillElixirDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOnePillElixirDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetOnePillElixirDataAck& from) {
    GetOnePillElixirDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOnePillElixirDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetOnePillElixirDataAck";
  }
  protected:
  explicit GetOnePillElixirDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.PillElixirData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::PillElixirData& data() const;
  PROTOBUF_NODISCARD ::idlepb::PillElixirData* release_data();
  ::idlepb::PillElixirData* mutable_data();
  void set_allocated_data(::idlepb::PillElixirData* data);
  private:
  const ::idlepb::PillElixirData& _internal_data() const;
  ::idlepb::PillElixirData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::PillElixirData* data);
  ::idlepb::PillElixirData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetOnePillElixirDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::PillElixirData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestModifyPillElixirFilterReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RequestModifyPillElixirFilterReq) */ {
 public:
  inline RequestModifyPillElixirFilterReq() : RequestModifyPillElixirFilterReq(nullptr) {}
  ~RequestModifyPillElixirFilterReq() override;
  explicit PROTOBUF_CONSTEXPR RequestModifyPillElixirFilterReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestModifyPillElixirFilterReq(const RequestModifyPillElixirFilterReq& from);
  RequestModifyPillElixirFilterReq(RequestModifyPillElixirFilterReq&& from) noexcept
    : RequestModifyPillElixirFilterReq() {
    *this = ::std::move(from);
  }

  inline RequestModifyPillElixirFilterReq& operator=(const RequestModifyPillElixirFilterReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestModifyPillElixirFilterReq& operator=(RequestModifyPillElixirFilterReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestModifyPillElixirFilterReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestModifyPillElixirFilterReq* internal_default_instance() {
    return reinterpret_cast<const RequestModifyPillElixirFilterReq*>(
               &_RequestModifyPillElixirFilterReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    151;

  friend void swap(RequestModifyPillElixirFilterReq& a, RequestModifyPillElixirFilterReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestModifyPillElixirFilterReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestModifyPillElixirFilterReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestModifyPillElixirFilterReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestModifyPillElixirFilterReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestModifyPillElixirFilterReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestModifyPillElixirFilterReq& from) {
    RequestModifyPillElixirFilterReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestModifyPillElixirFilterReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestModifyPillElixirFilterReq";
  }
  protected:
  explicit RequestModifyPillElixirFilterReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLimitDoubleFieldNumber = 1,
    kLimitExpFieldNumber = 2,
    kLimitPropertyFieldNumber = 3,
  };
  // int32 limit_double = 1;
  void clear_limit_double();
  int32_t limit_double() const;
  void set_limit_double(int32_t value);
  private:
  int32_t _internal_limit_double() const;
  void _internal_set_limit_double(int32_t value);
  public:

  // int32 limit_exp = 2;
  void clear_limit_exp();
  int32_t limit_exp() const;
  void set_limit_exp(int32_t value);
  private:
  int32_t _internal_limit_exp() const;
  void _internal_set_limit_exp(int32_t value);
  public:

  // int32 limit_property = 3;
  void clear_limit_property();
  int32_t limit_property() const;
  void set_limit_property(int32_t value);
  private:
  int32_t _internal_limit_property() const;
  void _internal_set_limit_property(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RequestModifyPillElixirFilterReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t limit_double_;
    int32_t limit_exp_;
    int32_t limit_property_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestModifyPillElixirFilterAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RequestModifyPillElixirFilterAck) */ {
 public:
  inline RequestModifyPillElixirFilterAck() : RequestModifyPillElixirFilterAck(nullptr) {}
  ~RequestModifyPillElixirFilterAck() override;
  explicit PROTOBUF_CONSTEXPR RequestModifyPillElixirFilterAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestModifyPillElixirFilterAck(const RequestModifyPillElixirFilterAck& from);
  RequestModifyPillElixirFilterAck(RequestModifyPillElixirFilterAck&& from) noexcept
    : RequestModifyPillElixirFilterAck() {
    *this = ::std::move(from);
  }

  inline RequestModifyPillElixirFilterAck& operator=(const RequestModifyPillElixirFilterAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestModifyPillElixirFilterAck& operator=(RequestModifyPillElixirFilterAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestModifyPillElixirFilterAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestModifyPillElixirFilterAck* internal_default_instance() {
    return reinterpret_cast<const RequestModifyPillElixirFilterAck*>(
               &_RequestModifyPillElixirFilterAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    152;

  friend void swap(RequestModifyPillElixirFilterAck& a, RequestModifyPillElixirFilterAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestModifyPillElixirFilterAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestModifyPillElixirFilterAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestModifyPillElixirFilterAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestModifyPillElixirFilterAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestModifyPillElixirFilterAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestModifyPillElixirFilterAck& from) {
    RequestModifyPillElixirFilterAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestModifyPillElixirFilterAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestModifyPillElixirFilterAck";
  }
  protected:
  explicit RequestModifyPillElixirFilterAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RequestModifyPillElixirFilterAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UsePillElixirReport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UsePillElixirReport) */ {
 public:
  inline UsePillElixirReport() : UsePillElixirReport(nullptr) {}
  ~UsePillElixirReport() override;
  explicit PROTOBUF_CONSTEXPR UsePillElixirReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsePillElixirReport(const UsePillElixirReport& from);
  UsePillElixirReport(UsePillElixirReport&& from) noexcept
    : UsePillElixirReport() {
    *this = ::std::move(from);
  }

  inline UsePillElixirReport& operator=(const UsePillElixirReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsePillElixirReport& operator=(UsePillElixirReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsePillElixirReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsePillElixirReport* internal_default_instance() {
    return reinterpret_cast<const UsePillElixirReport*>(
               &_UsePillElixirReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    153;

  friend void swap(UsePillElixirReport& a, UsePillElixirReport& b) {
    a.Swap(&b);
  }
  inline void Swap(UsePillElixirReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsePillElixirReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsePillElixirReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsePillElixirReport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsePillElixirReport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsePillElixirReport& from) {
    UsePillElixirReport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsePillElixirReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UsePillElixirReport";
  }
  protected:
  explicit UsePillElixirReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kNumFieldNumber = 2,
    kPropertyNumFieldNumber = 3,
  };
  // int32 item_id = 1;
  void clear_item_id();
  int32_t item_id() const;
  void set_item_id(int32_t value);
  private:
  int32_t _internal_item_id() const;
  void _internal_set_item_id(int32_t value);
  public:

  // int32 num = 2;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // float property_num = 3;
  void clear_property_num();
  float property_num() const;
  void set_property_num(float value);
  private:
  float _internal_property_num() const;
  void _internal_set_property_num(float value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UsePillElixirReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t item_id_;
    int32_t num_;
    float property_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UsePillElixirReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UsePillElixirReq) */ {
 public:
  inline UsePillElixirReq() : UsePillElixirReq(nullptr) {}
  ~UsePillElixirReq() override;
  explicit PROTOBUF_CONSTEXPR UsePillElixirReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsePillElixirReq(const UsePillElixirReq& from);
  UsePillElixirReq(UsePillElixirReq&& from) noexcept
    : UsePillElixirReq() {
    *this = ::std::move(from);
  }

  inline UsePillElixirReq& operator=(const UsePillElixirReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsePillElixirReq& operator=(UsePillElixirReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsePillElixirReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsePillElixirReq* internal_default_instance() {
    return reinterpret_cast<const UsePillElixirReq*>(
               &_UsePillElixirReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    154;

  friend void swap(UsePillElixirReq& a, UsePillElixirReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UsePillElixirReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsePillElixirReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsePillElixirReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsePillElixirReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsePillElixirReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsePillElixirReq& from) {
    UsePillElixirReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsePillElixirReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UsePillElixirReq";
  }
  protected:
  explicit UsePillElixirReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // int32 item_id = 1;
  void clear_item_id();
  int32_t item_id() const;
  void set_item_id(int32_t value);
  private:
  int32_t _internal_item_id() const;
  void _internal_set_item_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UsePillElixirReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t item_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UsePillElixirAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UsePillElixirAck) */ {
 public:
  inline UsePillElixirAck() : UsePillElixirAck(nullptr) {}
  ~UsePillElixirAck() override;
  explicit PROTOBUF_CONSTEXPR UsePillElixirAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsePillElixirAck(const UsePillElixirAck& from);
  UsePillElixirAck(UsePillElixirAck&& from) noexcept
    : UsePillElixirAck() {
    *this = ::std::move(from);
  }

  inline UsePillElixirAck& operator=(const UsePillElixirAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsePillElixirAck& operator=(UsePillElixirAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsePillElixirAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsePillElixirAck* internal_default_instance() {
    return reinterpret_cast<const UsePillElixirAck*>(
               &_UsePillElixirAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    155;

  friend void swap(UsePillElixirAck& a, UsePillElixirAck& b) {
    a.Swap(&b);
  }
  inline void Swap(UsePillElixirAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsePillElixirAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsePillElixirAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsePillElixirAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsePillElixirAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsePillElixirAck& from) {
    UsePillElixirAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsePillElixirAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UsePillElixirAck";
  }
  protected:
  explicit UsePillElixirAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UsePillElixirAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OneClickUsePillElixirReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.OneClickUsePillElixirReq) */ {
 public:
  inline OneClickUsePillElixirReq() : OneClickUsePillElixirReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OneClickUsePillElixirReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneClickUsePillElixirReq(const OneClickUsePillElixirReq& from);
  OneClickUsePillElixirReq(OneClickUsePillElixirReq&& from) noexcept
    : OneClickUsePillElixirReq() {
    *this = ::std::move(from);
  }

  inline OneClickUsePillElixirReq& operator=(const OneClickUsePillElixirReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneClickUsePillElixirReq& operator=(OneClickUsePillElixirReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneClickUsePillElixirReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneClickUsePillElixirReq* internal_default_instance() {
    return reinterpret_cast<const OneClickUsePillElixirReq*>(
               &_OneClickUsePillElixirReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    156;

  friend void swap(OneClickUsePillElixirReq& a, OneClickUsePillElixirReq& b) {
    a.Swap(&b);
  }
  inline void Swap(OneClickUsePillElixirReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneClickUsePillElixirReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneClickUsePillElixirReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneClickUsePillElixirReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OneClickUsePillElixirReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OneClickUsePillElixirReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OneClickUsePillElixirReq";
  }
  protected:
  explicit OneClickUsePillElixirReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.OneClickUsePillElixirReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OneClickUsePillElixirAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.OneClickUsePillElixirAck) */ {
 public:
  inline OneClickUsePillElixirAck() : OneClickUsePillElixirAck(nullptr) {}
  ~OneClickUsePillElixirAck() override;
  explicit PROTOBUF_CONSTEXPR OneClickUsePillElixirAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneClickUsePillElixirAck(const OneClickUsePillElixirAck& from);
  OneClickUsePillElixirAck(OneClickUsePillElixirAck&& from) noexcept
    : OneClickUsePillElixirAck() {
    *this = ::std::move(from);
  }

  inline OneClickUsePillElixirAck& operator=(const OneClickUsePillElixirAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneClickUsePillElixirAck& operator=(OneClickUsePillElixirAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneClickUsePillElixirAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneClickUsePillElixirAck* internal_default_instance() {
    return reinterpret_cast<const OneClickUsePillElixirAck*>(
               &_OneClickUsePillElixirAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    157;

  friend void swap(OneClickUsePillElixirAck& a, OneClickUsePillElixirAck& b) {
    a.Swap(&b);
  }
  inline void Swap(OneClickUsePillElixirAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneClickUsePillElixirAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneClickUsePillElixirAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneClickUsePillElixirAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OneClickUsePillElixirAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OneClickUsePillElixirAck& from) {
    OneClickUsePillElixirAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneClickUsePillElixirAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OneClickUsePillElixirAck";
  }
  protected:
  explicit OneClickUsePillElixirAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReportFieldNumber = 1,
  };
  // repeated .idlepb.UsePillElixirReport report = 1;
  int report_size() const;
  private:
  int _internal_report_size() const;
  public:
  void clear_report();
  ::idlepb::UsePillElixirReport* mutable_report(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::UsePillElixirReport >*
      mutable_report();
  private:
  const ::idlepb::UsePillElixirReport& _internal_report(int index) const;
  ::idlepb::UsePillElixirReport* _internal_add_report();
  public:
  const ::idlepb::UsePillElixirReport& report(int index) const;
  ::idlepb::UsePillElixirReport* add_report();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::UsePillElixirReport >&
      report() const;

  // @@protoc_insertion_point(class_scope:idlepb.OneClickUsePillElixirAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::UsePillElixirReport > report_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API TradePillElixirReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.TradePillElixirReq) */ {
 public:
  inline TradePillElixirReq() : TradePillElixirReq(nullptr) {}
  ~TradePillElixirReq() override;
  explicit PROTOBUF_CONSTEXPR TradePillElixirReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradePillElixirReq(const TradePillElixirReq& from);
  TradePillElixirReq(TradePillElixirReq&& from) noexcept
    : TradePillElixirReq() {
    *this = ::std::move(from);
  }

  inline TradePillElixirReq& operator=(const TradePillElixirReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradePillElixirReq& operator=(TradePillElixirReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradePillElixirReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradePillElixirReq* internal_default_instance() {
    return reinterpret_cast<const TradePillElixirReq*>(
               &_TradePillElixirReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    158;

  friend void swap(TradePillElixirReq& a, TradePillElixirReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TradePillElixirReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradePillElixirReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradePillElixirReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradePillElixirReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradePillElixirReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradePillElixirReq& from) {
    TradePillElixirReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradePillElixirReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.TradePillElixirReq";
  }
  protected:
  explicit TradePillElixirReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kNumFieldNumber = 2,
  };
  // int32 item_id = 1;
  void clear_item_id();
  int32_t item_id() const;
  void set_item_id(int32_t value);
  private:
  int32_t _internal_item_id() const;
  void _internal_set_item_id(int32_t value);
  public:

  // int32 num = 2;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.TradePillElixirReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t item_id_;
    int32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API TradePillElixirAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.TradePillElixirAck) */ {
 public:
  inline TradePillElixirAck() : TradePillElixirAck(nullptr) {}
  ~TradePillElixirAck() override;
  explicit PROTOBUF_CONSTEXPR TradePillElixirAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradePillElixirAck(const TradePillElixirAck& from);
  TradePillElixirAck(TradePillElixirAck&& from) noexcept
    : TradePillElixirAck() {
    *this = ::std::move(from);
  }

  inline TradePillElixirAck& operator=(const TradePillElixirAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradePillElixirAck& operator=(TradePillElixirAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradePillElixirAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradePillElixirAck* internal_default_instance() {
    return reinterpret_cast<const TradePillElixirAck*>(
               &_TradePillElixirAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    159;

  friend void swap(TradePillElixirAck& a, TradePillElixirAck& b) {
    a.Swap(&b);
  }
  inline void Swap(TradePillElixirAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradePillElixirAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradePillElixirAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradePillElixirAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradePillElixirAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradePillElixirAck& from) {
    TradePillElixirAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradePillElixirAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.TradePillElixirAck";
  }
  protected:
  explicit TradePillElixirAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.TradePillElixirAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyAutoModeStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyAutoModeStatus) */ {
 public:
  inline NotifyAutoModeStatus() : NotifyAutoModeStatus(nullptr) {}
  ~NotifyAutoModeStatus() override;
  explicit PROTOBUF_CONSTEXPR NotifyAutoModeStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyAutoModeStatus(const NotifyAutoModeStatus& from);
  NotifyAutoModeStatus(NotifyAutoModeStatus&& from) noexcept
    : NotifyAutoModeStatus() {
    *this = ::std::move(from);
  }

  inline NotifyAutoModeStatus& operator=(const NotifyAutoModeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyAutoModeStatus& operator=(NotifyAutoModeStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyAutoModeStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyAutoModeStatus* internal_default_instance() {
    return reinterpret_cast<const NotifyAutoModeStatus*>(
               &_NotifyAutoModeStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    160;

  friend void swap(NotifyAutoModeStatus& a, NotifyAutoModeStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyAutoModeStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyAutoModeStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyAutoModeStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyAutoModeStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyAutoModeStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyAutoModeStatus& from) {
    NotifyAutoModeStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyAutoModeStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyAutoModeStatus";
  }
  protected:
  explicit NotifyAutoModeStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
  };
  // bool enable = 1;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyAutoModeStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetAutoMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetAutoMode) */ {
 public:
  inline SetAutoMode() : SetAutoMode(nullptr) {}
  ~SetAutoMode() override;
  explicit PROTOBUF_CONSTEXPR SetAutoMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAutoMode(const SetAutoMode& from);
  SetAutoMode(SetAutoMode&& from) noexcept
    : SetAutoMode() {
    *this = ::std::move(from);
  }

  inline SetAutoMode& operator=(const SetAutoMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAutoMode& operator=(SetAutoMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAutoMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAutoMode* internal_default_instance() {
    return reinterpret_cast<const SetAutoMode*>(
               &_SetAutoMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    161;

  friend void swap(SetAutoMode& a, SetAutoMode& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAutoMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAutoMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAutoMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAutoMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAutoMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAutoMode& from) {
    SetAutoMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAutoMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetAutoMode";
  }
  protected:
  explicit SetAutoMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
  };
  // bool enable = 1;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetAutoMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReinforceEquipmentReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReinforceEquipmentReq) */ {
 public:
  inline ReinforceEquipmentReq() : ReinforceEquipmentReq(nullptr) {}
  ~ReinforceEquipmentReq() override;
  explicit PROTOBUF_CONSTEXPR ReinforceEquipmentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReinforceEquipmentReq(const ReinforceEquipmentReq& from);
  ReinforceEquipmentReq(ReinforceEquipmentReq&& from) noexcept
    : ReinforceEquipmentReq() {
    *this = ::std::move(from);
  }

  inline ReinforceEquipmentReq& operator=(const ReinforceEquipmentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReinforceEquipmentReq& operator=(ReinforceEquipmentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReinforceEquipmentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReinforceEquipmentReq* internal_default_instance() {
    return reinterpret_cast<const ReinforceEquipmentReq*>(
               &_ReinforceEquipmentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    162;

  friend void swap(ReinforceEquipmentReq& a, ReinforceEquipmentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReinforceEquipmentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReinforceEquipmentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReinforceEquipmentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReinforceEquipmentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReinforceEquipmentReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReinforceEquipmentReq& from) {
    ReinforceEquipmentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReinforceEquipmentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReinforceEquipmentReq";
  }
  protected:
  explicit ReinforceEquipmentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReinforceEquipmentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReinforceEquipmentAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReinforceEquipmentAck) */ {
 public:
  inline ReinforceEquipmentAck() : ReinforceEquipmentAck(nullptr) {}
  ~ReinforceEquipmentAck() override;
  explicit PROTOBUF_CONSTEXPR ReinforceEquipmentAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReinforceEquipmentAck(const ReinforceEquipmentAck& from);
  ReinforceEquipmentAck(ReinforceEquipmentAck&& from) noexcept
    : ReinforceEquipmentAck() {
    *this = ::std::move(from);
  }

  inline ReinforceEquipmentAck& operator=(const ReinforceEquipmentAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReinforceEquipmentAck& operator=(ReinforceEquipmentAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReinforceEquipmentAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReinforceEquipmentAck* internal_default_instance() {
    return reinterpret_cast<const ReinforceEquipmentAck*>(
               &_ReinforceEquipmentAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    163;

  friend void swap(ReinforceEquipmentAck& a, ReinforceEquipmentAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ReinforceEquipmentAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReinforceEquipmentAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReinforceEquipmentAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReinforceEquipmentAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReinforceEquipmentAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReinforceEquipmentAck& from) {
    ReinforceEquipmentAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReinforceEquipmentAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReinforceEquipmentAck";
  }
  protected:
  explicit ReinforceEquipmentAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReinforceEquipmentAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API QiWenEquipmentReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.QiWenEquipmentReq) */ {
 public:
  inline QiWenEquipmentReq() : QiWenEquipmentReq(nullptr) {}
  ~QiWenEquipmentReq() override;
  explicit PROTOBUF_CONSTEXPR QiWenEquipmentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QiWenEquipmentReq(const QiWenEquipmentReq& from);
  QiWenEquipmentReq(QiWenEquipmentReq&& from) noexcept
    : QiWenEquipmentReq() {
    *this = ::std::move(from);
  }

  inline QiWenEquipmentReq& operator=(const QiWenEquipmentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline QiWenEquipmentReq& operator=(QiWenEquipmentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QiWenEquipmentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const QiWenEquipmentReq* internal_default_instance() {
    return reinterpret_cast<const QiWenEquipmentReq*>(
               &_QiWenEquipmentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    164;

  friend void swap(QiWenEquipmentReq& a, QiWenEquipmentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(QiWenEquipmentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QiWenEquipmentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QiWenEquipmentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QiWenEquipmentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QiWenEquipmentReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QiWenEquipmentReq& from) {
    QiWenEquipmentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QiWenEquipmentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.QiWenEquipmentReq";
  }
  protected:
  explicit QiWenEquipmentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommitMaterialsFieldNumber = 3,
    kIdFieldNumber = 1,
    kSelectAbcFieldNumber = 2,
  };
  // repeated int64 commit_materials = 3;
  int commit_materials_size() const;
  private:
  int _internal_commit_materials_size() const;
  public:
  void clear_commit_materials();
  private:
  int64_t _internal_commit_materials(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_commit_materials() const;
  void _internal_add_commit_materials(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_commit_materials();
  public:
  int64_t commit_materials(int index) const;
  void set_commit_materials(int index, int64_t value);
  void add_commit_materials(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      commit_materials() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_commit_materials();

  // int64 id = 1;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // int32 select_abc = 2;
  void clear_select_abc();
  int32_t select_abc() const;
  void set_select_abc(int32_t value);
  private:
  int32_t _internal_select_abc() const;
  void _internal_set_select_abc(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.QiWenEquipmentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > commit_materials_;
    mutable std::atomic<int> _commit_materials_cached_byte_size_;
    int64_t id_;
    int32_t select_abc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API QiWenEquipmentAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.QiWenEquipmentAck) */ {
 public:
  inline QiWenEquipmentAck() : QiWenEquipmentAck(nullptr) {}
  ~QiWenEquipmentAck() override;
  explicit PROTOBUF_CONSTEXPR QiWenEquipmentAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QiWenEquipmentAck(const QiWenEquipmentAck& from);
  QiWenEquipmentAck(QiWenEquipmentAck&& from) noexcept
    : QiWenEquipmentAck() {
    *this = ::std::move(from);
  }

  inline QiWenEquipmentAck& operator=(const QiWenEquipmentAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline QiWenEquipmentAck& operator=(QiWenEquipmentAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QiWenEquipmentAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const QiWenEquipmentAck* internal_default_instance() {
    return reinterpret_cast<const QiWenEquipmentAck*>(
               &_QiWenEquipmentAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    165;

  friend void swap(QiWenEquipmentAck& a, QiWenEquipmentAck& b) {
    a.Swap(&b);
  }
  inline void Swap(QiWenEquipmentAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QiWenEquipmentAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QiWenEquipmentAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QiWenEquipmentAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QiWenEquipmentAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QiWenEquipmentAck& from) {
    QiWenEquipmentAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QiWenEquipmentAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.QiWenEquipmentAck";
  }
  protected:
  explicit QiWenEquipmentAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.QiWenEquipmentAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefineEquipmentReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefineEquipmentReq) */ {
 public:
  inline RefineEquipmentReq() : RefineEquipmentReq(nullptr) {}
  ~RefineEquipmentReq() override;
  explicit PROTOBUF_CONSTEXPR RefineEquipmentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefineEquipmentReq(const RefineEquipmentReq& from);
  RefineEquipmentReq(RefineEquipmentReq&& from) noexcept
    : RefineEquipmentReq() {
    *this = ::std::move(from);
  }

  inline RefineEquipmentReq& operator=(const RefineEquipmentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefineEquipmentReq& operator=(RefineEquipmentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefineEquipmentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefineEquipmentReq* internal_default_instance() {
    return reinterpret_cast<const RefineEquipmentReq*>(
               &_RefineEquipmentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    166;

  friend void swap(RefineEquipmentReq& a, RefineEquipmentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RefineEquipmentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefineEquipmentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefineEquipmentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefineEquipmentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefineEquipmentReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefineEquipmentReq& from) {
    RefineEquipmentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefineEquipmentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefineEquipmentReq";
  }
  protected:
  explicit RefineEquipmentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RefineEquipmentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefineEquipmentAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefineEquipmentAck) */ {
 public:
  inline RefineEquipmentAck() : RefineEquipmentAck(nullptr) {}
  ~RefineEquipmentAck() override;
  explicit PROTOBUF_CONSTEXPR RefineEquipmentAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefineEquipmentAck(const RefineEquipmentAck& from);
  RefineEquipmentAck(RefineEquipmentAck&& from) noexcept
    : RefineEquipmentAck() {
    *this = ::std::move(from);
  }

  inline RefineEquipmentAck& operator=(const RefineEquipmentAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefineEquipmentAck& operator=(RefineEquipmentAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefineEquipmentAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefineEquipmentAck* internal_default_instance() {
    return reinterpret_cast<const RefineEquipmentAck*>(
               &_RefineEquipmentAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    167;

  friend void swap(RefineEquipmentAck& a, RefineEquipmentAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RefineEquipmentAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefineEquipmentAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefineEquipmentAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefineEquipmentAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefineEquipmentAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefineEquipmentAck& from) {
    RefineEquipmentAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefineEquipmentAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefineEquipmentAck";
  }
  protected:
  explicit RefineEquipmentAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RefineEquipmentAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ResetEquipmentReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ResetEquipmentReq) */ {
 public:
  inline ResetEquipmentReq() : ResetEquipmentReq(nullptr) {}
  ~ResetEquipmentReq() override;
  explicit PROTOBUF_CONSTEXPR ResetEquipmentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetEquipmentReq(const ResetEquipmentReq& from);
  ResetEquipmentReq(ResetEquipmentReq&& from) noexcept
    : ResetEquipmentReq() {
    *this = ::std::move(from);
  }

  inline ResetEquipmentReq& operator=(const ResetEquipmentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetEquipmentReq& operator=(ResetEquipmentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetEquipmentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetEquipmentReq* internal_default_instance() {
    return reinterpret_cast<const ResetEquipmentReq*>(
               &_ResetEquipmentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    168;

  friend void swap(ResetEquipmentReq& a, ResetEquipmentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetEquipmentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetEquipmentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetEquipmentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetEquipmentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetEquipmentReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetEquipmentReq& from) {
    ResetEquipmentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetEquipmentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ResetEquipmentReq";
  }
  protected:
  explicit ResetEquipmentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated int64 id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;
  public:
  void clear_id();
  private:
  int64_t _internal_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_id() const;
  void _internal_add_id(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_id();
  public:
  int64_t id(int index) const;
  void set_id(int index, int64_t value);
  void add_id(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_id();

  // @@protoc_insertion_point(class_scope:idlepb.ResetEquipmentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > id_;
    mutable std::atomic<int> _id_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ResetEquipmentAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ResetEquipmentAck) */ {
 public:
  inline ResetEquipmentAck() : ResetEquipmentAck(nullptr) {}
  ~ResetEquipmentAck() override;
  explicit PROTOBUF_CONSTEXPR ResetEquipmentAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetEquipmentAck(const ResetEquipmentAck& from);
  ResetEquipmentAck(ResetEquipmentAck&& from) noexcept
    : ResetEquipmentAck() {
    *this = ::std::move(from);
  }

  inline ResetEquipmentAck& operator=(const ResetEquipmentAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetEquipmentAck& operator=(ResetEquipmentAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetEquipmentAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetEquipmentAck* internal_default_instance() {
    return reinterpret_cast<const ResetEquipmentAck*>(
               &_ResetEquipmentAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    169;

  friend void swap(ResetEquipmentAck& a, ResetEquipmentAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetEquipmentAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetEquipmentAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetEquipmentAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetEquipmentAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetEquipmentAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetEquipmentAck& from) {
    ResetEquipmentAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetEquipmentAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ResetEquipmentAck";
  }
  protected:
  explicit ResetEquipmentAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // repeated .idlepb.SimpleItemData items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::SimpleItemData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
      mutable_items();
  private:
  const ::idlepb::SimpleItemData& _internal_items(int index) const;
  ::idlepb::SimpleItemData* _internal_add_items();
  public:
  const ::idlepb::SimpleItemData& items(int index) const;
  ::idlepb::SimpleItemData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
      items() const;

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ResetEquipmentAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData > items_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API InheritEquipmentReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.InheritEquipmentReq) */ {
 public:
  inline InheritEquipmentReq() : InheritEquipmentReq(nullptr) {}
  ~InheritEquipmentReq() override;
  explicit PROTOBUF_CONSTEXPR InheritEquipmentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InheritEquipmentReq(const InheritEquipmentReq& from);
  InheritEquipmentReq(InheritEquipmentReq&& from) noexcept
    : InheritEquipmentReq() {
    *this = ::std::move(from);
  }

  inline InheritEquipmentReq& operator=(const InheritEquipmentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline InheritEquipmentReq& operator=(InheritEquipmentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InheritEquipmentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const InheritEquipmentReq* internal_default_instance() {
    return reinterpret_cast<const InheritEquipmentReq*>(
               &_InheritEquipmentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    170;

  friend void swap(InheritEquipmentReq& a, InheritEquipmentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(InheritEquipmentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InheritEquipmentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InheritEquipmentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InheritEquipmentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InheritEquipmentReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InheritEquipmentReq& from) {
    InheritEquipmentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InheritEquipmentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.InheritEquipmentReq";
  }
  protected:
  explicit InheritEquipmentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEquipmentFromFieldNumber = 1,
    kEquipmentToFieldNumber = 2,
  };
  // int64 equipment_from = 1;
  void clear_equipment_from();
  int64_t equipment_from() const;
  void set_equipment_from(int64_t value);
  private:
  int64_t _internal_equipment_from() const;
  void _internal_set_equipment_from(int64_t value);
  public:

  // int64 equipment_to = 2;
  void clear_equipment_to();
  int64_t equipment_to() const;
  void set_equipment_to(int64_t value);
  private:
  int64_t _internal_equipment_to() const;
  void _internal_set_equipment_to(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.InheritEquipmentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t equipment_from_;
    int64_t equipment_to_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API InheritEquipmentAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.InheritEquipmentAck) */ {
 public:
  inline InheritEquipmentAck() : InheritEquipmentAck(nullptr) {}
  ~InheritEquipmentAck() override;
  explicit PROTOBUF_CONSTEXPR InheritEquipmentAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InheritEquipmentAck(const InheritEquipmentAck& from);
  InheritEquipmentAck(InheritEquipmentAck&& from) noexcept
    : InheritEquipmentAck() {
    *this = ::std::move(from);
  }

  inline InheritEquipmentAck& operator=(const InheritEquipmentAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline InheritEquipmentAck& operator=(InheritEquipmentAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InheritEquipmentAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const InheritEquipmentAck* internal_default_instance() {
    return reinterpret_cast<const InheritEquipmentAck*>(
               &_InheritEquipmentAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    171;

  friend void swap(InheritEquipmentAck& a, InheritEquipmentAck& b) {
    a.Swap(&b);
  }
  inline void Swap(InheritEquipmentAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InheritEquipmentAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InheritEquipmentAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InheritEquipmentAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InheritEquipmentAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InheritEquipmentAck& from) {
    InheritEquipmentAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InheritEquipmentAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.InheritEquipmentAck";
  }
  protected:
  explicit InheritEquipmentAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // repeated .idlepb.SimpleItemData items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::SimpleItemData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
      mutable_items();
  private:
  const ::idlepb::SimpleItemData& _internal_items(int index) const;
  ::idlepb::SimpleItemData* _internal_add_items();
  public:
  const ::idlepb::SimpleItemData& items(int index) const;
  ::idlepb::SimpleItemData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
      items() const;

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.InheritEquipmentAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData > items_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API LockItemReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.LockItemReq) */ {
 public:
  inline LockItemReq() : LockItemReq(nullptr) {}
  ~LockItemReq() override;
  explicit PROTOBUF_CONSTEXPR LockItemReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LockItemReq(const LockItemReq& from);
  LockItemReq(LockItemReq&& from) noexcept
    : LockItemReq() {
    *this = ::std::move(from);
  }

  inline LockItemReq& operator=(const LockItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockItemReq& operator=(LockItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LockItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockItemReq* internal_default_instance() {
    return reinterpret_cast<const LockItemReq*>(
               &_LockItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    172;

  friend void swap(LockItemReq& a, LockItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LockItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockItemReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LockItemReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LockItemReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LockItemReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LockItemReq& from) {
    LockItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockItemReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.LockItemReq";
  }
  protected:
  explicit LockItemReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.LockItemReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API LockItemAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.LockItemAck) */ {
 public:
  inline LockItemAck() : LockItemAck(nullptr) {}
  ~LockItemAck() override;
  explicit PROTOBUF_CONSTEXPR LockItemAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LockItemAck(const LockItemAck& from);
  LockItemAck(LockItemAck&& from) noexcept
    : LockItemAck() {
    *this = ::std::move(from);
  }

  inline LockItemAck& operator=(const LockItemAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockItemAck& operator=(LockItemAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LockItemAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockItemAck* internal_default_instance() {
    return reinterpret_cast<const LockItemAck*>(
               &_LockItemAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    173;

  friend void swap(LockItemAck& a, LockItemAck& b) {
    a.Swap(&b);
  }
  inline void Swap(LockItemAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockItemAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LockItemAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LockItemAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LockItemAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LockItemAck& from) {
    LockItemAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockItemAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.LockItemAck";
  }
  protected:
  explicit LockItemAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.LockItemAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API CollectionActivatedSuit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.CollectionActivatedSuit) */ {
 public:
  inline CollectionActivatedSuit() : CollectionActivatedSuit(nullptr) {}
  ~CollectionActivatedSuit() override;
  explicit PROTOBUF_CONSTEXPR CollectionActivatedSuit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CollectionActivatedSuit(const CollectionActivatedSuit& from);
  CollectionActivatedSuit(CollectionActivatedSuit&& from) noexcept
    : CollectionActivatedSuit() {
    *this = ::std::move(from);
  }

  inline CollectionActivatedSuit& operator=(const CollectionActivatedSuit& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionActivatedSuit& operator=(CollectionActivatedSuit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionActivatedSuit& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectionActivatedSuit* internal_default_instance() {
    return reinterpret_cast<const CollectionActivatedSuit*>(
               &_CollectionActivatedSuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    174;

  friend void swap(CollectionActivatedSuit& a, CollectionActivatedSuit& b) {
    a.Swap(&b);
  }
  inline void Swap(CollectionActivatedSuit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionActivatedSuit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionActivatedSuit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollectionActivatedSuit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CollectionActivatedSuit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CollectionActivatedSuit& from) {
    CollectionActivatedSuit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CollectionActivatedSuit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.CollectionActivatedSuit";
  }
  protected:
  explicit CollectionActivatedSuit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIndexFieldNumber = 2,
    kCombatPowerFieldNumber = 3,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 index = 2;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // float combat_power = 3;
  void clear_combat_power();
  float combat_power() const;
  void set_combat_power(float value);
  private:
  float _internal_combat_power() const;
  void _internal_set_combat_power(float value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.CollectionActivatedSuit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    int32_t index_;
    float combat_power_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleCollectionDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetRoleCollectionDataReq) */ {
 public:
  inline GetRoleCollectionDataReq() : GetRoleCollectionDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetRoleCollectionDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleCollectionDataReq(const GetRoleCollectionDataReq& from);
  GetRoleCollectionDataReq(GetRoleCollectionDataReq&& from) noexcept
    : GetRoleCollectionDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleCollectionDataReq& operator=(const GetRoleCollectionDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleCollectionDataReq& operator=(GetRoleCollectionDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleCollectionDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleCollectionDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleCollectionDataReq*>(
               &_GetRoleCollectionDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    175;

  friend void swap(GetRoleCollectionDataReq& a, GetRoleCollectionDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleCollectionDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleCollectionDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleCollectionDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleCollectionDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetRoleCollectionDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetRoleCollectionDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleCollectionDataReq";
  }
  protected:
  explicit GetRoleCollectionDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleCollectionDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleCollectionDataRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleCollectionDataRsp) */ {
 public:
  inline GetRoleCollectionDataRsp() : GetRoleCollectionDataRsp(nullptr) {}
  ~GetRoleCollectionDataRsp() override;
  explicit PROTOBUF_CONSTEXPR GetRoleCollectionDataRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleCollectionDataRsp(const GetRoleCollectionDataRsp& from);
  GetRoleCollectionDataRsp(GetRoleCollectionDataRsp&& from) noexcept
    : GetRoleCollectionDataRsp() {
    *this = ::std::move(from);
  }

  inline GetRoleCollectionDataRsp& operator=(const GetRoleCollectionDataRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleCollectionDataRsp& operator=(GetRoleCollectionDataRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleCollectionDataRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleCollectionDataRsp* internal_default_instance() {
    return reinterpret_cast<const GetRoleCollectionDataRsp*>(
               &_GetRoleCollectionDataRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    176;

  friend void swap(GetRoleCollectionDataRsp& a, GetRoleCollectionDataRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleCollectionDataRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleCollectionDataRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleCollectionDataRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleCollectionDataRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleCollectionDataRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleCollectionDataRsp& from) {
    GetRoleCollectionDataRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleCollectionDataRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleCollectionDataRsp";
  }
  protected:
  explicit GetRoleCollectionDataRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kCommonPiecesFieldNumber = 2,
    kActivedSuiteFieldNumber = 3,
    kDrawAwardDoneHistoriesFieldNumber = 4,
    kCanAwardHistoriesFieldNumber = 5,
    kZoneActiveAwardsFieldNumber = 6,
    kNextResetEnhanceTicksFieldNumber = 7,
  };
  // repeated .idlepb.CollectionEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::idlepb::CollectionEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionEntry >*
      mutable_entries();
  private:
  const ::idlepb::CollectionEntry& _internal_entries(int index) const;
  ::idlepb::CollectionEntry* _internal_add_entries();
  public:
  const ::idlepb::CollectionEntry& entries(int index) const;
  ::idlepb::CollectionEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionEntry >&
      entries() const;

  // repeated .idlepb.CommonCollectionPieceData common_pieces = 2;
  int common_pieces_size() const;
  private:
  int _internal_common_pieces_size() const;
  public:
  void clear_common_pieces();
  ::idlepb::CommonCollectionPieceData* mutable_common_pieces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CommonCollectionPieceData >*
      mutable_common_pieces();
  private:
  const ::idlepb::CommonCollectionPieceData& _internal_common_pieces(int index) const;
  ::idlepb::CommonCollectionPieceData* _internal_add_common_pieces();
  public:
  const ::idlepb::CommonCollectionPieceData& common_pieces(int index) const;
  ::idlepb::CommonCollectionPieceData* add_common_pieces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CommonCollectionPieceData >&
      common_pieces() const;

  // repeated .idlepb.CollectionActivatedSuit actived_suite = 3;
  int actived_suite_size() const;
  private:
  int _internal_actived_suite_size() const;
  public:
  void clear_actived_suite();
  ::idlepb::CollectionActivatedSuit* mutable_actived_suite(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionActivatedSuit >*
      mutable_actived_suite();
  private:
  const ::idlepb::CollectionActivatedSuit& _internal_actived_suite(int index) const;
  ::idlepb::CollectionActivatedSuit* _internal_add_actived_suite();
  public:
  const ::idlepb::CollectionActivatedSuit& actived_suite(int index) const;
  ::idlepb::CollectionActivatedSuit* add_actived_suite();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionActivatedSuit >&
      actived_suite() const;

  // repeated int32 draw_award_done_histories = 4;
  int draw_award_done_histories_size() const;
  private:
  int _internal_draw_award_done_histories_size() const;
  public:
  void clear_draw_award_done_histories();
  private:
  int32_t _internal_draw_award_done_histories(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_draw_award_done_histories() const;
  void _internal_add_draw_award_done_histories(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_draw_award_done_histories();
  public:
  int32_t draw_award_done_histories(int index) const;
  void set_draw_award_done_histories(int index, int32_t value);
  void add_draw_award_done_histories(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      draw_award_done_histories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_draw_award_done_histories();

  // repeated int32 can_award_histories = 5;
  int can_award_histories_size() const;
  private:
  int _internal_can_award_histories_size() const;
  public:
  void clear_can_award_histories();
  private:
  int32_t _internal_can_award_histories(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_can_award_histories() const;
  void _internal_add_can_award_histories(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_can_award_histories();
  public:
  int32_t can_award_histories(int index) const;
  void set_can_award_histories(int index, int32_t value);
  void add_can_award_histories(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      can_award_histories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_can_award_histories();

  // repeated .idlepb.CollectionZoneActiveAwardData zone_active_awards = 6;
  int zone_active_awards_size() const;
  private:
  int _internal_zone_active_awards_size() const;
  public:
  void clear_zone_active_awards();
  ::idlepb::CollectionZoneActiveAwardData* mutable_zone_active_awards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionZoneActiveAwardData >*
      mutable_zone_active_awards();
  private:
  const ::idlepb::CollectionZoneActiveAwardData& _internal_zone_active_awards(int index) const;
  ::idlepb::CollectionZoneActiveAwardData* _internal_add_zone_active_awards();
  public:
  const ::idlepb::CollectionZoneActiveAwardData& zone_active_awards(int index) const;
  ::idlepb::CollectionZoneActiveAwardData* add_zone_active_awards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionZoneActiveAwardData >&
      zone_active_awards() const;

  // int64 next_reset_enhance_ticks = 7;
  void clear_next_reset_enhance_ticks();
  int64_t next_reset_enhance_ticks() const;
  void set_next_reset_enhance_ticks(int64_t value);
  private:
  int64_t _internal_next_reset_enhance_ticks() const;
  void _internal_set_next_reset_enhance_ticks(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleCollectionDataRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionEntry > entries_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CommonCollectionPieceData > common_pieces_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionActivatedSuit > actived_suite_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > draw_award_done_histories_;
    mutable std::atomic<int> _draw_award_done_histories_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > can_award_histories_;
    mutable std::atomic<int> _can_award_histories_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionZoneActiveAwardData > zone_active_awards_;
    int64_t next_reset_enhance_ticks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RoleCollectionOpReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RoleCollectionOpReq) */ {
 public:
  inline RoleCollectionOpReq() : RoleCollectionOpReq(nullptr) {}
  ~RoleCollectionOpReq() override;
  explicit PROTOBUF_CONSTEXPR RoleCollectionOpReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleCollectionOpReq(const RoleCollectionOpReq& from);
  RoleCollectionOpReq(RoleCollectionOpReq&& from) noexcept
    : RoleCollectionOpReq() {
    *this = ::std::move(from);
  }

  inline RoleCollectionOpReq& operator=(const RoleCollectionOpReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleCollectionOpReq& operator=(RoleCollectionOpReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleCollectionOpReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleCollectionOpReq* internal_default_instance() {
    return reinterpret_cast<const RoleCollectionOpReq*>(
               &_RoleCollectionOpReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    177;

  friend void swap(RoleCollectionOpReq& a, RoleCollectionOpReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleCollectionOpReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleCollectionOpReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleCollectionOpReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleCollectionOpReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleCollectionOpReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleCollectionOpReq& from) {
    RoleCollectionOpReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleCollectionOpReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RoleCollectionOpReq";
  }
  protected:
  explicit RoleCollectionOpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsumeListFieldNumber = 3,
    kOpTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kIsPreviewFieldNumber = 4,
  };
  // repeated .idlepb.MapValueInt32 consume_list = 3;
  int consume_list_size() const;
  private:
  int _internal_consume_list_size() const;
  public:
  void clear_consume_list();
  ::idlepb::MapValueInt32* mutable_consume_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::MapValueInt32 >*
      mutable_consume_list();
  private:
  const ::idlepb::MapValueInt32& _internal_consume_list(int index) const;
  ::idlepb::MapValueInt32* _internal_add_consume_list();
  public:
  const ::idlepb::MapValueInt32& consume_list(int index) const;
  ::idlepb::MapValueInt32* add_consume_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::MapValueInt32 >&
      consume_list() const;

  // .idlepb.RoleCollectionOpType op_type = 1;
  void clear_op_type();
  ::idlepb::RoleCollectionOpType op_type() const;
  void set_op_type(::idlepb::RoleCollectionOpType value);
  private:
  ::idlepb::RoleCollectionOpType _internal_op_type() const;
  void _internal_set_op_type(::idlepb::RoleCollectionOpType value);
  public:

  // int32 id = 2;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // bool is_preview = 4;
  void clear_is_preview();
  bool is_preview() const;
  void set_is_preview(bool value);
  private:
  bool _internal_is_preview() const;
  void _internal_set_is_preview(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RoleCollectionOpReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::MapValueInt32 > consume_list_;
    int op_type_;
    int32_t id_;
    bool is_preview_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RoleCollectionOpAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RoleCollectionOpAck) */ {
 public:
  inline RoleCollectionOpAck() : RoleCollectionOpAck(nullptr) {}
  ~RoleCollectionOpAck() override;
  explicit PROTOBUF_CONSTEXPR RoleCollectionOpAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleCollectionOpAck(const RoleCollectionOpAck& from);
  RoleCollectionOpAck(RoleCollectionOpAck&& from) noexcept
    : RoleCollectionOpAck() {
    *this = ::std::move(from);
  }

  inline RoleCollectionOpAck& operator=(const RoleCollectionOpAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleCollectionOpAck& operator=(RoleCollectionOpAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleCollectionOpAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleCollectionOpAck* internal_default_instance() {
    return reinterpret_cast<const RoleCollectionOpAck*>(
               &_RoleCollectionOpAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    178;

  friend void swap(RoleCollectionOpAck& a, RoleCollectionOpAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleCollectionOpAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleCollectionOpAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleCollectionOpAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleCollectionOpAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleCollectionOpAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleCollectionOpAck& from) {
    RoleCollectionOpAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleCollectionOpAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RoleCollectionOpAck";
  }
  protected:
  explicit RoleCollectionOpAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 3,
    kOpTypeFieldNumber = 1,
    kOkFieldNumber = 2,
  };
  // repeated .idlepb.SimpleItemData items = 3;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::SimpleItemData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
      mutable_items();
  private:
  const ::idlepb::SimpleItemData& _internal_items(int index) const;
  ::idlepb::SimpleItemData* _internal_add_items();
  public:
  const ::idlepb::SimpleItemData& items(int index) const;
  ::idlepb::SimpleItemData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
      items() const;

  // .idlepb.RoleCollectionOpType op_type = 1;
  void clear_op_type();
  ::idlepb::RoleCollectionOpType op_type() const;
  void set_op_type(::idlepb::RoleCollectionOpType value);
  private:
  ::idlepb::RoleCollectionOpType _internal_op_type() const;
  void _internal_set_op_type(::idlepb::RoleCollectionOpType value);
  public:

  // bool ok = 2;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RoleCollectionOpAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData > items_;
    int op_type_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyRoleCollectionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyRoleCollectionData) */ {
 public:
  inline NotifyRoleCollectionData() : NotifyRoleCollectionData(nullptr) {}
  ~NotifyRoleCollectionData() override;
  explicit PROTOBUF_CONSTEXPR NotifyRoleCollectionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyRoleCollectionData(const NotifyRoleCollectionData& from);
  NotifyRoleCollectionData(NotifyRoleCollectionData&& from) noexcept
    : NotifyRoleCollectionData() {
    *this = ::std::move(from);
  }

  inline NotifyRoleCollectionData& operator=(const NotifyRoleCollectionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyRoleCollectionData& operator=(NotifyRoleCollectionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyRoleCollectionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyRoleCollectionData* internal_default_instance() {
    return reinterpret_cast<const NotifyRoleCollectionData*>(
               &_NotifyRoleCollectionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    179;

  friend void swap(NotifyRoleCollectionData& a, NotifyRoleCollectionData& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyRoleCollectionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyRoleCollectionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyRoleCollectionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyRoleCollectionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyRoleCollectionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyRoleCollectionData& from) {
    NotifyRoleCollectionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyRoleCollectionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyRoleCollectionData";
  }
  protected:
  explicit NotifyRoleCollectionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // .idlepb.CollectionEntry entry = 1;
  bool has_entry() const;
  private:
  bool _internal_has_entry() const;
  public:
  void clear_entry();
  const ::idlepb::CollectionEntry& entry() const;
  PROTOBUF_NODISCARD ::idlepb::CollectionEntry* release_entry();
  ::idlepb::CollectionEntry* mutable_entry();
  void set_allocated_entry(::idlepb::CollectionEntry* entry);
  private:
  const ::idlepb::CollectionEntry& _internal_entry() const;
  ::idlepb::CollectionEntry* _internal_mutable_entry();
  public:
  void unsafe_arena_set_allocated_entry(
      ::idlepb::CollectionEntry* entry);
  ::idlepb::CollectionEntry* unsafe_arena_release_entry();

  // @@protoc_insertion_point(class_scope:idlepb.NotifyRoleCollectionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::CollectionEntry* entry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyCommonCollectionPieceData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyCommonCollectionPieceData) */ {
 public:
  inline NotifyCommonCollectionPieceData() : NotifyCommonCollectionPieceData(nullptr) {}
  ~NotifyCommonCollectionPieceData() override;
  explicit PROTOBUF_CONSTEXPR NotifyCommonCollectionPieceData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyCommonCollectionPieceData(const NotifyCommonCollectionPieceData& from);
  NotifyCommonCollectionPieceData(NotifyCommonCollectionPieceData&& from) noexcept
    : NotifyCommonCollectionPieceData() {
    *this = ::std::move(from);
  }

  inline NotifyCommonCollectionPieceData& operator=(const NotifyCommonCollectionPieceData& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyCommonCollectionPieceData& operator=(NotifyCommonCollectionPieceData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyCommonCollectionPieceData& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyCommonCollectionPieceData* internal_default_instance() {
    return reinterpret_cast<const NotifyCommonCollectionPieceData*>(
               &_NotifyCommonCollectionPieceData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    180;

  friend void swap(NotifyCommonCollectionPieceData& a, NotifyCommonCollectionPieceData& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyCommonCollectionPieceData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyCommonCollectionPieceData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyCommonCollectionPieceData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyCommonCollectionPieceData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyCommonCollectionPieceData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyCommonCollectionPieceData& from) {
    NotifyCommonCollectionPieceData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyCommonCollectionPieceData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyCommonCollectionPieceData";
  }
  protected:
  explicit NotifyCommonCollectionPieceData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonPiecesFieldNumber = 1,
  };
  // repeated .idlepb.CommonCollectionPieceData common_pieces = 1;
  int common_pieces_size() const;
  private:
  int _internal_common_pieces_size() const;
  public:
  void clear_common_pieces();
  ::idlepb::CommonCollectionPieceData* mutable_common_pieces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CommonCollectionPieceData >*
      mutable_common_pieces();
  private:
  const ::idlepb::CommonCollectionPieceData& _internal_common_pieces(int index) const;
  ::idlepb::CommonCollectionPieceData* _internal_add_common_pieces();
  public:
  const ::idlepb::CommonCollectionPieceData& common_pieces(int index) const;
  ::idlepb::CommonCollectionPieceData* add_common_pieces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CommonCollectionPieceData >&
      common_pieces() const;

  // @@protoc_insertion_point(class_scope:idlepb.NotifyCommonCollectionPieceData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CommonCollectionPieceData > common_pieces_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyCollectionActivatedSuit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyCollectionActivatedSuit) */ {
 public:
  inline NotifyCollectionActivatedSuit() : NotifyCollectionActivatedSuit(nullptr) {}
  ~NotifyCollectionActivatedSuit() override;
  explicit PROTOBUF_CONSTEXPR NotifyCollectionActivatedSuit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyCollectionActivatedSuit(const NotifyCollectionActivatedSuit& from);
  NotifyCollectionActivatedSuit(NotifyCollectionActivatedSuit&& from) noexcept
    : NotifyCollectionActivatedSuit() {
    *this = ::std::move(from);
  }

  inline NotifyCollectionActivatedSuit& operator=(const NotifyCollectionActivatedSuit& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyCollectionActivatedSuit& operator=(NotifyCollectionActivatedSuit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyCollectionActivatedSuit& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyCollectionActivatedSuit* internal_default_instance() {
    return reinterpret_cast<const NotifyCollectionActivatedSuit*>(
               &_NotifyCollectionActivatedSuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    181;

  friend void swap(NotifyCollectionActivatedSuit& a, NotifyCollectionActivatedSuit& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyCollectionActivatedSuit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyCollectionActivatedSuit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyCollectionActivatedSuit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyCollectionActivatedSuit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyCollectionActivatedSuit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyCollectionActivatedSuit& from) {
    NotifyCollectionActivatedSuit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyCollectionActivatedSuit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyCollectionActivatedSuit";
  }
  protected:
  explicit NotifyCollectionActivatedSuit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActivedSuiteFieldNumber = 1,
  };
  // repeated .idlepb.CollectionActivatedSuit actived_suite = 1;
  int actived_suite_size() const;
  private:
  int _internal_actived_suite_size() const;
  public:
  void clear_actived_suite();
  ::idlepb::CollectionActivatedSuit* mutable_actived_suite(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionActivatedSuit >*
      mutable_actived_suite();
  private:
  const ::idlepb::CollectionActivatedSuit& _internal_actived_suite(int index) const;
  ::idlepb::CollectionActivatedSuit* _internal_add_actived_suite();
  public:
  const ::idlepb::CollectionActivatedSuit& actived_suite(int index) const;
  ::idlepb::CollectionActivatedSuit* add_actived_suite();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionActivatedSuit >&
      actived_suite() const;

  // @@protoc_insertion_point(class_scope:idlepb.NotifyCollectionActivatedSuit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionActivatedSuit > actived_suite_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ShareSelfRoleCollectionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ShareSelfRoleCollectionReq) */ {
 public:
  inline ShareSelfRoleCollectionReq() : ShareSelfRoleCollectionReq(nullptr) {}
  ~ShareSelfRoleCollectionReq() override;
  explicit PROTOBUF_CONSTEXPR ShareSelfRoleCollectionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareSelfRoleCollectionReq(const ShareSelfRoleCollectionReq& from);
  ShareSelfRoleCollectionReq(ShareSelfRoleCollectionReq&& from) noexcept
    : ShareSelfRoleCollectionReq() {
    *this = ::std::move(from);
  }

  inline ShareSelfRoleCollectionReq& operator=(const ShareSelfRoleCollectionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareSelfRoleCollectionReq& operator=(ShareSelfRoleCollectionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShareSelfRoleCollectionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareSelfRoleCollectionReq* internal_default_instance() {
    return reinterpret_cast<const ShareSelfRoleCollectionReq*>(
               &_ShareSelfRoleCollectionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    182;

  friend void swap(ShareSelfRoleCollectionReq& a, ShareSelfRoleCollectionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareSelfRoleCollectionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareSelfRoleCollectionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareSelfRoleCollectionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareSelfRoleCollectionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShareSelfRoleCollectionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShareSelfRoleCollectionReq& from) {
    ShareSelfRoleCollectionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShareSelfRoleCollectionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ShareSelfRoleCollectionReq";
  }
  protected:
  explicit ShareSelfRoleCollectionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ShareSelfRoleCollectionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ShareSelfRoleCollectionRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ShareSelfRoleCollectionRsp) */ {
 public:
  inline ShareSelfRoleCollectionRsp() : ShareSelfRoleCollectionRsp(nullptr) {}
  ~ShareSelfRoleCollectionRsp() override;
  explicit PROTOBUF_CONSTEXPR ShareSelfRoleCollectionRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareSelfRoleCollectionRsp(const ShareSelfRoleCollectionRsp& from);
  ShareSelfRoleCollectionRsp(ShareSelfRoleCollectionRsp&& from) noexcept
    : ShareSelfRoleCollectionRsp() {
    *this = ::std::move(from);
  }

  inline ShareSelfRoleCollectionRsp& operator=(const ShareSelfRoleCollectionRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareSelfRoleCollectionRsp& operator=(ShareSelfRoleCollectionRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShareSelfRoleCollectionRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareSelfRoleCollectionRsp* internal_default_instance() {
    return reinterpret_cast<const ShareSelfRoleCollectionRsp*>(
               &_ShareSelfRoleCollectionRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    183;

  friend void swap(ShareSelfRoleCollectionRsp& a, ShareSelfRoleCollectionRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareSelfRoleCollectionRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareSelfRoleCollectionRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareSelfRoleCollectionRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareSelfRoleCollectionRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShareSelfRoleCollectionRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShareSelfRoleCollectionRsp& from) {
    ShareSelfRoleCollectionRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShareSelfRoleCollectionRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ShareSelfRoleCollectionRsp";
  }
  protected:
  explicit ShareSelfRoleCollectionRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShareIdFieldNumber = 1,
  };
  // int64 share_id = 1;
  void clear_share_id();
  int64_t share_id() const;
  void set_share_id(int64_t value);
  private:
  int64_t _internal_share_id() const;
  void _internal_set_share_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ShareSelfRoleCollectionRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t share_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetShareRoleCollectionDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetShareRoleCollectionDataReq) */ {
 public:
  inline GetShareRoleCollectionDataReq() : GetShareRoleCollectionDataReq(nullptr) {}
  ~GetShareRoleCollectionDataReq() override;
  explicit PROTOBUF_CONSTEXPR GetShareRoleCollectionDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShareRoleCollectionDataReq(const GetShareRoleCollectionDataReq& from);
  GetShareRoleCollectionDataReq(GetShareRoleCollectionDataReq&& from) noexcept
    : GetShareRoleCollectionDataReq() {
    *this = ::std::move(from);
  }

  inline GetShareRoleCollectionDataReq& operator=(const GetShareRoleCollectionDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShareRoleCollectionDataReq& operator=(GetShareRoleCollectionDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShareRoleCollectionDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetShareRoleCollectionDataReq* internal_default_instance() {
    return reinterpret_cast<const GetShareRoleCollectionDataReq*>(
               &_GetShareRoleCollectionDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    184;

  friend void swap(GetShareRoleCollectionDataReq& a, GetShareRoleCollectionDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShareRoleCollectionDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShareRoleCollectionDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShareRoleCollectionDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShareRoleCollectionDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetShareRoleCollectionDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetShareRoleCollectionDataReq& from) {
    GetShareRoleCollectionDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetShareRoleCollectionDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetShareRoleCollectionDataReq";
  }
  protected:
  explicit GetShareRoleCollectionDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShareIdFieldNumber = 1,
  };
  // int64 share_id = 1;
  void clear_share_id();
  int64_t share_id() const;
  void set_share_id(int64_t value);
  private:
  int64_t _internal_share_id() const;
  void _internal_set_share_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetShareRoleCollectionDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t share_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetShareRoleCollectionDataRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetShareRoleCollectionDataRsp) */ {
 public:
  inline GetShareRoleCollectionDataRsp() : GetShareRoleCollectionDataRsp(nullptr) {}
  ~GetShareRoleCollectionDataRsp() override;
  explicit PROTOBUF_CONSTEXPR GetShareRoleCollectionDataRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShareRoleCollectionDataRsp(const GetShareRoleCollectionDataRsp& from);
  GetShareRoleCollectionDataRsp(GetShareRoleCollectionDataRsp&& from) noexcept
    : GetShareRoleCollectionDataRsp() {
    *this = ::std::move(from);
  }

  inline GetShareRoleCollectionDataRsp& operator=(const GetShareRoleCollectionDataRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShareRoleCollectionDataRsp& operator=(GetShareRoleCollectionDataRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShareRoleCollectionDataRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetShareRoleCollectionDataRsp* internal_default_instance() {
    return reinterpret_cast<const GetShareRoleCollectionDataRsp*>(
               &_GetShareRoleCollectionDataRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    185;

  friend void swap(GetShareRoleCollectionDataRsp& a, GetShareRoleCollectionDataRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShareRoleCollectionDataRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShareRoleCollectionDataRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShareRoleCollectionDataRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShareRoleCollectionDataRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetShareRoleCollectionDataRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetShareRoleCollectionDataRsp& from) {
    GetShareRoleCollectionDataRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetShareRoleCollectionDataRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetShareRoleCollectionDataRsp";
  }
  protected:
  explicit GetShareRoleCollectionDataRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionDataFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.CollectionEntry collection_data = 2;
  bool has_collection_data() const;
  private:
  bool _internal_has_collection_data() const;
  public:
  void clear_collection_data();
  const ::idlepb::CollectionEntry& collection_data() const;
  PROTOBUF_NODISCARD ::idlepb::CollectionEntry* release_collection_data();
  ::idlepb::CollectionEntry* mutable_collection_data();
  void set_allocated_collection_data(::idlepb::CollectionEntry* collection_data);
  private:
  const ::idlepb::CollectionEntry& _internal_collection_data() const;
  ::idlepb::CollectionEntry* _internal_mutable_collection_data();
  public:
  void unsafe_arena_set_allocated_collection_data(
      ::idlepb::CollectionEntry* collection_data);
  ::idlepb::CollectionEntry* unsafe_arena_release_collection_data();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetShareRoleCollectionDataRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::CollectionEntry* collection_data_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyRoleCollectionHistories final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyRoleCollectionHistories) */ {
 public:
  inline NotifyRoleCollectionHistories() : NotifyRoleCollectionHistories(nullptr) {}
  ~NotifyRoleCollectionHistories() override;
  explicit PROTOBUF_CONSTEXPR NotifyRoleCollectionHistories(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyRoleCollectionHistories(const NotifyRoleCollectionHistories& from);
  NotifyRoleCollectionHistories(NotifyRoleCollectionHistories&& from) noexcept
    : NotifyRoleCollectionHistories() {
    *this = ::std::move(from);
  }

  inline NotifyRoleCollectionHistories& operator=(const NotifyRoleCollectionHistories& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyRoleCollectionHistories& operator=(NotifyRoleCollectionHistories&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyRoleCollectionHistories& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyRoleCollectionHistories* internal_default_instance() {
    return reinterpret_cast<const NotifyRoleCollectionHistories*>(
               &_NotifyRoleCollectionHistories_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    186;

  friend void swap(NotifyRoleCollectionHistories& a, NotifyRoleCollectionHistories& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyRoleCollectionHistories* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyRoleCollectionHistories* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyRoleCollectionHistories* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyRoleCollectionHistories>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyRoleCollectionHistories& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyRoleCollectionHistories& from) {
    NotifyRoleCollectionHistories::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyRoleCollectionHistories* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyRoleCollectionHistories";
  }
  protected:
  explicit NotifyRoleCollectionHistories(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawAwardDoneHistoriesFieldNumber = 1,
    kCanAwardHistoriesFieldNumber = 2,
  };
  // repeated int32 draw_award_done_histories = 1;
  int draw_award_done_histories_size() const;
  private:
  int _internal_draw_award_done_histories_size() const;
  public:
  void clear_draw_award_done_histories();
  private:
  int32_t _internal_draw_award_done_histories(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_draw_award_done_histories() const;
  void _internal_add_draw_award_done_histories(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_draw_award_done_histories();
  public:
  int32_t draw_award_done_histories(int index) const;
  void set_draw_award_done_histories(int index, int32_t value);
  void add_draw_award_done_histories(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      draw_award_done_histories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_draw_award_done_histories();

  // repeated int32 can_award_histories = 2;
  int can_award_histories_size() const;
  private:
  int _internal_can_award_histories_size() const;
  public:
  void clear_can_award_histories();
  private:
  int32_t _internal_can_award_histories(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_can_award_histories() const;
  void _internal_add_can_award_histories(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_can_award_histories();
  public:
  int32_t can_award_histories(int index) const;
  void set_can_award_histories(int index, int32_t value);
  void add_can_award_histories(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      can_award_histories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_can_award_histories();

  // @@protoc_insertion_point(class_scope:idlepb.NotifyRoleCollectionHistories)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > draw_award_done_histories_;
    mutable std::atomic<int> _draw_award_done_histories_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > can_award_histories_;
    mutable std::atomic<int> _can_award_histories_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyCollectionZoneActiveAwards final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyCollectionZoneActiveAwards) */ {
 public:
  inline NotifyCollectionZoneActiveAwards() : NotifyCollectionZoneActiveAwards(nullptr) {}
  ~NotifyCollectionZoneActiveAwards() override;
  explicit PROTOBUF_CONSTEXPR NotifyCollectionZoneActiveAwards(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyCollectionZoneActiveAwards(const NotifyCollectionZoneActiveAwards& from);
  NotifyCollectionZoneActiveAwards(NotifyCollectionZoneActiveAwards&& from) noexcept
    : NotifyCollectionZoneActiveAwards() {
    *this = ::std::move(from);
  }

  inline NotifyCollectionZoneActiveAwards& operator=(const NotifyCollectionZoneActiveAwards& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyCollectionZoneActiveAwards& operator=(NotifyCollectionZoneActiveAwards&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyCollectionZoneActiveAwards& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyCollectionZoneActiveAwards* internal_default_instance() {
    return reinterpret_cast<const NotifyCollectionZoneActiveAwards*>(
               &_NotifyCollectionZoneActiveAwards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    187;

  friend void swap(NotifyCollectionZoneActiveAwards& a, NotifyCollectionZoneActiveAwards& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyCollectionZoneActiveAwards* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyCollectionZoneActiveAwards* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyCollectionZoneActiveAwards* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyCollectionZoneActiveAwards>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyCollectionZoneActiveAwards& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyCollectionZoneActiveAwards& from) {
    NotifyCollectionZoneActiveAwards::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyCollectionZoneActiveAwards* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyCollectionZoneActiveAwards";
  }
  protected:
  explicit NotifyCollectionZoneActiveAwards(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZoneActiveAwardsFieldNumber = 1,
  };
  // repeated .idlepb.CollectionZoneActiveAwardData zone_active_awards = 1;
  int zone_active_awards_size() const;
  private:
  int _internal_zone_active_awards_size() const;
  public:
  void clear_zone_active_awards();
  ::idlepb::CollectionZoneActiveAwardData* mutable_zone_active_awards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionZoneActiveAwardData >*
      mutable_zone_active_awards();
  private:
  const ::idlepb::CollectionZoneActiveAwardData& _internal_zone_active_awards(int index) const;
  ::idlepb::CollectionZoneActiveAwardData* _internal_add_zone_active_awards();
  public:
  const ::idlepb::CollectionZoneActiveAwardData& zone_active_awards(int index) const;
  ::idlepb::CollectionZoneActiveAwardData* add_zone_active_awards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionZoneActiveAwardData >&
      zone_active_awards() const;

  // @@protoc_insertion_point(class_scope:idlepb.NotifyCollectionZoneActiveAwards)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionZoneActiveAwardData > zone_active_awards_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyRoleCollectionNextResetEnhanceTicks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyRoleCollectionNextResetEnhanceTicks) */ {
 public:
  inline NotifyRoleCollectionNextResetEnhanceTicks() : NotifyRoleCollectionNextResetEnhanceTicks(nullptr) {}
  ~NotifyRoleCollectionNextResetEnhanceTicks() override;
  explicit PROTOBUF_CONSTEXPR NotifyRoleCollectionNextResetEnhanceTicks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyRoleCollectionNextResetEnhanceTicks(const NotifyRoleCollectionNextResetEnhanceTicks& from);
  NotifyRoleCollectionNextResetEnhanceTicks(NotifyRoleCollectionNextResetEnhanceTicks&& from) noexcept
    : NotifyRoleCollectionNextResetEnhanceTicks() {
    *this = ::std::move(from);
  }

  inline NotifyRoleCollectionNextResetEnhanceTicks& operator=(const NotifyRoleCollectionNextResetEnhanceTicks& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyRoleCollectionNextResetEnhanceTicks& operator=(NotifyRoleCollectionNextResetEnhanceTicks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyRoleCollectionNextResetEnhanceTicks& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyRoleCollectionNextResetEnhanceTicks* internal_default_instance() {
    return reinterpret_cast<const NotifyRoleCollectionNextResetEnhanceTicks*>(
               &_NotifyRoleCollectionNextResetEnhanceTicks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    188;

  friend void swap(NotifyRoleCollectionNextResetEnhanceTicks& a, NotifyRoleCollectionNextResetEnhanceTicks& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyRoleCollectionNextResetEnhanceTicks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyRoleCollectionNextResetEnhanceTicks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyRoleCollectionNextResetEnhanceTicks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyRoleCollectionNextResetEnhanceTicks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyRoleCollectionNextResetEnhanceTicks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyRoleCollectionNextResetEnhanceTicks& from) {
    NotifyRoleCollectionNextResetEnhanceTicks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyRoleCollectionNextResetEnhanceTicks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyRoleCollectionNextResetEnhanceTicks";
  }
  protected:
  explicit NotifyRoleCollectionNextResetEnhanceTicks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextResetEnhanceTicksFieldNumber = 1,
  };
  // int64 next_reset_enhance_ticks = 1;
  void clear_next_reset_enhance_ticks();
  int64_t next_reset_enhance_ticks() const;
  void set_next_reset_enhance_ticks(int64_t value);
  private:
  int64_t _internal_next_reset_enhance_ticks() const;
  void _internal_set_next_reset_enhance_ticks(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyRoleCollectionNextResetEnhanceTicks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t next_reset_enhance_ticks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RoleBattleHistoryList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RoleBattleHistoryList) */ {
 public:
  inline RoleBattleHistoryList() : RoleBattleHistoryList(nullptr) {}
  ~RoleBattleHistoryList() override;
  explicit PROTOBUF_CONSTEXPR RoleBattleHistoryList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoleBattleHistoryList(const RoleBattleHistoryList& from);
  RoleBattleHistoryList(RoleBattleHistoryList&& from) noexcept
    : RoleBattleHistoryList() {
    *this = ::std::move(from);
  }

  inline RoleBattleHistoryList& operator=(const RoleBattleHistoryList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleBattleHistoryList& operator=(RoleBattleHistoryList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoleBattleHistoryList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoleBattleHistoryList* internal_default_instance() {
    return reinterpret_cast<const RoleBattleHistoryList*>(
               &_RoleBattleHistoryList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    189;

  friend void swap(RoleBattleHistoryList& a, RoleBattleHistoryList& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleBattleHistoryList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoleBattleHistoryList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoleBattleHistoryList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoleBattleHistoryList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoleBattleHistoryList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoleBattleHistoryList& from) {
    RoleBattleHistoryList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoleBattleHistoryList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RoleBattleHistoryList";
  }
  protected:
  explicit RoleBattleHistoryList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .idlepb.RoleBattleInfo entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::idlepb::RoleBattleInfo* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::RoleBattleInfo >*
      mutable_entries();
  private:
  const ::idlepb::RoleBattleInfo& _internal_entries(int index) const;
  ::idlepb::RoleBattleInfo* _internal_add_entries();
  public:
  const ::idlepb::RoleBattleInfo& entries(int index) const;
  ::idlepb::RoleBattleInfo* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::RoleBattleInfo >&
      entries() const;

  // @@protoc_insertion_point(class_scope:idlepb.RoleBattleHistoryList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::RoleBattleInfo > entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifySoloArenaChallengeOver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifySoloArenaChallengeOver) */ {
 public:
  inline NotifySoloArenaChallengeOver() : NotifySoloArenaChallengeOver(nullptr) {}
  ~NotifySoloArenaChallengeOver() override;
  explicit PROTOBUF_CONSTEXPR NotifySoloArenaChallengeOver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifySoloArenaChallengeOver(const NotifySoloArenaChallengeOver& from);
  NotifySoloArenaChallengeOver(NotifySoloArenaChallengeOver&& from) noexcept
    : NotifySoloArenaChallengeOver() {
    *this = ::std::move(from);
  }

  inline NotifySoloArenaChallengeOver& operator=(const NotifySoloArenaChallengeOver& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySoloArenaChallengeOver& operator=(NotifySoloArenaChallengeOver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySoloArenaChallengeOver& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySoloArenaChallengeOver* internal_default_instance() {
    return reinterpret_cast<const NotifySoloArenaChallengeOver*>(
               &_NotifySoloArenaChallengeOver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    190;

  friend void swap(NotifySoloArenaChallengeOver& a, NotifySoloArenaChallengeOver& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifySoloArenaChallengeOver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySoloArenaChallengeOver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySoloArenaChallengeOver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifySoloArenaChallengeOver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifySoloArenaChallengeOver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifySoloArenaChallengeOver& from) {
    NotifySoloArenaChallengeOver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifySoloArenaChallengeOver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifySoloArenaChallengeOver";
  }
  protected:
  explicit NotifySoloArenaChallengeOver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kWinFieldNumber = 1,
  };
  // .idlepb.BattleInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::idlepb::BattleInfo& info() const;
  PROTOBUF_NODISCARD ::idlepb::BattleInfo* release_info();
  ::idlepb::BattleInfo* mutable_info();
  void set_allocated_info(::idlepb::BattleInfo* info);
  private:
  const ::idlepb::BattleInfo& _internal_info() const;
  ::idlepb::BattleInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::idlepb::BattleInfo* info);
  ::idlepb::BattleInfo* unsafe_arena_release_info();

  // bool win = 1;
  void clear_win();
  bool win() const;
  void set_win(bool value);
  private:
  bool _internal_win() const;
  void _internal_set_win(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifySoloArenaChallengeOver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::BattleInfo* info_;
    bool win_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SoloArenaChallengeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SoloArenaChallengeReq) */ {
 public:
  inline SoloArenaChallengeReq() : SoloArenaChallengeReq(nullptr) {}
  ~SoloArenaChallengeReq() override;
  explicit PROTOBUF_CONSTEXPR SoloArenaChallengeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SoloArenaChallengeReq(const SoloArenaChallengeReq& from);
  SoloArenaChallengeReq(SoloArenaChallengeReq&& from) noexcept
    : SoloArenaChallengeReq() {
    *this = ::std::move(from);
  }

  inline SoloArenaChallengeReq& operator=(const SoloArenaChallengeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoloArenaChallengeReq& operator=(SoloArenaChallengeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoloArenaChallengeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoloArenaChallengeReq* internal_default_instance() {
    return reinterpret_cast<const SoloArenaChallengeReq*>(
               &_SoloArenaChallengeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    191;

  friend void swap(SoloArenaChallengeReq& a, SoloArenaChallengeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SoloArenaChallengeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoloArenaChallengeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoloArenaChallengeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SoloArenaChallengeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SoloArenaChallengeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SoloArenaChallengeReq& from) {
    SoloArenaChallengeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoloArenaChallengeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SoloArenaChallengeReq";
  }
  protected:
  explicit SoloArenaChallengeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetRoleIdFieldNumber = 1,
  };
  // int64 target_role_id = 1;
  void clear_target_role_id();
  int64_t target_role_id() const;
  void set_target_role_id(int64_t value);
  private:
  int64_t _internal_target_role_id() const;
  void _internal_set_target_role_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SoloArenaChallengeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t target_role_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SoloArenaChallengeAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SoloArenaChallengeAck) */ {
 public:
  inline SoloArenaChallengeAck() : SoloArenaChallengeAck(nullptr) {}
  ~SoloArenaChallengeAck() override;
  explicit PROTOBUF_CONSTEXPR SoloArenaChallengeAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SoloArenaChallengeAck(const SoloArenaChallengeAck& from);
  SoloArenaChallengeAck(SoloArenaChallengeAck&& from) noexcept
    : SoloArenaChallengeAck() {
    *this = ::std::move(from);
  }

  inline SoloArenaChallengeAck& operator=(const SoloArenaChallengeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoloArenaChallengeAck& operator=(SoloArenaChallengeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoloArenaChallengeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoloArenaChallengeAck* internal_default_instance() {
    return reinterpret_cast<const SoloArenaChallengeAck*>(
               &_SoloArenaChallengeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    192;

  friend void swap(SoloArenaChallengeAck& a, SoloArenaChallengeAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SoloArenaChallengeAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoloArenaChallengeAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoloArenaChallengeAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SoloArenaChallengeAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SoloArenaChallengeAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SoloArenaChallengeAck& from) {
    SoloArenaChallengeAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoloArenaChallengeAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SoloArenaChallengeAck";
  }
  protected:
  explicit SoloArenaChallengeAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SoloArenaChallengeAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SoloArenaQuickEndReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SoloArenaQuickEndReq) */ {
 public:
  inline SoloArenaQuickEndReq() : SoloArenaQuickEndReq(nullptr) {}
  ~SoloArenaQuickEndReq() override;
  explicit PROTOBUF_CONSTEXPR SoloArenaQuickEndReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SoloArenaQuickEndReq(const SoloArenaQuickEndReq& from);
  SoloArenaQuickEndReq(SoloArenaQuickEndReq&& from) noexcept
    : SoloArenaQuickEndReq() {
    *this = ::std::move(from);
  }

  inline SoloArenaQuickEndReq& operator=(const SoloArenaQuickEndReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoloArenaQuickEndReq& operator=(SoloArenaQuickEndReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoloArenaQuickEndReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoloArenaQuickEndReq* internal_default_instance() {
    return reinterpret_cast<const SoloArenaQuickEndReq*>(
               &_SoloArenaQuickEndReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    193;

  friend void swap(SoloArenaQuickEndReq& a, SoloArenaQuickEndReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SoloArenaQuickEndReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoloArenaQuickEndReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoloArenaQuickEndReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SoloArenaQuickEndReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SoloArenaQuickEndReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SoloArenaQuickEndReq& from) {
    SoloArenaQuickEndReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoloArenaQuickEndReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SoloArenaQuickEndReq";
  }
  protected:
  explicit SoloArenaQuickEndReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsExitFieldNumber = 1,
  };
  // bool is_exit = 1;
  void clear_is_exit();
  bool is_exit() const;
  void set_is_exit(bool value);
  private:
  bool _internal_is_exit() const;
  void _internal_set_is_exit(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SoloArenaQuickEndReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_exit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SoloArenaQuickEndAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.SoloArenaQuickEndAck) */ {
 public:
  inline SoloArenaQuickEndAck() : SoloArenaQuickEndAck(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SoloArenaQuickEndAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SoloArenaQuickEndAck(const SoloArenaQuickEndAck& from);
  SoloArenaQuickEndAck(SoloArenaQuickEndAck&& from) noexcept
    : SoloArenaQuickEndAck() {
    *this = ::std::move(from);
  }

  inline SoloArenaQuickEndAck& operator=(const SoloArenaQuickEndAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoloArenaQuickEndAck& operator=(SoloArenaQuickEndAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoloArenaQuickEndAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoloArenaQuickEndAck* internal_default_instance() {
    return reinterpret_cast<const SoloArenaQuickEndAck*>(
               &_SoloArenaQuickEndAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    194;

  friend void swap(SoloArenaQuickEndAck& a, SoloArenaQuickEndAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SoloArenaQuickEndAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoloArenaQuickEndAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoloArenaQuickEndAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SoloArenaQuickEndAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SoloArenaQuickEndAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SoloArenaQuickEndAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SoloArenaQuickEndAck";
  }
  protected:
  explicit SoloArenaQuickEndAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.SoloArenaQuickEndAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetSoloArenaHistoryListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetSoloArenaHistoryListReq) */ {
 public:
  inline GetSoloArenaHistoryListReq() : GetSoloArenaHistoryListReq(nullptr) {}
  ~GetSoloArenaHistoryListReq() override;
  explicit PROTOBUF_CONSTEXPR GetSoloArenaHistoryListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSoloArenaHistoryListReq(const GetSoloArenaHistoryListReq& from);
  GetSoloArenaHistoryListReq(GetSoloArenaHistoryListReq&& from) noexcept
    : GetSoloArenaHistoryListReq() {
    *this = ::std::move(from);
  }

  inline GetSoloArenaHistoryListReq& operator=(const GetSoloArenaHistoryListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSoloArenaHistoryListReq& operator=(GetSoloArenaHistoryListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSoloArenaHistoryListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSoloArenaHistoryListReq* internal_default_instance() {
    return reinterpret_cast<const GetSoloArenaHistoryListReq*>(
               &_GetSoloArenaHistoryListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    195;

  friend void swap(GetSoloArenaHistoryListReq& a, GetSoloArenaHistoryListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSoloArenaHistoryListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSoloArenaHistoryListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSoloArenaHistoryListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSoloArenaHistoryListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSoloArenaHistoryListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSoloArenaHistoryListReq& from) {
    GetSoloArenaHistoryListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSoloArenaHistoryListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetSoloArenaHistoryListReq";
  }
  protected:
  explicit GetSoloArenaHistoryListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .idlepb.SoloType type = 1;
  void clear_type();
  ::idlepb::SoloType type() const;
  void set_type(::idlepb::SoloType value);
  private:
  ::idlepb::SoloType _internal_type() const;
  void _internal_set_type(::idlepb::SoloType value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetSoloArenaHistoryListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetSoloArenaHistoryListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetSoloArenaHistoryListAck) */ {
 public:
  inline GetSoloArenaHistoryListAck() : GetSoloArenaHistoryListAck(nullptr) {}
  ~GetSoloArenaHistoryListAck() override;
  explicit PROTOBUF_CONSTEXPR GetSoloArenaHistoryListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSoloArenaHistoryListAck(const GetSoloArenaHistoryListAck& from);
  GetSoloArenaHistoryListAck(GetSoloArenaHistoryListAck&& from) noexcept
    : GetSoloArenaHistoryListAck() {
    *this = ::std::move(from);
  }

  inline GetSoloArenaHistoryListAck& operator=(const GetSoloArenaHistoryListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSoloArenaHistoryListAck& operator=(GetSoloArenaHistoryListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSoloArenaHistoryListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSoloArenaHistoryListAck* internal_default_instance() {
    return reinterpret_cast<const GetSoloArenaHistoryListAck*>(
               &_GetSoloArenaHistoryListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    196;

  friend void swap(GetSoloArenaHistoryListAck& a, GetSoloArenaHistoryListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSoloArenaHistoryListAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSoloArenaHistoryListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSoloArenaHistoryListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSoloArenaHistoryListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSoloArenaHistoryListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSoloArenaHistoryListAck& from) {
    GetSoloArenaHistoryListAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSoloArenaHistoryListAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetSoloArenaHistoryListAck";
  }
  protected:
  explicit GetSoloArenaHistoryListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleBattleHistoryList data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleBattleHistoryList& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleBattleHistoryList* release_data();
  ::idlepb::RoleBattleHistoryList* mutable_data();
  void set_allocated_data(::idlepb::RoleBattleHistoryList* data);
  private:
  const ::idlepb::RoleBattleHistoryList& _internal_data() const;
  ::idlepb::RoleBattleHistoryList* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleBattleHistoryList* data);
  ::idlepb::RoleBattleHistoryList* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetSoloArenaHistoryListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleBattleHistoryList* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReplaySoloArenaHistoryReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReplaySoloArenaHistoryReq) */ {
 public:
  inline ReplaySoloArenaHistoryReq() : ReplaySoloArenaHistoryReq(nullptr) {}
  ~ReplaySoloArenaHistoryReq() override;
  explicit PROTOBUF_CONSTEXPR ReplaySoloArenaHistoryReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplaySoloArenaHistoryReq(const ReplaySoloArenaHistoryReq& from);
  ReplaySoloArenaHistoryReq(ReplaySoloArenaHistoryReq&& from) noexcept
    : ReplaySoloArenaHistoryReq() {
    *this = ::std::move(from);
  }

  inline ReplaySoloArenaHistoryReq& operator=(const ReplaySoloArenaHistoryReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplaySoloArenaHistoryReq& operator=(ReplaySoloArenaHistoryReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplaySoloArenaHistoryReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplaySoloArenaHistoryReq* internal_default_instance() {
    return reinterpret_cast<const ReplaySoloArenaHistoryReq*>(
               &_ReplaySoloArenaHistoryReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    197;

  friend void swap(ReplaySoloArenaHistoryReq& a, ReplaySoloArenaHistoryReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplaySoloArenaHistoryReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplaySoloArenaHistoryReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplaySoloArenaHistoryReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplaySoloArenaHistoryReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplaySoloArenaHistoryReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplaySoloArenaHistoryReq& from) {
    ReplaySoloArenaHistoryReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplaySoloArenaHistoryReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReplaySoloArenaHistoryReq";
  }
  protected:
  explicit ReplaySoloArenaHistoryReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistoryWorldIdFieldNumber = 1,
  };
  // uint64 history_world_id = 1;
  void clear_history_world_id();
  uint64_t history_world_id() const;
  void set_history_world_id(uint64_t value);
  private:
  uint64_t _internal_history_world_id() const;
  void _internal_set_history_world_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReplaySoloArenaHistoryReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t history_world_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReplaySoloArenaHistoryAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReplaySoloArenaHistoryAck) */ {
 public:
  inline ReplaySoloArenaHistoryAck() : ReplaySoloArenaHistoryAck(nullptr) {}
  ~ReplaySoloArenaHistoryAck() override;
  explicit PROTOBUF_CONSTEXPR ReplaySoloArenaHistoryAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplaySoloArenaHistoryAck(const ReplaySoloArenaHistoryAck& from);
  ReplaySoloArenaHistoryAck(ReplaySoloArenaHistoryAck&& from) noexcept
    : ReplaySoloArenaHistoryAck() {
    *this = ::std::move(from);
  }

  inline ReplaySoloArenaHistoryAck& operator=(const ReplaySoloArenaHistoryAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplaySoloArenaHistoryAck& operator=(ReplaySoloArenaHistoryAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplaySoloArenaHistoryAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplaySoloArenaHistoryAck* internal_default_instance() {
    return reinterpret_cast<const ReplaySoloArenaHistoryAck*>(
               &_ReplaySoloArenaHistoryAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    198;

  friend void swap(ReplaySoloArenaHistoryAck& a, ReplaySoloArenaHistoryAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplaySoloArenaHistoryAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplaySoloArenaHistoryAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplaySoloArenaHistoryAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplaySoloArenaHistoryAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplaySoloArenaHistoryAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplaySoloArenaHistoryAck& from) {
    ReplaySoloArenaHistoryAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplaySoloArenaHistoryAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReplaySoloArenaHistoryAck";
  }
  protected:
  explicit ReplaySoloArenaHistoryAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.CompressedData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::CompressedData& data() const;
  PROTOBUF_NODISCARD ::idlepb::CompressedData* release_data();
  ::idlepb::CompressedData* mutable_data();
  void set_allocated_data(::idlepb::CompressedData* data);
  private:
  const ::idlepb::CompressedData& _internal_data() const;
  ::idlepb::CompressedData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::CompressedData* data);
  ::idlepb::CompressedData* unsafe_arena_release_data();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReplaySoloArenaHistoryAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::CompressedData* data_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetBattleHistoryInfoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetBattleHistoryInfoReq) */ {
 public:
  inline GetBattleHistoryInfoReq() : GetBattleHistoryInfoReq(nullptr) {}
  ~GetBattleHistoryInfoReq() override;
  explicit PROTOBUF_CONSTEXPR GetBattleHistoryInfoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBattleHistoryInfoReq(const GetBattleHistoryInfoReq& from);
  GetBattleHistoryInfoReq(GetBattleHistoryInfoReq&& from) noexcept
    : GetBattleHistoryInfoReq() {
    *this = ::std::move(from);
  }

  inline GetBattleHistoryInfoReq& operator=(const GetBattleHistoryInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBattleHistoryInfoReq& operator=(GetBattleHistoryInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBattleHistoryInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBattleHistoryInfoReq* internal_default_instance() {
    return reinterpret_cast<const GetBattleHistoryInfoReq*>(
               &_GetBattleHistoryInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    199;

  friend void swap(GetBattleHistoryInfoReq& a, GetBattleHistoryInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBattleHistoryInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBattleHistoryInfoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBattleHistoryInfoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBattleHistoryInfoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBattleHistoryInfoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBattleHistoryInfoReq& from) {
    GetBattleHistoryInfoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBattleHistoryInfoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetBattleHistoryInfoReq";
  }
  protected:
  explicit GetBattleHistoryInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistoryWorldIdFieldNumber = 1,
  };
  // uint64 history_world_id = 1;
  void clear_history_world_id();
  uint64_t history_world_id() const;
  void set_history_world_id(uint64_t value);
  private:
  uint64_t _internal_history_world_id() const;
  void _internal_set_history_world_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetBattleHistoryInfoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t history_world_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetBattleHistoryInfoAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetBattleHistoryInfoAck) */ {
 public:
  inline GetBattleHistoryInfoAck() : GetBattleHistoryInfoAck(nullptr) {}
  ~GetBattleHistoryInfoAck() override;
  explicit PROTOBUF_CONSTEXPR GetBattleHistoryInfoAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBattleHistoryInfoAck(const GetBattleHistoryInfoAck& from);
  GetBattleHistoryInfoAck(GetBattleHistoryInfoAck&& from) noexcept
    : GetBattleHistoryInfoAck() {
    *this = ::std::move(from);
  }

  inline GetBattleHistoryInfoAck& operator=(const GetBattleHistoryInfoAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBattleHistoryInfoAck& operator=(GetBattleHistoryInfoAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBattleHistoryInfoAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBattleHistoryInfoAck* internal_default_instance() {
    return reinterpret_cast<const GetBattleHistoryInfoAck*>(
               &_GetBattleHistoryInfoAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    200;

  friend void swap(GetBattleHistoryInfoAck& a, GetBattleHistoryInfoAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBattleHistoryInfoAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBattleHistoryInfoAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBattleHistoryInfoAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBattleHistoryInfoAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBattleHistoryInfoAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBattleHistoryInfoAck& from) {
    GetBattleHistoryInfoAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBattleHistoryInfoAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetBattleHistoryInfoAck";
  }
  protected:
  explicit GetBattleHistoryInfoAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.BattleInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::idlepb::BattleInfo& info() const;
  PROTOBUF_NODISCARD ::idlepb::BattleInfo* release_info();
  ::idlepb::BattleInfo* mutable_info();
  void set_allocated_info(::idlepb::BattleInfo* info);
  private:
  const ::idlepb::BattleInfo& _internal_info() const;
  ::idlepb::BattleInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::idlepb::BattleInfo* info);
  ::idlepb::BattleInfo* unsafe_arena_release_info();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetBattleHistoryInfoAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::BattleInfo* info_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyEnterOpenClientWorld final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyEnterOpenClientWorld) */ {
 public:
  inline NotifyEnterOpenClientWorld() : NotifyEnterOpenClientWorld(nullptr) {}
  ~NotifyEnterOpenClientWorld() override;
  explicit PROTOBUF_CONSTEXPR NotifyEnterOpenClientWorld(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyEnterOpenClientWorld(const NotifyEnterOpenClientWorld& from);
  NotifyEnterOpenClientWorld(NotifyEnterOpenClientWorld&& from) noexcept
    : NotifyEnterOpenClientWorld() {
    *this = ::std::move(from);
  }

  inline NotifyEnterOpenClientWorld& operator=(const NotifyEnterOpenClientWorld& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyEnterOpenClientWorld& operator=(NotifyEnterOpenClientWorld&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyEnterOpenClientWorld& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyEnterOpenClientWorld* internal_default_instance() {
    return reinterpret_cast<const NotifyEnterOpenClientWorld*>(
               &_NotifyEnterOpenClientWorld_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    201;

  friend void swap(NotifyEnterOpenClientWorld& a, NotifyEnterOpenClientWorld& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyEnterOpenClientWorld* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyEnterOpenClientWorld* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyEnterOpenClientWorld* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyEnterOpenClientWorld>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyEnterOpenClientWorld& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyEnterOpenClientWorld& from) {
    NotifyEnterOpenClientWorld::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyEnterOpenClientWorld* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyEnterOpenClientWorld";
  }
  protected:
  explicit NotifyEnterOpenClientWorld(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldCfgIdFieldNumber = 1,
  };
  // int32 world_cfg_id = 1;
  void clear_world_cfg_id();
  int32_t world_cfg_id() const;
  void set_world_cfg_id(int32_t value);
  private:
  int32_t _internal_world_cfg_id() const;
  void _internal_set_world_cfg_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyEnterOpenClientWorld)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t world_cfg_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyMonsterTowerData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyMonsterTowerData) */ {
 public:
  inline NotifyMonsterTowerData() : NotifyMonsterTowerData(nullptr) {}
  ~NotifyMonsterTowerData() override;
  explicit PROTOBUF_CONSTEXPR NotifyMonsterTowerData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyMonsterTowerData(const NotifyMonsterTowerData& from);
  NotifyMonsterTowerData(NotifyMonsterTowerData&& from) noexcept
    : NotifyMonsterTowerData() {
    *this = ::std::move(from);
  }

  inline NotifyMonsterTowerData& operator=(const NotifyMonsterTowerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyMonsterTowerData& operator=(NotifyMonsterTowerData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyMonsterTowerData& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyMonsterTowerData* internal_default_instance() {
    return reinterpret_cast<const NotifyMonsterTowerData*>(
               &_NotifyMonsterTowerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    202;

  friend void swap(NotifyMonsterTowerData& a, NotifyMonsterTowerData& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyMonsterTowerData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyMonsterTowerData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyMonsterTowerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyMonsterTowerData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyMonsterTowerData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyMonsterTowerData& from) {
    NotifyMonsterTowerData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyMonsterTowerData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyMonsterTowerData";
  }
  protected:
  explicit NotifyMonsterTowerData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleMonsterTowerData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleMonsterTowerData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleMonsterTowerData* release_data();
  ::idlepb::RoleMonsterTowerData* mutable_data();
  void set_allocated_data(::idlepb::RoleMonsterTowerData* data);
  private:
  const ::idlepb::RoleMonsterTowerData& _internal_data() const;
  ::idlepb::RoleMonsterTowerData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleMonsterTowerData* data);
  ::idlepb::RoleMonsterTowerData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.NotifyMonsterTowerData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleMonsterTowerData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyMonsterTowerChallengeOver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyMonsterTowerChallengeOver) */ {
 public:
  inline NotifyMonsterTowerChallengeOver() : NotifyMonsterTowerChallengeOver(nullptr) {}
  ~NotifyMonsterTowerChallengeOver() override;
  explicit PROTOBUF_CONSTEXPR NotifyMonsterTowerChallengeOver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyMonsterTowerChallengeOver(const NotifyMonsterTowerChallengeOver& from);
  NotifyMonsterTowerChallengeOver(NotifyMonsterTowerChallengeOver&& from) noexcept
    : NotifyMonsterTowerChallengeOver() {
    *this = ::std::move(from);
  }

  inline NotifyMonsterTowerChallengeOver& operator=(const NotifyMonsterTowerChallengeOver& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyMonsterTowerChallengeOver& operator=(NotifyMonsterTowerChallengeOver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyMonsterTowerChallengeOver& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyMonsterTowerChallengeOver* internal_default_instance() {
    return reinterpret_cast<const NotifyMonsterTowerChallengeOver*>(
               &_NotifyMonsterTowerChallengeOver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    203;

  friend void swap(NotifyMonsterTowerChallengeOver& a, NotifyMonsterTowerChallengeOver& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyMonsterTowerChallengeOver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyMonsterTowerChallengeOver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyMonsterTowerChallengeOver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyMonsterTowerChallengeOver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyMonsterTowerChallengeOver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyMonsterTowerChallengeOver& from) {
    NotifyMonsterTowerChallengeOver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyMonsterTowerChallengeOver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyMonsterTowerChallengeOver";
  }
  protected:
  explicit NotifyMonsterTowerChallengeOver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFloorFieldNumber = 1,
    kWinFieldNumber = 2,
  };
  // int32 floor = 1;
  void clear_floor();
  int32_t floor() const;
  void set_floor(int32_t value);
  private:
  int32_t _internal_floor() const;
  void _internal_set_floor(int32_t value);
  public:

  // bool win = 2;
  void clear_win();
  bool win() const;
  void set_win(bool value);
  private:
  bool _internal_win() const;
  void _internal_set_win(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyMonsterTowerChallengeOver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t floor_;
    bool win_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API MonsterTowerChallengeReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.MonsterTowerChallengeReq) */ {
 public:
  inline MonsterTowerChallengeReq() : MonsterTowerChallengeReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MonsterTowerChallengeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonsterTowerChallengeReq(const MonsterTowerChallengeReq& from);
  MonsterTowerChallengeReq(MonsterTowerChallengeReq&& from) noexcept
    : MonsterTowerChallengeReq() {
    *this = ::std::move(from);
  }

  inline MonsterTowerChallengeReq& operator=(const MonsterTowerChallengeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterTowerChallengeReq& operator=(MonsterTowerChallengeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterTowerChallengeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonsterTowerChallengeReq* internal_default_instance() {
    return reinterpret_cast<const MonsterTowerChallengeReq*>(
               &_MonsterTowerChallengeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    204;

  friend void swap(MonsterTowerChallengeReq& a, MonsterTowerChallengeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MonsterTowerChallengeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterTowerChallengeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterTowerChallengeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonsterTowerChallengeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MonsterTowerChallengeReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MonsterTowerChallengeReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.MonsterTowerChallengeReq";
  }
  protected:
  explicit MonsterTowerChallengeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.MonsterTowerChallengeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API MonsterTowerChallengeAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.MonsterTowerChallengeAck) */ {
 public:
  inline MonsterTowerChallengeAck() : MonsterTowerChallengeAck(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MonsterTowerChallengeAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonsterTowerChallengeAck(const MonsterTowerChallengeAck& from);
  MonsterTowerChallengeAck(MonsterTowerChallengeAck&& from) noexcept
    : MonsterTowerChallengeAck() {
    *this = ::std::move(from);
  }

  inline MonsterTowerChallengeAck& operator=(const MonsterTowerChallengeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterTowerChallengeAck& operator=(MonsterTowerChallengeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterTowerChallengeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonsterTowerChallengeAck* internal_default_instance() {
    return reinterpret_cast<const MonsterTowerChallengeAck*>(
               &_MonsterTowerChallengeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    205;

  friend void swap(MonsterTowerChallengeAck& a, MonsterTowerChallengeAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MonsterTowerChallengeAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterTowerChallengeAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterTowerChallengeAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonsterTowerChallengeAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MonsterTowerChallengeAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MonsterTowerChallengeAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.MonsterTowerChallengeAck";
  }
  protected:
  explicit MonsterTowerChallengeAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.MonsterTowerChallengeAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API MonsterTowerDrawIdleAwardReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.MonsterTowerDrawIdleAwardReq) */ {
 public:
  inline MonsterTowerDrawIdleAwardReq() : MonsterTowerDrawIdleAwardReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MonsterTowerDrawIdleAwardReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonsterTowerDrawIdleAwardReq(const MonsterTowerDrawIdleAwardReq& from);
  MonsterTowerDrawIdleAwardReq(MonsterTowerDrawIdleAwardReq&& from) noexcept
    : MonsterTowerDrawIdleAwardReq() {
    *this = ::std::move(from);
  }

  inline MonsterTowerDrawIdleAwardReq& operator=(const MonsterTowerDrawIdleAwardReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterTowerDrawIdleAwardReq& operator=(MonsterTowerDrawIdleAwardReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterTowerDrawIdleAwardReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonsterTowerDrawIdleAwardReq* internal_default_instance() {
    return reinterpret_cast<const MonsterTowerDrawIdleAwardReq*>(
               &_MonsterTowerDrawIdleAwardReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    206;

  friend void swap(MonsterTowerDrawIdleAwardReq& a, MonsterTowerDrawIdleAwardReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MonsterTowerDrawIdleAwardReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterTowerDrawIdleAwardReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterTowerDrawIdleAwardReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonsterTowerDrawIdleAwardReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MonsterTowerDrawIdleAwardReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MonsterTowerDrawIdleAwardReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.MonsterTowerDrawIdleAwardReq";
  }
  protected:
  explicit MonsterTowerDrawIdleAwardReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.MonsterTowerDrawIdleAwardReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API MonsterTowerDrawIdleAwardAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.MonsterTowerDrawIdleAwardAck) */ {
 public:
  inline MonsterTowerDrawIdleAwardAck() : MonsterTowerDrawIdleAwardAck(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MonsterTowerDrawIdleAwardAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonsterTowerDrawIdleAwardAck(const MonsterTowerDrawIdleAwardAck& from);
  MonsterTowerDrawIdleAwardAck(MonsterTowerDrawIdleAwardAck&& from) noexcept
    : MonsterTowerDrawIdleAwardAck() {
    *this = ::std::move(from);
  }

  inline MonsterTowerDrawIdleAwardAck& operator=(const MonsterTowerDrawIdleAwardAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterTowerDrawIdleAwardAck& operator=(MonsterTowerDrawIdleAwardAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterTowerDrawIdleAwardAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonsterTowerDrawIdleAwardAck* internal_default_instance() {
    return reinterpret_cast<const MonsterTowerDrawIdleAwardAck*>(
               &_MonsterTowerDrawIdleAwardAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    207;

  friend void swap(MonsterTowerDrawIdleAwardAck& a, MonsterTowerDrawIdleAwardAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MonsterTowerDrawIdleAwardAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterTowerDrawIdleAwardAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterTowerDrawIdleAwardAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonsterTowerDrawIdleAwardAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MonsterTowerDrawIdleAwardAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MonsterTowerDrawIdleAwardAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.MonsterTowerDrawIdleAwardAck";
  }
  protected:
  explicit MonsterTowerDrawIdleAwardAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.MonsterTowerDrawIdleAwardAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API MonsterTowerClosedDoorTrainingReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.MonsterTowerClosedDoorTrainingReq) */ {
 public:
  inline MonsterTowerClosedDoorTrainingReq() : MonsterTowerClosedDoorTrainingReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MonsterTowerClosedDoorTrainingReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonsterTowerClosedDoorTrainingReq(const MonsterTowerClosedDoorTrainingReq& from);
  MonsterTowerClosedDoorTrainingReq(MonsterTowerClosedDoorTrainingReq&& from) noexcept
    : MonsterTowerClosedDoorTrainingReq() {
    *this = ::std::move(from);
  }

  inline MonsterTowerClosedDoorTrainingReq& operator=(const MonsterTowerClosedDoorTrainingReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterTowerClosedDoorTrainingReq& operator=(MonsterTowerClosedDoorTrainingReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterTowerClosedDoorTrainingReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonsterTowerClosedDoorTrainingReq* internal_default_instance() {
    return reinterpret_cast<const MonsterTowerClosedDoorTrainingReq*>(
               &_MonsterTowerClosedDoorTrainingReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    208;

  friend void swap(MonsterTowerClosedDoorTrainingReq& a, MonsterTowerClosedDoorTrainingReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MonsterTowerClosedDoorTrainingReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterTowerClosedDoorTrainingReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterTowerClosedDoorTrainingReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonsterTowerClosedDoorTrainingReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MonsterTowerClosedDoorTrainingReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MonsterTowerClosedDoorTrainingReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.MonsterTowerClosedDoorTrainingReq";
  }
  protected:
  explicit MonsterTowerClosedDoorTrainingReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.MonsterTowerClosedDoorTrainingReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API MonsterTowerClosedDoorTrainingAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.MonsterTowerClosedDoorTrainingAck) */ {
 public:
  inline MonsterTowerClosedDoorTrainingAck() : MonsterTowerClosedDoorTrainingAck(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MonsterTowerClosedDoorTrainingAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonsterTowerClosedDoorTrainingAck(const MonsterTowerClosedDoorTrainingAck& from);
  MonsterTowerClosedDoorTrainingAck(MonsterTowerClosedDoorTrainingAck&& from) noexcept
    : MonsterTowerClosedDoorTrainingAck() {
    *this = ::std::move(from);
  }

  inline MonsterTowerClosedDoorTrainingAck& operator=(const MonsterTowerClosedDoorTrainingAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterTowerClosedDoorTrainingAck& operator=(MonsterTowerClosedDoorTrainingAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterTowerClosedDoorTrainingAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonsterTowerClosedDoorTrainingAck* internal_default_instance() {
    return reinterpret_cast<const MonsterTowerClosedDoorTrainingAck*>(
               &_MonsterTowerClosedDoorTrainingAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    209;

  friend void swap(MonsterTowerClosedDoorTrainingAck& a, MonsterTowerClosedDoorTrainingAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MonsterTowerClosedDoorTrainingAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterTowerClosedDoorTrainingAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterTowerClosedDoorTrainingAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonsterTowerClosedDoorTrainingAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MonsterTowerClosedDoorTrainingAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MonsterTowerClosedDoorTrainingAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.MonsterTowerClosedDoorTrainingAck";
  }
  protected:
  explicit MonsterTowerClosedDoorTrainingAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.MonsterTowerClosedDoorTrainingAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API MonsterTowerQuickEndReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.MonsterTowerQuickEndReq) */ {
 public:
  inline MonsterTowerQuickEndReq() : MonsterTowerQuickEndReq(nullptr) {}
  ~MonsterTowerQuickEndReq() override;
  explicit PROTOBUF_CONSTEXPR MonsterTowerQuickEndReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonsterTowerQuickEndReq(const MonsterTowerQuickEndReq& from);
  MonsterTowerQuickEndReq(MonsterTowerQuickEndReq&& from) noexcept
    : MonsterTowerQuickEndReq() {
    *this = ::std::move(from);
  }

  inline MonsterTowerQuickEndReq& operator=(const MonsterTowerQuickEndReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterTowerQuickEndReq& operator=(MonsterTowerQuickEndReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterTowerQuickEndReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonsterTowerQuickEndReq* internal_default_instance() {
    return reinterpret_cast<const MonsterTowerQuickEndReq*>(
               &_MonsterTowerQuickEndReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    210;

  friend void swap(MonsterTowerQuickEndReq& a, MonsterTowerQuickEndReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MonsterTowerQuickEndReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterTowerQuickEndReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterTowerQuickEndReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonsterTowerQuickEndReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MonsterTowerQuickEndReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MonsterTowerQuickEndReq& from) {
    MonsterTowerQuickEndReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonsterTowerQuickEndReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.MonsterTowerQuickEndReq";
  }
  protected:
  explicit MonsterTowerQuickEndReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsExitFieldNumber = 1,
  };
  // bool is_exit = 1;
  void clear_is_exit();
  bool is_exit() const;
  void set_is_exit(bool value);
  private:
  bool _internal_is_exit() const;
  void _internal_set_is_exit(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.MonsterTowerQuickEndReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_exit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API MonsterTowerQuickEndAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.MonsterTowerQuickEndAck) */ {
 public:
  inline MonsterTowerQuickEndAck() : MonsterTowerQuickEndAck(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MonsterTowerQuickEndAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonsterTowerQuickEndAck(const MonsterTowerQuickEndAck& from);
  MonsterTowerQuickEndAck(MonsterTowerQuickEndAck&& from) noexcept
    : MonsterTowerQuickEndAck() {
    *this = ::std::move(from);
  }

  inline MonsterTowerQuickEndAck& operator=(const MonsterTowerQuickEndAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonsterTowerQuickEndAck& operator=(MonsterTowerQuickEndAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonsterTowerQuickEndAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonsterTowerQuickEndAck* internal_default_instance() {
    return reinterpret_cast<const MonsterTowerQuickEndAck*>(
               &_MonsterTowerQuickEndAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    211;

  friend void swap(MonsterTowerQuickEndAck& a, MonsterTowerQuickEndAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MonsterTowerQuickEndAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonsterTowerQuickEndAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonsterTowerQuickEndAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonsterTowerQuickEndAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MonsterTowerQuickEndAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MonsterTowerQuickEndAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.MonsterTowerQuickEndAck";
  }
  protected:
  explicit MonsterTowerQuickEndAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.MonsterTowerQuickEndAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyFightModeData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyFightModeData) */ {
 public:
  inline NotifyFightModeData() : NotifyFightModeData(nullptr) {}
  ~NotifyFightModeData() override;
  explicit PROTOBUF_CONSTEXPR NotifyFightModeData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyFightModeData(const NotifyFightModeData& from);
  NotifyFightModeData(NotifyFightModeData&& from) noexcept
    : NotifyFightModeData() {
    *this = ::std::move(from);
  }

  inline NotifyFightModeData& operator=(const NotifyFightModeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyFightModeData& operator=(NotifyFightModeData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyFightModeData& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyFightModeData* internal_default_instance() {
    return reinterpret_cast<const NotifyFightModeData*>(
               &_NotifyFightModeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    212;

  friend void swap(NotifyFightModeData& a, NotifyFightModeData& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyFightModeData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyFightModeData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyFightModeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyFightModeData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyFightModeData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyFightModeData& from) {
    NotifyFightModeData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyFightModeData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyFightModeData";
  }
  protected:
  explicit NotifyFightModeData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleFightModeData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleFightModeData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleFightModeData* release_data();
  ::idlepb::RoleFightModeData* mutable_data();
  void set_allocated_data(::idlepb::RoleFightModeData* data);
  private:
  const ::idlepb::RoleFightModeData& _internal_data() const;
  ::idlepb::RoleFightModeData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleFightModeData* data);
  ::idlepb::RoleFightModeData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.NotifyFightModeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleFightModeData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetFightModeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetFightModeReq) */ {
 public:
  inline SetFightModeReq() : SetFightModeReq(nullptr) {}
  ~SetFightModeReq() override;
  explicit PROTOBUF_CONSTEXPR SetFightModeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetFightModeReq(const SetFightModeReq& from);
  SetFightModeReq(SetFightModeReq&& from) noexcept
    : SetFightModeReq() {
    *this = ::std::move(from);
  }

  inline SetFightModeReq& operator=(const SetFightModeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFightModeReq& operator=(SetFightModeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFightModeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFightModeReq* internal_default_instance() {
    return reinterpret_cast<const SetFightModeReq*>(
               &_SetFightModeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    213;

  friend void swap(SetFightModeReq& a, SetFightModeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFightModeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFightModeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFightModeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFightModeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetFightModeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetFightModeReq& from) {
    SetFightModeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetFightModeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetFightModeReq";
  }
  protected:
  explicit SetFightModeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // .idlepb.FightMode mode = 1;
  void clear_mode();
  ::idlepb::FightMode mode() const;
  void set_mode(::idlepb::FightMode value);
  private:
  ::idlepb::FightMode _internal_mode() const;
  void _internal_set_mode(::idlepb::FightMode value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetFightModeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetFightModeAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetFightModeAck) */ {
 public:
  inline SetFightModeAck() : SetFightModeAck(nullptr) {}
  ~SetFightModeAck() override;
  explicit PROTOBUF_CONSTEXPR SetFightModeAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetFightModeAck(const SetFightModeAck& from);
  SetFightModeAck(SetFightModeAck&& from) noexcept
    : SetFightModeAck() {
    *this = ::std::move(from);
  }

  inline SetFightModeAck& operator=(const SetFightModeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFightModeAck& operator=(SetFightModeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFightModeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFightModeAck* internal_default_instance() {
    return reinterpret_cast<const SetFightModeAck*>(
               &_SetFightModeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    214;

  friend void swap(SetFightModeAck& a, SetFightModeAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFightModeAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFightModeAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFightModeAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFightModeAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetFightModeAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetFightModeAck& from) {
    SetFightModeAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetFightModeAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetFightModeAck";
  }
  protected:
  explicit SetFightModeAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // .idlepb.SetFightModeAckErrorCode error_code = 2;
  void clear_error_code();
  ::idlepb::SetFightModeAckErrorCode error_code() const;
  void set_error_code(::idlepb::SetFightModeAckErrorCode value);
  private:
  ::idlepb::SetFightModeAckErrorCode _internal_error_code() const;
  void _internal_set_error_code(::idlepb::SetFightModeAckErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetFightModeAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    int error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyInventorySpaceNum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyInventorySpaceNum) */ {
 public:
  inline NotifyInventorySpaceNum() : NotifyInventorySpaceNum(nullptr) {}
  ~NotifyInventorySpaceNum() override;
  explicit PROTOBUF_CONSTEXPR NotifyInventorySpaceNum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyInventorySpaceNum(const NotifyInventorySpaceNum& from);
  NotifyInventorySpaceNum(NotifyInventorySpaceNum&& from) noexcept
    : NotifyInventorySpaceNum() {
    *this = ::std::move(from);
  }

  inline NotifyInventorySpaceNum& operator=(const NotifyInventorySpaceNum& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyInventorySpaceNum& operator=(NotifyInventorySpaceNum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyInventorySpaceNum& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyInventorySpaceNum* internal_default_instance() {
    return reinterpret_cast<const NotifyInventorySpaceNum*>(
               &_NotifyInventorySpaceNum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    215;

  friend void swap(NotifyInventorySpaceNum& a, NotifyInventorySpaceNum& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyInventorySpaceNum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyInventorySpaceNum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyInventorySpaceNum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyInventorySpaceNum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyInventorySpaceNum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyInventorySpaceNum& from) {
    NotifyInventorySpaceNum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyInventorySpaceNum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyInventorySpaceNum";
  }
  protected:
  explicit NotifyInventorySpaceNum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumFieldNumber = 1,
  };
  // int32 num = 1;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyInventorySpaceNum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyInventoryFullMailItem final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.NotifyInventoryFullMailItem) */ {
 public:
  inline NotifyInventoryFullMailItem() : NotifyInventoryFullMailItem(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NotifyInventoryFullMailItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyInventoryFullMailItem(const NotifyInventoryFullMailItem& from);
  NotifyInventoryFullMailItem(NotifyInventoryFullMailItem&& from) noexcept
    : NotifyInventoryFullMailItem() {
    *this = ::std::move(from);
  }

  inline NotifyInventoryFullMailItem& operator=(const NotifyInventoryFullMailItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyInventoryFullMailItem& operator=(NotifyInventoryFullMailItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyInventoryFullMailItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyInventoryFullMailItem* internal_default_instance() {
    return reinterpret_cast<const NotifyInventoryFullMailItem*>(
               &_NotifyInventoryFullMailItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    216;

  friend void swap(NotifyInventoryFullMailItem& a, NotifyInventoryFullMailItem& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyInventoryFullMailItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyInventoryFullMailItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyInventoryFullMailItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyInventoryFullMailItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NotifyInventoryFullMailItem& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NotifyInventoryFullMailItem& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyInventoryFullMailItem";
  }
  protected:
  explicit NotifyInventoryFullMailItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.NotifyInventoryFullMailItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyQiCollectorRank final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyQiCollectorRank) */ {
 public:
  inline NotifyQiCollectorRank() : NotifyQiCollectorRank(nullptr) {}
  ~NotifyQiCollectorRank() override;
  explicit PROTOBUF_CONSTEXPR NotifyQiCollectorRank(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyQiCollectorRank(const NotifyQiCollectorRank& from);
  NotifyQiCollectorRank(NotifyQiCollectorRank&& from) noexcept
    : NotifyQiCollectorRank() {
    *this = ::std::move(from);
  }

  inline NotifyQiCollectorRank& operator=(const NotifyQiCollectorRank& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyQiCollectorRank& operator=(NotifyQiCollectorRank&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyQiCollectorRank& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyQiCollectorRank* internal_default_instance() {
    return reinterpret_cast<const NotifyQiCollectorRank*>(
               &_NotifyQiCollectorRank_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    217;

  friend void swap(NotifyQiCollectorRank& a, NotifyQiCollectorRank& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyQiCollectorRank* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyQiCollectorRank* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyQiCollectorRank* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyQiCollectorRank>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyQiCollectorRank& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyQiCollectorRank& from) {
    NotifyQiCollectorRank::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyQiCollectorRank* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyQiCollectorRank";
  }
  protected:
  explicit NotifyQiCollectorRank(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRankFieldNumber = 1,
  };
  // int32 rank = 1;
  void clear_rank();
  int32_t rank() const;
  void set_rank(int32_t value);
  private:
  int32_t _internal_rank() const;
  void _internal_set_rank(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyQiCollectorRank)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t rank_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UpgradeQiCollectorReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.UpgradeQiCollectorReq) */ {
 public:
  inline UpgradeQiCollectorReq() : UpgradeQiCollectorReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpgradeQiCollectorReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpgradeQiCollectorReq(const UpgradeQiCollectorReq& from);
  UpgradeQiCollectorReq(UpgradeQiCollectorReq&& from) noexcept
    : UpgradeQiCollectorReq() {
    *this = ::std::move(from);
  }

  inline UpgradeQiCollectorReq& operator=(const UpgradeQiCollectorReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpgradeQiCollectorReq& operator=(UpgradeQiCollectorReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpgradeQiCollectorReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpgradeQiCollectorReq* internal_default_instance() {
    return reinterpret_cast<const UpgradeQiCollectorReq*>(
               &_UpgradeQiCollectorReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    218;

  friend void swap(UpgradeQiCollectorReq& a, UpgradeQiCollectorReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpgradeQiCollectorReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpgradeQiCollectorReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpgradeQiCollectorReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpgradeQiCollectorReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpgradeQiCollectorReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpgradeQiCollectorReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UpgradeQiCollectorReq";
  }
  protected:
  explicit UpgradeQiCollectorReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.UpgradeQiCollectorReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UpgradeQiCollectorAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UpgradeQiCollectorAck) */ {
 public:
  inline UpgradeQiCollectorAck() : UpgradeQiCollectorAck(nullptr) {}
  ~UpgradeQiCollectorAck() override;
  explicit PROTOBUF_CONSTEXPR UpgradeQiCollectorAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpgradeQiCollectorAck(const UpgradeQiCollectorAck& from);
  UpgradeQiCollectorAck(UpgradeQiCollectorAck&& from) noexcept
    : UpgradeQiCollectorAck() {
    *this = ::std::move(from);
  }

  inline UpgradeQiCollectorAck& operator=(const UpgradeQiCollectorAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpgradeQiCollectorAck& operator=(UpgradeQiCollectorAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpgradeQiCollectorAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpgradeQiCollectorAck* internal_default_instance() {
    return reinterpret_cast<const UpgradeQiCollectorAck*>(
               &_UpgradeQiCollectorAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    219;

  friend void swap(UpgradeQiCollectorAck& a, UpgradeQiCollectorAck& b) {
    a.Swap(&b);
  }
  inline void Swap(UpgradeQiCollectorAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpgradeQiCollectorAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpgradeQiCollectorAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpgradeQiCollectorAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpgradeQiCollectorAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpgradeQiCollectorAck& from) {
    UpgradeQiCollectorAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpgradeQiCollectorAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UpgradeQiCollectorAck";
  }
  protected:
  explicit UpgradeQiCollectorAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UpgradeQiCollectorAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleAllStatsReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetRoleAllStatsReq) */ {
 public:
  inline GetRoleAllStatsReq() : GetRoleAllStatsReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetRoleAllStatsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleAllStatsReq(const GetRoleAllStatsReq& from);
  GetRoleAllStatsReq(GetRoleAllStatsReq&& from) noexcept
    : GetRoleAllStatsReq() {
    *this = ::std::move(from);
  }

  inline GetRoleAllStatsReq& operator=(const GetRoleAllStatsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleAllStatsReq& operator=(GetRoleAllStatsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleAllStatsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleAllStatsReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleAllStatsReq*>(
               &_GetRoleAllStatsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    220;

  friend void swap(GetRoleAllStatsReq& a, GetRoleAllStatsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleAllStatsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleAllStatsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleAllStatsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleAllStatsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetRoleAllStatsReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetRoleAllStatsReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleAllStatsReq";
  }
  protected:
  explicit GetRoleAllStatsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleAllStatsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleAllStatsAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleAllStatsAck) */ {
 public:
  inline GetRoleAllStatsAck() : GetRoleAllStatsAck(nullptr) {}
  ~GetRoleAllStatsAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleAllStatsAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleAllStatsAck(const GetRoleAllStatsAck& from);
  GetRoleAllStatsAck(GetRoleAllStatsAck&& from) noexcept
    : GetRoleAllStatsAck() {
    *this = ::std::move(from);
  }

  inline GetRoleAllStatsAck& operator=(const GetRoleAllStatsAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleAllStatsAck& operator=(GetRoleAllStatsAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleAllStatsAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleAllStatsAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleAllStatsAck*>(
               &_GetRoleAllStatsAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    221;

  friend void swap(GetRoleAllStatsAck& a, GetRoleAllStatsAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleAllStatsAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleAllStatsAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleAllStatsAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleAllStatsAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleAllStatsAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleAllStatsAck& from) {
    GetRoleAllStatsAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleAllStatsAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleAllStatsAck";
  }
  protected:
  explicit GetRoleAllStatsAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllStatsDataFieldNumber = 1,
  };
  // .idlepb.GameStatsAllModuleData all_stats_data = 1;
  bool has_all_stats_data() const;
  private:
  bool _internal_has_all_stats_data() const;
  public:
  void clear_all_stats_data();
  const ::idlepb::GameStatsAllModuleData& all_stats_data() const;
  PROTOBUF_NODISCARD ::idlepb::GameStatsAllModuleData* release_all_stats_data();
  ::idlepb::GameStatsAllModuleData* mutable_all_stats_data();
  void set_allocated_all_stats_data(::idlepb::GameStatsAllModuleData* all_stats_data);
  private:
  const ::idlepb::GameStatsAllModuleData& _internal_all_stats_data() const;
  ::idlepb::GameStatsAllModuleData* _internal_mutable_all_stats_data();
  public:
  void unsafe_arena_set_allocated_all_stats_data(
      ::idlepb::GameStatsAllModuleData* all_stats_data);
  ::idlepb::GameStatsAllModuleData* unsafe_arena_release_all_stats_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleAllStatsAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::GameStatsAllModuleData* all_stats_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetShanhetuDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetShanhetuDataReq) */ {
 public:
  inline GetShanhetuDataReq() : GetShanhetuDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetShanhetuDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShanhetuDataReq(const GetShanhetuDataReq& from);
  GetShanhetuDataReq(GetShanhetuDataReq&& from) noexcept
    : GetShanhetuDataReq() {
    *this = ::std::move(from);
  }

  inline GetShanhetuDataReq& operator=(const GetShanhetuDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShanhetuDataReq& operator=(GetShanhetuDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShanhetuDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetShanhetuDataReq* internal_default_instance() {
    return reinterpret_cast<const GetShanhetuDataReq*>(
               &_GetShanhetuDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    222;

  friend void swap(GetShanhetuDataReq& a, GetShanhetuDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShanhetuDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShanhetuDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShanhetuDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShanhetuDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetShanhetuDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetShanhetuDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetShanhetuDataReq";
  }
  protected:
  explicit GetShanhetuDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetShanhetuDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetShanhetuDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetShanhetuDataAck) */ {
 public:
  inline GetShanhetuDataAck() : GetShanhetuDataAck(nullptr) {}
  ~GetShanhetuDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetShanhetuDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShanhetuDataAck(const GetShanhetuDataAck& from);
  GetShanhetuDataAck(GetShanhetuDataAck&& from) noexcept
    : GetShanhetuDataAck() {
    *this = ::std::move(from);
  }

  inline GetShanhetuDataAck& operator=(const GetShanhetuDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShanhetuDataAck& operator=(GetShanhetuDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShanhetuDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetShanhetuDataAck* internal_default_instance() {
    return reinterpret_cast<const GetShanhetuDataAck*>(
               &_GetShanhetuDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    223;

  friend void swap(GetShanhetuDataAck& a, GetShanhetuDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShanhetuDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShanhetuDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShanhetuDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShanhetuDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetShanhetuDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetShanhetuDataAck& from) {
    GetShanhetuDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetShanhetuDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetShanhetuDataAck";
  }
  protected:
  explicit GetShanhetuDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleShanhetuData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleShanhetuData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleShanhetuData* release_data();
  ::idlepb::RoleShanhetuData* mutable_data();
  void set_allocated_data(::idlepb::RoleShanhetuData* data);
  private:
  const ::idlepb::RoleShanhetuData& _internal_data() const;
  ::idlepb::RoleShanhetuData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleShanhetuData* data);
  ::idlepb::RoleShanhetuData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetShanhetuDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleShanhetuData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetShanhetuUseConfigReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetShanhetuUseConfigReq) */ {
 public:
  inline SetShanhetuUseConfigReq() : SetShanhetuUseConfigReq(nullptr) {}
  ~SetShanhetuUseConfigReq() override;
  explicit PROTOBUF_CONSTEXPR SetShanhetuUseConfigReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetShanhetuUseConfigReq(const SetShanhetuUseConfigReq& from);
  SetShanhetuUseConfigReq(SetShanhetuUseConfigReq&& from) noexcept
    : SetShanhetuUseConfigReq() {
    *this = ::std::move(from);
  }

  inline SetShanhetuUseConfigReq& operator=(const SetShanhetuUseConfigReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetShanhetuUseConfigReq& operator=(SetShanhetuUseConfigReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetShanhetuUseConfigReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetShanhetuUseConfigReq* internal_default_instance() {
    return reinterpret_cast<const SetShanhetuUseConfigReq*>(
               &_SetShanhetuUseConfigReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    224;

  friend void swap(SetShanhetuUseConfigReq& a, SetShanhetuUseConfigReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetShanhetuUseConfigReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetShanhetuUseConfigReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetShanhetuUseConfigReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetShanhetuUseConfigReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetShanhetuUseConfigReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetShanhetuUseConfigReq& from) {
    SetShanhetuUseConfigReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetShanhetuUseConfigReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetShanhetuUseConfigReq";
  }
  protected:
  explicit SetShanhetuUseConfigReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAutoSkipGreenFieldNumber = 1,
    kAutoSkipBlueFieldNumber = 2,
    kAutoSkipPerpoFieldNumber = 3,
    kAutoSkipGoldFieldNumber = 4,
    kAutoSkipRedFieldNumber = 5,
    kAutoSelectFieldNumber = 6,
  };
  // bool auto_skip_green = 1;
  void clear_auto_skip_green();
  bool auto_skip_green() const;
  void set_auto_skip_green(bool value);
  private:
  bool _internal_auto_skip_green() const;
  void _internal_set_auto_skip_green(bool value);
  public:

  // bool auto_skip_blue = 2;
  void clear_auto_skip_blue();
  bool auto_skip_blue() const;
  void set_auto_skip_blue(bool value);
  private:
  bool _internal_auto_skip_blue() const;
  void _internal_set_auto_skip_blue(bool value);
  public:

  // bool auto_skip_perpo = 3;
  void clear_auto_skip_perpo();
  bool auto_skip_perpo() const;
  void set_auto_skip_perpo(bool value);
  private:
  bool _internal_auto_skip_perpo() const;
  void _internal_set_auto_skip_perpo(bool value);
  public:

  // bool auto_skip_gold = 4;
  void clear_auto_skip_gold();
  bool auto_skip_gold() const;
  void set_auto_skip_gold(bool value);
  private:
  bool _internal_auto_skip_gold() const;
  void _internal_set_auto_skip_gold(bool value);
  public:

  // bool auto_skip_red = 5;
  void clear_auto_skip_red();
  bool auto_skip_red() const;
  void set_auto_skip_red(bool value);
  private:
  bool _internal_auto_skip_red() const;
  void _internal_set_auto_skip_red(bool value);
  public:

  // int32 auto_select = 6;
  void clear_auto_select();
  int32_t auto_select() const;
  void set_auto_select(int32_t value);
  private:
  int32_t _internal_auto_select() const;
  void _internal_set_auto_select(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetShanhetuUseConfigReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool auto_skip_green_;
    bool auto_skip_blue_;
    bool auto_skip_perpo_;
    bool auto_skip_gold_;
    bool auto_skip_red_;
    int32_t auto_select_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetShanhetuUseConfigAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetShanhetuUseConfigAck) */ {
 public:
  inline SetShanhetuUseConfigAck() : SetShanhetuUseConfigAck(nullptr) {}
  ~SetShanhetuUseConfigAck() override;
  explicit PROTOBUF_CONSTEXPR SetShanhetuUseConfigAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetShanhetuUseConfigAck(const SetShanhetuUseConfigAck& from);
  SetShanhetuUseConfigAck(SetShanhetuUseConfigAck&& from) noexcept
    : SetShanhetuUseConfigAck() {
    *this = ::std::move(from);
  }

  inline SetShanhetuUseConfigAck& operator=(const SetShanhetuUseConfigAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetShanhetuUseConfigAck& operator=(SetShanhetuUseConfigAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetShanhetuUseConfigAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetShanhetuUseConfigAck* internal_default_instance() {
    return reinterpret_cast<const SetShanhetuUseConfigAck*>(
               &_SetShanhetuUseConfigAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    225;

  friend void swap(SetShanhetuUseConfigAck& a, SetShanhetuUseConfigAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SetShanhetuUseConfigAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetShanhetuUseConfigAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetShanhetuUseConfigAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetShanhetuUseConfigAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetShanhetuUseConfigAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetShanhetuUseConfigAck& from) {
    SetShanhetuUseConfigAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetShanhetuUseConfigAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetShanhetuUseConfigAck";
  }
  protected:
  explicit SetShanhetuUseConfigAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetShanhetuUseConfigAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UseShanhetuReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UseShanhetuReq) */ {
 public:
  inline UseShanhetuReq() : UseShanhetuReq(nullptr) {}
  ~UseShanhetuReq() override;
  explicit PROTOBUF_CONSTEXPR UseShanhetuReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UseShanhetuReq(const UseShanhetuReq& from);
  UseShanhetuReq(UseShanhetuReq&& from) noexcept
    : UseShanhetuReq() {
    *this = ::std::move(from);
  }

  inline UseShanhetuReq& operator=(const UseShanhetuReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseShanhetuReq& operator=(UseShanhetuReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseShanhetuReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseShanhetuReq* internal_default_instance() {
    return reinterpret_cast<const UseShanhetuReq*>(
               &_UseShanhetuReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    226;

  friend void swap(UseShanhetuReq& a, UseShanhetuReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UseShanhetuReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseShanhetuReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseShanhetuReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseShanhetuReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UseShanhetuReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UseShanhetuReq& from) {
    UseShanhetuReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UseShanhetuReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UseShanhetuReq";
  }
  protected:
  explicit UseShanhetuReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kSkipFieldNumber = 2,
    kNumFieldNumber = 3,
  };
  // int32 item_id = 1;
  void clear_item_id();
  int32_t item_id() const;
  void set_item_id(int32_t value);
  private:
  int32_t _internal_item_id() const;
  void _internal_set_item_id(int32_t value);
  public:

  // bool skip = 2;
  void clear_skip();
  bool skip() const;
  void set_skip(bool value);
  private:
  bool _internal_skip() const;
  void _internal_set_skip(bool value);
  public:

  // int32 num = 3;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UseShanhetuReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t item_id_;
    bool skip_;
    int32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UseShanhetuAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UseShanhetuAck) */ {
 public:
  inline UseShanhetuAck() : UseShanhetuAck(nullptr) {}
  ~UseShanhetuAck() override;
  explicit PROTOBUF_CONSTEXPR UseShanhetuAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UseShanhetuAck(const UseShanhetuAck& from);
  UseShanhetuAck(UseShanhetuAck&& from) noexcept
    : UseShanhetuAck() {
    *this = ::std::move(from);
  }

  inline UseShanhetuAck& operator=(const UseShanhetuAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseShanhetuAck& operator=(UseShanhetuAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseShanhetuAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseShanhetuAck* internal_default_instance() {
    return reinterpret_cast<const UseShanhetuAck*>(
               &_UseShanhetuAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    227;

  friend void swap(UseShanhetuAck& a, UseShanhetuAck& b) {
    a.Swap(&b);
  }
  inline void Swap(UseShanhetuAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseShanhetuAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseShanhetuAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseShanhetuAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UseShanhetuAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UseShanhetuAck& from) {
    UseShanhetuAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UseShanhetuAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UseShanhetuAck";
  }
  protected:
  explicit UseShanhetuAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kMapFieldNumber = 3,
    kOkFieldNumber = 1,
  };
  // repeated .idlepb.SimpleItemData items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::SimpleItemData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
      mutable_items();
  private:
  const ::idlepb::SimpleItemData& _internal_items(int index) const;
  ::idlepb::SimpleItemData* _internal_add_items();
  public:
  const ::idlepb::SimpleItemData& items(int index) const;
  ::idlepb::SimpleItemData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
      items() const;

  // .idlepb.ShanhetuMap map = 3;
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::idlepb::ShanhetuMap& map() const;
  PROTOBUF_NODISCARD ::idlepb::ShanhetuMap* release_map();
  ::idlepb::ShanhetuMap* mutable_map();
  void set_allocated_map(::idlepb::ShanhetuMap* map);
  private:
  const ::idlepb::ShanhetuMap& _internal_map() const;
  ::idlepb::ShanhetuMap* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::idlepb::ShanhetuMap* map);
  ::idlepb::ShanhetuMap* unsafe_arena_release_map();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UseShanhetuAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData > items_;
    ::idlepb::ShanhetuMap* map_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API StepShanhetuReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.StepShanhetuReq) */ {
 public:
  inline StepShanhetuReq() : StepShanhetuReq(nullptr) {}
  ~StepShanhetuReq() override;
  explicit PROTOBUF_CONSTEXPR StepShanhetuReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepShanhetuReq(const StepShanhetuReq& from);
  StepShanhetuReq(StepShanhetuReq&& from) noexcept
    : StepShanhetuReq() {
    *this = ::std::move(from);
  }

  inline StepShanhetuReq& operator=(const StepShanhetuReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepShanhetuReq& operator=(StepShanhetuReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepShanhetuReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepShanhetuReq* internal_default_instance() {
    return reinterpret_cast<const StepShanhetuReq*>(
               &_StepShanhetuReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    228;

  friend void swap(StepShanhetuReq& a, StepShanhetuReq& b) {
    a.Swap(&b);
  }
  inline void Swap(StepShanhetuReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepShanhetuReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepShanhetuReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepShanhetuReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepShanhetuReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StepShanhetuReq& from) {
    StepShanhetuReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepShanhetuReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.StepShanhetuReq";
  }
  protected:
  explicit StepShanhetuReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChooseEventFieldNumber = 1,
  };
  // int32 choose_event = 1;
  void clear_choose_event();
  int32_t choose_event() const;
  void set_choose_event(int32_t value);
  private:
  int32_t _internal_choose_event() const;
  void _internal_set_choose_event(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.StepShanhetuReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t choose_event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API StepShanhetuAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.StepShanhetuAck) */ {
 public:
  inline StepShanhetuAck() : StepShanhetuAck(nullptr) {}
  ~StepShanhetuAck() override;
  explicit PROTOBUF_CONSTEXPR StepShanhetuAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepShanhetuAck(const StepShanhetuAck& from);
  StepShanhetuAck(StepShanhetuAck&& from) noexcept
    : StepShanhetuAck() {
    *this = ::std::move(from);
  }

  inline StepShanhetuAck& operator=(const StepShanhetuAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepShanhetuAck& operator=(StepShanhetuAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepShanhetuAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepShanhetuAck* internal_default_instance() {
    return reinterpret_cast<const StepShanhetuAck*>(
               &_StepShanhetuAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    229;

  friend void swap(StepShanhetuAck& a, StepShanhetuAck& b) {
    a.Swap(&b);
  }
  inline void Swap(StepShanhetuAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepShanhetuAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepShanhetuAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepShanhetuAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepShanhetuAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StepShanhetuAck& from) {
    StepShanhetuAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepShanhetuAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.StepShanhetuAck";
  }
  protected:
  explicit StepShanhetuAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordFieldNumber = 3,
    kDoneFieldNumber = 1,
    kCurrentRowFieldNumber = 2,
  };
  // .idlepb.ShanhetuRecord record = 3;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::idlepb::ShanhetuRecord& record() const;
  PROTOBUF_NODISCARD ::idlepb::ShanhetuRecord* release_record();
  ::idlepb::ShanhetuRecord* mutable_record();
  void set_allocated_record(::idlepb::ShanhetuRecord* record);
  private:
  const ::idlepb::ShanhetuRecord& _internal_record() const;
  ::idlepb::ShanhetuRecord* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::idlepb::ShanhetuRecord* record);
  ::idlepb::ShanhetuRecord* unsafe_arena_release_record();

  // bool done = 1;
  void clear_done();
  bool done() const;
  void set_done(bool value);
  private:
  bool _internal_done() const;
  void _internal_set_done(bool value);
  public:

  // int32 current_row = 2;
  void clear_current_row();
  int32_t current_row() const;
  void set_current_row(int32_t value);
  private:
  int32_t _internal_current_row() const;
  void _internal_set_current_row(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.StepShanhetuAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::ShanhetuRecord* record_;
    bool done_;
    int32_t current_row_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetShanhetuUseRecordReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetShanhetuUseRecordReq) */ {
 public:
  inline GetShanhetuUseRecordReq() : GetShanhetuUseRecordReq(nullptr) {}
  ~GetShanhetuUseRecordReq() override;
  explicit PROTOBUF_CONSTEXPR GetShanhetuUseRecordReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShanhetuUseRecordReq(const GetShanhetuUseRecordReq& from);
  GetShanhetuUseRecordReq(GetShanhetuUseRecordReq&& from) noexcept
    : GetShanhetuUseRecordReq() {
    *this = ::std::move(from);
  }

  inline GetShanhetuUseRecordReq& operator=(const GetShanhetuUseRecordReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShanhetuUseRecordReq& operator=(GetShanhetuUseRecordReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShanhetuUseRecordReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetShanhetuUseRecordReq* internal_default_instance() {
    return reinterpret_cast<const GetShanhetuUseRecordReq*>(
               &_GetShanhetuUseRecordReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    230;

  friend void swap(GetShanhetuUseRecordReq& a, GetShanhetuUseRecordReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShanhetuUseRecordReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShanhetuUseRecordReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShanhetuUseRecordReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShanhetuUseRecordReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetShanhetuUseRecordReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetShanhetuUseRecordReq& from) {
    GetShanhetuUseRecordReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetShanhetuUseRecordReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetShanhetuUseRecordReq";
  }
  protected:
  explicit GetShanhetuUseRecordReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
    kUidFieldNumber = 2,
  };
  // int64 role_id = 1;
  void clear_role_id();
  int64_t role_id() const;
  void set_role_id(int64_t value);
  private:
  int64_t _internal_role_id() const;
  void _internal_set_role_id(int64_t value);
  public:

  // int64 uid = 2;
  void clear_uid();
  int64_t uid() const;
  void set_uid(int64_t value);
  private:
  int64_t _internal_uid() const;
  void _internal_set_uid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetShanhetuUseRecordReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t role_id_;
    int64_t uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetShanhetuUseRecordAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetShanhetuUseRecordAck) */ {
 public:
  inline GetShanhetuUseRecordAck() : GetShanhetuUseRecordAck(nullptr) {}
  ~GetShanhetuUseRecordAck() override;
  explicit PROTOBUF_CONSTEXPR GetShanhetuUseRecordAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShanhetuUseRecordAck(const GetShanhetuUseRecordAck& from);
  GetShanhetuUseRecordAck(GetShanhetuUseRecordAck&& from) noexcept
    : GetShanhetuUseRecordAck() {
    *this = ::std::move(from);
  }

  inline GetShanhetuUseRecordAck& operator=(const GetShanhetuUseRecordAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShanhetuUseRecordAck& operator=(GetShanhetuUseRecordAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShanhetuUseRecordAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetShanhetuUseRecordAck* internal_default_instance() {
    return reinterpret_cast<const GetShanhetuUseRecordAck*>(
               &_GetShanhetuUseRecordAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    231;

  friend void swap(GetShanhetuUseRecordAck& a, GetShanhetuUseRecordAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShanhetuUseRecordAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShanhetuUseRecordAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShanhetuUseRecordAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShanhetuUseRecordAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetShanhetuUseRecordAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetShanhetuUseRecordAck& from) {
    GetShanhetuUseRecordAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetShanhetuUseRecordAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetShanhetuUseRecordAck";
  }
  protected:
  explicit GetShanhetuUseRecordAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordFieldNumber = 1,
  };
  // .idlepb.ShanhetuRecord record = 1;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::idlepb::ShanhetuRecord& record() const;
  PROTOBUF_NODISCARD ::idlepb::ShanhetuRecord* release_record();
  ::idlepb::ShanhetuRecord* mutable_record();
  void set_allocated_record(::idlepb::ShanhetuRecord* record);
  private:
  const ::idlepb::ShanhetuRecord& _internal_record() const;
  ::idlepb::ShanhetuRecord* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::idlepb::ShanhetuRecord* record);
  ::idlepb::ShanhetuRecord* unsafe_arena_release_record();

  // @@protoc_insertion_point(class_scope:idlepb.GetShanhetuUseRecordAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::ShanhetuRecord* record_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetAttackLockTypeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetAttackLockTypeReq) */ {
 public:
  inline SetAttackLockTypeReq() : SetAttackLockTypeReq(nullptr) {}
  ~SetAttackLockTypeReq() override;
  explicit PROTOBUF_CONSTEXPR SetAttackLockTypeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAttackLockTypeReq(const SetAttackLockTypeReq& from);
  SetAttackLockTypeReq(SetAttackLockTypeReq&& from) noexcept
    : SetAttackLockTypeReq() {
    *this = ::std::move(from);
  }

  inline SetAttackLockTypeReq& operator=(const SetAttackLockTypeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAttackLockTypeReq& operator=(SetAttackLockTypeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAttackLockTypeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAttackLockTypeReq* internal_default_instance() {
    return reinterpret_cast<const SetAttackLockTypeReq*>(
               &_SetAttackLockTypeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    232;

  friend void swap(SetAttackLockTypeReq& a, SetAttackLockTypeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAttackLockTypeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAttackLockTypeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAttackLockTypeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAttackLockTypeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAttackLockTypeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAttackLockTypeReq& from) {
    SetAttackLockTypeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAttackLockTypeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetAttackLockTypeReq";
  }
  protected:
  explicit SetAttackLockTypeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .idlepb.AttackLockType type = 1;
  void clear_type();
  ::idlepb::AttackLockType type() const;
  void set_type(::idlepb::AttackLockType value);
  private:
  ::idlepb::AttackLockType _internal_type() const;
  void _internal_set_type(::idlepb::AttackLockType value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetAttackLockTypeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetAttackLockTypeAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetAttackLockTypeAck) */ {
 public:
  inline SetAttackLockTypeAck() : SetAttackLockTypeAck(nullptr) {}
  ~SetAttackLockTypeAck() override;
  explicit PROTOBUF_CONSTEXPR SetAttackLockTypeAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAttackLockTypeAck(const SetAttackLockTypeAck& from);
  SetAttackLockTypeAck(SetAttackLockTypeAck&& from) noexcept
    : SetAttackLockTypeAck() {
    *this = ::std::move(from);
  }

  inline SetAttackLockTypeAck& operator=(const SetAttackLockTypeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAttackLockTypeAck& operator=(SetAttackLockTypeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAttackLockTypeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAttackLockTypeAck* internal_default_instance() {
    return reinterpret_cast<const SetAttackLockTypeAck*>(
               &_SetAttackLockTypeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    233;

  friend void swap(SetAttackLockTypeAck& a, SetAttackLockTypeAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAttackLockTypeAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAttackLockTypeAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAttackLockTypeAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAttackLockTypeAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAttackLockTypeAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAttackLockTypeAck& from) {
    SetAttackLockTypeAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAttackLockTypeAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetAttackLockTypeAck";
  }
  protected:
  explicit SetAttackLockTypeAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetAttackLockTypeAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetAttackUnlockTypeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetAttackUnlockTypeReq) */ {
 public:
  inline SetAttackUnlockTypeReq() : SetAttackUnlockTypeReq(nullptr) {}
  ~SetAttackUnlockTypeReq() override;
  explicit PROTOBUF_CONSTEXPR SetAttackUnlockTypeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAttackUnlockTypeReq(const SetAttackUnlockTypeReq& from);
  SetAttackUnlockTypeReq(SetAttackUnlockTypeReq&& from) noexcept
    : SetAttackUnlockTypeReq() {
    *this = ::std::move(from);
  }

  inline SetAttackUnlockTypeReq& operator=(const SetAttackUnlockTypeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAttackUnlockTypeReq& operator=(SetAttackUnlockTypeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAttackUnlockTypeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAttackUnlockTypeReq* internal_default_instance() {
    return reinterpret_cast<const SetAttackUnlockTypeReq*>(
               &_SetAttackUnlockTypeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    234;

  friend void swap(SetAttackUnlockTypeReq& a, SetAttackUnlockTypeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAttackUnlockTypeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAttackUnlockTypeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAttackUnlockTypeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAttackUnlockTypeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAttackUnlockTypeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAttackUnlockTypeReq& from) {
    SetAttackUnlockTypeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAttackUnlockTypeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetAttackUnlockTypeReq";
  }
  protected:
  explicit SetAttackUnlockTypeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .idlepb.AttackUnlockType type = 1;
  void clear_type();
  ::idlepb::AttackUnlockType type() const;
  void set_type(::idlepb::AttackUnlockType value);
  private:
  ::idlepb::AttackUnlockType _internal_type() const;
  void _internal_set_type(::idlepb::AttackUnlockType value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetAttackUnlockTypeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetAttackUnlockTypeAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetAttackUnlockTypeAck) */ {
 public:
  inline SetAttackUnlockTypeAck() : SetAttackUnlockTypeAck(nullptr) {}
  ~SetAttackUnlockTypeAck() override;
  explicit PROTOBUF_CONSTEXPR SetAttackUnlockTypeAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAttackUnlockTypeAck(const SetAttackUnlockTypeAck& from);
  SetAttackUnlockTypeAck(SetAttackUnlockTypeAck&& from) noexcept
    : SetAttackUnlockTypeAck() {
    *this = ::std::move(from);
  }

  inline SetAttackUnlockTypeAck& operator=(const SetAttackUnlockTypeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAttackUnlockTypeAck& operator=(SetAttackUnlockTypeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAttackUnlockTypeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAttackUnlockTypeAck* internal_default_instance() {
    return reinterpret_cast<const SetAttackUnlockTypeAck*>(
               &_SetAttackUnlockTypeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    235;

  friend void swap(SetAttackUnlockTypeAck& a, SetAttackUnlockTypeAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAttackUnlockTypeAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAttackUnlockTypeAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAttackUnlockTypeAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAttackUnlockTypeAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAttackUnlockTypeAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAttackUnlockTypeAck& from) {
    SetAttackUnlockTypeAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAttackUnlockTypeAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetAttackUnlockTypeAck";
  }
  protected:
  explicit SetAttackUnlockTypeAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetAttackUnlockTypeAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetShowUnlockButtonReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetShowUnlockButtonReq) */ {
 public:
  inline SetShowUnlockButtonReq() : SetShowUnlockButtonReq(nullptr) {}
  ~SetShowUnlockButtonReq() override;
  explicit PROTOBUF_CONSTEXPR SetShowUnlockButtonReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetShowUnlockButtonReq(const SetShowUnlockButtonReq& from);
  SetShowUnlockButtonReq(SetShowUnlockButtonReq&& from) noexcept
    : SetShowUnlockButtonReq() {
    *this = ::std::move(from);
  }

  inline SetShowUnlockButtonReq& operator=(const SetShowUnlockButtonReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetShowUnlockButtonReq& operator=(SetShowUnlockButtonReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetShowUnlockButtonReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetShowUnlockButtonReq* internal_default_instance() {
    return reinterpret_cast<const SetShowUnlockButtonReq*>(
               &_SetShowUnlockButtonReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    236;

  friend void swap(SetShowUnlockButtonReq& a, SetShowUnlockButtonReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SetShowUnlockButtonReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetShowUnlockButtonReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetShowUnlockButtonReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetShowUnlockButtonReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetShowUnlockButtonReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetShowUnlockButtonReq& from) {
    SetShowUnlockButtonReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetShowUnlockButtonReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetShowUnlockButtonReq";
  }
  protected:
  explicit SetShowUnlockButtonReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
  };
  // bool enable = 1;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetShowUnlockButtonReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetShowUnlockButtonAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetShowUnlockButtonAck) */ {
 public:
  inline SetShowUnlockButtonAck() : SetShowUnlockButtonAck(nullptr) {}
  ~SetShowUnlockButtonAck() override;
  explicit PROTOBUF_CONSTEXPR SetShowUnlockButtonAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetShowUnlockButtonAck(const SetShowUnlockButtonAck& from);
  SetShowUnlockButtonAck(SetShowUnlockButtonAck&& from) noexcept
    : SetShowUnlockButtonAck() {
    *this = ::std::move(from);
  }

  inline SetShowUnlockButtonAck& operator=(const SetShowUnlockButtonAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetShowUnlockButtonAck& operator=(SetShowUnlockButtonAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetShowUnlockButtonAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetShowUnlockButtonAck* internal_default_instance() {
    return reinterpret_cast<const SetShowUnlockButtonAck*>(
               &_SetShowUnlockButtonAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    237;

  friend void swap(SetShowUnlockButtonAck& a, SetShowUnlockButtonAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SetShowUnlockButtonAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetShowUnlockButtonAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetShowUnlockButtonAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetShowUnlockButtonAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetShowUnlockButtonAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetShowUnlockButtonAck& from) {
    SetShowUnlockButtonAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetShowUnlockButtonAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetShowUnlockButtonAck";
  }
  protected:
  explicit SetShowUnlockButtonAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetShowUnlockButtonAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshRoleNormalSetting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshRoleNormalSetting) */ {
 public:
  inline RefreshRoleNormalSetting() : RefreshRoleNormalSetting(nullptr) {}
  ~RefreshRoleNormalSetting() override;
  explicit PROTOBUF_CONSTEXPR RefreshRoleNormalSetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshRoleNormalSetting(const RefreshRoleNormalSetting& from);
  RefreshRoleNormalSetting(RefreshRoleNormalSetting&& from) noexcept
    : RefreshRoleNormalSetting() {
    *this = ::std::move(from);
  }

  inline RefreshRoleNormalSetting& operator=(const RefreshRoleNormalSetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshRoleNormalSetting& operator=(RefreshRoleNormalSetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshRoleNormalSetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshRoleNormalSetting* internal_default_instance() {
    return reinterpret_cast<const RefreshRoleNormalSetting*>(
               &_RefreshRoleNormalSetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    238;

  friend void swap(RefreshRoleNormalSetting& a, RefreshRoleNormalSetting& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshRoleNormalSetting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshRoleNormalSetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshRoleNormalSetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshRoleNormalSetting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshRoleNormalSetting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshRoleNormalSetting& from) {
    RefreshRoleNormalSetting::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshRoleNormalSetting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshRoleNormalSetting";
  }
  protected:
  explicit RefreshRoleNormalSetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 1,
  };
  // .idlepb.RoleNormalSettings settings = 1;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::idlepb::RoleNormalSettings& settings() const;
  PROTOBUF_NODISCARD ::idlepb::RoleNormalSettings* release_settings();
  ::idlepb::RoleNormalSettings* mutable_settings();
  void set_allocated_settings(::idlepb::RoleNormalSettings* settings);
  private:
  const ::idlepb::RoleNormalSettings& _internal_settings() const;
  ::idlepb::RoleNormalSettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::idlepb::RoleNormalSettings* settings);
  ::idlepb::RoleNormalSettings* unsafe_arena_release_settings();

  // @@protoc_insertion_point(class_scope:idlepb.RefreshRoleNormalSetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleNormalSettings* settings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetUserVarReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetUserVarReq) */ {
 public:
  inline GetUserVarReq() : GetUserVarReq(nullptr) {}
  ~GetUserVarReq() override;
  explicit PROTOBUF_CONSTEXPR GetUserVarReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserVarReq(const GetUserVarReq& from);
  GetUserVarReq(GetUserVarReq&& from) noexcept
    : GetUserVarReq() {
    *this = ::std::move(from);
  }

  inline GetUserVarReq& operator=(const GetUserVarReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserVarReq& operator=(GetUserVarReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserVarReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserVarReq* internal_default_instance() {
    return reinterpret_cast<const GetUserVarReq*>(
               &_GetUserVarReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    239;

  friend void swap(GetUserVarReq& a, GetUserVarReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserVarReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserVarReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserVarReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserVarReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserVarReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserVarReq& from) {
    GetUserVarReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserVarReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetUserVarReq";
  }
  protected:
  explicit GetUserVarReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarNameFieldNumber = 1,
  };
  // string var_name = 1;
  void clear_var_name();
  const std::string& var_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var_name();
  PROTOBUF_NODISCARD std::string* release_var_name();
  void set_allocated_var_name(std::string* var_name);
  private:
  const std::string& _internal_var_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_name(const std::string& value);
  std::string* _internal_mutable_var_name();
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetUserVarReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetUserVarRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetUserVarRsp) */ {
 public:
  inline GetUserVarRsp() : GetUserVarRsp(nullptr) {}
  ~GetUserVarRsp() override;
  explicit PROTOBUF_CONSTEXPR GetUserVarRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserVarRsp(const GetUserVarRsp& from);
  GetUserVarRsp(GetUserVarRsp&& from) noexcept
    : GetUserVarRsp() {
    *this = ::std::move(from);
  }

  inline GetUserVarRsp& operator=(const GetUserVarRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserVarRsp& operator=(GetUserVarRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserVarRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserVarRsp* internal_default_instance() {
    return reinterpret_cast<const GetUserVarRsp*>(
               &_GetUserVarRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    240;

  friend void swap(GetUserVarRsp& a, GetUserVarRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserVarRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserVarRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserVarRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserVarRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserVarRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserVarRsp& from) {
    GetUserVarRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserVarRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetUserVarRsp";
  }
  protected:
  explicit GetUserVarRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarValueFieldNumber = 1,
  };
  // int32 var_value = 1;
  void clear_var_value();
  int32_t var_value() const;
  void set_var_value(int32_t value);
  private:
  int32_t _internal_var_value() const;
  void _internal_set_var_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetUserVarRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t var_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetUserVarsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetUserVarsReq) */ {
 public:
  inline GetUserVarsReq() : GetUserVarsReq(nullptr) {}
  ~GetUserVarsReq() override;
  explicit PROTOBUF_CONSTEXPR GetUserVarsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserVarsReq(const GetUserVarsReq& from);
  GetUserVarsReq(GetUserVarsReq&& from) noexcept
    : GetUserVarsReq() {
    *this = ::std::move(from);
  }

  inline GetUserVarsReq& operator=(const GetUserVarsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserVarsReq& operator=(GetUserVarsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserVarsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserVarsReq* internal_default_instance() {
    return reinterpret_cast<const GetUserVarsReq*>(
               &_GetUserVarsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    241;

  friend void swap(GetUserVarsReq& a, GetUserVarsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserVarsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserVarsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserVarsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserVarsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserVarsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserVarsReq& from) {
    GetUserVarsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserVarsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetUserVarsReq";
  }
  protected:
  explicit GetUserVarsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarNameFieldNumber = 1,
  };
  // repeated string var_name = 1;
  int var_name_size() const;
  private:
  int _internal_var_name_size() const;
  public:
  void clear_var_name();
  const std::string& var_name(int index) const;
  std::string* mutable_var_name(int index);
  void set_var_name(int index, const std::string& value);
  void set_var_name(int index, std::string&& value);
  void set_var_name(int index, const char* value);
  void set_var_name(int index, const char* value, size_t size);
  std::string* add_var_name();
  void add_var_name(const std::string& value);
  void add_var_name(std::string&& value);
  void add_var_name(const char* value);
  void add_var_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& var_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_var_name();
  private:
  const std::string& _internal_var_name(int index) const;
  std::string* _internal_add_var_name();
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetUserVarsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> var_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetUserVarsRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetUserVarsRsp) */ {
 public:
  inline GetUserVarsRsp() : GetUserVarsRsp(nullptr) {}
  ~GetUserVarsRsp() override;
  explicit PROTOBUF_CONSTEXPR GetUserVarsRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserVarsRsp(const GetUserVarsRsp& from);
  GetUserVarsRsp(GetUserVarsRsp&& from) noexcept
    : GetUserVarsRsp() {
    *this = ::std::move(from);
  }

  inline GetUserVarsRsp& operator=(const GetUserVarsRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserVarsRsp& operator=(GetUserVarsRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserVarsRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserVarsRsp* internal_default_instance() {
    return reinterpret_cast<const GetUserVarsRsp*>(
               &_GetUserVarsRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    242;

  friend void swap(GetUserVarsRsp& a, GetUserVarsRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserVarsRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserVarsRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserVarsRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserVarsRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserVarsRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserVarsRsp& from) {
    GetUserVarsRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserVarsRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetUserVarsRsp";
  }
  protected:
  explicit GetUserVarsRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .idlepb.StringKeyInt32ValueEntry data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::idlepb::StringKeyInt32ValueEntry* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::StringKeyInt32ValueEntry >*
      mutable_data();
  private:
  const ::idlepb::StringKeyInt32ValueEntry& _internal_data(int index) const;
  ::idlepb::StringKeyInt32ValueEntry* _internal_add_data();
  public:
  const ::idlepb::StringKeyInt32ValueEntry& data(int index) const;
  ::idlepb::StringKeyInt32ValueEntry* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::StringKeyInt32ValueEntry >&
      data() const;

  // @@protoc_insertion_point(class_scope:idlepb.GetUserVarsRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::StringKeyInt32ValueEntry > data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SetUserVar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SetUserVar) */ {
 public:
  inline SetUserVar() : SetUserVar(nullptr) {}
  ~SetUserVar() override;
  explicit PROTOBUF_CONSTEXPR SetUserVar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetUserVar(const SetUserVar& from);
  SetUserVar(SetUserVar&& from) noexcept
    : SetUserVar() {
    *this = ::std::move(from);
  }

  inline SetUserVar& operator=(const SetUserVar& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetUserVar& operator=(SetUserVar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetUserVar& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetUserVar* internal_default_instance() {
    return reinterpret_cast<const SetUserVar*>(
               &_SetUserVar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    243;

  friend void swap(SetUserVar& a, SetUserVar& b) {
    a.Swap(&b);
  }
  inline void Swap(SetUserVar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetUserVar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetUserVar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetUserVar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetUserVar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetUserVar& from) {
    SetUserVar::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetUserVar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SetUserVar";
  }
  protected:
  explicit SetUserVar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarNameFieldNumber = 1,
    kVarValueFieldNumber = 2,
  };
  // string var_name = 1;
  void clear_var_name();
  const std::string& var_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var_name();
  PROTOBUF_NODISCARD std::string* release_var_name();
  void set_allocated_var_name(std::string* var_name);
  private:
  const std::string& _internal_var_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_name(const std::string& value);
  std::string* _internal_mutable_var_name();
  public:

  // int32 var_value = 2;
  void clear_var_value();
  int32_t var_value() const;
  void set_var_value(int32_t value);
  private:
  int32_t _internal_var_value() const;
  void _internal_set_var_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SetUserVar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_name_;
    int32_t var_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DelUserVar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DelUserVar) */ {
 public:
  inline DelUserVar() : DelUserVar(nullptr) {}
  ~DelUserVar() override;
  explicit PROTOBUF_CONSTEXPR DelUserVar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelUserVar(const DelUserVar& from);
  DelUserVar(DelUserVar&& from) noexcept
    : DelUserVar() {
    *this = ::std::move(from);
  }

  inline DelUserVar& operator=(const DelUserVar& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelUserVar& operator=(DelUserVar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelUserVar& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelUserVar* internal_default_instance() {
    return reinterpret_cast<const DelUserVar*>(
               &_DelUserVar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    244;

  friend void swap(DelUserVar& a, DelUserVar& b) {
    a.Swap(&b);
  }
  inline void Swap(DelUserVar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelUserVar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelUserVar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelUserVar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelUserVar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DelUserVar& from) {
    DelUserVar::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelUserVar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DelUserVar";
  }
  protected:
  explicit DelUserVar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarNameFieldNumber = 1,
  };
  // string var_name = 1;
  void clear_var_name();
  const std::string& var_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var_name();
  PROTOBUF_NODISCARD std::string* release_var_name();
  void set_allocated_var_name(std::string* var_name);
  private:
  const std::string& _internal_var_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_name(const std::string& value);
  std::string* _internal_mutable_var_name();
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DelUserVar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ShareSelfItemReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ShareSelfItemReq) */ {
 public:
  inline ShareSelfItemReq() : ShareSelfItemReq(nullptr) {}
  ~ShareSelfItemReq() override;
  explicit PROTOBUF_CONSTEXPR ShareSelfItemReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareSelfItemReq(const ShareSelfItemReq& from);
  ShareSelfItemReq(ShareSelfItemReq&& from) noexcept
    : ShareSelfItemReq() {
    *this = ::std::move(from);
  }

  inline ShareSelfItemReq& operator=(const ShareSelfItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareSelfItemReq& operator=(ShareSelfItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShareSelfItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareSelfItemReq* internal_default_instance() {
    return reinterpret_cast<const ShareSelfItemReq*>(
               &_ShareSelfItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    245;

  friend void swap(ShareSelfItemReq& a, ShareSelfItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareSelfItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareSelfItemReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareSelfItemReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareSelfItemReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShareSelfItemReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShareSelfItemReq& from) {
    ShareSelfItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShareSelfItemReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ShareSelfItemReq";
  }
  protected:
  explicit ShareSelfItemReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // int64 item_id = 1;
  void clear_item_id();
  int64_t item_id() const;
  void set_item_id(int64_t value);
  private:
  int64_t _internal_item_id() const;
  void _internal_set_item_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ShareSelfItemReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t item_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ShareSelfItemRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ShareSelfItemRsp) */ {
 public:
  inline ShareSelfItemRsp() : ShareSelfItemRsp(nullptr) {}
  ~ShareSelfItemRsp() override;
  explicit PROTOBUF_CONSTEXPR ShareSelfItemRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareSelfItemRsp(const ShareSelfItemRsp& from);
  ShareSelfItemRsp(ShareSelfItemRsp&& from) noexcept
    : ShareSelfItemRsp() {
    *this = ::std::move(from);
  }

  inline ShareSelfItemRsp& operator=(const ShareSelfItemRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareSelfItemRsp& operator=(ShareSelfItemRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShareSelfItemRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareSelfItemRsp* internal_default_instance() {
    return reinterpret_cast<const ShareSelfItemRsp*>(
               &_ShareSelfItemRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    246;

  friend void swap(ShareSelfItemRsp& a, ShareSelfItemRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareSelfItemRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareSelfItemRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareSelfItemRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareSelfItemRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShareSelfItemRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShareSelfItemRsp& from) {
    ShareSelfItemRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShareSelfItemRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ShareSelfItemRsp";
  }
  protected:
  explicit ShareSelfItemRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShareIdFieldNumber = 1,
  };
  // int64 share_id = 1;
  void clear_share_id();
  int64_t share_id() const;
  void set_share_id(int64_t value);
  private:
  int64_t _internal_share_id() const;
  void _internal_set_share_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ShareSelfItemRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t share_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ShareSelfItemsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ShareSelfItemsReq) */ {
 public:
  inline ShareSelfItemsReq() : ShareSelfItemsReq(nullptr) {}
  ~ShareSelfItemsReq() override;
  explicit PROTOBUF_CONSTEXPR ShareSelfItemsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareSelfItemsReq(const ShareSelfItemsReq& from);
  ShareSelfItemsReq(ShareSelfItemsReq&& from) noexcept
    : ShareSelfItemsReq() {
    *this = ::std::move(from);
  }

  inline ShareSelfItemsReq& operator=(const ShareSelfItemsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareSelfItemsReq& operator=(ShareSelfItemsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShareSelfItemsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareSelfItemsReq* internal_default_instance() {
    return reinterpret_cast<const ShareSelfItemsReq*>(
               &_ShareSelfItemsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    247;

  friend void swap(ShareSelfItemsReq& a, ShareSelfItemsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareSelfItemsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareSelfItemsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareSelfItemsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareSelfItemsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShareSelfItemsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShareSelfItemsReq& from) {
    ShareSelfItemsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShareSelfItemsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ShareSelfItemsReq";
  }
  protected:
  explicit ShareSelfItemsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // repeated int64 item_id = 1;
  int item_id_size() const;
  private:
  int _internal_item_id_size() const;
  public:
  void clear_item_id();
  private:
  int64_t _internal_item_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_item_id() const;
  void _internal_add_item_id(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_item_id();
  public:
  int64_t item_id(int index) const;
  void set_item_id(int index, int64_t value);
  void add_item_id(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      item_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_item_id();

  // @@protoc_insertion_point(class_scope:idlepb.ShareSelfItemsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > item_id_;
    mutable std::atomic<int> _item_id_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ShareSelfItemsRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ShareSelfItemsRsp) */ {
 public:
  inline ShareSelfItemsRsp() : ShareSelfItemsRsp(nullptr) {}
  ~ShareSelfItemsRsp() override;
  explicit PROTOBUF_CONSTEXPR ShareSelfItemsRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareSelfItemsRsp(const ShareSelfItemsRsp& from);
  ShareSelfItemsRsp(ShareSelfItemsRsp&& from) noexcept
    : ShareSelfItemsRsp() {
    *this = ::std::move(from);
  }

  inline ShareSelfItemsRsp& operator=(const ShareSelfItemsRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareSelfItemsRsp& operator=(ShareSelfItemsRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShareSelfItemsRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareSelfItemsRsp* internal_default_instance() {
    return reinterpret_cast<const ShareSelfItemsRsp*>(
               &_ShareSelfItemsRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    248;

  friend void swap(ShareSelfItemsRsp& a, ShareSelfItemsRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(ShareSelfItemsRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareSelfItemsRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareSelfItemsRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareSelfItemsRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShareSelfItemsRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShareSelfItemsRsp& from) {
    ShareSelfItemsRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShareSelfItemsRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ShareSelfItemsRsp";
  }
  protected:
  explicit ShareSelfItemsRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShareIdFieldNumber = 1,
  };
  // repeated .idlepb.Int64Pair share_id = 1;
  int share_id_size() const;
  private:
  int _internal_share_id_size() const;
  public:
  void clear_share_id();
  ::idlepb::Int64Pair* mutable_share_id(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Int64Pair >*
      mutable_share_id();
  private:
  const ::idlepb::Int64Pair& _internal_share_id(int index) const;
  ::idlepb::Int64Pair* _internal_add_share_id();
  public:
  const ::idlepb::Int64Pair& share_id(int index) const;
  ::idlepb::Int64Pair* add_share_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Int64Pair >&
      share_id() const;

  // @@protoc_insertion_point(class_scope:idlepb.ShareSelfItemsRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Int64Pair > share_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetShareItemDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetShareItemDataReq) */ {
 public:
  inline GetShareItemDataReq() : GetShareItemDataReq(nullptr) {}
  ~GetShareItemDataReq() override;
  explicit PROTOBUF_CONSTEXPR GetShareItemDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShareItemDataReq(const GetShareItemDataReq& from);
  GetShareItemDataReq(GetShareItemDataReq&& from) noexcept
    : GetShareItemDataReq() {
    *this = ::std::move(from);
  }

  inline GetShareItemDataReq& operator=(const GetShareItemDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShareItemDataReq& operator=(GetShareItemDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShareItemDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetShareItemDataReq* internal_default_instance() {
    return reinterpret_cast<const GetShareItemDataReq*>(
               &_GetShareItemDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    249;

  friend void swap(GetShareItemDataReq& a, GetShareItemDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShareItemDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShareItemDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShareItemDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShareItemDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetShareItemDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetShareItemDataReq& from) {
    GetShareItemDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetShareItemDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetShareItemDataReq";
  }
  protected:
  explicit GetShareItemDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShareIdFieldNumber = 1,
  };
  // int64 share_id = 1;
  void clear_share_id();
  int64_t share_id() const;
  void set_share_id(int64_t value);
  private:
  int64_t _internal_share_id() const;
  void _internal_set_share_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetShareItemDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t share_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetShareItemDataRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetShareItemDataRsp) */ {
 public:
  inline GetShareItemDataRsp() : GetShareItemDataRsp(nullptr) {}
  ~GetShareItemDataRsp() override;
  explicit PROTOBUF_CONSTEXPR GetShareItemDataRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShareItemDataRsp(const GetShareItemDataRsp& from);
  GetShareItemDataRsp(GetShareItemDataRsp&& from) noexcept
    : GetShareItemDataRsp() {
    *this = ::std::move(from);
  }

  inline GetShareItemDataRsp& operator=(const GetShareItemDataRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShareItemDataRsp& operator=(GetShareItemDataRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShareItemDataRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetShareItemDataRsp* internal_default_instance() {
    return reinterpret_cast<const GetShareItemDataRsp*>(
               &_GetShareItemDataRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    250;

  friend void swap(GetShareItemDataRsp& a, GetShareItemDataRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShareItemDataRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShareItemDataRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShareItemDataRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShareItemDataRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetShareItemDataRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetShareItemDataRsp& from) {
    GetShareItemDataRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetShareItemDataRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetShareItemDataRsp";
  }
  protected:
  explicit GetShareItemDataRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemDataFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.ItemData item_data = 2;
  bool has_item_data() const;
  private:
  bool _internal_has_item_data() const;
  public:
  void clear_item_data();
  const ::idlepb::ItemData& item_data() const;
  PROTOBUF_NODISCARD ::idlepb::ItemData* release_item_data();
  ::idlepb::ItemData* mutable_item_data();
  void set_allocated_item_data(::idlepb::ItemData* item_data);
  private:
  const ::idlepb::ItemData& _internal_item_data() const;
  ::idlepb::ItemData* _internal_mutable_item_data();
  public:
  void unsafe_arena_set_allocated_item_data(
      ::idlepb::ItemData* item_data);
  ::idlepb::ItemData* unsafe_arena_release_item_data();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetShareItemDataRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::ItemData* item_data_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetChecklistDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetChecklistDataReq) */ {
 public:
  inline GetChecklistDataReq() : GetChecklistDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetChecklistDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetChecklistDataReq(const GetChecklistDataReq& from);
  GetChecklistDataReq(GetChecklistDataReq&& from) noexcept
    : GetChecklistDataReq() {
    *this = ::std::move(from);
  }

  inline GetChecklistDataReq& operator=(const GetChecklistDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetChecklistDataReq& operator=(GetChecklistDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetChecklistDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetChecklistDataReq* internal_default_instance() {
    return reinterpret_cast<const GetChecklistDataReq*>(
               &_GetChecklistDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    251;

  friend void swap(GetChecklistDataReq& a, GetChecklistDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetChecklistDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetChecklistDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetChecklistDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetChecklistDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetChecklistDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetChecklistDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetChecklistDataReq";
  }
  protected:
  explicit GetChecklistDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetChecklistDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetChecklistDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetChecklistDataAck) */ {
 public:
  inline GetChecklistDataAck() : GetChecklistDataAck(nullptr) {}
  ~GetChecklistDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetChecklistDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetChecklistDataAck(const GetChecklistDataAck& from);
  GetChecklistDataAck(GetChecklistDataAck&& from) noexcept
    : GetChecklistDataAck() {
    *this = ::std::move(from);
  }

  inline GetChecklistDataAck& operator=(const GetChecklistDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetChecklistDataAck& operator=(GetChecklistDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetChecklistDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetChecklistDataAck* internal_default_instance() {
    return reinterpret_cast<const GetChecklistDataAck*>(
               &_GetChecklistDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    252;

  friend void swap(GetChecklistDataAck& a, GetChecklistDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetChecklistDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetChecklistDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetChecklistDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetChecklistDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetChecklistDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetChecklistDataAck& from) {
    GetChecklistDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetChecklistDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetChecklistDataAck";
  }
  protected:
  explicit GetChecklistDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleChecklistData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleChecklistData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleChecklistData* release_data();
  ::idlepb::RoleChecklistData* mutable_data();
  void set_allocated_data(::idlepb::RoleChecklistData* data);
  private:
  const ::idlepb::RoleChecklistData& _internal_data() const;
  ::idlepb::RoleChecklistData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleChecklistData* data);
  ::idlepb::RoleChecklistData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetChecklistDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleChecklistData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyChecklist final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.NotifyChecklist) */ {
 public:
  inline NotifyChecklist() : NotifyChecklist(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NotifyChecklist(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyChecklist(const NotifyChecklist& from);
  NotifyChecklist(NotifyChecklist&& from) noexcept
    : NotifyChecklist() {
    *this = ::std::move(from);
  }

  inline NotifyChecklist& operator=(const NotifyChecklist& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyChecklist& operator=(NotifyChecklist&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyChecklist& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyChecklist* internal_default_instance() {
    return reinterpret_cast<const NotifyChecklist*>(
               &_NotifyChecklist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    253;

  friend void swap(NotifyChecklist& a, NotifyChecklist& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyChecklist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyChecklist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyChecklist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyChecklist>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NotifyChecklist& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NotifyChecklist& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyChecklist";
  }
  protected:
  explicit NotifyChecklist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.NotifyChecklist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ChecklistOpReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ChecklistOpReq) */ {
 public:
  inline ChecklistOpReq() : ChecklistOpReq(nullptr) {}
  ~ChecklistOpReq() override;
  explicit PROTOBUF_CONSTEXPR ChecklistOpReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChecklistOpReq(const ChecklistOpReq& from);
  ChecklistOpReq(ChecklistOpReq&& from) noexcept
    : ChecklistOpReq() {
    *this = ::std::move(from);
  }

  inline ChecklistOpReq& operator=(const ChecklistOpReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChecklistOpReq& operator=(ChecklistOpReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChecklistOpReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChecklistOpReq* internal_default_instance() {
    return reinterpret_cast<const ChecklistOpReq*>(
               &_ChecklistOpReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    254;

  friend void swap(ChecklistOpReq& a, ChecklistOpReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ChecklistOpReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChecklistOpReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChecklistOpReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChecklistOpReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChecklistOpReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChecklistOpReq& from) {
    ChecklistOpReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChecklistOpReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ChecklistOpReq";
  }
  protected:
  explicit ChecklistOpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSumbmitOrReceiveFieldNumber = 1,
    kDayOrWeekFieldNumber = 2,
  };
  // bool sumbmit_or_receive = 1;
  void clear_sumbmit_or_receive();
  bool sumbmit_or_receive() const;
  void set_sumbmit_or_receive(bool value);
  private:
  bool _internal_sumbmit_or_receive() const;
  void _internal_set_sumbmit_or_receive(bool value);
  public:

  // bool day_or_week = 2;
  void clear_day_or_week();
  bool day_or_week() const;
  void set_day_or_week(bool value);
  private:
  bool _internal_day_or_week() const;
  void _internal_set_day_or_week(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ChecklistOpReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool sumbmit_or_receive_;
    bool day_or_week_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ChecklistOpAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ChecklistOpAck) */ {
 public:
  inline ChecklistOpAck() : ChecklistOpAck(nullptr) {}
  ~ChecklistOpAck() override;
  explicit PROTOBUF_CONSTEXPR ChecklistOpAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChecklistOpAck(const ChecklistOpAck& from);
  ChecklistOpAck(ChecklistOpAck&& from) noexcept
    : ChecklistOpAck() {
    *this = ::std::move(from);
  }

  inline ChecklistOpAck& operator=(const ChecklistOpAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChecklistOpAck& operator=(ChecklistOpAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChecklistOpAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChecklistOpAck* internal_default_instance() {
    return reinterpret_cast<const ChecklistOpAck*>(
               &_ChecklistOpAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    255;

  friend void swap(ChecklistOpAck& a, ChecklistOpAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ChecklistOpAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChecklistOpAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChecklistOpAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChecklistOpAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChecklistOpAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChecklistOpAck& from) {
    ChecklistOpAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChecklistOpAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ChecklistOpAck";
  }
  protected:
  explicit ChecklistOpAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.RoleChecklistData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleChecklistData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleChecklistData* release_data();
  ::idlepb::RoleChecklistData* mutable_data();
  void set_allocated_data(::idlepb::RoleChecklistData* data);
  private:
  const ::idlepb::RoleChecklistData& _internal_data() const;
  ::idlepb::RoleChecklistData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleChecklistData* data);
  ::idlepb::RoleChecklistData* unsafe_arena_release_data();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ChecklistOpAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleChecklistData* data_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UpdateChecklistReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UpdateChecklistReq) */ {
 public:
  inline UpdateChecklistReq() : UpdateChecklistReq(nullptr) {}
  ~UpdateChecklistReq() override;
  explicit PROTOBUF_CONSTEXPR UpdateChecklistReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateChecklistReq(const UpdateChecklistReq& from);
  UpdateChecklistReq(UpdateChecklistReq&& from) noexcept
    : UpdateChecklistReq() {
    *this = ::std::move(from);
  }

  inline UpdateChecklistReq& operator=(const UpdateChecklistReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateChecklistReq& operator=(UpdateChecklistReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateChecklistReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateChecklistReq* internal_default_instance() {
    return reinterpret_cast<const UpdateChecklistReq*>(
               &_UpdateChecklistReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    256;

  friend void swap(UpdateChecklistReq& a, UpdateChecklistReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateChecklistReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateChecklistReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateChecklistReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateChecklistReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateChecklistReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateChecklistReq& from) {
    UpdateChecklistReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateChecklistReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UpdateChecklistReq";
  }
  protected:
  explicit UpdateChecklistReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // int32 type = 1;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UpdateChecklistReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UpdateChecklistAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UpdateChecklistAck) */ {
 public:
  inline UpdateChecklistAck() : UpdateChecklistAck(nullptr) {}
  ~UpdateChecklistAck() override;
  explicit PROTOBUF_CONSTEXPR UpdateChecklistAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateChecklistAck(const UpdateChecklistAck& from);
  UpdateChecklistAck(UpdateChecklistAck&& from) noexcept
    : UpdateChecklistAck() {
    *this = ::std::move(from);
  }

  inline UpdateChecklistAck& operator=(const UpdateChecklistAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateChecklistAck& operator=(UpdateChecklistAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateChecklistAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateChecklistAck* internal_default_instance() {
    return reinterpret_cast<const UpdateChecklistAck*>(
               &_UpdateChecklistAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    257;

  friend void swap(UpdateChecklistAck& a, UpdateChecklistAck& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateChecklistAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateChecklistAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateChecklistAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateChecklistAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateChecklistAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateChecklistAck& from) {
    UpdateChecklistAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateChecklistAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UpdateChecklistAck";
  }
  protected:
  explicit UpdateChecklistAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UpdateChecklistAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetCommonItemExchangeDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetCommonItemExchangeDataReq) */ {
 public:
  inline GetCommonItemExchangeDataReq() : GetCommonItemExchangeDataReq(nullptr) {}
  ~GetCommonItemExchangeDataReq() override;
  explicit PROTOBUF_CONSTEXPR GetCommonItemExchangeDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCommonItemExchangeDataReq(const GetCommonItemExchangeDataReq& from);
  GetCommonItemExchangeDataReq(GetCommonItemExchangeDataReq&& from) noexcept
    : GetCommonItemExchangeDataReq() {
    *this = ::std::move(from);
  }

  inline GetCommonItemExchangeDataReq& operator=(const GetCommonItemExchangeDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCommonItemExchangeDataReq& operator=(GetCommonItemExchangeDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCommonItemExchangeDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCommonItemExchangeDataReq* internal_default_instance() {
    return reinterpret_cast<const GetCommonItemExchangeDataReq*>(
               &_GetCommonItemExchangeDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    258;

  friend void swap(GetCommonItemExchangeDataReq& a, GetCommonItemExchangeDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCommonItemExchangeDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCommonItemExchangeDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCommonItemExchangeDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCommonItemExchangeDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCommonItemExchangeDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCommonItemExchangeDataReq& from) {
    GetCommonItemExchangeDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCommonItemExchangeDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetCommonItemExchangeDataReq";
  }
  protected:
  explicit GetCommonItemExchangeDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCfgIdFieldNumber = 1,
  };
  // int32 cfg_id = 1;
  void clear_cfg_id();
  int32_t cfg_id() const;
  void set_cfg_id(int32_t value);
  private:
  int32_t _internal_cfg_id() const;
  void _internal_set_cfg_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetCommonItemExchangeDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t cfg_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetCommonItemExchangeDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetCommonItemExchangeDataAck) */ {
 public:
  inline GetCommonItemExchangeDataAck() : GetCommonItemExchangeDataAck(nullptr) {}
  ~GetCommonItemExchangeDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetCommonItemExchangeDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCommonItemExchangeDataAck(const GetCommonItemExchangeDataAck& from);
  GetCommonItemExchangeDataAck(GetCommonItemExchangeDataAck&& from) noexcept
    : GetCommonItemExchangeDataAck() {
    *this = ::std::move(from);
  }

  inline GetCommonItemExchangeDataAck& operator=(const GetCommonItemExchangeDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCommonItemExchangeDataAck& operator=(GetCommonItemExchangeDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCommonItemExchangeDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCommonItemExchangeDataAck* internal_default_instance() {
    return reinterpret_cast<const GetCommonItemExchangeDataAck*>(
               &_GetCommonItemExchangeDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    259;

  friend void swap(GetCommonItemExchangeDataAck& a, GetCommonItemExchangeDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCommonItemExchangeDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCommonItemExchangeDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCommonItemExchangeDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCommonItemExchangeDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCommonItemExchangeDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCommonItemExchangeDataAck& from) {
    GetCommonItemExchangeDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCommonItemExchangeDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetCommonItemExchangeDataAck";
  }
  protected:
  explicit GetCommonItemExchangeDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTodayExchangeNumFieldNumber = 1,
  };
  // int32 today_exchange_num = 1;
  void clear_today_exchange_num();
  int32_t today_exchange_num() const;
  void set_today_exchange_num(int32_t value);
  private:
  int32_t _internal_today_exchange_num() const;
  void _internal_set_today_exchange_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetCommonItemExchangeDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t today_exchange_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ExchangeCommonItemReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ExchangeCommonItemReq) */ {
 public:
  inline ExchangeCommonItemReq() : ExchangeCommonItemReq(nullptr) {}
  ~ExchangeCommonItemReq() override;
  explicit PROTOBUF_CONSTEXPR ExchangeCommonItemReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeCommonItemReq(const ExchangeCommonItemReq& from);
  ExchangeCommonItemReq(ExchangeCommonItemReq&& from) noexcept
    : ExchangeCommonItemReq() {
    *this = ::std::move(from);
  }

  inline ExchangeCommonItemReq& operator=(const ExchangeCommonItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeCommonItemReq& operator=(ExchangeCommonItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeCommonItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeCommonItemReq* internal_default_instance() {
    return reinterpret_cast<const ExchangeCommonItemReq*>(
               &_ExchangeCommonItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    260;

  friend void swap(ExchangeCommonItemReq& a, ExchangeCommonItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeCommonItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeCommonItemReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeCommonItemReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExchangeCommonItemReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExchangeCommonItemReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExchangeCommonItemReq& from) {
    ExchangeCommonItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeCommonItemReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ExchangeCommonItemReq";
  }
  protected:
  explicit ExchangeCommonItemReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCfgIdFieldNumber = 1,
    kNumFieldNumber = 2,
  };
  // int32 cfg_id = 1;
  void clear_cfg_id();
  int32_t cfg_id() const;
  void set_cfg_id(int32_t value);
  private:
  int32_t _internal_cfg_id() const;
  void _internal_set_cfg_id(int32_t value);
  public:

  // int32 num = 2;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ExchangeCommonItemReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t cfg_id_;
    int32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ExchangeCommonItemAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ExchangeCommonItemAck) */ {
 public:
  inline ExchangeCommonItemAck() : ExchangeCommonItemAck(nullptr) {}
  ~ExchangeCommonItemAck() override;
  explicit PROTOBUF_CONSTEXPR ExchangeCommonItemAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeCommonItemAck(const ExchangeCommonItemAck& from);
  ExchangeCommonItemAck(ExchangeCommonItemAck&& from) noexcept
    : ExchangeCommonItemAck() {
    *this = ::std::move(from);
  }

  inline ExchangeCommonItemAck& operator=(const ExchangeCommonItemAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeCommonItemAck& operator=(ExchangeCommonItemAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeCommonItemAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeCommonItemAck* internal_default_instance() {
    return reinterpret_cast<const ExchangeCommonItemAck*>(
               &_ExchangeCommonItemAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    261;

  friend void swap(ExchangeCommonItemAck& a, ExchangeCommonItemAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeCommonItemAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeCommonItemAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeCommonItemAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExchangeCommonItemAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExchangeCommonItemAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExchangeCommonItemAck& from) {
    ExchangeCommonItemAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeCommonItemAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ExchangeCommonItemAck";
  }
  protected:
  explicit ExchangeCommonItemAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
    kOutNumFieldNumber = 2,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // int32 out_num = 2;
  void clear_out_num();
  int32_t out_num() const;
  void set_out_num(int32_t value);
  private:
  int32_t _internal_out_num() const;
  void _internal_set_out_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ExchangeCommonItemAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    int32_t out_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SynthesisCommonItemReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SynthesisCommonItemReq) */ {
 public:
  inline SynthesisCommonItemReq() : SynthesisCommonItemReq(nullptr) {}
  ~SynthesisCommonItemReq() override;
  explicit PROTOBUF_CONSTEXPR SynthesisCommonItemReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SynthesisCommonItemReq(const SynthesisCommonItemReq& from);
  SynthesisCommonItemReq(SynthesisCommonItemReq&& from) noexcept
    : SynthesisCommonItemReq() {
    *this = ::std::move(from);
  }

  inline SynthesisCommonItemReq& operator=(const SynthesisCommonItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesisCommonItemReq& operator=(SynthesisCommonItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesisCommonItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SynthesisCommonItemReq* internal_default_instance() {
    return reinterpret_cast<const SynthesisCommonItemReq*>(
               &_SynthesisCommonItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    262;

  friend void swap(SynthesisCommonItemReq& a, SynthesisCommonItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesisCommonItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesisCommonItemReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SynthesisCommonItemReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SynthesisCommonItemReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SynthesisCommonItemReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SynthesisCommonItemReq& from) {
    SynthesisCommonItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesisCommonItemReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SynthesisCommonItemReq";
  }
  protected:
  explicit SynthesisCommonItemReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCfgIdFieldNumber = 1,
    kNumFieldNumber = 2,
  };
  // int32 cfg_id = 1;
  void clear_cfg_id();
  int32_t cfg_id() const;
  void set_cfg_id(int32_t value);
  private:
  int32_t _internal_cfg_id() const;
  void _internal_set_cfg_id(int32_t value);
  public:

  // int32 num = 2;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SynthesisCommonItemReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t cfg_id_;
    int32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API SynthesisCommonItemAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.SynthesisCommonItemAck) */ {
 public:
  inline SynthesisCommonItemAck() : SynthesisCommonItemAck(nullptr) {}
  ~SynthesisCommonItemAck() override;
  explicit PROTOBUF_CONSTEXPR SynthesisCommonItemAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SynthesisCommonItemAck(const SynthesisCommonItemAck& from);
  SynthesisCommonItemAck(SynthesisCommonItemAck&& from) noexcept
    : SynthesisCommonItemAck() {
    *this = ::std::move(from);
  }

  inline SynthesisCommonItemAck& operator=(const SynthesisCommonItemAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SynthesisCommonItemAck& operator=(SynthesisCommonItemAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SynthesisCommonItemAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SynthesisCommonItemAck* internal_default_instance() {
    return reinterpret_cast<const SynthesisCommonItemAck*>(
               &_SynthesisCommonItemAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    263;

  friend void swap(SynthesisCommonItemAck& a, SynthesisCommonItemAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SynthesisCommonItemAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SynthesisCommonItemAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SynthesisCommonItemAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SynthesisCommonItemAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SynthesisCommonItemAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SynthesisCommonItemAck& from) {
    SynthesisCommonItemAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SynthesisCommonItemAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.SynthesisCommonItemAck";
  }
  protected:
  explicit SynthesisCommonItemAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.SynthesisCommonItemAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleSeptShopDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetRoleSeptShopDataReq) */ {
 public:
  inline GetRoleSeptShopDataReq() : GetRoleSeptShopDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetRoleSeptShopDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleSeptShopDataReq(const GetRoleSeptShopDataReq& from);
  GetRoleSeptShopDataReq(GetRoleSeptShopDataReq&& from) noexcept
    : GetRoleSeptShopDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleSeptShopDataReq& operator=(const GetRoleSeptShopDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleSeptShopDataReq& operator=(GetRoleSeptShopDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleSeptShopDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleSeptShopDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleSeptShopDataReq*>(
               &_GetRoleSeptShopDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    264;

  friend void swap(GetRoleSeptShopDataReq& a, GetRoleSeptShopDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleSeptShopDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleSeptShopDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleSeptShopDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleSeptShopDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetRoleSeptShopDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetRoleSeptShopDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleSeptShopDataReq";
  }
  protected:
  explicit GetRoleSeptShopDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleSeptShopDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleSeptShopDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleSeptShopDataAck) */ {
 public:
  inline GetRoleSeptShopDataAck() : GetRoleSeptShopDataAck(nullptr) {}
  ~GetRoleSeptShopDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleSeptShopDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleSeptShopDataAck(const GetRoleSeptShopDataAck& from);
  GetRoleSeptShopDataAck(GetRoleSeptShopDataAck&& from) noexcept
    : GetRoleSeptShopDataAck() {
    *this = ::std::move(from);
  }

  inline GetRoleSeptShopDataAck& operator=(const GetRoleSeptShopDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleSeptShopDataAck& operator=(GetRoleSeptShopDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleSeptShopDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleSeptShopDataAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleSeptShopDataAck*>(
               &_GetRoleSeptShopDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    265;

  friend void swap(GetRoleSeptShopDataAck& a, GetRoleSeptShopDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleSeptShopDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleSeptShopDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleSeptShopDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleSeptShopDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleSeptShopDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleSeptShopDataAck& from) {
    GetRoleSeptShopDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleSeptShopDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleSeptShopDataAck";
  }
  protected:
  explicit GetRoleSeptShopDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleSeptShopData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleSeptShopData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleSeptShopData* release_data();
  ::idlepb::RoleSeptShopData* mutable_data();
  void set_allocated_data(::idlepb::RoleSeptShopData* data);
  private:
  const ::idlepb::RoleSeptShopData& _internal_data() const;
  ::idlepb::RoleSeptShopData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleSeptShopData* data);
  ::idlepb::RoleSeptShopData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleSeptShopDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleSeptShopData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleSeptQuestDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetRoleSeptQuestDataReq) */ {
 public:
  inline GetRoleSeptQuestDataReq() : GetRoleSeptQuestDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetRoleSeptQuestDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleSeptQuestDataReq(const GetRoleSeptQuestDataReq& from);
  GetRoleSeptQuestDataReq(GetRoleSeptQuestDataReq&& from) noexcept
    : GetRoleSeptQuestDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleSeptQuestDataReq& operator=(const GetRoleSeptQuestDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleSeptQuestDataReq& operator=(GetRoleSeptQuestDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleSeptQuestDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleSeptQuestDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleSeptQuestDataReq*>(
               &_GetRoleSeptQuestDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    266;

  friend void swap(GetRoleSeptQuestDataReq& a, GetRoleSeptQuestDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleSeptQuestDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleSeptQuestDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleSeptQuestDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleSeptQuestDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetRoleSeptQuestDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetRoleSeptQuestDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleSeptQuestDataReq";
  }
  protected:
  explicit GetRoleSeptQuestDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleSeptQuestDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleSeptQuestDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleSeptQuestDataAck) */ {
 public:
  inline GetRoleSeptQuestDataAck() : GetRoleSeptQuestDataAck(nullptr) {}
  ~GetRoleSeptQuestDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleSeptQuestDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleSeptQuestDataAck(const GetRoleSeptQuestDataAck& from);
  GetRoleSeptQuestDataAck(GetRoleSeptQuestDataAck&& from) noexcept
    : GetRoleSeptQuestDataAck() {
    *this = ::std::move(from);
  }

  inline GetRoleSeptQuestDataAck& operator=(const GetRoleSeptQuestDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleSeptQuestDataAck& operator=(GetRoleSeptQuestDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleSeptQuestDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleSeptQuestDataAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleSeptQuestDataAck*>(
               &_GetRoleSeptQuestDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    267;

  friend void swap(GetRoleSeptQuestDataAck& a, GetRoleSeptQuestDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleSeptQuestDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleSeptQuestDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleSeptQuestDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleSeptQuestDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleSeptQuestDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleSeptQuestDataAck& from) {
    GetRoleSeptQuestDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleSeptQuestDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleSeptQuestDataAck";
  }
  protected:
  explicit GetRoleSeptQuestDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleSeptQuestData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleSeptQuestData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleSeptQuestData* release_data();
  ::idlepb::RoleSeptQuestData* mutable_data();
  void set_allocated_data(::idlepb::RoleSeptQuestData* data);
  private:
  const ::idlepb::RoleSeptQuestData& _internal_data() const;
  ::idlepb::RoleSeptQuestData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleSeptQuestData* data);
  ::idlepb::RoleSeptQuestData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleSeptQuestDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleSeptQuestData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API BuySeptShopItemReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.BuySeptShopItemReq) */ {
 public:
  inline BuySeptShopItemReq() : BuySeptShopItemReq(nullptr) {}
  ~BuySeptShopItemReq() override;
  explicit PROTOBUF_CONSTEXPR BuySeptShopItemReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuySeptShopItemReq(const BuySeptShopItemReq& from);
  BuySeptShopItemReq(BuySeptShopItemReq&& from) noexcept
    : BuySeptShopItemReq() {
    *this = ::std::move(from);
  }

  inline BuySeptShopItemReq& operator=(const BuySeptShopItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuySeptShopItemReq& operator=(BuySeptShopItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuySeptShopItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuySeptShopItemReq* internal_default_instance() {
    return reinterpret_cast<const BuySeptShopItemReq*>(
               &_BuySeptShopItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    268;

  friend void swap(BuySeptShopItemReq& a, BuySeptShopItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(BuySeptShopItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuySeptShopItemReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuySeptShopItemReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuySeptShopItemReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuySeptShopItemReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BuySeptShopItemReq& from) {
    BuySeptShopItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuySeptShopItemReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.BuySeptShopItemReq";
  }
  protected:
  explicit BuySeptShopItemReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNumFieldNumber = 2,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 num = 2;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.BuySeptShopItemReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    int32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API BuySeptShopItemAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.BuySeptShopItemAck) */ {
 public:
  inline BuySeptShopItemAck() : BuySeptShopItemAck(nullptr) {}
  ~BuySeptShopItemAck() override;
  explicit PROTOBUF_CONSTEXPR BuySeptShopItemAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuySeptShopItemAck(const BuySeptShopItemAck& from);
  BuySeptShopItemAck(BuySeptShopItemAck&& from) noexcept
    : BuySeptShopItemAck() {
    *this = ::std::move(from);
  }

  inline BuySeptShopItemAck& operator=(const BuySeptShopItemAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuySeptShopItemAck& operator=(BuySeptShopItemAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuySeptShopItemAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuySeptShopItemAck* internal_default_instance() {
    return reinterpret_cast<const BuySeptShopItemAck*>(
               &_BuySeptShopItemAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    269;

  friend void swap(BuySeptShopItemAck& a, BuySeptShopItemAck& b) {
    a.Swap(&b);
  }
  inline void Swap(BuySeptShopItemAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuySeptShopItemAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuySeptShopItemAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuySeptShopItemAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuySeptShopItemAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BuySeptShopItemAck& from) {
    BuySeptShopItemAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuySeptShopItemAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.BuySeptShopItemAck";
  }
  protected:
  explicit BuySeptShopItemAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.BuySeptShopItemAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReqRoleSeptQuestOpReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReqRoleSeptQuestOpReq) */ {
 public:
  inline ReqRoleSeptQuestOpReq() : ReqRoleSeptQuestOpReq(nullptr) {}
  ~ReqRoleSeptQuestOpReq() override;
  explicit PROTOBUF_CONSTEXPR ReqRoleSeptQuestOpReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqRoleSeptQuestOpReq(const ReqRoleSeptQuestOpReq& from);
  ReqRoleSeptQuestOpReq(ReqRoleSeptQuestOpReq&& from) noexcept
    : ReqRoleSeptQuestOpReq() {
    *this = ::std::move(from);
  }

  inline ReqRoleSeptQuestOpReq& operator=(const ReqRoleSeptQuestOpReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqRoleSeptQuestOpReq& operator=(ReqRoleSeptQuestOpReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqRoleSeptQuestOpReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqRoleSeptQuestOpReq* internal_default_instance() {
    return reinterpret_cast<const ReqRoleSeptQuestOpReq*>(
               &_ReqRoleSeptQuestOpReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    270;

  friend void swap(ReqRoleSeptQuestOpReq& a, ReqRoleSeptQuestOpReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqRoleSeptQuestOpReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqRoleSeptQuestOpReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqRoleSeptQuestOpReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqRoleSeptQuestOpReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqRoleSeptQuestOpReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqRoleSeptQuestOpReq& from) {
    ReqRoleSeptQuestOpReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqRoleSeptQuestOpReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReqRoleSeptQuestOpReq";
  }
  protected:
  explicit ReqRoleSeptQuestOpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReqRoleSeptQuestOpReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReqRoleSeptQuestOpAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReqRoleSeptQuestOpAck) */ {
 public:
  inline ReqRoleSeptQuestOpAck() : ReqRoleSeptQuestOpAck(nullptr) {}
  ~ReqRoleSeptQuestOpAck() override;
  explicit PROTOBUF_CONSTEXPR ReqRoleSeptQuestOpAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqRoleSeptQuestOpAck(const ReqRoleSeptQuestOpAck& from);
  ReqRoleSeptQuestOpAck(ReqRoleSeptQuestOpAck&& from) noexcept
    : ReqRoleSeptQuestOpAck() {
    *this = ::std::move(from);
  }

  inline ReqRoleSeptQuestOpAck& operator=(const ReqRoleSeptQuestOpAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqRoleSeptQuestOpAck& operator=(ReqRoleSeptQuestOpAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqRoleSeptQuestOpAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqRoleSeptQuestOpAck* internal_default_instance() {
    return reinterpret_cast<const ReqRoleSeptQuestOpAck*>(
               &_ReqRoleSeptQuestOpAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    271;

  friend void swap(ReqRoleSeptQuestOpAck& a, ReqRoleSeptQuestOpAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqRoleSeptQuestOpAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqRoleSeptQuestOpAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqRoleSeptQuestOpAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqRoleSeptQuestOpAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqRoleSeptQuestOpAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqRoleSeptQuestOpAck& from) {
    ReqRoleSeptQuestOpAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqRoleSeptQuestOpAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReqRoleSeptQuestOpAck";
  }
  protected:
  explicit ReqRoleSeptQuestOpAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReqRoleSeptQuestOpAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshSeptQuestReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.RefreshSeptQuestReq) */ {
 public:
  inline RefreshSeptQuestReq() : RefreshSeptQuestReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RefreshSeptQuestReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshSeptQuestReq(const RefreshSeptQuestReq& from);
  RefreshSeptQuestReq(RefreshSeptQuestReq&& from) noexcept
    : RefreshSeptQuestReq() {
    *this = ::std::move(from);
  }

  inline RefreshSeptQuestReq& operator=(const RefreshSeptQuestReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshSeptQuestReq& operator=(RefreshSeptQuestReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshSeptQuestReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshSeptQuestReq* internal_default_instance() {
    return reinterpret_cast<const RefreshSeptQuestReq*>(
               &_RefreshSeptQuestReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    272;

  friend void swap(RefreshSeptQuestReq& a, RefreshSeptQuestReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshSeptQuestReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshSeptQuestReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshSeptQuestReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshSeptQuestReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RefreshSeptQuestReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RefreshSeptQuestReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshSeptQuestReq";
  }
  protected:
  explicit RefreshSeptQuestReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.RefreshSeptQuestReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshSeptQuestAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshSeptQuestAck) */ {
 public:
  inline RefreshSeptQuestAck() : RefreshSeptQuestAck(nullptr) {}
  ~RefreshSeptQuestAck() override;
  explicit PROTOBUF_CONSTEXPR RefreshSeptQuestAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshSeptQuestAck(const RefreshSeptQuestAck& from);
  RefreshSeptQuestAck(RefreshSeptQuestAck&& from) noexcept
    : RefreshSeptQuestAck() {
    *this = ::std::move(from);
  }

  inline RefreshSeptQuestAck& operator=(const RefreshSeptQuestAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshSeptQuestAck& operator=(RefreshSeptQuestAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshSeptQuestAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshSeptQuestAck* internal_default_instance() {
    return reinterpret_cast<const RefreshSeptQuestAck*>(
               &_RefreshSeptQuestAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    273;

  friend void swap(RefreshSeptQuestAck& a, RefreshSeptQuestAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshSeptQuestAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshSeptQuestAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshSeptQuestAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshSeptQuestAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshSeptQuestAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshSeptQuestAck& from) {
    RefreshSeptQuestAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshSeptQuestAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshSeptQuestAck";
  }
  protected:
  explicit RefreshSeptQuestAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleSeptQuestData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleSeptQuestData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleSeptQuestData* release_data();
  ::idlepb::RoleSeptQuestData* mutable_data();
  void set_allocated_data(::idlepb::RoleSeptQuestData* data);
  private:
  const ::idlepb::RoleSeptQuestData& _internal_data() const;
  ::idlepb::RoleSeptQuestData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleSeptQuestData* data);
  ::idlepb::RoleSeptQuestData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.RefreshSeptQuestAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleSeptQuestData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReqSeptQuestRankUpReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.ReqSeptQuestRankUpReq) */ {
 public:
  inline ReqSeptQuestRankUpReq() : ReqSeptQuestRankUpReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReqSeptQuestRankUpReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSeptQuestRankUpReq(const ReqSeptQuestRankUpReq& from);
  ReqSeptQuestRankUpReq(ReqSeptQuestRankUpReq&& from) noexcept
    : ReqSeptQuestRankUpReq() {
    *this = ::std::move(from);
  }

  inline ReqSeptQuestRankUpReq& operator=(const ReqSeptQuestRankUpReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSeptQuestRankUpReq& operator=(ReqSeptQuestRankUpReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSeptQuestRankUpReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSeptQuestRankUpReq* internal_default_instance() {
    return reinterpret_cast<const ReqSeptQuestRankUpReq*>(
               &_ReqSeptQuestRankUpReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    274;

  friend void swap(ReqSeptQuestRankUpReq& a, ReqSeptQuestRankUpReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSeptQuestRankUpReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSeptQuestRankUpReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSeptQuestRankUpReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSeptQuestRankUpReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqSeptQuestRankUpReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqSeptQuestRankUpReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReqSeptQuestRankUpReq";
  }
  protected:
  explicit ReqSeptQuestRankUpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.ReqSeptQuestRankUpReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReqSeptQuestRankUpAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReqSeptQuestRankUpAck) */ {
 public:
  inline ReqSeptQuestRankUpAck() : ReqSeptQuestRankUpAck(nullptr) {}
  ~ReqSeptQuestRankUpAck() override;
  explicit PROTOBUF_CONSTEXPR ReqSeptQuestRankUpAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSeptQuestRankUpAck(const ReqSeptQuestRankUpAck& from);
  ReqSeptQuestRankUpAck(ReqSeptQuestRankUpAck&& from) noexcept
    : ReqSeptQuestRankUpAck() {
    *this = ::std::move(from);
  }

  inline ReqSeptQuestRankUpAck& operator=(const ReqSeptQuestRankUpAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSeptQuestRankUpAck& operator=(ReqSeptQuestRankUpAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSeptQuestRankUpAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSeptQuestRankUpAck* internal_default_instance() {
    return reinterpret_cast<const ReqSeptQuestRankUpAck*>(
               &_ReqSeptQuestRankUpAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    275;

  friend void swap(ReqSeptQuestRankUpAck& a, ReqSeptQuestRankUpAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSeptQuestRankUpAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSeptQuestRankUpAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSeptQuestRankUpAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSeptQuestRankUpAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSeptQuestRankUpAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReqSeptQuestRankUpAck& from) {
    ReqSeptQuestRankUpAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSeptQuestRankUpAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReqSeptQuestRankUpAck";
  }
  protected:
  explicit ReqSeptQuestRankUpAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReqSeptQuestRankUpAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetGongFaDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetGongFaDataReq) */ {
 public:
  inline GetGongFaDataReq() : GetGongFaDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetGongFaDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetGongFaDataReq(const GetGongFaDataReq& from);
  GetGongFaDataReq(GetGongFaDataReq&& from) noexcept
    : GetGongFaDataReq() {
    *this = ::std::move(from);
  }

  inline GetGongFaDataReq& operator=(const GetGongFaDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGongFaDataReq& operator=(GetGongFaDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetGongFaDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetGongFaDataReq* internal_default_instance() {
    return reinterpret_cast<const GetGongFaDataReq*>(
               &_GetGongFaDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    276;

  friend void swap(GetGongFaDataReq& a, GetGongFaDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetGongFaDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetGongFaDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetGongFaDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetGongFaDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetGongFaDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetGongFaDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetGongFaDataReq";
  }
  protected:
  explicit GetGongFaDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetGongFaDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetGongFaDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetGongFaDataAck) */ {
 public:
  inline GetGongFaDataAck() : GetGongFaDataAck(nullptr) {}
  ~GetGongFaDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetGongFaDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetGongFaDataAck(const GetGongFaDataAck& from);
  GetGongFaDataAck(GetGongFaDataAck&& from) noexcept
    : GetGongFaDataAck() {
    *this = ::std::move(from);
  }

  inline GetGongFaDataAck& operator=(const GetGongFaDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGongFaDataAck& operator=(GetGongFaDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetGongFaDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetGongFaDataAck* internal_default_instance() {
    return reinterpret_cast<const GetGongFaDataAck*>(
               &_GetGongFaDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    277;

  friend void swap(GetGongFaDataAck& a, GetGongFaDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetGongFaDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetGongFaDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetGongFaDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetGongFaDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetGongFaDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetGongFaDataAck& from) {
    GetGongFaDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetGongFaDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetGongFaDataAck";
  }
  protected:
  explicit GetGongFaDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleGongFaData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleGongFaData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleGongFaData* release_data();
  ::idlepb::RoleGongFaData* mutable_data();
  void set_allocated_data(::idlepb::RoleGongFaData* data);
  private:
  const ::idlepb::RoleGongFaData& _internal_data() const;
  ::idlepb::RoleGongFaData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleGongFaData* data);
  ::idlepb::RoleGongFaData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetGongFaDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleGongFaData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GongFaOpReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GongFaOpReq) */ {
 public:
  inline GongFaOpReq() : GongFaOpReq(nullptr) {}
  ~GongFaOpReq() override;
  explicit PROTOBUF_CONSTEXPR GongFaOpReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GongFaOpReq(const GongFaOpReq& from);
  GongFaOpReq(GongFaOpReq&& from) noexcept
    : GongFaOpReq() {
    *this = ::std::move(from);
  }

  inline GongFaOpReq& operator=(const GongFaOpReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GongFaOpReq& operator=(GongFaOpReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GongFaOpReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GongFaOpReq* internal_default_instance() {
    return reinterpret_cast<const GongFaOpReq*>(
               &_GongFaOpReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    278;

  friend void swap(GongFaOpReq& a, GongFaOpReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GongFaOpReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GongFaOpReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GongFaOpReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GongFaOpReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GongFaOpReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GongFaOpReq& from) {
    GongFaOpReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GongFaOpReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GongFaOpReq";
  }
  protected:
  explicit GongFaOpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGongfaIdFieldNumber = 1,
  };
  // int32 gongfa_id = 1;
  void clear_gongfa_id();
  int32_t gongfa_id() const;
  void set_gongfa_id(int32_t value);
  private:
  int32_t _internal_gongfa_id() const;
  void _internal_set_gongfa_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GongFaOpReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t gongfa_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GongFaOpAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GongFaOpAck) */ {
 public:
  inline GongFaOpAck() : GongFaOpAck(nullptr) {}
  ~GongFaOpAck() override;
  explicit PROTOBUF_CONSTEXPR GongFaOpAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GongFaOpAck(const GongFaOpAck& from);
  GongFaOpAck(GongFaOpAck&& from) noexcept
    : GongFaOpAck() {
    *this = ::std::move(from);
  }

  inline GongFaOpAck& operator=(const GongFaOpAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GongFaOpAck& operator=(GongFaOpAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GongFaOpAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GongFaOpAck* internal_default_instance() {
    return reinterpret_cast<const GongFaOpAck*>(
               &_GongFaOpAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    279;

  friend void swap(GongFaOpAck& a, GongFaOpAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GongFaOpAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GongFaOpAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GongFaOpAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GongFaOpAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GongFaOpAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GongFaOpAck& from) {
    GongFaOpAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GongFaOpAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GongFaOpAck";
  }
  protected:
  explicit GongFaOpAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGongfaDataFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.GongFaData gongfa_data = 2;
  bool has_gongfa_data() const;
  private:
  bool _internal_has_gongfa_data() const;
  public:
  void clear_gongfa_data();
  const ::idlepb::GongFaData& gongfa_data() const;
  PROTOBUF_NODISCARD ::idlepb::GongFaData* release_gongfa_data();
  ::idlepb::GongFaData* mutable_gongfa_data();
  void set_allocated_gongfa_data(::idlepb::GongFaData* gongfa_data);
  private:
  const ::idlepb::GongFaData& _internal_gongfa_data() const;
  ::idlepb::GongFaData* _internal_mutable_gongfa_data();
  public:
  void unsafe_arena_set_allocated_gongfa_data(
      ::idlepb::GongFaData* gongfa_data);
  ::idlepb::GongFaData* unsafe_arena_release_gongfa_data();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GongFaOpAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::GongFaData* gongfa_data_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ActivateGongFaMaxEffectReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ActivateGongFaMaxEffectReq) */ {
 public:
  inline ActivateGongFaMaxEffectReq() : ActivateGongFaMaxEffectReq(nullptr) {}
  ~ActivateGongFaMaxEffectReq() override;
  explicit PROTOBUF_CONSTEXPR ActivateGongFaMaxEffectReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActivateGongFaMaxEffectReq(const ActivateGongFaMaxEffectReq& from);
  ActivateGongFaMaxEffectReq(ActivateGongFaMaxEffectReq&& from) noexcept
    : ActivateGongFaMaxEffectReq() {
    *this = ::std::move(from);
  }

  inline ActivateGongFaMaxEffectReq& operator=(const ActivateGongFaMaxEffectReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivateGongFaMaxEffectReq& operator=(ActivateGongFaMaxEffectReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivateGongFaMaxEffectReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActivateGongFaMaxEffectReq* internal_default_instance() {
    return reinterpret_cast<const ActivateGongFaMaxEffectReq*>(
               &_ActivateGongFaMaxEffectReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    280;

  friend void swap(ActivateGongFaMaxEffectReq& a, ActivateGongFaMaxEffectReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ActivateGongFaMaxEffectReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivateGongFaMaxEffectReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivateGongFaMaxEffectReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActivateGongFaMaxEffectReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActivateGongFaMaxEffectReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActivateGongFaMaxEffectReq& from) {
    ActivateGongFaMaxEffectReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActivateGongFaMaxEffectReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ActivateGongFaMaxEffectReq";
  }
  protected:
  explicit ActivateGongFaMaxEffectReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCfgIdFieldNumber = 1,
  };
  // int32 cfg_id = 1;
  void clear_cfg_id();
  int32_t cfg_id() const;
  void set_cfg_id(int32_t value);
  private:
  int32_t _internal_cfg_id() const;
  void _internal_set_cfg_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ActivateGongFaMaxEffectReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t cfg_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ActivateGongFaMaxEffectAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ActivateGongFaMaxEffectAck) */ {
 public:
  inline ActivateGongFaMaxEffectAck() : ActivateGongFaMaxEffectAck(nullptr) {}
  ~ActivateGongFaMaxEffectAck() override;
  explicit PROTOBUF_CONSTEXPR ActivateGongFaMaxEffectAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActivateGongFaMaxEffectAck(const ActivateGongFaMaxEffectAck& from);
  ActivateGongFaMaxEffectAck(ActivateGongFaMaxEffectAck&& from) noexcept
    : ActivateGongFaMaxEffectAck() {
    *this = ::std::move(from);
  }

  inline ActivateGongFaMaxEffectAck& operator=(const ActivateGongFaMaxEffectAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivateGongFaMaxEffectAck& operator=(ActivateGongFaMaxEffectAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivateGongFaMaxEffectAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActivateGongFaMaxEffectAck* internal_default_instance() {
    return reinterpret_cast<const ActivateGongFaMaxEffectAck*>(
               &_ActivateGongFaMaxEffectAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    281;

  friend void swap(ActivateGongFaMaxEffectAck& a, ActivateGongFaMaxEffectAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ActivateGongFaMaxEffectAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivateGongFaMaxEffectAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivateGongFaMaxEffectAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActivateGongFaMaxEffectAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActivateGongFaMaxEffectAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActivateGongFaMaxEffectAck& from) {
    ActivateGongFaMaxEffectAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActivateGongFaMaxEffectAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ActivateGongFaMaxEffectAck";
  }
  protected:
  explicit ActivateGongFaMaxEffectAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ActivateGongFaMaxEffectAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReceiveFuZengRewardsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReceiveFuZengRewardsReq) */ {
 public:
  inline ReceiveFuZengRewardsReq() : ReceiveFuZengRewardsReq(nullptr) {}
  ~ReceiveFuZengRewardsReq() override;
  explicit PROTOBUF_CONSTEXPR ReceiveFuZengRewardsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveFuZengRewardsReq(const ReceiveFuZengRewardsReq& from);
  ReceiveFuZengRewardsReq(ReceiveFuZengRewardsReq&& from) noexcept
    : ReceiveFuZengRewardsReq() {
    *this = ::std::move(from);
  }

  inline ReceiveFuZengRewardsReq& operator=(const ReceiveFuZengRewardsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveFuZengRewardsReq& operator=(ReceiveFuZengRewardsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveFuZengRewardsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveFuZengRewardsReq* internal_default_instance() {
    return reinterpret_cast<const ReceiveFuZengRewardsReq*>(
               &_ReceiveFuZengRewardsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    282;

  friend void swap(ReceiveFuZengRewardsReq& a, ReceiveFuZengRewardsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveFuZengRewardsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveFuZengRewardsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveFuZengRewardsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveFuZengRewardsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveFuZengRewardsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiveFuZengRewardsReq& from) {
    ReceiveFuZengRewardsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveFuZengRewardsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReceiveFuZengRewardsReq";
  }
  protected:
  explicit ReceiveFuZengRewardsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCfgIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // int32 cfg_id = 1;
  void clear_cfg_id();
  int32_t cfg_id() const;
  void set_cfg_id(int32_t value);
  private:
  int32_t _internal_cfg_id() const;
  void _internal_set_cfg_id(int32_t value);
  public:

  // .idlepb.FuZengType type = 2;
  void clear_type();
  ::idlepb::FuZengType type() const;
  void set_type(::idlepb::FuZengType value);
  private:
  ::idlepb::FuZengType _internal_type() const;
  void _internal_set_type(::idlepb::FuZengType value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReceiveFuZengRewardsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t cfg_id_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReceiveFuZengRewardsAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReceiveFuZengRewardsAck) */ {
 public:
  inline ReceiveFuZengRewardsAck() : ReceiveFuZengRewardsAck(nullptr) {}
  ~ReceiveFuZengRewardsAck() override;
  explicit PROTOBUF_CONSTEXPR ReceiveFuZengRewardsAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveFuZengRewardsAck(const ReceiveFuZengRewardsAck& from);
  ReceiveFuZengRewardsAck(ReceiveFuZengRewardsAck&& from) noexcept
    : ReceiveFuZengRewardsAck() {
    *this = ::std::move(from);
  }

  inline ReceiveFuZengRewardsAck& operator=(const ReceiveFuZengRewardsAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveFuZengRewardsAck& operator=(ReceiveFuZengRewardsAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveFuZengRewardsAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveFuZengRewardsAck* internal_default_instance() {
    return reinterpret_cast<const ReceiveFuZengRewardsAck*>(
               &_ReceiveFuZengRewardsAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    283;

  friend void swap(ReceiveFuZengRewardsAck& a, ReceiveFuZengRewardsAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveFuZengRewardsAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveFuZengRewardsAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveFuZengRewardsAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveFuZengRewardsAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveFuZengRewardsAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiveFuZengRewardsAck& from) {
    ReceiveFuZengRewardsAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveFuZengRewardsAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReceiveFuZengRewardsAck";
  }
  protected:
  explicit ReceiveFuZengRewardsAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.FuZengData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::FuZengData& data() const;
  PROTOBUF_NODISCARD ::idlepb::FuZengData* release_data();
  ::idlepb::FuZengData* mutable_data();
  void set_allocated_data(::idlepb::FuZengData* data);
  private:
  const ::idlepb::FuZengData& _internal_data() const;
  ::idlepb::FuZengData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::FuZengData* data);
  ::idlepb::FuZengData* unsafe_arena_release_data();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReceiveFuZengRewardsAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::FuZengData* data_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleFuZengDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetRoleFuZengDataReq) */ {
 public:
  inline GetRoleFuZengDataReq() : GetRoleFuZengDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetRoleFuZengDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleFuZengDataReq(const GetRoleFuZengDataReq& from);
  GetRoleFuZengDataReq(GetRoleFuZengDataReq&& from) noexcept
    : GetRoleFuZengDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleFuZengDataReq& operator=(const GetRoleFuZengDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleFuZengDataReq& operator=(GetRoleFuZengDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleFuZengDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleFuZengDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleFuZengDataReq*>(
               &_GetRoleFuZengDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    284;

  friend void swap(GetRoleFuZengDataReq& a, GetRoleFuZengDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleFuZengDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleFuZengDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleFuZengDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleFuZengDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetRoleFuZengDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetRoleFuZengDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleFuZengDataReq";
  }
  protected:
  explicit GetRoleFuZengDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleFuZengDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleFuZengDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleFuZengDataAck) */ {
 public:
  inline GetRoleFuZengDataAck() : GetRoleFuZengDataAck(nullptr) {}
  ~GetRoleFuZengDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleFuZengDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleFuZengDataAck(const GetRoleFuZengDataAck& from);
  GetRoleFuZengDataAck(GetRoleFuZengDataAck&& from) noexcept
    : GetRoleFuZengDataAck() {
    *this = ::std::move(from);
  }

  inline GetRoleFuZengDataAck& operator=(const GetRoleFuZengDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleFuZengDataAck& operator=(GetRoleFuZengDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleFuZengDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleFuZengDataAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleFuZengDataAck*>(
               &_GetRoleFuZengDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    285;

  friend void swap(GetRoleFuZengDataAck& a, GetRoleFuZengDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleFuZengDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleFuZengDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleFuZengDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleFuZengDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleFuZengDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleFuZengDataAck& from) {
    GetRoleFuZengDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleFuZengDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleFuZengDataAck";
  }
  protected:
  explicit GetRoleFuZengDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleFuZengData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleFuZengData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleFuZengData* release_data();
  ::idlepb::RoleFuZengData* mutable_data();
  void set_allocated_data(::idlepb::RoleFuZengData* data);
  private:
  const ::idlepb::RoleFuZengData& _internal_data() const;
  ::idlepb::RoleFuZengData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleFuZengData* data);
  ::idlepb::RoleFuZengData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleFuZengDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleFuZengData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyFuZeng final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyFuZeng) */ {
 public:
  inline NotifyFuZeng() : NotifyFuZeng(nullptr) {}
  ~NotifyFuZeng() override;
  explicit PROTOBUF_CONSTEXPR NotifyFuZeng(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyFuZeng(const NotifyFuZeng& from);
  NotifyFuZeng(NotifyFuZeng&& from) noexcept
    : NotifyFuZeng() {
    *this = ::std::move(from);
  }

  inline NotifyFuZeng& operator=(const NotifyFuZeng& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyFuZeng& operator=(NotifyFuZeng&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyFuZeng& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyFuZeng* internal_default_instance() {
    return reinterpret_cast<const NotifyFuZeng*>(
               &_NotifyFuZeng_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    286;

  friend void swap(NotifyFuZeng& a, NotifyFuZeng& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyFuZeng* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyFuZeng* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyFuZeng* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyFuZeng>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyFuZeng& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyFuZeng& from) {
    NotifyFuZeng::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyFuZeng* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyFuZeng";
  }
  protected:
  explicit NotifyFuZeng(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumFieldNumber = 2,
    kTypeFieldNumber = 1,
    kCfgIdFieldNumber = 3,
  };
  // int64 num = 2;
  void clear_num();
  int64_t num() const;
  void set_num(int64_t value);
  private:
  int64_t _internal_num() const;
  void _internal_set_num(int64_t value);
  public:

  // .idlepb.FuZengType type = 1;
  void clear_type();
  ::idlepb::FuZengType type() const;
  void set_type(::idlepb::FuZengType value);
  private:
  ::idlepb::FuZengType _internal_type() const;
  void _internal_set_type(::idlepb::FuZengType value);
  public:

  // int32 cfg_id = 3;
  void clear_cfg_id();
  int32_t cfg_id() const;
  void set_cfg_id(int32_t value);
  private:
  int32_t _internal_cfg_id() const;
  void _internal_set_cfg_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyFuZeng)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t num_;
    int type_;
    int32_t cfg_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleTreasuryDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleTreasuryDataReq) */ {
 public:
  inline GetRoleTreasuryDataReq() : GetRoleTreasuryDataReq(nullptr) {}
  ~GetRoleTreasuryDataReq() override;
  explicit PROTOBUF_CONSTEXPR GetRoleTreasuryDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleTreasuryDataReq(const GetRoleTreasuryDataReq& from);
  GetRoleTreasuryDataReq(GetRoleTreasuryDataReq&& from) noexcept
    : GetRoleTreasuryDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleTreasuryDataReq& operator=(const GetRoleTreasuryDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleTreasuryDataReq& operator=(GetRoleTreasuryDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleTreasuryDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleTreasuryDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleTreasuryDataReq*>(
               &_GetRoleTreasuryDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    287;

  friend void swap(GetRoleTreasuryDataReq& a, GetRoleTreasuryDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleTreasuryDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleTreasuryDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleTreasuryDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleTreasuryDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleTreasuryDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleTreasuryDataReq& from) {
    GetRoleTreasuryDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleTreasuryDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleTreasuryDataReq";
  }
  protected:
  explicit GetRoleTreasuryDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirtyFlagFieldNumber = 1,
  };
  // bool dirty_flag = 1;
  void clear_dirty_flag();
  bool dirty_flag() const;
  void set_dirty_flag(bool value);
  private:
  bool _internal_dirty_flag() const;
  void _internal_set_dirty_flag(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleTreasuryDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool dirty_flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleTreasuryDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleTreasuryDataAck) */ {
 public:
  inline GetRoleTreasuryDataAck() : GetRoleTreasuryDataAck(nullptr) {}
  ~GetRoleTreasuryDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleTreasuryDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleTreasuryDataAck(const GetRoleTreasuryDataAck& from);
  GetRoleTreasuryDataAck(GetRoleTreasuryDataAck&& from) noexcept
    : GetRoleTreasuryDataAck() {
    *this = ::std::move(from);
  }

  inline GetRoleTreasuryDataAck& operator=(const GetRoleTreasuryDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleTreasuryDataAck& operator=(GetRoleTreasuryDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleTreasuryDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleTreasuryDataAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleTreasuryDataAck*>(
               &_GetRoleTreasuryDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    288;

  friend void swap(GetRoleTreasuryDataAck& a, GetRoleTreasuryDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleTreasuryDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleTreasuryDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleTreasuryDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleTreasuryDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleTreasuryDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleTreasuryDataAck& from) {
    GetRoleTreasuryDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleTreasuryDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleTreasuryDataAck";
  }
  protected:
  explicit GetRoleTreasuryDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleTreasurySaveData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleTreasurySaveData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleTreasurySaveData* release_data();
  ::idlepb::RoleTreasurySaveData* mutable_data();
  void set_allocated_data(::idlepb::RoleTreasurySaveData* data);
  private:
  const ::idlepb::RoleTreasurySaveData& _internal_data() const;
  ::idlepb::RoleTreasurySaveData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleTreasurySaveData* data);
  ::idlepb::RoleTreasurySaveData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleTreasuryDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleTreasurySaveData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OpenTreasuryChestReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.OpenTreasuryChestReq) */ {
 public:
  inline OpenTreasuryChestReq() : OpenTreasuryChestReq(nullptr) {}
  ~OpenTreasuryChestReq() override;
  explicit PROTOBUF_CONSTEXPR OpenTreasuryChestReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenTreasuryChestReq(const OpenTreasuryChestReq& from);
  OpenTreasuryChestReq(OpenTreasuryChestReq&& from) noexcept
    : OpenTreasuryChestReq() {
    *this = ::std::move(from);
  }

  inline OpenTreasuryChestReq& operator=(const OpenTreasuryChestReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenTreasuryChestReq& operator=(OpenTreasuryChestReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenTreasuryChestReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenTreasuryChestReq* internal_default_instance() {
    return reinterpret_cast<const OpenTreasuryChestReq*>(
               &_OpenTreasuryChestReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    289;

  friend void swap(OpenTreasuryChestReq& a, OpenTreasuryChestReq& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenTreasuryChestReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenTreasuryChestReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenTreasuryChestReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenTreasuryChestReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenTreasuryChestReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenTreasuryChestReq& from) {
    OpenTreasuryChestReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenTreasuryChestReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OpenTreasuryChestReq";
  }
  protected:
  explicit OpenTreasuryChestReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChestTypeFieldNumber = 1,
    kNumFieldNumber = 2,
  };
  // int32 chest_type = 1;
  void clear_chest_type();
  int32_t chest_type() const;
  void set_chest_type(int32_t value);
  private:
  int32_t _internal_chest_type() const;
  void _internal_set_chest_type(int32_t value);
  public:

  // int32 num = 2;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.OpenTreasuryChestReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t chest_type_;
    int32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OpenTreasuryChestAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.OpenTreasuryChestAck) */ {
 public:
  inline OpenTreasuryChestAck() : OpenTreasuryChestAck(nullptr) {}
  ~OpenTreasuryChestAck() override;
  explicit PROTOBUF_CONSTEXPR OpenTreasuryChestAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenTreasuryChestAck(const OpenTreasuryChestAck& from);
  OpenTreasuryChestAck(OpenTreasuryChestAck&& from) noexcept
    : OpenTreasuryChestAck() {
    *this = ::std::move(from);
  }

  inline OpenTreasuryChestAck& operator=(const OpenTreasuryChestAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenTreasuryChestAck& operator=(OpenTreasuryChestAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenTreasuryChestAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenTreasuryChestAck* internal_default_instance() {
    return reinterpret_cast<const OpenTreasuryChestAck*>(
               &_OpenTreasuryChestAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    290;

  friend void swap(OpenTreasuryChestAck& a, OpenTreasuryChestAck& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenTreasuryChestAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenTreasuryChestAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenTreasuryChestAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenTreasuryChestAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenTreasuryChestAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenTreasuryChestAck& from) {
    OpenTreasuryChestAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenTreasuryChestAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OpenTreasuryChestAck";
  }
  protected:
  explicit OpenTreasuryChestAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.OpenTreasuryChestAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OneClickOpenTreasuryChestReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.OneClickOpenTreasuryChestReq) */ {
 public:
  inline OneClickOpenTreasuryChestReq() : OneClickOpenTreasuryChestReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OneClickOpenTreasuryChestReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneClickOpenTreasuryChestReq(const OneClickOpenTreasuryChestReq& from);
  OneClickOpenTreasuryChestReq(OneClickOpenTreasuryChestReq&& from) noexcept
    : OneClickOpenTreasuryChestReq() {
    *this = ::std::move(from);
  }

  inline OneClickOpenTreasuryChestReq& operator=(const OneClickOpenTreasuryChestReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneClickOpenTreasuryChestReq& operator=(OneClickOpenTreasuryChestReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneClickOpenTreasuryChestReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneClickOpenTreasuryChestReq* internal_default_instance() {
    return reinterpret_cast<const OneClickOpenTreasuryChestReq*>(
               &_OneClickOpenTreasuryChestReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    291;

  friend void swap(OneClickOpenTreasuryChestReq& a, OneClickOpenTreasuryChestReq& b) {
    a.Swap(&b);
  }
  inline void Swap(OneClickOpenTreasuryChestReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneClickOpenTreasuryChestReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneClickOpenTreasuryChestReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneClickOpenTreasuryChestReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OneClickOpenTreasuryChestReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OneClickOpenTreasuryChestReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OneClickOpenTreasuryChestReq";
  }
  protected:
  explicit OneClickOpenTreasuryChestReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.OneClickOpenTreasuryChestReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OneClickOpenTreasuryChestAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.OneClickOpenTreasuryChestAck) */ {
 public:
  inline OneClickOpenTreasuryChestAck() : OneClickOpenTreasuryChestAck(nullptr) {}
  ~OneClickOpenTreasuryChestAck() override;
  explicit PROTOBUF_CONSTEXPR OneClickOpenTreasuryChestAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OneClickOpenTreasuryChestAck(const OneClickOpenTreasuryChestAck& from);
  OneClickOpenTreasuryChestAck(OneClickOpenTreasuryChestAck&& from) noexcept
    : OneClickOpenTreasuryChestAck() {
    *this = ::std::move(from);
  }

  inline OneClickOpenTreasuryChestAck& operator=(const OneClickOpenTreasuryChestAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneClickOpenTreasuryChestAck& operator=(OneClickOpenTreasuryChestAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneClickOpenTreasuryChestAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneClickOpenTreasuryChestAck* internal_default_instance() {
    return reinterpret_cast<const OneClickOpenTreasuryChestAck*>(
               &_OneClickOpenTreasuryChestAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    292;

  friend void swap(OneClickOpenTreasuryChestAck& a, OneClickOpenTreasuryChestAck& b) {
    a.Swap(&b);
  }
  inline void Swap(OneClickOpenTreasuryChestAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneClickOpenTreasuryChestAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneClickOpenTreasuryChestAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneClickOpenTreasuryChestAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OneClickOpenTreasuryChestAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OneClickOpenTreasuryChestAck& from) {
    OneClickOpenTreasuryChestAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneClickOpenTreasuryChestAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OneClickOpenTreasuryChestAck";
  }
  protected:
  explicit OneClickOpenTreasuryChestAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTodayOpenTimesFieldNumber = 2,
    kGuaranteeCountFieldNumber = 3,
    kOkFieldNumber = 1,
  };
  // repeated int32 today_open_times = 2;
  int today_open_times_size() const;
  private:
  int _internal_today_open_times_size() const;
  public:
  void clear_today_open_times();
  private:
  int32_t _internal_today_open_times(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_today_open_times() const;
  void _internal_add_today_open_times(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_today_open_times();
  public:
  int32_t today_open_times(int index) const;
  void set_today_open_times(int index, int32_t value);
  void add_today_open_times(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      today_open_times() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_today_open_times();

  // repeated int32 guarantee_count = 3;
  int guarantee_count_size() const;
  private:
  int _internal_guarantee_count_size() const;
  public:
  void clear_guarantee_count();
  private:
  int32_t _internal_guarantee_count(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_guarantee_count() const;
  void _internal_add_guarantee_count(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_guarantee_count();
  public:
  int32_t guarantee_count(int index) const;
  void set_guarantee_count(int index, int32_t value);
  void add_guarantee_count(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      guarantee_count() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_guarantee_count();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.OneClickOpenTreasuryChestAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > today_open_times_;
    mutable std::atomic<int> _today_open_times_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > guarantee_count_;
    mutable std::atomic<int> _guarantee_count_cached_byte_size_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OpenTreasuryGachaReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.OpenTreasuryGachaReq) */ {
 public:
  inline OpenTreasuryGachaReq() : OpenTreasuryGachaReq(nullptr) {}
  ~OpenTreasuryGachaReq() override;
  explicit PROTOBUF_CONSTEXPR OpenTreasuryGachaReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenTreasuryGachaReq(const OpenTreasuryGachaReq& from);
  OpenTreasuryGachaReq(OpenTreasuryGachaReq&& from) noexcept
    : OpenTreasuryGachaReq() {
    *this = ::std::move(from);
  }

  inline OpenTreasuryGachaReq& operator=(const OpenTreasuryGachaReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenTreasuryGachaReq& operator=(OpenTreasuryGachaReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenTreasuryGachaReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenTreasuryGachaReq* internal_default_instance() {
    return reinterpret_cast<const OpenTreasuryGachaReq*>(
               &_OpenTreasuryGachaReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    293;

  friend void swap(OpenTreasuryGachaReq& a, OpenTreasuryGachaReq& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenTreasuryGachaReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenTreasuryGachaReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenTreasuryGachaReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenTreasuryGachaReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenTreasuryGachaReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenTreasuryGachaReq& from) {
    OpenTreasuryGachaReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenTreasuryGachaReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OpenTreasuryGachaReq";
  }
  protected:
  explicit OpenTreasuryGachaReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGachaTypeFieldNumber = 1,
    kNumFieldNumber = 2,
  };
  // int32 gacha_type = 1;
  void clear_gacha_type();
  int32_t gacha_type() const;
  void set_gacha_type(int32_t value);
  private:
  int32_t _internal_gacha_type() const;
  void _internal_set_gacha_type(int32_t value);
  public:

  // int32 num = 2;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.OpenTreasuryGachaReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t gacha_type_;
    int32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API OpenTreasuryGachaAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.OpenTreasuryGachaAck) */ {
 public:
  inline OpenTreasuryGachaAck() : OpenTreasuryGachaAck(nullptr) {}
  ~OpenTreasuryGachaAck() override;
  explicit PROTOBUF_CONSTEXPR OpenTreasuryGachaAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenTreasuryGachaAck(const OpenTreasuryGachaAck& from);
  OpenTreasuryGachaAck(OpenTreasuryGachaAck&& from) noexcept
    : OpenTreasuryGachaAck() {
    *this = ::std::move(from);
  }

  inline OpenTreasuryGachaAck& operator=(const OpenTreasuryGachaAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenTreasuryGachaAck& operator=(OpenTreasuryGachaAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenTreasuryGachaAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenTreasuryGachaAck* internal_default_instance() {
    return reinterpret_cast<const OpenTreasuryGachaAck*>(
               &_OpenTreasuryGachaAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    294;

  friend void swap(OpenTreasuryGachaAck& a, OpenTreasuryGachaAck& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenTreasuryGachaAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenTreasuryGachaAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenTreasuryGachaAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenTreasuryGachaAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenTreasuryGachaAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenTreasuryGachaAck& from) {
    OpenTreasuryGachaAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenTreasuryGachaAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.OpenTreasuryGachaAck";
  }
  protected:
  explicit OpenTreasuryGachaAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
    kFreeFieldNumber = 2,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // bool free = 2;
  void clear_free();
  bool free() const;
  void set_free(bool value);
  private:
  bool _internal_free() const;
  void _internal_set_free(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.OpenTreasuryGachaAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    bool free_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshTreasuryShopReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.RefreshTreasuryShopReq) */ {
 public:
  inline RefreshTreasuryShopReq() : RefreshTreasuryShopReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RefreshTreasuryShopReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshTreasuryShopReq(const RefreshTreasuryShopReq& from);
  RefreshTreasuryShopReq(RefreshTreasuryShopReq&& from) noexcept
    : RefreshTreasuryShopReq() {
    *this = ::std::move(from);
  }

  inline RefreshTreasuryShopReq& operator=(const RefreshTreasuryShopReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshTreasuryShopReq& operator=(RefreshTreasuryShopReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshTreasuryShopReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshTreasuryShopReq* internal_default_instance() {
    return reinterpret_cast<const RefreshTreasuryShopReq*>(
               &_RefreshTreasuryShopReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    295;

  friend void swap(RefreshTreasuryShopReq& a, RefreshTreasuryShopReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshTreasuryShopReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshTreasuryShopReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshTreasuryShopReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshTreasuryShopReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RefreshTreasuryShopReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RefreshTreasuryShopReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshTreasuryShopReq";
  }
  protected:
  explicit RefreshTreasuryShopReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.RefreshTreasuryShopReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RefreshTreasuryShopAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RefreshTreasuryShopAck) */ {
 public:
  inline RefreshTreasuryShopAck() : RefreshTreasuryShopAck(nullptr) {}
  ~RefreshTreasuryShopAck() override;
  explicit PROTOBUF_CONSTEXPR RefreshTreasuryShopAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshTreasuryShopAck(const RefreshTreasuryShopAck& from);
  RefreshTreasuryShopAck(RefreshTreasuryShopAck&& from) noexcept
    : RefreshTreasuryShopAck() {
    *this = ::std::move(from);
  }

  inline RefreshTreasuryShopAck& operator=(const RefreshTreasuryShopAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshTreasuryShopAck& operator=(RefreshTreasuryShopAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshTreasuryShopAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshTreasuryShopAck* internal_default_instance() {
    return reinterpret_cast<const RefreshTreasuryShopAck*>(
               &_RefreshTreasuryShopAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    296;

  friend void swap(RefreshTreasuryShopAck& a, RefreshTreasuryShopAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshTreasuryShopAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshTreasuryShopAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshTreasuryShopAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshTreasuryShopAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshTreasuryShopAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshTreasuryShopAck& from) {
    RefreshTreasuryShopAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshTreasuryShopAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RefreshTreasuryShopAck";
  }
  protected:
  explicit RefreshTreasuryShopAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // repeated .idlepb.TreasuryShopItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::TreasuryShopItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TreasuryShopItem >*
      mutable_items();
  private:
  const ::idlepb::TreasuryShopItem& _internal_items(int index) const;
  ::idlepb::TreasuryShopItem* _internal_add_items();
  public:
  const ::idlepb::TreasuryShopItem& items(int index) const;
  ::idlepb::TreasuryShopItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TreasuryShopItem >&
      items() const;

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RefreshTreasuryShopAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TreasuryShopItem > items_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API TreasuryShopBuyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.TreasuryShopBuyReq) */ {
 public:
  inline TreasuryShopBuyReq() : TreasuryShopBuyReq(nullptr) {}
  ~TreasuryShopBuyReq() override;
  explicit PROTOBUF_CONSTEXPR TreasuryShopBuyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TreasuryShopBuyReq(const TreasuryShopBuyReq& from);
  TreasuryShopBuyReq(TreasuryShopBuyReq&& from) noexcept
    : TreasuryShopBuyReq() {
    *this = ::std::move(from);
  }

  inline TreasuryShopBuyReq& operator=(const TreasuryShopBuyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreasuryShopBuyReq& operator=(TreasuryShopBuyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TreasuryShopBuyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TreasuryShopBuyReq* internal_default_instance() {
    return reinterpret_cast<const TreasuryShopBuyReq*>(
               &_TreasuryShopBuyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    297;

  friend void swap(TreasuryShopBuyReq& a, TreasuryShopBuyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TreasuryShopBuyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TreasuryShopBuyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TreasuryShopBuyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TreasuryShopBuyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TreasuryShopBuyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TreasuryShopBuyReq& from) {
    TreasuryShopBuyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreasuryShopBuyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.TreasuryShopBuyReq";
  }
  protected:
  explicit TreasuryShopBuyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.TreasuryShopBuyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API TreasuryShopBuyAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.TreasuryShopBuyAck) */ {
 public:
  inline TreasuryShopBuyAck() : TreasuryShopBuyAck(nullptr) {}
  ~TreasuryShopBuyAck() override;
  explicit PROTOBUF_CONSTEXPR TreasuryShopBuyAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TreasuryShopBuyAck(const TreasuryShopBuyAck& from);
  TreasuryShopBuyAck(TreasuryShopBuyAck&& from) noexcept
    : TreasuryShopBuyAck() {
    *this = ::std::move(from);
  }

  inline TreasuryShopBuyAck& operator=(const TreasuryShopBuyAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreasuryShopBuyAck& operator=(TreasuryShopBuyAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TreasuryShopBuyAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const TreasuryShopBuyAck* internal_default_instance() {
    return reinterpret_cast<const TreasuryShopBuyAck*>(
               &_TreasuryShopBuyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    298;

  friend void swap(TreasuryShopBuyAck& a, TreasuryShopBuyAck& b) {
    a.Swap(&b);
  }
  inline void Swap(TreasuryShopBuyAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TreasuryShopBuyAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TreasuryShopBuyAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TreasuryShopBuyAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TreasuryShopBuyAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TreasuryShopBuyAck& from) {
    TreasuryShopBuyAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreasuryShopBuyAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.TreasuryShopBuyAck";
  }
  protected:
  explicit TreasuryShopBuyAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.TreasuryShopBuyAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetLifeCounterDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetLifeCounterDataReq) */ {
 public:
  inline GetLifeCounterDataReq() : GetLifeCounterDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetLifeCounterDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLifeCounterDataReq(const GetLifeCounterDataReq& from);
  GetLifeCounterDataReq(GetLifeCounterDataReq&& from) noexcept
    : GetLifeCounterDataReq() {
    *this = ::std::move(from);
  }

  inline GetLifeCounterDataReq& operator=(const GetLifeCounterDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLifeCounterDataReq& operator=(GetLifeCounterDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLifeCounterDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLifeCounterDataReq* internal_default_instance() {
    return reinterpret_cast<const GetLifeCounterDataReq*>(
               &_GetLifeCounterDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    299;

  friend void swap(GetLifeCounterDataReq& a, GetLifeCounterDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLifeCounterDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLifeCounterDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLifeCounterDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLifeCounterDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetLifeCounterDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetLifeCounterDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetLifeCounterDataReq";
  }
  protected:
  explicit GetLifeCounterDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetLifeCounterDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetLifeCounterDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetLifeCounterDataAck) */ {
 public:
  inline GetLifeCounterDataAck() : GetLifeCounterDataAck(nullptr) {}
  ~GetLifeCounterDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetLifeCounterDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLifeCounterDataAck(const GetLifeCounterDataAck& from);
  GetLifeCounterDataAck(GetLifeCounterDataAck&& from) noexcept
    : GetLifeCounterDataAck() {
    *this = ::std::move(from);
  }

  inline GetLifeCounterDataAck& operator=(const GetLifeCounterDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLifeCounterDataAck& operator=(GetLifeCounterDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLifeCounterDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLifeCounterDataAck* internal_default_instance() {
    return reinterpret_cast<const GetLifeCounterDataAck*>(
               &_GetLifeCounterDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    300;

  friend void swap(GetLifeCounterDataAck& a, GetLifeCounterDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLifeCounterDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLifeCounterDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLifeCounterDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLifeCounterDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLifeCounterDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLifeCounterDataAck& from) {
    GetLifeCounterDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLifeCounterDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetLifeCounterDataAck";
  }
  protected:
  explicit GetLifeCounterDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleLifeCounterData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleLifeCounterData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleLifeCounterData* release_data();
  ::idlepb::RoleLifeCounterData* mutable_data();
  void set_allocated_data(::idlepb::RoleLifeCounterData* data);
  private:
  const ::idlepb::RoleLifeCounterData& _internal_data() const;
  ::idlepb::RoleLifeCounterData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleLifeCounterData* data);
  ::idlepb::RoleLifeCounterData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetLifeCounterDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleLifeCounterData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UpdateLifeCounter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UpdateLifeCounter) */ {
 public:
  inline UpdateLifeCounter() : UpdateLifeCounter(nullptr) {}
  ~UpdateLifeCounter() override;
  explicit PROTOBUF_CONSTEXPR UpdateLifeCounter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLifeCounter(const UpdateLifeCounter& from);
  UpdateLifeCounter(UpdateLifeCounter&& from) noexcept
    : UpdateLifeCounter() {
    *this = ::std::move(from);
  }

  inline UpdateLifeCounter& operator=(const UpdateLifeCounter& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLifeCounter& operator=(UpdateLifeCounter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLifeCounter& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLifeCounter* internal_default_instance() {
    return reinterpret_cast<const UpdateLifeCounter*>(
               &_UpdateLifeCounter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    301;

  friend void swap(UpdateLifeCounter& a, UpdateLifeCounter& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLifeCounter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLifeCounter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLifeCounter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLifeCounter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLifeCounter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateLifeCounter& from) {
    UpdateLifeCounter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLifeCounter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UpdateLifeCounter";
  }
  protected:
  explicit UpdateLifeCounter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionTypeFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kNewNumFieldNumber = 3,
  };
  // int32 function_type = 1;
  void clear_function_type();
  int32_t function_type() const;
  void set_function_type(int32_t value);
  private:
  int32_t _internal_function_type() const;
  void _internal_set_function_type(int32_t value);
  public:

  // int32 target_id = 2;
  void clear_target_id();
  int32_t target_id() const;
  void set_target_id(int32_t value);
  private:
  int32_t _internal_target_id() const;
  void _internal_set_target_id(int32_t value);
  public:

  // int64 new_num = 3;
  void clear_new_num();
  int64_t new_num() const;
  void set_new_num(int64_t value);
  private:
  int64_t _internal_new_num() const;
  void _internal_set_new_num(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UpdateLifeCounter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t function_type_;
    int32_t target_id_;
    int64_t new_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DoQuestFightReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DoQuestFightReq) */ {
 public:
  inline DoQuestFightReq() : DoQuestFightReq(nullptr) {}
  ~DoQuestFightReq() override;
  explicit PROTOBUF_CONSTEXPR DoQuestFightReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoQuestFightReq(const DoQuestFightReq& from);
  DoQuestFightReq(DoQuestFightReq&& from) noexcept
    : DoQuestFightReq() {
    *this = ::std::move(from);
  }

  inline DoQuestFightReq& operator=(const DoQuestFightReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoQuestFightReq& operator=(DoQuestFightReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoQuestFightReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoQuestFightReq* internal_default_instance() {
    return reinterpret_cast<const DoQuestFightReq*>(
               &_DoQuestFightReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    302;

  friend void swap(DoQuestFightReq& a, DoQuestFightReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DoQuestFightReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoQuestFightReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoQuestFightReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoQuestFightReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoQuestFightReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoQuestFightReq& from) {
    DoQuestFightReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoQuestFightReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DoQuestFightReq";
  }
  protected:
  explicit DoQuestFightReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestIdFieldNumber = 1,
  };
  // int32 quest_id = 1;
  void clear_quest_id();
  int32_t quest_id() const;
  void set_quest_id(int32_t value);
  private:
  int32_t _internal_quest_id() const;
  void _internal_set_quest_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DoQuestFightReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t quest_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DoQuestFightAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DoQuestFightAck) */ {
 public:
  inline DoQuestFightAck() : DoQuestFightAck(nullptr) {}
  ~DoQuestFightAck() override;
  explicit PROTOBUF_CONSTEXPR DoQuestFightAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoQuestFightAck(const DoQuestFightAck& from);
  DoQuestFightAck(DoQuestFightAck&& from) noexcept
    : DoQuestFightAck() {
    *this = ::std::move(from);
  }

  inline DoQuestFightAck& operator=(const DoQuestFightAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoQuestFightAck& operator=(DoQuestFightAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoQuestFightAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoQuestFightAck* internal_default_instance() {
    return reinterpret_cast<const DoQuestFightAck*>(
               &_DoQuestFightAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    303;

  friend void swap(DoQuestFightAck& a, DoQuestFightAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DoQuestFightAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoQuestFightAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoQuestFightAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoQuestFightAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoQuestFightAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoQuestFightAck& from) {
    DoQuestFightAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoQuestFightAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DoQuestFightAck";
  }
  protected:
  explicit DoQuestFightAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DoQuestFightAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API QuestFightQuickEndReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.QuestFightQuickEndReq) */ {
 public:
  inline QuestFightQuickEndReq() : QuestFightQuickEndReq(nullptr) {}
  ~QuestFightQuickEndReq() override;
  explicit PROTOBUF_CONSTEXPR QuestFightQuickEndReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuestFightQuickEndReq(const QuestFightQuickEndReq& from);
  QuestFightQuickEndReq(QuestFightQuickEndReq&& from) noexcept
    : QuestFightQuickEndReq() {
    *this = ::std::move(from);
  }

  inline QuestFightQuickEndReq& operator=(const QuestFightQuickEndReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestFightQuickEndReq& operator=(QuestFightQuickEndReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestFightQuickEndReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestFightQuickEndReq* internal_default_instance() {
    return reinterpret_cast<const QuestFightQuickEndReq*>(
               &_QuestFightQuickEndReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    304;

  friend void swap(QuestFightQuickEndReq& a, QuestFightQuickEndReq& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestFightQuickEndReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestFightQuickEndReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestFightQuickEndReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestFightQuickEndReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuestFightQuickEndReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuestFightQuickEndReq& from) {
    QuestFightQuickEndReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuestFightQuickEndReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.QuestFightQuickEndReq";
  }
  protected:
  explicit QuestFightQuickEndReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsExitFieldNumber = 1,
  };
  // bool is_exit = 1;
  void clear_is_exit();
  bool is_exit() const;
  void set_is_exit(bool value);
  private:
  bool _internal_is_exit() const;
  void _internal_set_is_exit(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.QuestFightQuickEndReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_exit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API QuestFightQuickEndAck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.QuestFightQuickEndAck) */ {
 public:
  inline QuestFightQuickEndAck() : QuestFightQuickEndAck(nullptr) {}
  explicit PROTOBUF_CONSTEXPR QuestFightQuickEndAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuestFightQuickEndAck(const QuestFightQuickEndAck& from);
  QuestFightQuickEndAck(QuestFightQuickEndAck&& from) noexcept
    : QuestFightQuickEndAck() {
    *this = ::std::move(from);
  }

  inline QuestFightQuickEndAck& operator=(const QuestFightQuickEndAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestFightQuickEndAck& operator=(QuestFightQuickEndAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestFightQuickEndAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestFightQuickEndAck* internal_default_instance() {
    return reinterpret_cast<const QuestFightQuickEndAck*>(
               &_QuestFightQuickEndAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    305;

  friend void swap(QuestFightQuickEndAck& a, QuestFightQuickEndAck& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestFightQuickEndAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestFightQuickEndAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestFightQuickEndAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestFightQuickEndAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const QuestFightQuickEndAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const QuestFightQuickEndAck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.QuestFightQuickEndAck";
  }
  protected:
  explicit QuestFightQuickEndAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.QuestFightQuickEndAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyQuestFightChallengeOver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyQuestFightChallengeOver) */ {
 public:
  inline NotifyQuestFightChallengeOver() : NotifyQuestFightChallengeOver(nullptr) {}
  ~NotifyQuestFightChallengeOver() override;
  explicit PROTOBUF_CONSTEXPR NotifyQuestFightChallengeOver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyQuestFightChallengeOver(const NotifyQuestFightChallengeOver& from);
  NotifyQuestFightChallengeOver(NotifyQuestFightChallengeOver&& from) noexcept
    : NotifyQuestFightChallengeOver() {
    *this = ::std::move(from);
  }

  inline NotifyQuestFightChallengeOver& operator=(const NotifyQuestFightChallengeOver& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyQuestFightChallengeOver& operator=(NotifyQuestFightChallengeOver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyQuestFightChallengeOver& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyQuestFightChallengeOver* internal_default_instance() {
    return reinterpret_cast<const NotifyQuestFightChallengeOver*>(
               &_NotifyQuestFightChallengeOver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    306;

  friend void swap(NotifyQuestFightChallengeOver& a, NotifyQuestFightChallengeOver& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyQuestFightChallengeOver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyQuestFightChallengeOver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyQuestFightChallengeOver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyQuestFightChallengeOver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyQuestFightChallengeOver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyQuestFightChallengeOver& from) {
    NotifyQuestFightChallengeOver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyQuestFightChallengeOver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyQuestFightChallengeOver";
  }
  protected:
  explicit NotifyQuestFightChallengeOver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestIdFieldNumber = 1,
    kWinFieldNumber = 2,
  };
  // int32 quest_id = 1;
  void clear_quest_id();
  int32_t quest_id() const;
  void set_quest_id(int32_t value);
  private:
  int32_t _internal_quest_id() const;
  void _internal_set_quest_id(int32_t value);
  public:

  // bool win = 2;
  void clear_win();
  bool win() const;
  void set_win(bool value);
  private:
  bool _internal_win() const;
  void _internal_set_win(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyQuestFightChallengeOver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t quest_id_;
    bool win_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetAppearanceDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetAppearanceDataReq) */ {
 public:
  inline GetAppearanceDataReq() : GetAppearanceDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetAppearanceDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAppearanceDataReq(const GetAppearanceDataReq& from);
  GetAppearanceDataReq(GetAppearanceDataReq&& from) noexcept
    : GetAppearanceDataReq() {
    *this = ::std::move(from);
  }

  inline GetAppearanceDataReq& operator=(const GetAppearanceDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppearanceDataReq& operator=(GetAppearanceDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppearanceDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppearanceDataReq* internal_default_instance() {
    return reinterpret_cast<const GetAppearanceDataReq*>(
               &_GetAppearanceDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    307;

  friend void swap(GetAppearanceDataReq& a, GetAppearanceDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAppearanceDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppearanceDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAppearanceDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAppearanceDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetAppearanceDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetAppearanceDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetAppearanceDataReq";
  }
  protected:
  explicit GetAppearanceDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetAppearanceDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetAppearanceDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetAppearanceDataAck) */ {
 public:
  inline GetAppearanceDataAck() : GetAppearanceDataAck(nullptr) {}
  ~GetAppearanceDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetAppearanceDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAppearanceDataAck(const GetAppearanceDataAck& from);
  GetAppearanceDataAck(GetAppearanceDataAck&& from) noexcept
    : GetAppearanceDataAck() {
    *this = ::std::move(from);
  }

  inline GetAppearanceDataAck& operator=(const GetAppearanceDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppearanceDataAck& operator=(GetAppearanceDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppearanceDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppearanceDataAck* internal_default_instance() {
    return reinterpret_cast<const GetAppearanceDataAck*>(
               &_GetAppearanceDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    308;

  friend void swap(GetAppearanceDataAck& a, GetAppearanceDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAppearanceDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppearanceDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAppearanceDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAppearanceDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAppearanceDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAppearanceDataAck& from) {
    GetAppearanceDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAppearanceDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetAppearanceDataAck";
  }
  protected:
  explicit GetAppearanceDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleAppearanceData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleAppearanceData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleAppearanceData* release_data();
  ::idlepb::RoleAppearanceData* mutable_data();
  void set_allocated_data(::idlepb::RoleAppearanceData* data);
  private:
  const ::idlepb::RoleAppearanceData& _internal_data() const;
  ::idlepb::RoleAppearanceData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleAppearanceData* data);
  ::idlepb::RoleAppearanceData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetAppearanceDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleAppearanceData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AppearanceAddReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AppearanceAddReq) */ {
 public:
  inline AppearanceAddReq() : AppearanceAddReq(nullptr) {}
  ~AppearanceAddReq() override;
  explicit PROTOBUF_CONSTEXPR AppearanceAddReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppearanceAddReq(const AppearanceAddReq& from);
  AppearanceAddReq(AppearanceAddReq&& from) noexcept
    : AppearanceAddReq() {
    *this = ::std::move(from);
  }

  inline AppearanceAddReq& operator=(const AppearanceAddReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppearanceAddReq& operator=(AppearanceAddReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppearanceAddReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppearanceAddReq* internal_default_instance() {
    return reinterpret_cast<const AppearanceAddReq*>(
               &_AppearanceAddReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    309;

  friend void swap(AppearanceAddReq& a, AppearanceAddReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AppearanceAddReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppearanceAddReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppearanceAddReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppearanceAddReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppearanceAddReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppearanceAddReq& from) {
    AppearanceAddReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppearanceAddReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AppearanceAddReq";
  }
  protected:
  explicit AppearanceAddReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // int32 item_id = 1;
  void clear_item_id();
  int32_t item_id() const;
  void set_item_id(int32_t value);
  private:
  int32_t _internal_item_id() const;
  void _internal_set_item_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AppearanceAddReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t item_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AppearanceAddAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AppearanceAddAck) */ {
 public:
  inline AppearanceAddAck() : AppearanceAddAck(nullptr) {}
  ~AppearanceAddAck() override;
  explicit PROTOBUF_CONSTEXPR AppearanceAddAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppearanceAddAck(const AppearanceAddAck& from);
  AppearanceAddAck(AppearanceAddAck&& from) noexcept
    : AppearanceAddAck() {
    *this = ::std::move(from);
  }

  inline AppearanceAddAck& operator=(const AppearanceAddAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppearanceAddAck& operator=(AppearanceAddAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppearanceAddAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppearanceAddAck* internal_default_instance() {
    return reinterpret_cast<const AppearanceAddAck*>(
               &_AppearanceAddAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    310;

  friend void swap(AppearanceAddAck& a, AppearanceAddAck& b) {
    a.Swap(&b);
  }
  inline void Swap(AppearanceAddAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppearanceAddAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppearanceAddAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppearanceAddAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppearanceAddAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppearanceAddAck& from) {
    AppearanceAddAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppearanceAddAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AppearanceAddAck";
  }
  protected:
  explicit AppearanceAddAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AppearanceAddAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AppearanceActiveReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AppearanceActiveReq) */ {
 public:
  inline AppearanceActiveReq() : AppearanceActiveReq(nullptr) {}
  ~AppearanceActiveReq() override;
  explicit PROTOBUF_CONSTEXPR AppearanceActiveReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppearanceActiveReq(const AppearanceActiveReq& from);
  AppearanceActiveReq(AppearanceActiveReq&& from) noexcept
    : AppearanceActiveReq() {
    *this = ::std::move(from);
  }

  inline AppearanceActiveReq& operator=(const AppearanceActiveReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppearanceActiveReq& operator=(AppearanceActiveReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppearanceActiveReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppearanceActiveReq* internal_default_instance() {
    return reinterpret_cast<const AppearanceActiveReq*>(
               &_AppearanceActiveReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    311;

  friend void swap(AppearanceActiveReq& a, AppearanceActiveReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AppearanceActiveReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppearanceActiveReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppearanceActiveReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppearanceActiveReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppearanceActiveReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppearanceActiveReq& from) {
    AppearanceActiveReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppearanceActiveReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AppearanceActiveReq";
  }
  protected:
  explicit AppearanceActiveReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIdFieldNumber = 1,
  };
  // int32 group_id = 1;
  void clear_group_id();
  int32_t group_id() const;
  void set_group_id(int32_t value);
  private:
  int32_t _internal_group_id() const;
  void _internal_set_group_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AppearanceActiveReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t group_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AppearanceActiveAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AppearanceActiveAck) */ {
 public:
  inline AppearanceActiveAck() : AppearanceActiveAck(nullptr) {}
  ~AppearanceActiveAck() override;
  explicit PROTOBUF_CONSTEXPR AppearanceActiveAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppearanceActiveAck(const AppearanceActiveAck& from);
  AppearanceActiveAck(AppearanceActiveAck&& from) noexcept
    : AppearanceActiveAck() {
    *this = ::std::move(from);
  }

  inline AppearanceActiveAck& operator=(const AppearanceActiveAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppearanceActiveAck& operator=(AppearanceActiveAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppearanceActiveAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppearanceActiveAck* internal_default_instance() {
    return reinterpret_cast<const AppearanceActiveAck*>(
               &_AppearanceActiveAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    312;

  friend void swap(AppearanceActiveAck& a, AppearanceActiveAck& b) {
    a.Swap(&b);
  }
  inline void Swap(AppearanceActiveAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppearanceActiveAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppearanceActiveAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppearanceActiveAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppearanceActiveAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppearanceActiveAck& from) {
    AppearanceActiveAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppearanceActiveAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AppearanceActiveAck";
  }
  protected:
  explicit AppearanceActiveAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AppearanceActiveAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AppearanceWearReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AppearanceWearReq) */ {
 public:
  inline AppearanceWearReq() : AppearanceWearReq(nullptr) {}
  ~AppearanceWearReq() override;
  explicit PROTOBUF_CONSTEXPR AppearanceWearReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppearanceWearReq(const AppearanceWearReq& from);
  AppearanceWearReq(AppearanceWearReq&& from) noexcept
    : AppearanceWearReq() {
    *this = ::std::move(from);
  }

  inline AppearanceWearReq& operator=(const AppearanceWearReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppearanceWearReq& operator=(AppearanceWearReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppearanceWearReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppearanceWearReq* internal_default_instance() {
    return reinterpret_cast<const AppearanceWearReq*>(
               &_AppearanceWearReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    313;

  friend void swap(AppearanceWearReq& a, AppearanceWearReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AppearanceWearReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppearanceWearReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppearanceWearReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppearanceWearReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppearanceWearReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppearanceWearReq& from) {
    AppearanceWearReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppearanceWearReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AppearanceWearReq";
  }
  protected:
  explicit AppearanceWearReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIdFieldNumber = 1,
  };
  // int32 group_id = 1;
  void clear_group_id();
  int32_t group_id() const;
  void set_group_id(int32_t value);
  private:
  int32_t _internal_group_id() const;
  void _internal_set_group_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AppearanceWearReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t group_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AppearanceWearAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AppearanceWearAck) */ {
 public:
  inline AppearanceWearAck() : AppearanceWearAck(nullptr) {}
  ~AppearanceWearAck() override;
  explicit PROTOBUF_CONSTEXPR AppearanceWearAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppearanceWearAck(const AppearanceWearAck& from);
  AppearanceWearAck(AppearanceWearAck&& from) noexcept
    : AppearanceWearAck() {
    *this = ::std::move(from);
  }

  inline AppearanceWearAck& operator=(const AppearanceWearAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppearanceWearAck& operator=(AppearanceWearAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppearanceWearAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppearanceWearAck* internal_default_instance() {
    return reinterpret_cast<const AppearanceWearAck*>(
               &_AppearanceWearAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    314;

  friend void swap(AppearanceWearAck& a, AppearanceWearAck& b) {
    a.Swap(&b);
  }
  inline void Swap(AppearanceWearAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppearanceWearAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppearanceWearAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppearanceWearAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppearanceWearAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppearanceWearAck& from) {
    AppearanceWearAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppearanceWearAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AppearanceWearAck";
  }
  protected:
  explicit AppearanceWearAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AppearanceWearAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AppearanceChangeSkTypeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AppearanceChangeSkTypeReq) */ {
 public:
  inline AppearanceChangeSkTypeReq() : AppearanceChangeSkTypeReq(nullptr) {}
  ~AppearanceChangeSkTypeReq() override;
  explicit PROTOBUF_CONSTEXPR AppearanceChangeSkTypeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppearanceChangeSkTypeReq(const AppearanceChangeSkTypeReq& from);
  AppearanceChangeSkTypeReq(AppearanceChangeSkTypeReq&& from) noexcept
    : AppearanceChangeSkTypeReq() {
    *this = ::std::move(from);
  }

  inline AppearanceChangeSkTypeReq& operator=(const AppearanceChangeSkTypeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppearanceChangeSkTypeReq& operator=(AppearanceChangeSkTypeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppearanceChangeSkTypeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppearanceChangeSkTypeReq* internal_default_instance() {
    return reinterpret_cast<const AppearanceChangeSkTypeReq*>(
               &_AppearanceChangeSkTypeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    315;

  friend void swap(AppearanceChangeSkTypeReq& a, AppearanceChangeSkTypeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AppearanceChangeSkTypeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppearanceChangeSkTypeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppearanceChangeSkTypeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppearanceChangeSkTypeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppearanceChangeSkTypeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppearanceChangeSkTypeReq& from) {
    AppearanceChangeSkTypeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppearanceChangeSkTypeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AppearanceChangeSkTypeReq";
  }
  protected:
  explicit AppearanceChangeSkTypeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkTypeFieldNumber = 1,
  };
  // int32 sk_type = 1;
  void clear_sk_type();
  int32_t sk_type() const;
  void set_sk_type(int32_t value);
  private:
  int32_t _internal_sk_type() const;
  void _internal_set_sk_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AppearanceChangeSkTypeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t sk_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AppearanceChangeSkTypeAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AppearanceChangeSkTypeAck) */ {
 public:
  inline AppearanceChangeSkTypeAck() : AppearanceChangeSkTypeAck(nullptr) {}
  ~AppearanceChangeSkTypeAck() override;
  explicit PROTOBUF_CONSTEXPR AppearanceChangeSkTypeAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppearanceChangeSkTypeAck(const AppearanceChangeSkTypeAck& from);
  AppearanceChangeSkTypeAck(AppearanceChangeSkTypeAck&& from) noexcept
    : AppearanceChangeSkTypeAck() {
    *this = ::std::move(from);
  }

  inline AppearanceChangeSkTypeAck& operator=(const AppearanceChangeSkTypeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppearanceChangeSkTypeAck& operator=(AppearanceChangeSkTypeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppearanceChangeSkTypeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppearanceChangeSkTypeAck* internal_default_instance() {
    return reinterpret_cast<const AppearanceChangeSkTypeAck*>(
               &_AppearanceChangeSkTypeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    316;

  friend void swap(AppearanceChangeSkTypeAck& a, AppearanceChangeSkTypeAck& b) {
    a.Swap(&b);
  }
  inline void Swap(AppearanceChangeSkTypeAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppearanceChangeSkTypeAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppearanceChangeSkTypeAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppearanceChangeSkTypeAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppearanceChangeSkTypeAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppearanceChangeSkTypeAck& from) {
    AppearanceChangeSkTypeAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppearanceChangeSkTypeAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AppearanceChangeSkTypeAck";
  }
  protected:
  explicit AppearanceChangeSkTypeAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AppearanceChangeSkTypeAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AppearanceBuyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AppearanceBuyReq) */ {
 public:
  inline AppearanceBuyReq() : AppearanceBuyReq(nullptr) {}
  ~AppearanceBuyReq() override;
  explicit PROTOBUF_CONSTEXPR AppearanceBuyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppearanceBuyReq(const AppearanceBuyReq& from);
  AppearanceBuyReq(AppearanceBuyReq&& from) noexcept
    : AppearanceBuyReq() {
    *this = ::std::move(from);
  }

  inline AppearanceBuyReq& operator=(const AppearanceBuyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppearanceBuyReq& operator=(AppearanceBuyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppearanceBuyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppearanceBuyReq* internal_default_instance() {
    return reinterpret_cast<const AppearanceBuyReq*>(
               &_AppearanceBuyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    317;

  friend void swap(AppearanceBuyReq& a, AppearanceBuyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AppearanceBuyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppearanceBuyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppearanceBuyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppearanceBuyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppearanceBuyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppearanceBuyReq& from) {
    AppearanceBuyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppearanceBuyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AppearanceBuyReq";
  }
  protected:
  explicit AppearanceBuyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShopIndexFieldNumber = 1,
    kItemIndexFieldNumber = 2,
  };
  // int32 shop_index = 1;
  void clear_shop_index();
  int32_t shop_index() const;
  void set_shop_index(int32_t value);
  private:
  int32_t _internal_shop_index() const;
  void _internal_set_shop_index(int32_t value);
  public:

  // int32 item_index = 2;
  void clear_item_index();
  int32_t item_index() const;
  void set_item_index(int32_t value);
  private:
  int32_t _internal_item_index() const;
  void _internal_set_item_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AppearanceBuyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t shop_index_;
    int32_t item_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AppearanceBuyAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AppearanceBuyAck) */ {
 public:
  inline AppearanceBuyAck() : AppearanceBuyAck(nullptr) {}
  ~AppearanceBuyAck() override;
  explicit PROTOBUF_CONSTEXPR AppearanceBuyAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppearanceBuyAck(const AppearanceBuyAck& from);
  AppearanceBuyAck(AppearanceBuyAck&& from) noexcept
    : AppearanceBuyAck() {
    *this = ::std::move(from);
  }

  inline AppearanceBuyAck& operator=(const AppearanceBuyAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppearanceBuyAck& operator=(AppearanceBuyAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppearanceBuyAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppearanceBuyAck* internal_default_instance() {
    return reinterpret_cast<const AppearanceBuyAck*>(
               &_AppearanceBuyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    318;

  friend void swap(AppearanceBuyAck& a, AppearanceBuyAck& b) {
    a.Swap(&b);
  }
  inline void Swap(AppearanceBuyAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppearanceBuyAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppearanceBuyAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppearanceBuyAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppearanceBuyAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppearanceBuyAck& from) {
    AppearanceBuyAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppearanceBuyAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AppearanceBuyAck";
  }
  protected:
  explicit AppearanceBuyAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.AppearanceBuyAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetArenaCheckListDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetArenaCheckListDataReq) */ {
 public:
  inline GetArenaCheckListDataReq() : GetArenaCheckListDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetArenaCheckListDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArenaCheckListDataReq(const GetArenaCheckListDataReq& from);
  GetArenaCheckListDataReq(GetArenaCheckListDataReq&& from) noexcept
    : GetArenaCheckListDataReq() {
    *this = ::std::move(from);
  }

  inline GetArenaCheckListDataReq& operator=(const GetArenaCheckListDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArenaCheckListDataReq& operator=(GetArenaCheckListDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArenaCheckListDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArenaCheckListDataReq* internal_default_instance() {
    return reinterpret_cast<const GetArenaCheckListDataReq*>(
               &_GetArenaCheckListDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    319;

  friend void swap(GetArenaCheckListDataReq& a, GetArenaCheckListDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArenaCheckListDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArenaCheckListDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArenaCheckListDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArenaCheckListDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetArenaCheckListDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetArenaCheckListDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetArenaCheckListDataReq";
  }
  protected:
  explicit GetArenaCheckListDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetArenaCheckListDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetArenaCheckListDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetArenaCheckListDataAck) */ {
 public:
  inline GetArenaCheckListDataAck() : GetArenaCheckListDataAck(nullptr) {}
  ~GetArenaCheckListDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetArenaCheckListDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArenaCheckListDataAck(const GetArenaCheckListDataAck& from);
  GetArenaCheckListDataAck(GetArenaCheckListDataAck&& from) noexcept
    : GetArenaCheckListDataAck() {
    *this = ::std::move(from);
  }

  inline GetArenaCheckListDataAck& operator=(const GetArenaCheckListDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArenaCheckListDataAck& operator=(GetArenaCheckListDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArenaCheckListDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArenaCheckListDataAck* internal_default_instance() {
    return reinterpret_cast<const GetArenaCheckListDataAck*>(
               &_GetArenaCheckListDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    320;

  friend void swap(GetArenaCheckListDataAck& a, GetArenaCheckListDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArenaCheckListDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArenaCheckListDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArenaCheckListDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArenaCheckListDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetArenaCheckListDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetArenaCheckListDataAck& from) {
    GetArenaCheckListDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArenaCheckListDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetArenaCheckListDataAck";
  }
  protected:
  explicit GetArenaCheckListDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleArenaCheckListData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleArenaCheckListData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleArenaCheckListData* release_data();
  ::idlepb::RoleArenaCheckListData* mutable_data();
  void set_allocated_data(::idlepb::RoleArenaCheckListData* data);
  private:
  const ::idlepb::RoleArenaCheckListData& _internal_data() const;
  ::idlepb::RoleArenaCheckListData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleArenaCheckListData* data);
  ::idlepb::RoleArenaCheckListData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetArenaCheckListDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleArenaCheckListData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ArenaCheckListSubmitReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ArenaCheckListSubmitReq) */ {
 public:
  inline ArenaCheckListSubmitReq() : ArenaCheckListSubmitReq(nullptr) {}
  ~ArenaCheckListSubmitReq() override;
  explicit PROTOBUF_CONSTEXPR ArenaCheckListSubmitReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArenaCheckListSubmitReq(const ArenaCheckListSubmitReq& from);
  ArenaCheckListSubmitReq(ArenaCheckListSubmitReq&& from) noexcept
    : ArenaCheckListSubmitReq() {
    *this = ::std::move(from);
  }

  inline ArenaCheckListSubmitReq& operator=(const ArenaCheckListSubmitReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArenaCheckListSubmitReq& operator=(ArenaCheckListSubmitReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArenaCheckListSubmitReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArenaCheckListSubmitReq* internal_default_instance() {
    return reinterpret_cast<const ArenaCheckListSubmitReq*>(
               &_ArenaCheckListSubmitReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    321;

  friend void swap(ArenaCheckListSubmitReq& a, ArenaCheckListSubmitReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ArenaCheckListSubmitReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArenaCheckListSubmitReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArenaCheckListSubmitReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArenaCheckListSubmitReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArenaCheckListSubmitReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArenaCheckListSubmitReq& from) {
    ArenaCheckListSubmitReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArenaCheckListSubmitReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ArenaCheckListSubmitReq";
  }
  protected:
  explicit ArenaCheckListSubmitReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCheckListIdFieldNumber = 1,
  };
  // int32 check_list_id = 1;
  void clear_check_list_id();
  int32_t check_list_id() const;
  void set_check_list_id(int32_t value);
  private:
  int32_t _internal_check_list_id() const;
  void _internal_set_check_list_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ArenaCheckListSubmitReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t check_list_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ArenaCheckListSubmitAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ArenaCheckListSubmitAck) */ {
 public:
  inline ArenaCheckListSubmitAck() : ArenaCheckListSubmitAck(nullptr) {}
  ~ArenaCheckListSubmitAck() override;
  explicit PROTOBUF_CONSTEXPR ArenaCheckListSubmitAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArenaCheckListSubmitAck(const ArenaCheckListSubmitAck& from);
  ArenaCheckListSubmitAck(ArenaCheckListSubmitAck&& from) noexcept
    : ArenaCheckListSubmitAck() {
    *this = ::std::move(from);
  }

  inline ArenaCheckListSubmitAck& operator=(const ArenaCheckListSubmitAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArenaCheckListSubmitAck& operator=(ArenaCheckListSubmitAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArenaCheckListSubmitAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArenaCheckListSubmitAck* internal_default_instance() {
    return reinterpret_cast<const ArenaCheckListSubmitAck*>(
               &_ArenaCheckListSubmitAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    322;

  friend void swap(ArenaCheckListSubmitAck& a, ArenaCheckListSubmitAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ArenaCheckListSubmitAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArenaCheckListSubmitAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArenaCheckListSubmitAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArenaCheckListSubmitAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArenaCheckListSubmitAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArenaCheckListSubmitAck& from) {
    ArenaCheckListSubmitAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArenaCheckListSubmitAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ArenaCheckListSubmitAck";
  }
  protected:
  explicit ArenaCheckListSubmitAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.ArenaCheckListData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::ArenaCheckListData& data() const;
  PROTOBUF_NODISCARD ::idlepb::ArenaCheckListData* release_data();
  ::idlepb::ArenaCheckListData* mutable_data();
  void set_allocated_data(::idlepb::ArenaCheckListData* data);
  private:
  const ::idlepb::ArenaCheckListData& _internal_data() const;
  ::idlepb::ArenaCheckListData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::ArenaCheckListData* data);
  ::idlepb::ArenaCheckListData* unsafe_arena_release_data();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ArenaCheckListSubmitAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::ArenaCheckListData* data_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ArenaCheckListRewardSubmitReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ArenaCheckListRewardSubmitReq) */ {
 public:
  inline ArenaCheckListRewardSubmitReq() : ArenaCheckListRewardSubmitReq(nullptr) {}
  ~ArenaCheckListRewardSubmitReq() override;
  explicit PROTOBUF_CONSTEXPR ArenaCheckListRewardSubmitReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArenaCheckListRewardSubmitReq(const ArenaCheckListRewardSubmitReq& from);
  ArenaCheckListRewardSubmitReq(ArenaCheckListRewardSubmitReq&& from) noexcept
    : ArenaCheckListRewardSubmitReq() {
    *this = ::std::move(from);
  }

  inline ArenaCheckListRewardSubmitReq& operator=(const ArenaCheckListRewardSubmitReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArenaCheckListRewardSubmitReq& operator=(ArenaCheckListRewardSubmitReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArenaCheckListRewardSubmitReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArenaCheckListRewardSubmitReq* internal_default_instance() {
    return reinterpret_cast<const ArenaCheckListRewardSubmitReq*>(
               &_ArenaCheckListRewardSubmitReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    323;

  friend void swap(ArenaCheckListRewardSubmitReq& a, ArenaCheckListRewardSubmitReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ArenaCheckListRewardSubmitReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArenaCheckListRewardSubmitReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArenaCheckListRewardSubmitReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArenaCheckListRewardSubmitReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArenaCheckListRewardSubmitReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArenaCheckListRewardSubmitReq& from) {
    ArenaCheckListRewardSubmitReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArenaCheckListRewardSubmitReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ArenaCheckListRewardSubmitReq";
  }
  protected:
  explicit ArenaCheckListRewardSubmitReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardIdFieldNumber = 1,
  };
  // int32 reward_id = 1;
  void clear_reward_id();
  int32_t reward_id() const;
  void set_reward_id(int32_t value);
  private:
  int32_t _internal_reward_id() const;
  void _internal_set_reward_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ArenaCheckListRewardSubmitReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t reward_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ArenaCheckListRewardSubmitAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ArenaCheckListRewardSubmitAck) */ {
 public:
  inline ArenaCheckListRewardSubmitAck() : ArenaCheckListRewardSubmitAck(nullptr) {}
  ~ArenaCheckListRewardSubmitAck() override;
  explicit PROTOBUF_CONSTEXPR ArenaCheckListRewardSubmitAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArenaCheckListRewardSubmitAck(const ArenaCheckListRewardSubmitAck& from);
  ArenaCheckListRewardSubmitAck(ArenaCheckListRewardSubmitAck&& from) noexcept
    : ArenaCheckListRewardSubmitAck() {
    *this = ::std::move(from);
  }

  inline ArenaCheckListRewardSubmitAck& operator=(const ArenaCheckListRewardSubmitAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArenaCheckListRewardSubmitAck& operator=(ArenaCheckListRewardSubmitAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArenaCheckListRewardSubmitAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArenaCheckListRewardSubmitAck* internal_default_instance() {
    return reinterpret_cast<const ArenaCheckListRewardSubmitAck*>(
               &_ArenaCheckListRewardSubmitAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    324;

  friend void swap(ArenaCheckListRewardSubmitAck& a, ArenaCheckListRewardSubmitAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ArenaCheckListRewardSubmitAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArenaCheckListRewardSubmitAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArenaCheckListRewardSubmitAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArenaCheckListRewardSubmitAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArenaCheckListRewardSubmitAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArenaCheckListRewardSubmitAck& from) {
    ArenaCheckListRewardSubmitAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArenaCheckListRewardSubmitAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ArenaCheckListRewardSubmitAck";
  }
  protected:
  explicit ArenaCheckListRewardSubmitAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // .idlepb.ArenaCheckListRewardData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::ArenaCheckListRewardData& data() const;
  PROTOBUF_NODISCARD ::idlepb::ArenaCheckListRewardData* release_data();
  ::idlepb::ArenaCheckListRewardData* mutable_data();
  void set_allocated_data(::idlepb::ArenaCheckListRewardData* data);
  private:
  const ::idlepb::ArenaCheckListRewardData& _internal_data() const;
  ::idlepb::ArenaCheckListRewardData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::ArenaCheckListRewardData* data);
  ::idlepb::ArenaCheckListRewardData* unsafe_arena_release_data();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ArenaCheckListRewardSubmitAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::ArenaCheckListRewardData* data_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DungeonKillAllChallengeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DungeonKillAllChallengeReq) */ {
 public:
  inline DungeonKillAllChallengeReq() : DungeonKillAllChallengeReq(nullptr) {}
  ~DungeonKillAllChallengeReq() override;
  explicit PROTOBUF_CONSTEXPR DungeonKillAllChallengeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DungeonKillAllChallengeReq(const DungeonKillAllChallengeReq& from);
  DungeonKillAllChallengeReq(DungeonKillAllChallengeReq&& from) noexcept
    : DungeonKillAllChallengeReq() {
    *this = ::std::move(from);
  }

  inline DungeonKillAllChallengeReq& operator=(const DungeonKillAllChallengeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonKillAllChallengeReq& operator=(DungeonKillAllChallengeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonKillAllChallengeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DungeonKillAllChallengeReq* internal_default_instance() {
    return reinterpret_cast<const DungeonKillAllChallengeReq*>(
               &_DungeonKillAllChallengeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    325;

  friend void swap(DungeonKillAllChallengeReq& a, DungeonKillAllChallengeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DungeonKillAllChallengeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonKillAllChallengeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonKillAllChallengeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DungeonKillAllChallengeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DungeonKillAllChallengeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DungeonKillAllChallengeReq& from) {
    DungeonKillAllChallengeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonKillAllChallengeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DungeonKillAllChallengeReq";
  }
  protected:
  explicit DungeonKillAllChallengeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDungeonUidIdFieldNumber = 1,
  };
  // int32 dungeon_uid_id = 1;
  void clear_dungeon_uid_id();
  int32_t dungeon_uid_id() const;
  void set_dungeon_uid_id(int32_t value);
  private:
  int32_t _internal_dungeon_uid_id() const;
  void _internal_set_dungeon_uid_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DungeonKillAllChallengeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t dungeon_uid_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DungeonKillAllChallengeAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DungeonKillAllChallengeAck) */ {
 public:
  inline DungeonKillAllChallengeAck() : DungeonKillAllChallengeAck(nullptr) {}
  ~DungeonKillAllChallengeAck() override;
  explicit PROTOBUF_CONSTEXPR DungeonKillAllChallengeAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DungeonKillAllChallengeAck(const DungeonKillAllChallengeAck& from);
  DungeonKillAllChallengeAck(DungeonKillAllChallengeAck&& from) noexcept
    : DungeonKillAllChallengeAck() {
    *this = ::std::move(from);
  }

  inline DungeonKillAllChallengeAck& operator=(const DungeonKillAllChallengeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonKillAllChallengeAck& operator=(DungeonKillAllChallengeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonKillAllChallengeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DungeonKillAllChallengeAck* internal_default_instance() {
    return reinterpret_cast<const DungeonKillAllChallengeAck*>(
               &_DungeonKillAllChallengeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    326;

  friend void swap(DungeonKillAllChallengeAck& a, DungeonKillAllChallengeAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DungeonKillAllChallengeAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonKillAllChallengeAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonKillAllChallengeAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DungeonKillAllChallengeAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DungeonKillAllChallengeAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DungeonKillAllChallengeAck& from) {
    DungeonKillAllChallengeAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonKillAllChallengeAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DungeonKillAllChallengeAck";
  }
  protected:
  explicit DungeonKillAllChallengeAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DungeonKillAllChallengeAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DungeonKillAllQuickEndReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DungeonKillAllQuickEndReq) */ {
 public:
  inline DungeonKillAllQuickEndReq() : DungeonKillAllQuickEndReq(nullptr) {}
  ~DungeonKillAllQuickEndReq() override;
  explicit PROTOBUF_CONSTEXPR DungeonKillAllQuickEndReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DungeonKillAllQuickEndReq(const DungeonKillAllQuickEndReq& from);
  DungeonKillAllQuickEndReq(DungeonKillAllQuickEndReq&& from) noexcept
    : DungeonKillAllQuickEndReq() {
    *this = ::std::move(from);
  }

  inline DungeonKillAllQuickEndReq& operator=(const DungeonKillAllQuickEndReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonKillAllQuickEndReq& operator=(DungeonKillAllQuickEndReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonKillAllQuickEndReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DungeonKillAllQuickEndReq* internal_default_instance() {
    return reinterpret_cast<const DungeonKillAllQuickEndReq*>(
               &_DungeonKillAllQuickEndReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    327;

  friend void swap(DungeonKillAllQuickEndReq& a, DungeonKillAllQuickEndReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DungeonKillAllQuickEndReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonKillAllQuickEndReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonKillAllQuickEndReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DungeonKillAllQuickEndReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DungeonKillAllQuickEndReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DungeonKillAllQuickEndReq& from) {
    DungeonKillAllQuickEndReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonKillAllQuickEndReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DungeonKillAllQuickEndReq";
  }
  protected:
  explicit DungeonKillAllQuickEndReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsExitFieldNumber = 1,
  };
  // bool is_exit = 1;
  void clear_is_exit();
  bool is_exit() const;
  void set_is_exit(bool value);
  private:
  bool _internal_is_exit() const;
  void _internal_set_is_exit(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DungeonKillAllQuickEndReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_exit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DungeonKillAllQuickEndAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DungeonKillAllQuickEndAck) */ {
 public:
  inline DungeonKillAllQuickEndAck() : DungeonKillAllQuickEndAck(nullptr) {}
  ~DungeonKillAllQuickEndAck() override;
  explicit PROTOBUF_CONSTEXPR DungeonKillAllQuickEndAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DungeonKillAllQuickEndAck(const DungeonKillAllQuickEndAck& from);
  DungeonKillAllQuickEndAck(DungeonKillAllQuickEndAck&& from) noexcept
    : DungeonKillAllQuickEndAck() {
    *this = ::std::move(from);
  }

  inline DungeonKillAllQuickEndAck& operator=(const DungeonKillAllQuickEndAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonKillAllQuickEndAck& operator=(DungeonKillAllQuickEndAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonKillAllQuickEndAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DungeonKillAllQuickEndAck* internal_default_instance() {
    return reinterpret_cast<const DungeonKillAllQuickEndAck*>(
               &_DungeonKillAllQuickEndAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    328;

  friend void swap(DungeonKillAllQuickEndAck& a, DungeonKillAllQuickEndAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DungeonKillAllQuickEndAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonKillAllQuickEndAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonKillAllQuickEndAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DungeonKillAllQuickEndAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DungeonKillAllQuickEndAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DungeonKillAllQuickEndAck& from) {
    DungeonKillAllQuickEndAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonKillAllQuickEndAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DungeonKillAllQuickEndAck";
  }
  protected:
  explicit DungeonKillAllQuickEndAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DungeonKillAllQuickEndAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyDungeonKillAllChallengeOver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyDungeonKillAllChallengeOver) */ {
 public:
  inline NotifyDungeonKillAllChallengeOver() : NotifyDungeonKillAllChallengeOver(nullptr) {}
  ~NotifyDungeonKillAllChallengeOver() override;
  explicit PROTOBUF_CONSTEXPR NotifyDungeonKillAllChallengeOver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyDungeonKillAllChallengeOver(const NotifyDungeonKillAllChallengeOver& from);
  NotifyDungeonKillAllChallengeOver(NotifyDungeonKillAllChallengeOver&& from) noexcept
    : NotifyDungeonKillAllChallengeOver() {
    *this = ::std::move(from);
  }

  inline NotifyDungeonKillAllChallengeOver& operator=(const NotifyDungeonKillAllChallengeOver& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyDungeonKillAllChallengeOver& operator=(NotifyDungeonKillAllChallengeOver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyDungeonKillAllChallengeOver& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyDungeonKillAllChallengeOver* internal_default_instance() {
    return reinterpret_cast<const NotifyDungeonKillAllChallengeOver*>(
               &_NotifyDungeonKillAllChallengeOver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    329;

  friend void swap(NotifyDungeonKillAllChallengeOver& a, NotifyDungeonKillAllChallengeOver& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyDungeonKillAllChallengeOver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyDungeonKillAllChallengeOver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyDungeonKillAllChallengeOver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyDungeonKillAllChallengeOver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyDungeonKillAllChallengeOver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyDungeonKillAllChallengeOver& from) {
    NotifyDungeonKillAllChallengeOver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyDungeonKillAllChallengeOver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyDungeonKillAllChallengeOver";
  }
  protected:
  explicit NotifyDungeonKillAllChallengeOver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kWinFieldNumber = 2,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // bool win = 2;
  void clear_win();
  bool win() const;
  void set_win(bool value);
  private:
  bool _internal_win() const;
  void _internal_set_win(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyDungeonKillAllChallengeOver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t uid_;
    bool win_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyDungeonKillAllChallengeCurWaveNum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyDungeonKillAllChallengeCurWaveNum) */ {
 public:
  inline NotifyDungeonKillAllChallengeCurWaveNum() : NotifyDungeonKillAllChallengeCurWaveNum(nullptr) {}
  ~NotifyDungeonKillAllChallengeCurWaveNum() override;
  explicit PROTOBUF_CONSTEXPR NotifyDungeonKillAllChallengeCurWaveNum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyDungeonKillAllChallengeCurWaveNum(const NotifyDungeonKillAllChallengeCurWaveNum& from);
  NotifyDungeonKillAllChallengeCurWaveNum(NotifyDungeonKillAllChallengeCurWaveNum&& from) noexcept
    : NotifyDungeonKillAllChallengeCurWaveNum() {
    *this = ::std::move(from);
  }

  inline NotifyDungeonKillAllChallengeCurWaveNum& operator=(const NotifyDungeonKillAllChallengeCurWaveNum& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyDungeonKillAllChallengeCurWaveNum& operator=(NotifyDungeonKillAllChallengeCurWaveNum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyDungeonKillAllChallengeCurWaveNum& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyDungeonKillAllChallengeCurWaveNum* internal_default_instance() {
    return reinterpret_cast<const NotifyDungeonKillAllChallengeCurWaveNum*>(
               &_NotifyDungeonKillAllChallengeCurWaveNum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    330;

  friend void swap(NotifyDungeonKillAllChallengeCurWaveNum& a, NotifyDungeonKillAllChallengeCurWaveNum& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyDungeonKillAllChallengeCurWaveNum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyDungeonKillAllChallengeCurWaveNum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyDungeonKillAllChallengeCurWaveNum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyDungeonKillAllChallengeCurWaveNum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyDungeonKillAllChallengeCurWaveNum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyDungeonKillAllChallengeCurWaveNum& from) {
    NotifyDungeonKillAllChallengeCurWaveNum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyDungeonKillAllChallengeCurWaveNum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyDungeonKillAllChallengeCurWaveNum";
  }
  protected:
  explicit NotifyDungeonKillAllChallengeCurWaveNum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kCurnumFieldNumber = 2,
    kMaxnumFieldNumber = 3,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 curnum = 2;
  void clear_curnum();
  int32_t curnum() const;
  void set_curnum(int32_t value);
  private:
  int32_t _internal_curnum() const;
  void _internal_set_curnum(int32_t value);
  public:

  // int32 maxnum = 3;
  void clear_maxnum();
  int32_t maxnum() const;
  void set_maxnum(int32_t value);
  private:
  int32_t _internal_maxnum() const;
  void _internal_set_maxnum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyDungeonKillAllChallengeCurWaveNum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t uid_;
    int32_t curnum_;
    int32_t maxnum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DungeonKillAllDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DungeonKillAllDataReq) */ {
 public:
  inline DungeonKillAllDataReq() : DungeonKillAllDataReq(nullptr) {}
  ~DungeonKillAllDataReq() override;
  explicit PROTOBUF_CONSTEXPR DungeonKillAllDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DungeonKillAllDataReq(const DungeonKillAllDataReq& from);
  DungeonKillAllDataReq(DungeonKillAllDataReq&& from) noexcept
    : DungeonKillAllDataReq() {
    *this = ::std::move(from);
  }

  inline DungeonKillAllDataReq& operator=(const DungeonKillAllDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonKillAllDataReq& operator=(DungeonKillAllDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonKillAllDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DungeonKillAllDataReq* internal_default_instance() {
    return reinterpret_cast<const DungeonKillAllDataReq*>(
               &_DungeonKillAllDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    331;

  friend void swap(DungeonKillAllDataReq& a, DungeonKillAllDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DungeonKillAllDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonKillAllDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonKillAllDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DungeonKillAllDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DungeonKillAllDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DungeonKillAllDataReq& from) {
    DungeonKillAllDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonKillAllDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DungeonKillAllDataReq";
  }
  protected:
  explicit DungeonKillAllDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAskUidFieldNumber = 1,
  };
  // int32 ask_uid = 1;
  void clear_ask_uid();
  int32_t ask_uid() const;
  void set_ask_uid(int32_t value);
  private:
  int32_t _internal_ask_uid() const;
  void _internal_set_ask_uid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DungeonKillAllDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t ask_uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DungeonKillAllDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DungeonKillAllDataAck) */ {
 public:
  inline DungeonKillAllDataAck() : DungeonKillAllDataAck(nullptr) {}
  ~DungeonKillAllDataAck() override;
  explicit PROTOBUF_CONSTEXPR DungeonKillAllDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DungeonKillAllDataAck(const DungeonKillAllDataAck& from);
  DungeonKillAllDataAck(DungeonKillAllDataAck&& from) noexcept
    : DungeonKillAllDataAck() {
    *this = ::std::move(from);
  }

  inline DungeonKillAllDataAck& operator=(const DungeonKillAllDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonKillAllDataAck& operator=(DungeonKillAllDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonKillAllDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DungeonKillAllDataAck* internal_default_instance() {
    return reinterpret_cast<const DungeonKillAllDataAck*>(
               &_DungeonKillAllDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    332;

  friend void swap(DungeonKillAllDataAck& a, DungeonKillAllDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DungeonKillAllDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonKillAllDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonKillAllDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DungeonKillAllDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DungeonKillAllDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DungeonKillAllDataAck& from) {
    DungeonKillAllDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonKillAllDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DungeonKillAllDataAck";
  }
  protected:
  explicit DungeonKillAllDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DungeonKillAllDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DungeonSurviveChallengeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DungeonSurviveChallengeReq) */ {
 public:
  inline DungeonSurviveChallengeReq() : DungeonSurviveChallengeReq(nullptr) {}
  ~DungeonSurviveChallengeReq() override;
  explicit PROTOBUF_CONSTEXPR DungeonSurviveChallengeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DungeonSurviveChallengeReq(const DungeonSurviveChallengeReq& from);
  DungeonSurviveChallengeReq(DungeonSurviveChallengeReq&& from) noexcept
    : DungeonSurviveChallengeReq() {
    *this = ::std::move(from);
  }

  inline DungeonSurviveChallengeReq& operator=(const DungeonSurviveChallengeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonSurviveChallengeReq& operator=(DungeonSurviveChallengeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonSurviveChallengeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DungeonSurviveChallengeReq* internal_default_instance() {
    return reinterpret_cast<const DungeonSurviveChallengeReq*>(
               &_DungeonSurviveChallengeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    333;

  friend void swap(DungeonSurviveChallengeReq& a, DungeonSurviveChallengeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DungeonSurviveChallengeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonSurviveChallengeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonSurviveChallengeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DungeonSurviveChallengeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DungeonSurviveChallengeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DungeonSurviveChallengeReq& from) {
    DungeonSurviveChallengeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonSurviveChallengeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DungeonSurviveChallengeReq";
  }
  protected:
  explicit DungeonSurviveChallengeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDungeonUidFieldNumber = 1,
  };
  // int32 dungeon_uid = 1;
  void clear_dungeon_uid();
  int32_t dungeon_uid() const;
  void set_dungeon_uid(int32_t value);
  private:
  int32_t _internal_dungeon_uid() const;
  void _internal_set_dungeon_uid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DungeonSurviveChallengeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t dungeon_uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DungeonSurviveChallengeAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DungeonSurviveChallengeAck) */ {
 public:
  inline DungeonSurviveChallengeAck() : DungeonSurviveChallengeAck(nullptr) {}
  ~DungeonSurviveChallengeAck() override;
  explicit PROTOBUF_CONSTEXPR DungeonSurviveChallengeAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DungeonSurviveChallengeAck(const DungeonSurviveChallengeAck& from);
  DungeonSurviveChallengeAck(DungeonSurviveChallengeAck&& from) noexcept
    : DungeonSurviveChallengeAck() {
    *this = ::std::move(from);
  }

  inline DungeonSurviveChallengeAck& operator=(const DungeonSurviveChallengeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonSurviveChallengeAck& operator=(DungeonSurviveChallengeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonSurviveChallengeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DungeonSurviveChallengeAck* internal_default_instance() {
    return reinterpret_cast<const DungeonSurviveChallengeAck*>(
               &_DungeonSurviveChallengeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    334;

  friend void swap(DungeonSurviveChallengeAck& a, DungeonSurviveChallengeAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DungeonSurviveChallengeAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonSurviveChallengeAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonSurviveChallengeAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DungeonSurviveChallengeAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DungeonSurviveChallengeAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DungeonSurviveChallengeAck& from) {
    DungeonSurviveChallengeAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonSurviveChallengeAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DungeonSurviveChallengeAck";
  }
  protected:
  explicit DungeonSurviveChallengeAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DungeonSurviveChallengeAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DungeonSurviveQuickEndReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DungeonSurviveQuickEndReq) */ {
 public:
  inline DungeonSurviveQuickEndReq() : DungeonSurviveQuickEndReq(nullptr) {}
  ~DungeonSurviveQuickEndReq() override;
  explicit PROTOBUF_CONSTEXPR DungeonSurviveQuickEndReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DungeonSurviveQuickEndReq(const DungeonSurviveQuickEndReq& from);
  DungeonSurviveQuickEndReq(DungeonSurviveQuickEndReq&& from) noexcept
    : DungeonSurviveQuickEndReq() {
    *this = ::std::move(from);
  }

  inline DungeonSurviveQuickEndReq& operator=(const DungeonSurviveQuickEndReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonSurviveQuickEndReq& operator=(DungeonSurviveQuickEndReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonSurviveQuickEndReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DungeonSurviveQuickEndReq* internal_default_instance() {
    return reinterpret_cast<const DungeonSurviveQuickEndReq*>(
               &_DungeonSurviveQuickEndReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    335;

  friend void swap(DungeonSurviveQuickEndReq& a, DungeonSurviveQuickEndReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DungeonSurviveQuickEndReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonSurviveQuickEndReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonSurviveQuickEndReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DungeonSurviveQuickEndReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DungeonSurviveQuickEndReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DungeonSurviveQuickEndReq& from) {
    DungeonSurviveQuickEndReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonSurviveQuickEndReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DungeonSurviveQuickEndReq";
  }
  protected:
  explicit DungeonSurviveQuickEndReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsExitFieldNumber = 1,
  };
  // bool is_exit = 1;
  void clear_is_exit();
  bool is_exit() const;
  void set_is_exit(bool value);
  private:
  bool _internal_is_exit() const;
  void _internal_set_is_exit(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DungeonSurviveQuickEndReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_exit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DungeonSurviveQuickEndAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DungeonSurviveQuickEndAck) */ {
 public:
  inline DungeonSurviveQuickEndAck() : DungeonSurviveQuickEndAck(nullptr) {}
  ~DungeonSurviveQuickEndAck() override;
  explicit PROTOBUF_CONSTEXPR DungeonSurviveQuickEndAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DungeonSurviveQuickEndAck(const DungeonSurviveQuickEndAck& from);
  DungeonSurviveQuickEndAck(DungeonSurviveQuickEndAck&& from) noexcept
    : DungeonSurviveQuickEndAck() {
    *this = ::std::move(from);
  }

  inline DungeonSurviveQuickEndAck& operator=(const DungeonSurviveQuickEndAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonSurviveQuickEndAck& operator=(DungeonSurviveQuickEndAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonSurviveQuickEndAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DungeonSurviveQuickEndAck* internal_default_instance() {
    return reinterpret_cast<const DungeonSurviveQuickEndAck*>(
               &_DungeonSurviveQuickEndAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    336;

  friend void swap(DungeonSurviveQuickEndAck& a, DungeonSurviveQuickEndAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DungeonSurviveQuickEndAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonSurviveQuickEndAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonSurviveQuickEndAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DungeonSurviveQuickEndAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DungeonSurviveQuickEndAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DungeonSurviveQuickEndAck& from) {
    DungeonSurviveQuickEndAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonSurviveQuickEndAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DungeonSurviveQuickEndAck";
  }
  protected:
  explicit DungeonSurviveQuickEndAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DungeonSurviveQuickEndAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyDungeonSurviveChallengeOver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyDungeonSurviveChallengeOver) */ {
 public:
  inline NotifyDungeonSurviveChallengeOver() : NotifyDungeonSurviveChallengeOver(nullptr) {}
  ~NotifyDungeonSurviveChallengeOver() override;
  explicit PROTOBUF_CONSTEXPR NotifyDungeonSurviveChallengeOver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyDungeonSurviveChallengeOver(const NotifyDungeonSurviveChallengeOver& from);
  NotifyDungeonSurviveChallengeOver(NotifyDungeonSurviveChallengeOver&& from) noexcept
    : NotifyDungeonSurviveChallengeOver() {
    *this = ::std::move(from);
  }

  inline NotifyDungeonSurviveChallengeOver& operator=(const NotifyDungeonSurviveChallengeOver& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyDungeonSurviveChallengeOver& operator=(NotifyDungeonSurviveChallengeOver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyDungeonSurviveChallengeOver& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyDungeonSurviveChallengeOver* internal_default_instance() {
    return reinterpret_cast<const NotifyDungeonSurviveChallengeOver*>(
               &_NotifyDungeonSurviveChallengeOver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    337;

  friend void swap(NotifyDungeonSurviveChallengeOver& a, NotifyDungeonSurviveChallengeOver& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyDungeonSurviveChallengeOver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyDungeonSurviveChallengeOver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyDungeonSurviveChallengeOver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyDungeonSurviveChallengeOver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyDungeonSurviveChallengeOver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyDungeonSurviveChallengeOver& from) {
    NotifyDungeonSurviveChallengeOver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyDungeonSurviveChallengeOver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyDungeonSurviveChallengeOver";
  }
  protected:
  explicit NotifyDungeonSurviveChallengeOver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kWinFieldNumber = 2,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // bool win = 2;
  void clear_win();
  bool win() const;
  void set_win(bool value);
  private:
  bool _internal_win() const;
  void _internal_set_win(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyDungeonSurviveChallengeOver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t uid_;
    bool win_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyDungeonSurviveChallengeCurWaveNum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyDungeonSurviveChallengeCurWaveNum) */ {
 public:
  inline NotifyDungeonSurviveChallengeCurWaveNum() : NotifyDungeonSurviveChallengeCurWaveNum(nullptr) {}
  ~NotifyDungeonSurviveChallengeCurWaveNum() override;
  explicit PROTOBUF_CONSTEXPR NotifyDungeonSurviveChallengeCurWaveNum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyDungeonSurviveChallengeCurWaveNum(const NotifyDungeonSurviveChallengeCurWaveNum& from);
  NotifyDungeonSurviveChallengeCurWaveNum(NotifyDungeonSurviveChallengeCurWaveNum&& from) noexcept
    : NotifyDungeonSurviveChallengeCurWaveNum() {
    *this = ::std::move(from);
  }

  inline NotifyDungeonSurviveChallengeCurWaveNum& operator=(const NotifyDungeonSurviveChallengeCurWaveNum& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyDungeonSurviveChallengeCurWaveNum& operator=(NotifyDungeonSurviveChallengeCurWaveNum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyDungeonSurviveChallengeCurWaveNum& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyDungeonSurviveChallengeCurWaveNum* internal_default_instance() {
    return reinterpret_cast<const NotifyDungeonSurviveChallengeCurWaveNum*>(
               &_NotifyDungeonSurviveChallengeCurWaveNum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    338;

  friend void swap(NotifyDungeonSurviveChallengeCurWaveNum& a, NotifyDungeonSurviveChallengeCurWaveNum& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyDungeonSurviveChallengeCurWaveNum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyDungeonSurviveChallengeCurWaveNum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyDungeonSurviveChallengeCurWaveNum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyDungeonSurviveChallengeCurWaveNum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyDungeonSurviveChallengeCurWaveNum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyDungeonSurviveChallengeCurWaveNum& from) {
    NotifyDungeonSurviveChallengeCurWaveNum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyDungeonSurviveChallengeCurWaveNum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyDungeonSurviveChallengeCurWaveNum";
  }
  protected:
  explicit NotifyDungeonSurviveChallengeCurWaveNum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kCurnumFieldNumber = 2,
    kMaxnumFieldNumber = 3,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 curnum = 2;
  void clear_curnum();
  int32_t curnum() const;
  void set_curnum(int32_t value);
  private:
  int32_t _internal_curnum() const;
  void _internal_set_curnum(int32_t value);
  public:

  // int32 maxnum = 3;
  void clear_maxnum();
  int32_t maxnum() const;
  void set_maxnum(int32_t value);
  private:
  int32_t _internal_maxnum() const;
  void _internal_set_maxnum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyDungeonSurviveChallengeCurWaveNum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t uid_;
    int32_t curnum_;
    int32_t maxnum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DungeonSurviveDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DungeonSurviveDataReq) */ {
 public:
  inline DungeonSurviveDataReq() : DungeonSurviveDataReq(nullptr) {}
  ~DungeonSurviveDataReq() override;
  explicit PROTOBUF_CONSTEXPR DungeonSurviveDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DungeonSurviveDataReq(const DungeonSurviveDataReq& from);
  DungeonSurviveDataReq(DungeonSurviveDataReq&& from) noexcept
    : DungeonSurviveDataReq() {
    *this = ::std::move(from);
  }

  inline DungeonSurviveDataReq& operator=(const DungeonSurviveDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonSurviveDataReq& operator=(DungeonSurviveDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonSurviveDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DungeonSurviveDataReq* internal_default_instance() {
    return reinterpret_cast<const DungeonSurviveDataReq*>(
               &_DungeonSurviveDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    339;

  friend void swap(DungeonSurviveDataReq& a, DungeonSurviveDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DungeonSurviveDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonSurviveDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonSurviveDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DungeonSurviveDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DungeonSurviveDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DungeonSurviveDataReq& from) {
    DungeonSurviveDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonSurviveDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DungeonSurviveDataReq";
  }
  protected:
  explicit DungeonSurviveDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAskUidFieldNumber = 1,
  };
  // int32 ask_uid = 1;
  void clear_ask_uid();
  int32_t ask_uid() const;
  void set_ask_uid(int32_t value);
  private:
  int32_t _internal_ask_uid() const;
  void _internal_set_ask_uid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DungeonSurviveDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t ask_uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DungeonSurviveDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DungeonSurviveDataAck) */ {
 public:
  inline DungeonSurviveDataAck() : DungeonSurviveDataAck(nullptr) {}
  ~DungeonSurviveDataAck() override;
  explicit PROTOBUF_CONSTEXPR DungeonSurviveDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DungeonSurviveDataAck(const DungeonSurviveDataAck& from);
  DungeonSurviveDataAck(DungeonSurviveDataAck&& from) noexcept
    : DungeonSurviveDataAck() {
    *this = ::std::move(from);
  }

  inline DungeonSurviveDataAck& operator=(const DungeonSurviveDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DungeonSurviveDataAck& operator=(DungeonSurviveDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DungeonSurviveDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DungeonSurviveDataAck* internal_default_instance() {
    return reinterpret_cast<const DungeonSurviveDataAck*>(
               &_DungeonSurviveDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    340;

  friend void swap(DungeonSurviveDataAck& a, DungeonSurviveDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DungeonSurviveDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DungeonSurviveDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DungeonSurviveDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DungeonSurviveDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DungeonSurviveDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DungeonSurviveDataAck& from) {
    DungeonSurviveDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonSurviveDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DungeonSurviveDataAck";
  }
  protected:
  explicit DungeonSurviveDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DungeonSurviveDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestEnterSeptDemonWorldReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RequestEnterSeptDemonWorldReq) */ {
 public:
  inline RequestEnterSeptDemonWorldReq() : RequestEnterSeptDemonWorldReq(nullptr) {}
  ~RequestEnterSeptDemonWorldReq() override;
  explicit PROTOBUF_CONSTEXPR RequestEnterSeptDemonWorldReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestEnterSeptDemonWorldReq(const RequestEnterSeptDemonWorldReq& from);
  RequestEnterSeptDemonWorldReq(RequestEnterSeptDemonWorldReq&& from) noexcept
    : RequestEnterSeptDemonWorldReq() {
    *this = ::std::move(from);
  }

  inline RequestEnterSeptDemonWorldReq& operator=(const RequestEnterSeptDemonWorldReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestEnterSeptDemonWorldReq& operator=(RequestEnterSeptDemonWorldReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestEnterSeptDemonWorldReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestEnterSeptDemonWorldReq* internal_default_instance() {
    return reinterpret_cast<const RequestEnterSeptDemonWorldReq*>(
               &_RequestEnterSeptDemonWorldReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    341;

  friend void swap(RequestEnterSeptDemonWorldReq& a, RequestEnterSeptDemonWorldReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestEnterSeptDemonWorldReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestEnterSeptDemonWorldReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestEnterSeptDemonWorldReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestEnterSeptDemonWorldReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestEnterSeptDemonWorldReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestEnterSeptDemonWorldReq& from) {
    RequestEnterSeptDemonWorldReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestEnterSeptDemonWorldReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestEnterSeptDemonWorldReq";
  }
  protected:
  explicit RequestEnterSeptDemonWorldReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeptIdFieldNumber = 1,
  };
  // int64 sept_id = 1;
  void clear_sept_id();
  int64_t sept_id() const;
  void set_sept_id(int64_t value);
  private:
  int64_t _internal_sept_id() const;
  void _internal_set_sept_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RequestEnterSeptDemonWorldReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t sept_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestEnterSeptDemonWorldAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RequestEnterSeptDemonWorldAck) */ {
 public:
  inline RequestEnterSeptDemonWorldAck() : RequestEnterSeptDemonWorldAck(nullptr) {}
  ~RequestEnterSeptDemonWorldAck() override;
  explicit PROTOBUF_CONSTEXPR RequestEnterSeptDemonWorldAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestEnterSeptDemonWorldAck(const RequestEnterSeptDemonWorldAck& from);
  RequestEnterSeptDemonWorldAck(RequestEnterSeptDemonWorldAck&& from) noexcept
    : RequestEnterSeptDemonWorldAck() {
    *this = ::std::move(from);
  }

  inline RequestEnterSeptDemonWorldAck& operator=(const RequestEnterSeptDemonWorldAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestEnterSeptDemonWorldAck& operator=(RequestEnterSeptDemonWorldAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestEnterSeptDemonWorldAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestEnterSeptDemonWorldAck* internal_default_instance() {
    return reinterpret_cast<const RequestEnterSeptDemonWorldAck*>(
               &_RequestEnterSeptDemonWorldAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    342;

  friend void swap(RequestEnterSeptDemonWorldAck& a, RequestEnterSeptDemonWorldAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestEnterSeptDemonWorldAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestEnterSeptDemonWorldAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestEnterSeptDemonWorldAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestEnterSeptDemonWorldAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestEnterSeptDemonWorldAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestEnterSeptDemonWorldAck& from) {
    RequestEnterSeptDemonWorldAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestEnterSeptDemonWorldAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestEnterSeptDemonWorldAck";
  }
  protected:
  explicit RequestEnterSeptDemonWorldAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RequestEnterSeptDemonWorldAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestLeaveSeptDemonWorldReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RequestLeaveSeptDemonWorldReq) */ {
 public:
  inline RequestLeaveSeptDemonWorldReq() : RequestLeaveSeptDemonWorldReq(nullptr) {}
  ~RequestLeaveSeptDemonWorldReq() override;
  explicit PROTOBUF_CONSTEXPR RequestLeaveSeptDemonWorldReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestLeaveSeptDemonWorldReq(const RequestLeaveSeptDemonWorldReq& from);
  RequestLeaveSeptDemonWorldReq(RequestLeaveSeptDemonWorldReq&& from) noexcept
    : RequestLeaveSeptDemonWorldReq() {
    *this = ::std::move(from);
  }

  inline RequestLeaveSeptDemonWorldReq& operator=(const RequestLeaveSeptDemonWorldReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestLeaveSeptDemonWorldReq& operator=(RequestLeaveSeptDemonWorldReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestLeaveSeptDemonWorldReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestLeaveSeptDemonWorldReq* internal_default_instance() {
    return reinterpret_cast<const RequestLeaveSeptDemonWorldReq*>(
               &_RequestLeaveSeptDemonWorldReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    343;

  friend void swap(RequestLeaveSeptDemonWorldReq& a, RequestLeaveSeptDemonWorldReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestLeaveSeptDemonWorldReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestLeaveSeptDemonWorldReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestLeaveSeptDemonWorldReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestLeaveSeptDemonWorldReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestLeaveSeptDemonWorldReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestLeaveSeptDemonWorldReq& from) {
    RequestLeaveSeptDemonWorldReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestLeaveSeptDemonWorldReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestLeaveSeptDemonWorldReq";
  }
  protected:
  explicit RequestLeaveSeptDemonWorldReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeptIdFieldNumber = 1,
  };
  // int64 sept_id = 1;
  void clear_sept_id();
  int64_t sept_id() const;
  void set_sept_id(int64_t value);
  private:
  int64_t _internal_sept_id() const;
  void _internal_set_sept_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RequestLeaveSeptDemonWorldReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t sept_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestLeaveSeptDemonWorldAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RequestLeaveSeptDemonWorldAck) */ {
 public:
  inline RequestLeaveSeptDemonWorldAck() : RequestLeaveSeptDemonWorldAck(nullptr) {}
  ~RequestLeaveSeptDemonWorldAck() override;
  explicit PROTOBUF_CONSTEXPR RequestLeaveSeptDemonWorldAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestLeaveSeptDemonWorldAck(const RequestLeaveSeptDemonWorldAck& from);
  RequestLeaveSeptDemonWorldAck(RequestLeaveSeptDemonWorldAck&& from) noexcept
    : RequestLeaveSeptDemonWorldAck() {
    *this = ::std::move(from);
  }

  inline RequestLeaveSeptDemonWorldAck& operator=(const RequestLeaveSeptDemonWorldAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestLeaveSeptDemonWorldAck& operator=(RequestLeaveSeptDemonWorldAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestLeaveSeptDemonWorldAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestLeaveSeptDemonWorldAck* internal_default_instance() {
    return reinterpret_cast<const RequestLeaveSeptDemonWorldAck*>(
               &_RequestLeaveSeptDemonWorldAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    344;

  friend void swap(RequestLeaveSeptDemonWorldAck& a, RequestLeaveSeptDemonWorldAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestLeaveSeptDemonWorldAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestLeaveSeptDemonWorldAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestLeaveSeptDemonWorldAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestLeaveSeptDemonWorldAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestLeaveSeptDemonWorldAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestLeaveSeptDemonWorldAck& from) {
    RequestLeaveSeptDemonWorldAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestLeaveSeptDemonWorldAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestLeaveSeptDemonWorldAck";
  }
  protected:
  explicit RequestLeaveSeptDemonWorldAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RequestLeaveSeptDemonWorldAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestSeptDemonWorldDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RequestSeptDemonWorldDataReq) */ {
 public:
  inline RequestSeptDemonWorldDataReq() : RequestSeptDemonWorldDataReq(nullptr) {}
  ~RequestSeptDemonWorldDataReq() override;
  explicit PROTOBUF_CONSTEXPR RequestSeptDemonWorldDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestSeptDemonWorldDataReq(const RequestSeptDemonWorldDataReq& from);
  RequestSeptDemonWorldDataReq(RequestSeptDemonWorldDataReq&& from) noexcept
    : RequestSeptDemonWorldDataReq() {
    *this = ::std::move(from);
  }

  inline RequestSeptDemonWorldDataReq& operator=(const RequestSeptDemonWorldDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestSeptDemonWorldDataReq& operator=(RequestSeptDemonWorldDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestSeptDemonWorldDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestSeptDemonWorldDataReq* internal_default_instance() {
    return reinterpret_cast<const RequestSeptDemonWorldDataReq*>(
               &_RequestSeptDemonWorldDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    345;

  friend void swap(RequestSeptDemonWorldDataReq& a, RequestSeptDemonWorldDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestSeptDemonWorldDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestSeptDemonWorldDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestSeptDemonWorldDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestSeptDemonWorldDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestSeptDemonWorldDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestSeptDemonWorldDataReq& from) {
    RequestSeptDemonWorldDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSeptDemonWorldDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestSeptDemonWorldDataReq";
  }
  protected:
  explicit RequestSeptDemonWorldDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeptIdFieldNumber = 1,
  };
  // int64 sept_id = 1;
  void clear_sept_id();
  int64_t sept_id() const;
  void set_sept_id(int64_t value);
  private:
  int64_t _internal_sept_id() const;
  void _internal_set_sept_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RequestSeptDemonWorldDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t sept_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestSeptDemonWorldDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RequestSeptDemonWorldDataAck) */ {
 public:
  inline RequestSeptDemonWorldDataAck() : RequestSeptDemonWorldDataAck(nullptr) {}
  ~RequestSeptDemonWorldDataAck() override;
  explicit PROTOBUF_CONSTEXPR RequestSeptDemonWorldDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestSeptDemonWorldDataAck(const RequestSeptDemonWorldDataAck& from);
  RequestSeptDemonWorldDataAck(RequestSeptDemonWorldDataAck&& from) noexcept
    : RequestSeptDemonWorldDataAck() {
    *this = ::std::move(from);
  }

  inline RequestSeptDemonWorldDataAck& operator=(const RequestSeptDemonWorldDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestSeptDemonWorldDataAck& operator=(RequestSeptDemonWorldDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestSeptDemonWorldDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestSeptDemonWorldDataAck* internal_default_instance() {
    return reinterpret_cast<const RequestSeptDemonWorldDataAck*>(
               &_RequestSeptDemonWorldDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    346;

  friend void swap(RequestSeptDemonWorldDataAck& a, RequestSeptDemonWorldDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestSeptDemonWorldDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestSeptDemonWorldDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestSeptDemonWorldDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestSeptDemonWorldDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestSeptDemonWorldDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestSeptDemonWorldDataAck& from) {
    RequestSeptDemonWorldDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSeptDemonWorldDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestSeptDemonWorldDataAck";
  }
  protected:
  explicit RequestSeptDemonWorldDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.SeptDemonWorldData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::SeptDemonWorldData& data() const;
  PROTOBUF_NODISCARD ::idlepb::SeptDemonWorldData* release_data();
  ::idlepb::SeptDemonWorldData* mutable_data();
  void set_allocated_data(::idlepb::SeptDemonWorldData* data);
  private:
  const ::idlepb::SeptDemonWorldData& _internal_data() const;
  ::idlepb::SeptDemonWorldData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::SeptDemonWorldData* data);
  ::idlepb::SeptDemonWorldData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.RequestSeptDemonWorldDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::SeptDemonWorldData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestInSeptDemonWorldEndTimeReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.RequestInSeptDemonWorldEndTimeReq) */ {
 public:
  inline RequestInSeptDemonWorldEndTimeReq() : RequestInSeptDemonWorldEndTimeReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RequestInSeptDemonWorldEndTimeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestInSeptDemonWorldEndTimeReq(const RequestInSeptDemonWorldEndTimeReq& from);
  RequestInSeptDemonWorldEndTimeReq(RequestInSeptDemonWorldEndTimeReq&& from) noexcept
    : RequestInSeptDemonWorldEndTimeReq() {
    *this = ::std::move(from);
  }

  inline RequestInSeptDemonWorldEndTimeReq& operator=(const RequestInSeptDemonWorldEndTimeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestInSeptDemonWorldEndTimeReq& operator=(RequestInSeptDemonWorldEndTimeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestInSeptDemonWorldEndTimeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestInSeptDemonWorldEndTimeReq* internal_default_instance() {
    return reinterpret_cast<const RequestInSeptDemonWorldEndTimeReq*>(
               &_RequestInSeptDemonWorldEndTimeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    347;

  friend void swap(RequestInSeptDemonWorldEndTimeReq& a, RequestInSeptDemonWorldEndTimeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestInSeptDemonWorldEndTimeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestInSeptDemonWorldEndTimeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestInSeptDemonWorldEndTimeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestInSeptDemonWorldEndTimeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RequestInSeptDemonWorldEndTimeReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RequestInSeptDemonWorldEndTimeReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestInSeptDemonWorldEndTimeReq";
  }
  protected:
  explicit RequestInSeptDemonWorldEndTimeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.RequestInSeptDemonWorldEndTimeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API RequestInSeptDemonWorldEndTimeAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.RequestInSeptDemonWorldEndTimeAck) */ {
 public:
  inline RequestInSeptDemonWorldEndTimeAck() : RequestInSeptDemonWorldEndTimeAck(nullptr) {}
  ~RequestInSeptDemonWorldEndTimeAck() override;
  explicit PROTOBUF_CONSTEXPR RequestInSeptDemonWorldEndTimeAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestInSeptDemonWorldEndTimeAck(const RequestInSeptDemonWorldEndTimeAck& from);
  RequestInSeptDemonWorldEndTimeAck(RequestInSeptDemonWorldEndTimeAck&& from) noexcept
    : RequestInSeptDemonWorldEndTimeAck() {
    *this = ::std::move(from);
  }

  inline RequestInSeptDemonWorldEndTimeAck& operator=(const RequestInSeptDemonWorldEndTimeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestInSeptDemonWorldEndTimeAck& operator=(RequestInSeptDemonWorldEndTimeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestInSeptDemonWorldEndTimeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestInSeptDemonWorldEndTimeAck* internal_default_instance() {
    return reinterpret_cast<const RequestInSeptDemonWorldEndTimeAck*>(
               &_RequestInSeptDemonWorldEndTimeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    348;

  friend void swap(RequestInSeptDemonWorldEndTimeAck& a, RequestInSeptDemonWorldEndTimeAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestInSeptDemonWorldEndTimeAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestInSeptDemonWorldEndTimeAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestInSeptDemonWorldEndTimeAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestInSeptDemonWorldEndTimeAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestInSeptDemonWorldEndTimeAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestInSeptDemonWorldEndTimeAck& from) {
    RequestInSeptDemonWorldEndTimeAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestInSeptDemonWorldEndTimeAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.RequestInSeptDemonWorldEndTimeAck";
  }
  protected:
  explicit RequestInSeptDemonWorldEndTimeAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndTimeFieldNumber = 1,
  };
  // int64 end_time = 1;
  void clear_end_time();
  int64_t end_time() const;
  void set_end_time(int64_t value);
  private:
  int64_t _internal_end_time() const;
  void _internal_set_end_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.RequestInSeptDemonWorldEndTimeAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t end_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetFarmlandDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetFarmlandDataReq) */ {
 public:
  inline GetFarmlandDataReq() : GetFarmlandDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetFarmlandDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFarmlandDataReq(const GetFarmlandDataReq& from);
  GetFarmlandDataReq(GetFarmlandDataReq&& from) noexcept
    : GetFarmlandDataReq() {
    *this = ::std::move(from);
  }

  inline GetFarmlandDataReq& operator=(const GetFarmlandDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFarmlandDataReq& operator=(GetFarmlandDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFarmlandDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFarmlandDataReq* internal_default_instance() {
    return reinterpret_cast<const GetFarmlandDataReq*>(
               &_GetFarmlandDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    349;

  friend void swap(GetFarmlandDataReq& a, GetFarmlandDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFarmlandDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFarmlandDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFarmlandDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFarmlandDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetFarmlandDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetFarmlandDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetFarmlandDataReq";
  }
  protected:
  explicit GetFarmlandDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetFarmlandDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetFarmlandDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetFarmlandDataAck) */ {
 public:
  inline GetFarmlandDataAck() : GetFarmlandDataAck(nullptr) {}
  ~GetFarmlandDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetFarmlandDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFarmlandDataAck(const GetFarmlandDataAck& from);
  GetFarmlandDataAck(GetFarmlandDataAck&& from) noexcept
    : GetFarmlandDataAck() {
    *this = ::std::move(from);
  }

  inline GetFarmlandDataAck& operator=(const GetFarmlandDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFarmlandDataAck& operator=(GetFarmlandDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFarmlandDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFarmlandDataAck* internal_default_instance() {
    return reinterpret_cast<const GetFarmlandDataAck*>(
               &_GetFarmlandDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    350;

  friend void swap(GetFarmlandDataAck& a, GetFarmlandDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFarmlandDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFarmlandDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFarmlandDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFarmlandDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFarmlandDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFarmlandDataAck& from) {
    GetFarmlandDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFarmlandDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetFarmlandDataAck";
  }
  protected:
  explicit GetFarmlandDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleFarmlandData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleFarmlandData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleFarmlandData* release_data();
  ::idlepb::RoleFarmlandData* mutable_data();
  void set_allocated_data(::idlepb::RoleFarmlandData* data);
  private:
  const ::idlepb::RoleFarmlandData& _internal_data() const;
  ::idlepb::RoleFarmlandData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleFarmlandData* data);
  ::idlepb::RoleFarmlandData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetFarmlandDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleFarmlandData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmlandUnlockBlockReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmlandUnlockBlockReq) */ {
 public:
  inline FarmlandUnlockBlockReq() : FarmlandUnlockBlockReq(nullptr) {}
  ~FarmlandUnlockBlockReq() override;
  explicit PROTOBUF_CONSTEXPR FarmlandUnlockBlockReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmlandUnlockBlockReq(const FarmlandUnlockBlockReq& from);
  FarmlandUnlockBlockReq(FarmlandUnlockBlockReq&& from) noexcept
    : FarmlandUnlockBlockReq() {
    *this = ::std::move(from);
  }

  inline FarmlandUnlockBlockReq& operator=(const FarmlandUnlockBlockReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmlandUnlockBlockReq& operator=(FarmlandUnlockBlockReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmlandUnlockBlockReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmlandUnlockBlockReq* internal_default_instance() {
    return reinterpret_cast<const FarmlandUnlockBlockReq*>(
               &_FarmlandUnlockBlockReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    351;

  friend void swap(FarmlandUnlockBlockReq& a, FarmlandUnlockBlockReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmlandUnlockBlockReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmlandUnlockBlockReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmlandUnlockBlockReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmlandUnlockBlockReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmlandUnlockBlockReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmlandUnlockBlockReq& from) {
    FarmlandUnlockBlockReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmlandUnlockBlockReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmlandUnlockBlockReq";
  }
  protected:
  explicit FarmlandUnlockBlockReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FarmlandUnlockBlockReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmlandUnlockBlockAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmlandUnlockBlockAck) */ {
 public:
  inline FarmlandUnlockBlockAck() : FarmlandUnlockBlockAck(nullptr) {}
  ~FarmlandUnlockBlockAck() override;
  explicit PROTOBUF_CONSTEXPR FarmlandUnlockBlockAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmlandUnlockBlockAck(const FarmlandUnlockBlockAck& from);
  FarmlandUnlockBlockAck(FarmlandUnlockBlockAck&& from) noexcept
    : FarmlandUnlockBlockAck() {
    *this = ::std::move(from);
  }

  inline FarmlandUnlockBlockAck& operator=(const FarmlandUnlockBlockAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmlandUnlockBlockAck& operator=(FarmlandUnlockBlockAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmlandUnlockBlockAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmlandUnlockBlockAck* internal_default_instance() {
    return reinterpret_cast<const FarmlandUnlockBlockAck*>(
               &_FarmlandUnlockBlockAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    352;

  friend void swap(FarmlandUnlockBlockAck& a, FarmlandUnlockBlockAck& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmlandUnlockBlockAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmlandUnlockBlockAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmlandUnlockBlockAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmlandUnlockBlockAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmlandUnlockBlockAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmlandUnlockBlockAck& from) {
    FarmlandUnlockBlockAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmlandUnlockBlockAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmlandUnlockBlockAck";
  }
  protected:
  explicit FarmlandUnlockBlockAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FarmlandUnlockBlockAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmlandPlantSeedReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmlandPlantSeedReq) */ {
 public:
  inline FarmlandPlantSeedReq() : FarmlandPlantSeedReq(nullptr) {}
  ~FarmlandPlantSeedReq() override;
  explicit PROTOBUF_CONSTEXPR FarmlandPlantSeedReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmlandPlantSeedReq(const FarmlandPlantSeedReq& from);
  FarmlandPlantSeedReq(FarmlandPlantSeedReq&& from) noexcept
    : FarmlandPlantSeedReq() {
    *this = ::std::move(from);
  }

  inline FarmlandPlantSeedReq& operator=(const FarmlandPlantSeedReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmlandPlantSeedReq& operator=(FarmlandPlantSeedReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmlandPlantSeedReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmlandPlantSeedReq* internal_default_instance() {
    return reinterpret_cast<const FarmlandPlantSeedReq*>(
               &_FarmlandPlantSeedReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    353;

  friend void swap(FarmlandPlantSeedReq& a, FarmlandPlantSeedReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmlandPlantSeedReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmlandPlantSeedReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmlandPlantSeedReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmlandPlantSeedReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmlandPlantSeedReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmlandPlantSeedReq& from) {
    FarmlandPlantSeedReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmlandPlantSeedReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmlandPlantSeedReq";
  }
  protected:
  explicit FarmlandPlantSeedReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kRotationFieldNumber = 4,
    kIsDeleteFieldNumber = 5,
  };
  // int32 item_id = 1;
  void clear_item_id();
  int32_t item_id() const;
  void set_item_id(int32_t value);
  private:
  int32_t _internal_item_id() const;
  void _internal_set_item_id(int32_t value);
  public:

  // int32 x = 2;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 3;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // int32 rotation = 4;
  void clear_rotation();
  int32_t rotation() const;
  void set_rotation(int32_t value);
  private:
  int32_t _internal_rotation() const;
  void _internal_set_rotation(int32_t value);
  public:

  // bool is_delete = 5;
  void clear_is_delete();
  bool is_delete() const;
  void set_is_delete(bool value);
  private:
  bool _internal_is_delete() const;
  void _internal_set_is_delete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FarmlandPlantSeedReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t item_id_;
    int32_t x_;
    int32_t y_;
    int32_t rotation_;
    bool is_delete_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmlandPlantSeedAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmlandPlantSeedAck) */ {
 public:
  inline FarmlandPlantSeedAck() : FarmlandPlantSeedAck(nullptr) {}
  ~FarmlandPlantSeedAck() override;
  explicit PROTOBUF_CONSTEXPR FarmlandPlantSeedAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmlandPlantSeedAck(const FarmlandPlantSeedAck& from);
  FarmlandPlantSeedAck(FarmlandPlantSeedAck&& from) noexcept
    : FarmlandPlantSeedAck() {
    *this = ::std::move(from);
  }

  inline FarmlandPlantSeedAck& operator=(const FarmlandPlantSeedAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmlandPlantSeedAck& operator=(FarmlandPlantSeedAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmlandPlantSeedAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmlandPlantSeedAck* internal_default_instance() {
    return reinterpret_cast<const FarmlandPlantSeedAck*>(
               &_FarmlandPlantSeedAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    354;

  friend void swap(FarmlandPlantSeedAck& a, FarmlandPlantSeedAck& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmlandPlantSeedAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmlandPlantSeedAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmlandPlantSeedAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmlandPlantSeedAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmlandPlantSeedAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmlandPlantSeedAck& from) {
    FarmlandPlantSeedAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmlandPlantSeedAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmlandPlantSeedAck";
  }
  protected:
  explicit FarmlandPlantSeedAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlantDataFieldNumber = 2,
  };
  // .idlepb.FarmlandPlantData plant_data = 2;
  bool has_plant_data() const;
  private:
  bool _internal_has_plant_data() const;
  public:
  void clear_plant_data();
  const ::idlepb::FarmlandPlantData& plant_data() const;
  PROTOBUF_NODISCARD ::idlepb::FarmlandPlantData* release_plant_data();
  ::idlepb::FarmlandPlantData* mutable_plant_data();
  void set_allocated_plant_data(::idlepb::FarmlandPlantData* plant_data);
  private:
  const ::idlepb::FarmlandPlantData& _internal_plant_data() const;
  ::idlepb::FarmlandPlantData* _internal_mutable_plant_data();
  public:
  void unsafe_arena_set_allocated_plant_data(
      ::idlepb::FarmlandPlantData* plant_data);
  ::idlepb::FarmlandPlantData* unsafe_arena_release_plant_data();

  // @@protoc_insertion_point(class_scope:idlepb.FarmlandPlantSeedAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::FarmlandPlantData* plant_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmlandWateringReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmlandWateringReq) */ {
 public:
  inline FarmlandWateringReq() : FarmlandWateringReq(nullptr) {}
  ~FarmlandWateringReq() override;
  explicit PROTOBUF_CONSTEXPR FarmlandWateringReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmlandWateringReq(const FarmlandWateringReq& from);
  FarmlandWateringReq(FarmlandWateringReq&& from) noexcept
    : FarmlandWateringReq() {
    *this = ::std::move(from);
  }

  inline FarmlandWateringReq& operator=(const FarmlandWateringReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmlandWateringReq& operator=(FarmlandWateringReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmlandWateringReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmlandWateringReq* internal_default_instance() {
    return reinterpret_cast<const FarmlandWateringReq*>(
               &_FarmlandWateringReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    355;

  friend void swap(FarmlandWateringReq& a, FarmlandWateringReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmlandWateringReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmlandWateringReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmlandWateringReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmlandWateringReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmlandWateringReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmlandWateringReq& from) {
    FarmlandWateringReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmlandWateringReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmlandWateringReq";
  }
  protected:
  explicit FarmlandWateringReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumFieldNumber = 1,
  };
  // int32 num = 1;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FarmlandWateringReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmlandWateringAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmlandWateringAck) */ {
 public:
  inline FarmlandWateringAck() : FarmlandWateringAck(nullptr) {}
  ~FarmlandWateringAck() override;
  explicit PROTOBUF_CONSTEXPR FarmlandWateringAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmlandWateringAck(const FarmlandWateringAck& from);
  FarmlandWateringAck(FarmlandWateringAck&& from) noexcept
    : FarmlandWateringAck() {
    *this = ::std::move(from);
  }

  inline FarmlandWateringAck& operator=(const FarmlandWateringAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmlandWateringAck& operator=(FarmlandWateringAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmlandWateringAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmlandWateringAck* internal_default_instance() {
    return reinterpret_cast<const FarmlandWateringAck*>(
               &_FarmlandWateringAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    356;

  friend void swap(FarmlandWateringAck& a, FarmlandWateringAck& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmlandWateringAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmlandWateringAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmlandWateringAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmlandWateringAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmlandWateringAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmlandWateringAck& from) {
    FarmlandWateringAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmlandWateringAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmlandWateringAck";
  }
  protected:
  explicit FarmlandWateringAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotaolSpeedUpFieldNumber = 1,
  };
  // int32 totaol_speed_up = 1;
  void clear_totaol_speed_up();
  int32_t totaol_speed_up() const;
  void set_totaol_speed_up(int32_t value);
  private:
  int32_t _internal_totaol_speed_up() const;
  void _internal_set_totaol_speed_up(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FarmlandWateringAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t totaol_speed_up_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmlandRipeningReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmlandRipeningReq) */ {
 public:
  inline FarmlandRipeningReq() : FarmlandRipeningReq(nullptr) {}
  ~FarmlandRipeningReq() override;
  explicit PROTOBUF_CONSTEXPR FarmlandRipeningReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmlandRipeningReq(const FarmlandRipeningReq& from);
  FarmlandRipeningReq(FarmlandRipeningReq&& from) noexcept
    : FarmlandRipeningReq() {
    *this = ::std::move(from);
  }

  inline FarmlandRipeningReq& operator=(const FarmlandRipeningReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmlandRipeningReq& operator=(FarmlandRipeningReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmlandRipeningReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmlandRipeningReq* internal_default_instance() {
    return reinterpret_cast<const FarmlandRipeningReq*>(
               &_FarmlandRipeningReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    357;

  friend void swap(FarmlandRipeningReq& a, FarmlandRipeningReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmlandRipeningReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmlandRipeningReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmlandRipeningReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmlandRipeningReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmlandRipeningReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmlandRipeningReq& from) {
    FarmlandRipeningReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmlandRipeningReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmlandRipeningReq";
  }
  protected:
  explicit FarmlandRipeningReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOneClickPlantsFieldNumber = 5,
    kPlantUidFieldNumber = 1,
    kItemIdFieldNumber = 2,
    kNumFieldNumber = 3,
    kOneClickFieldNumber = 4,
  };
  // repeated .idlepb.FarmlandManagementInfo one_click_plants = 5;
  int one_click_plants_size() const;
  private:
  int _internal_one_click_plants_size() const;
  public:
  void clear_one_click_plants();
  ::idlepb::FarmlandManagementInfo* mutable_one_click_plants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandManagementInfo >*
      mutable_one_click_plants();
  private:
  const ::idlepb::FarmlandManagementInfo& _internal_one_click_plants(int index) const;
  ::idlepb::FarmlandManagementInfo* _internal_add_one_click_plants();
  public:
  const ::idlepb::FarmlandManagementInfo& one_click_plants(int index) const;
  ::idlepb::FarmlandManagementInfo* add_one_click_plants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandManagementInfo >&
      one_click_plants() const;

  // int32 plant_uid = 1;
  void clear_plant_uid();
  int32_t plant_uid() const;
  void set_plant_uid(int32_t value);
  private:
  int32_t _internal_plant_uid() const;
  void _internal_set_plant_uid(int32_t value);
  public:

  // int32 item_id = 2;
  void clear_item_id();
  int32_t item_id() const;
  void set_item_id(int32_t value);
  private:
  int32_t _internal_item_id() const;
  void _internal_set_item_id(int32_t value);
  public:

  // int32 num = 3;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // int32 one_click = 4;
  void clear_one_click();
  int32_t one_click() const;
  void set_one_click(int32_t value);
  private:
  int32_t _internal_one_click() const;
  void _internal_set_one_click(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FarmlandRipeningReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandManagementInfo > one_click_plants_;
    int32_t plant_uid_;
    int32_t item_id_;
    int32_t num_;
    int32_t one_click_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmlandRipeningAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmlandRipeningAck) */ {
 public:
  inline FarmlandRipeningAck() : FarmlandRipeningAck(nullptr) {}
  ~FarmlandRipeningAck() override;
  explicit PROTOBUF_CONSTEXPR FarmlandRipeningAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmlandRipeningAck(const FarmlandRipeningAck& from);
  FarmlandRipeningAck(FarmlandRipeningAck&& from) noexcept
    : FarmlandRipeningAck() {
    *this = ::std::move(from);
  }

  inline FarmlandRipeningAck& operator=(const FarmlandRipeningAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmlandRipeningAck& operator=(FarmlandRipeningAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmlandRipeningAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmlandRipeningAck* internal_default_instance() {
    return reinterpret_cast<const FarmlandRipeningAck*>(
               &_FarmlandRipeningAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    358;

  friend void swap(FarmlandRipeningAck& a, FarmlandRipeningAck& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmlandRipeningAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmlandRipeningAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmlandRipeningAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmlandRipeningAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmlandRipeningAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmlandRipeningAck& from) {
    FarmlandRipeningAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmlandRipeningAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmlandRipeningAck";
  }
  protected:
  explicit FarmlandRipeningAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kUsedRipeItemsFieldNumber = 3,
    kOkFieldNumber = 1,
  };
  // repeated .idlepb.FarmlandPlantData result = 2;
  int result_size() const;
  private:
  int _internal_result_size() const;
  public:
  void clear_result();
  ::idlepb::FarmlandPlantData* mutable_result(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData >*
      mutable_result();
  private:
  const ::idlepb::FarmlandPlantData& _internal_result(int index) const;
  ::idlepb::FarmlandPlantData* _internal_add_result();
  public:
  const ::idlepb::FarmlandPlantData& result(int index) const;
  ::idlepb::FarmlandPlantData* add_result();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData >&
      result() const;

  // repeated .idlepb.SimpleItemData used_ripe_items = 3;
  int used_ripe_items_size() const;
  private:
  int _internal_used_ripe_items_size() const;
  public:
  void clear_used_ripe_items();
  ::idlepb::SimpleItemData* mutable_used_ripe_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
      mutable_used_ripe_items();
  private:
  const ::idlepb::SimpleItemData& _internal_used_ripe_items(int index) const;
  ::idlepb::SimpleItemData* _internal_add_used_ripe_items();
  public:
  const ::idlepb::SimpleItemData& used_ripe_items(int index) const;
  ::idlepb::SimpleItemData* add_used_ripe_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
      used_ripe_items() const;

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FarmlandRipeningAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData > result_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData > used_ripe_items_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmlandHarvestReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmlandHarvestReq) */ {
 public:
  inline FarmlandHarvestReq() : FarmlandHarvestReq(nullptr) {}
  ~FarmlandHarvestReq() override;
  explicit PROTOBUF_CONSTEXPR FarmlandHarvestReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmlandHarvestReq(const FarmlandHarvestReq& from);
  FarmlandHarvestReq(FarmlandHarvestReq&& from) noexcept
    : FarmlandHarvestReq() {
    *this = ::std::move(from);
  }

  inline FarmlandHarvestReq& operator=(const FarmlandHarvestReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmlandHarvestReq& operator=(FarmlandHarvestReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmlandHarvestReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmlandHarvestReq* internal_default_instance() {
    return reinterpret_cast<const FarmlandHarvestReq*>(
               &_FarmlandHarvestReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    359;

  friend void swap(FarmlandHarvestReq& a, FarmlandHarvestReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmlandHarvestReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmlandHarvestReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmlandHarvestReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmlandHarvestReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmlandHarvestReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmlandHarvestReq& from) {
    FarmlandHarvestReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmlandHarvestReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmlandHarvestReq";
  }
  protected:
  explicit FarmlandHarvestReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlantIdsFieldNumber = 1,
    kAutoHarvestSameClassFieldNumber = 2,
  };
  // repeated int32 plant_ids = 1;
  int plant_ids_size() const;
  private:
  int _internal_plant_ids_size() const;
  public:
  void clear_plant_ids();
  private:
  int32_t _internal_plant_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_plant_ids() const;
  void _internal_add_plant_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_plant_ids();
  public:
  int32_t plant_ids(int index) const;
  void set_plant_ids(int index, int32_t value);
  void add_plant_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      plant_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_plant_ids();

  // bool auto_harvest_same_class = 2;
  void clear_auto_harvest_same_class();
  bool auto_harvest_same_class() const;
  void set_auto_harvest_same_class(bool value);
  private:
  bool _internal_auto_harvest_same_class() const;
  void _internal_set_auto_harvest_same_class(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FarmlandHarvestReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > plant_ids_;
    mutable std::atomic<int> _plant_ids_cached_byte_size_;
    bool auto_harvest_same_class_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmlandHarvestAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmlandHarvestAck) */ {
 public:
  inline FarmlandHarvestAck() : FarmlandHarvestAck(nullptr) {}
  ~FarmlandHarvestAck() override;
  explicit PROTOBUF_CONSTEXPR FarmlandHarvestAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmlandHarvestAck(const FarmlandHarvestAck& from);
  FarmlandHarvestAck(FarmlandHarvestAck&& from) noexcept
    : FarmlandHarvestAck() {
    *this = ::std::move(from);
  }

  inline FarmlandHarvestAck& operator=(const FarmlandHarvestAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmlandHarvestAck& operator=(FarmlandHarvestAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmlandHarvestAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmlandHarvestAck* internal_default_instance() {
    return reinterpret_cast<const FarmlandHarvestAck*>(
               &_FarmlandHarvestAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    360;

  friend void swap(FarmlandHarvestAck& a, FarmlandHarvestAck& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmlandHarvestAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmlandHarvestAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmlandHarvestAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmlandHarvestAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmlandHarvestAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmlandHarvestAck& from) {
    FarmlandHarvestAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmlandHarvestAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmlandHarvestAck";
  }
  protected:
  explicit FarmlandHarvestAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kOpSuccessPlantIdFieldNumber = 3,
    kContinueSeedsFieldNumber = 4,
    kOkFieldNumber = 1,
  };
  // repeated .idlepb.SimpleItemData items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::SimpleItemData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
      mutable_items();
  private:
  const ::idlepb::SimpleItemData& _internal_items(int index) const;
  ::idlepb::SimpleItemData* _internal_add_items();
  public:
  const ::idlepb::SimpleItemData& items(int index) const;
  ::idlepb::SimpleItemData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
      items() const;

  // repeated int32 op_success_plant_id = 3;
  int op_success_plant_id_size() const;
  private:
  int _internal_op_success_plant_id_size() const;
  public:
  void clear_op_success_plant_id();
  private:
  int32_t _internal_op_success_plant_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_op_success_plant_id() const;
  void _internal_add_op_success_plant_id(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_op_success_plant_id();
  public:
  int32_t op_success_plant_id(int index) const;
  void set_op_success_plant_id(int index, int32_t value);
  void add_op_success_plant_id(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      op_success_plant_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_op_success_plant_id();

  // repeated .idlepb.FarmlandPlantData continue_seeds = 4;
  int continue_seeds_size() const;
  private:
  int _internal_continue_seeds_size() const;
  public:
  void clear_continue_seeds();
  ::idlepb::FarmlandPlantData* mutable_continue_seeds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData >*
      mutable_continue_seeds();
  private:
  const ::idlepb::FarmlandPlantData& _internal_continue_seeds(int index) const;
  ::idlepb::FarmlandPlantData* _internal_add_continue_seeds();
  public:
  const ::idlepb::FarmlandPlantData& continue_seeds(int index) const;
  ::idlepb::FarmlandPlantData* add_continue_seeds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData >&
      continue_seeds() const;

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FarmlandHarvestAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData > items_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > op_success_plant_id_;
    mutable std::atomic<int> _op_success_plant_id_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData > continue_seeds_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmerRankUpReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.FarmerRankUpReq) */ {
 public:
  inline FarmerRankUpReq() : FarmerRankUpReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FarmerRankUpReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmerRankUpReq(const FarmerRankUpReq& from);
  FarmerRankUpReq(FarmerRankUpReq&& from) noexcept
    : FarmerRankUpReq() {
    *this = ::std::move(from);
  }

  inline FarmerRankUpReq& operator=(const FarmerRankUpReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmerRankUpReq& operator=(FarmerRankUpReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmerRankUpReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmerRankUpReq* internal_default_instance() {
    return reinterpret_cast<const FarmerRankUpReq*>(
               &_FarmerRankUpReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    361;

  friend void swap(FarmerRankUpReq& a, FarmerRankUpReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmerRankUpReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmerRankUpReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmerRankUpReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmerRankUpReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FarmerRankUpReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FarmerRankUpReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmerRankUpReq";
  }
  protected:
  explicit FarmerRankUpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.FarmerRankUpReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmerRankUpAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmerRankUpAck) */ {
 public:
  inline FarmerRankUpAck() : FarmerRankUpAck(nullptr) {}
  ~FarmerRankUpAck() override;
  explicit PROTOBUF_CONSTEXPR FarmerRankUpAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmerRankUpAck(const FarmerRankUpAck& from);
  FarmerRankUpAck(FarmerRankUpAck&& from) noexcept
    : FarmerRankUpAck() {
    *this = ::std::move(from);
  }

  inline FarmerRankUpAck& operator=(const FarmerRankUpAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmerRankUpAck& operator=(FarmerRankUpAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmerRankUpAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmerRankUpAck* internal_default_instance() {
    return reinterpret_cast<const FarmerRankUpAck*>(
               &_FarmerRankUpAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    362;

  friend void swap(FarmerRankUpAck& a, FarmerRankUpAck& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmerRankUpAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmerRankUpAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmerRankUpAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmerRankUpAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmerRankUpAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmerRankUpAck& from) {
    FarmerRankUpAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmerRankUpAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmerRankUpAck";
  }
  protected:
  explicit FarmerRankUpAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FarmerRankUpAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmlandSetManagementReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmlandSetManagementReq) */ {
 public:
  inline FarmlandSetManagementReq() : FarmlandSetManagementReq(nullptr) {}
  ~FarmlandSetManagementReq() override;
  explicit PROTOBUF_CONSTEXPR FarmlandSetManagementReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmlandSetManagementReq(const FarmlandSetManagementReq& from);
  FarmlandSetManagementReq(FarmlandSetManagementReq&& from) noexcept
    : FarmlandSetManagementReq() {
    *this = ::std::move(from);
  }

  inline FarmlandSetManagementReq& operator=(const FarmlandSetManagementReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmlandSetManagementReq& operator=(FarmlandSetManagementReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmlandSetManagementReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmlandSetManagementReq* internal_default_instance() {
    return reinterpret_cast<const FarmlandSetManagementReq*>(
               &_FarmlandSetManagementReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    363;

  friend void swap(FarmlandSetManagementReq& a, FarmlandSetManagementReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmlandSetManagementReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmlandSetManagementReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmlandSetManagementReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmlandSetManagementReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmlandSetManagementReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmlandSetManagementReq& from) {
    FarmlandSetManagementReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmlandSetManagementReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmlandSetManagementReq";
  }
  protected:
  explicit FarmlandSetManagementReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlansFieldNumber = 1,
  };
  // repeated .idlepb.FarmlandManagementInfo plans = 1;
  int plans_size() const;
  private:
  int _internal_plans_size() const;
  public:
  void clear_plans();
  ::idlepb::FarmlandManagementInfo* mutable_plans(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandManagementInfo >*
      mutable_plans();
  private:
  const ::idlepb::FarmlandManagementInfo& _internal_plans(int index) const;
  ::idlepb::FarmlandManagementInfo* _internal_add_plans();
  public:
  const ::idlepb::FarmlandManagementInfo& plans(int index) const;
  ::idlepb::FarmlandManagementInfo* add_plans();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandManagementInfo >&
      plans() const;

  // @@protoc_insertion_point(class_scope:idlepb.FarmlandSetManagementReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandManagementInfo > plans_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FarmlandSetManagementAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FarmlandSetManagementAck) */ {
 public:
  inline FarmlandSetManagementAck() : FarmlandSetManagementAck(nullptr) {}
  ~FarmlandSetManagementAck() override;
  explicit PROTOBUF_CONSTEXPR FarmlandSetManagementAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FarmlandSetManagementAck(const FarmlandSetManagementAck& from);
  FarmlandSetManagementAck(FarmlandSetManagementAck&& from) noexcept
    : FarmlandSetManagementAck() {
    *this = ::std::move(from);
  }

  inline FarmlandSetManagementAck& operator=(const FarmlandSetManagementAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline FarmlandSetManagementAck& operator=(FarmlandSetManagementAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FarmlandSetManagementAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const FarmlandSetManagementAck* internal_default_instance() {
    return reinterpret_cast<const FarmlandSetManagementAck*>(
               &_FarmlandSetManagementAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    364;

  friend void swap(FarmlandSetManagementAck& a, FarmlandSetManagementAck& b) {
    a.Swap(&b);
  }
  inline void Swap(FarmlandSetManagementAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FarmlandSetManagementAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FarmlandSetManagementAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FarmlandSetManagementAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FarmlandSetManagementAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FarmlandSetManagementAck& from) {
    FarmlandSetManagementAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FarmlandSetManagementAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FarmlandSetManagementAck";
  }
  protected:
  explicit FarmlandSetManagementAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FarmlandSetManagementAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UpdateFarmlandStateReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.UpdateFarmlandStateReq) */ {
 public:
  inline UpdateFarmlandStateReq() : UpdateFarmlandStateReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateFarmlandStateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateFarmlandStateReq(const UpdateFarmlandStateReq& from);
  UpdateFarmlandStateReq(UpdateFarmlandStateReq&& from) noexcept
    : UpdateFarmlandStateReq() {
    *this = ::std::move(from);
  }

  inline UpdateFarmlandStateReq& operator=(const UpdateFarmlandStateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFarmlandStateReq& operator=(UpdateFarmlandStateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateFarmlandStateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateFarmlandStateReq* internal_default_instance() {
    return reinterpret_cast<const UpdateFarmlandStateReq*>(
               &_UpdateFarmlandStateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    365;

  friend void swap(UpdateFarmlandStateReq& a, UpdateFarmlandStateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFarmlandStateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFarmlandStateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateFarmlandStateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateFarmlandStateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateFarmlandStateReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateFarmlandStateReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UpdateFarmlandStateReq";
  }
  protected:
  explicit UpdateFarmlandStateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.UpdateFarmlandStateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API UpdateFarmlandStateAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.UpdateFarmlandStateAck) */ {
 public:
  inline UpdateFarmlandStateAck() : UpdateFarmlandStateAck(nullptr) {}
  ~UpdateFarmlandStateAck() override;
  explicit PROTOBUF_CONSTEXPR UpdateFarmlandStateAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateFarmlandStateAck(const UpdateFarmlandStateAck& from);
  UpdateFarmlandStateAck(UpdateFarmlandStateAck&& from) noexcept
    : UpdateFarmlandStateAck() {
    *this = ::std::move(from);
  }

  inline UpdateFarmlandStateAck& operator=(const UpdateFarmlandStateAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFarmlandStateAck& operator=(UpdateFarmlandStateAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateFarmlandStateAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateFarmlandStateAck* internal_default_instance() {
    return reinterpret_cast<const UpdateFarmlandStateAck*>(
               &_UpdateFarmlandStateAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    366;

  friend void swap(UpdateFarmlandStateAck& a, UpdateFarmlandStateAck& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFarmlandStateAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFarmlandStateAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateFarmlandStateAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateFarmlandStateAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateFarmlandStateAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateFarmlandStateAck& from) {
    UpdateFarmlandStateAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateFarmlandStateAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.UpdateFarmlandStateAck";
  }
  protected:
  explicit UpdateFarmlandStateAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAutoHarvestPlantsFieldNumber = 2,
    kContinueSeedsFieldNumber = 3,
    kHarvestItemsFieldNumber = 4,
    kFarmerFriendshipExpFieldNumber = 1,
  };
  // repeated int32 auto_harvest_plants = 2;
  int auto_harvest_plants_size() const;
  private:
  int _internal_auto_harvest_plants_size() const;
  public:
  void clear_auto_harvest_plants();
  private:
  int32_t _internal_auto_harvest_plants(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_auto_harvest_plants() const;
  void _internal_add_auto_harvest_plants(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_auto_harvest_plants();
  public:
  int32_t auto_harvest_plants(int index) const;
  void set_auto_harvest_plants(int index, int32_t value);
  void add_auto_harvest_plants(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      auto_harvest_plants() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_auto_harvest_plants();

  // repeated .idlepb.FarmlandPlantData continue_seeds = 3;
  int continue_seeds_size() const;
  private:
  int _internal_continue_seeds_size() const;
  public:
  void clear_continue_seeds();
  ::idlepb::FarmlandPlantData* mutable_continue_seeds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData >*
      mutable_continue_seeds();
  private:
  const ::idlepb::FarmlandPlantData& _internal_continue_seeds(int index) const;
  ::idlepb::FarmlandPlantData* _internal_add_continue_seeds();
  public:
  const ::idlepb::FarmlandPlantData& continue_seeds(int index) const;
  ::idlepb::FarmlandPlantData* add_continue_seeds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData >&
      continue_seeds() const;

  // repeated .idlepb.SimpleItemData harvest_items = 4;
  int harvest_items_size() const;
  private:
  int _internal_harvest_items_size() const;
  public:
  void clear_harvest_items();
  ::idlepb::SimpleItemData* mutable_harvest_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
      mutable_harvest_items();
  private:
  const ::idlepb::SimpleItemData& _internal_harvest_items(int index) const;
  ::idlepb::SimpleItemData* _internal_add_harvest_items();
  public:
  const ::idlepb::SimpleItemData& harvest_items(int index) const;
  ::idlepb::SimpleItemData* add_harvest_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
      harvest_items() const;

  // int32 farmer_friendship_exp = 1;
  void clear_farmer_friendship_exp();
  int32_t farmer_friendship_exp() const;
  void set_farmer_friendship_exp(int32_t value);
  private:
  int32_t _internal_farmer_friendship_exp() const;
  void _internal_set_farmer_friendship_exp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.UpdateFarmlandStateAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > auto_harvest_plants_;
    mutable std::atomic<int> _auto_harvest_plants_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData > continue_seeds_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData > harvest_items_;
    int32_t farmer_friendship_exp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleInfoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleInfoReq) */ {
 public:
  inline GetRoleInfoReq() : GetRoleInfoReq(nullptr) {}
  ~GetRoleInfoReq() override;
  explicit PROTOBUF_CONSTEXPR GetRoleInfoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleInfoReq(const GetRoleInfoReq& from);
  GetRoleInfoReq(GetRoleInfoReq&& from) noexcept
    : GetRoleInfoReq() {
    *this = ::std::move(from);
  }

  inline GetRoleInfoReq& operator=(const GetRoleInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleInfoReq& operator=(GetRoleInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleInfoReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleInfoReq*>(
               &_GetRoleInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    367;

  friend void swap(GetRoleInfoReq& a, GetRoleInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleInfoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleInfoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleInfoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleInfoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleInfoReq& from) {
    GetRoleInfoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleInfoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleInfoReq";
  }
  protected:
  explicit GetRoleInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
  };
  // uint64 role_id = 1;
  void clear_role_id();
  uint64_t role_id() const;
  void set_role_id(uint64_t value);
  private:
  uint64_t _internal_role_id() const;
  void _internal_set_role_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleInfoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t role_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleInfoAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleInfoAck) */ {
 public:
  inline GetRoleInfoAck() : GetRoleInfoAck(nullptr) {}
  ~GetRoleInfoAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleInfoAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleInfoAck(const GetRoleInfoAck& from);
  GetRoleInfoAck(GetRoleInfoAck&& from) noexcept
    : GetRoleInfoAck() {
    *this = ::std::move(from);
  }

  inline GetRoleInfoAck& operator=(const GetRoleInfoAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleInfoAck& operator=(GetRoleInfoAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleInfoAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleInfoAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleInfoAck*>(
               &_GetRoleInfoAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    368;

  friend void swap(GetRoleInfoAck& a, GetRoleInfoAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleInfoAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleInfoAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleInfoAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleInfoAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleInfoAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleInfoAck& from) {
    GetRoleInfoAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleInfoAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleInfoAck";
  }
  protected:
  explicit GetRoleInfoAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleInfoFieldNumber = 1,
    kOkFieldNumber = 2,
  };
  // .idlepb.RoleInfo role_info = 1;
  bool has_role_info() const;
  private:
  bool _internal_has_role_info() const;
  public:
  void clear_role_info();
  const ::idlepb::RoleInfo& role_info() const;
  PROTOBUF_NODISCARD ::idlepb::RoleInfo* release_role_info();
  ::idlepb::RoleInfo* mutable_role_info();
  void set_allocated_role_info(::idlepb::RoleInfo* role_info);
  private:
  const ::idlepb::RoleInfo& _internal_role_info() const;
  ::idlepb::RoleInfo* _internal_mutable_role_info();
  public:
  void unsafe_arena_set_allocated_role_info(
      ::idlepb::RoleInfo* role_info);
  ::idlepb::RoleInfo* unsafe_arena_release_role_info();

  // bool ok = 2;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleInfoAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleInfo* role_info_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleFriendDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetRoleFriendDataReq) */ {
 public:
  inline GetRoleFriendDataReq() : GetRoleFriendDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetRoleFriendDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleFriendDataReq(const GetRoleFriendDataReq& from);
  GetRoleFriendDataReq(GetRoleFriendDataReq&& from) noexcept
    : GetRoleFriendDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleFriendDataReq& operator=(const GetRoleFriendDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleFriendDataReq& operator=(GetRoleFriendDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleFriendDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleFriendDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleFriendDataReq*>(
               &_GetRoleFriendDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    369;

  friend void swap(GetRoleFriendDataReq& a, GetRoleFriendDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleFriendDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleFriendDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleFriendDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleFriendDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetRoleFriendDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetRoleFriendDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleFriendDataReq";
  }
  protected:
  explicit GetRoleFriendDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleFriendDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleFriendDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleFriendDataAck) */ {
 public:
  inline GetRoleFriendDataAck() : GetRoleFriendDataAck(nullptr) {}
  ~GetRoleFriendDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleFriendDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleFriendDataAck(const GetRoleFriendDataAck& from);
  GetRoleFriendDataAck(GetRoleFriendDataAck&& from) noexcept
    : GetRoleFriendDataAck() {
    *this = ::std::move(from);
  }

  inline GetRoleFriendDataAck& operator=(const GetRoleFriendDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleFriendDataAck& operator=(GetRoleFriendDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleFriendDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleFriendDataAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleFriendDataAck*>(
               &_GetRoleFriendDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    370;

  friend void swap(GetRoleFriendDataAck& a, GetRoleFriendDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleFriendDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleFriendDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleFriendDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleFriendDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleFriendDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleFriendDataAck& from) {
    GetRoleFriendDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleFriendDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleFriendDataAck";
  }
  protected:
  explicit GetRoleFriendDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleInfosFieldNumber = 11,
    kDataFieldNumber = 1,
  };
  // repeated .idlepb.SimpleRoleInfo role_infos = 11;
  int role_infos_size() const;
  private:
  int _internal_role_infos_size() const;
  public:
  void clear_role_infos();
  ::idlepb::SimpleRoleInfo* mutable_role_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo >*
      mutable_role_infos();
  private:
  const ::idlepb::SimpleRoleInfo& _internal_role_infos(int index) const;
  ::idlepb::SimpleRoleInfo* _internal_add_role_infos();
  public:
  const ::idlepb::SimpleRoleInfo& role_infos(int index) const;
  ::idlepb::SimpleRoleInfo* add_role_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo >&
      role_infos() const;

  // .idlepb.RoleFriendData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleFriendData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleFriendData* release_data();
  ::idlepb::RoleFriendData* mutable_data();
  void set_allocated_data(::idlepb::RoleFriendData* data);
  private:
  const ::idlepb::RoleFriendData& _internal_data() const;
  ::idlepb::RoleFriendData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleFriendData* data);
  ::idlepb::RoleFriendData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleFriendDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo > role_infos_;
    ::idlepb::RoleFriendData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FriendOpReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FriendOpReq) */ {
 public:
  inline FriendOpReq() : FriendOpReq(nullptr) {}
  ~FriendOpReq() override;
  explicit PROTOBUF_CONSTEXPR FriendOpReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendOpReq(const FriendOpReq& from);
  FriendOpReq(FriendOpReq&& from) noexcept
    : FriendOpReq() {
    *this = ::std::move(from);
  }

  inline FriendOpReq& operator=(const FriendOpReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendOpReq& operator=(FriendOpReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendOpReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendOpReq* internal_default_instance() {
    return reinterpret_cast<const FriendOpReq*>(
               &_FriendOpReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    371;

  friend void swap(FriendOpReq& a, FriendOpReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendOpReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendOpReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendOpReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendOpReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendOpReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendOpReq& from) {
    FriendOpReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendOpReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FriendOpReq";
  }
  protected:
  explicit FriendOpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
    kOpTypeFieldNumber = 2,
    kReverseOpFieldNumber = 3,
  };
  // int64 role_id = 1;
  void clear_role_id();
  int64_t role_id() const;
  void set_role_id(int64_t value);
  private:
  int64_t _internal_role_id() const;
  void _internal_set_role_id(int64_t value);
  public:

  // .idlepb.FriendRelationshipType op_type = 2;
  void clear_op_type();
  ::idlepb::FriendRelationshipType op_type() const;
  void set_op_type(::idlepb::FriendRelationshipType value);
  private:
  ::idlepb::FriendRelationshipType _internal_op_type() const;
  void _internal_set_op_type(::idlepb::FriendRelationshipType value);
  public:

  // bool reverse_op = 3;
  void clear_reverse_op();
  bool reverse_op() const;
  void set_reverse_op(bool value);
  private:
  bool _internal_reverse_op() const;
  void _internal_set_reverse_op(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FriendOpReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t role_id_;
    int op_type_;
    bool reverse_op_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FriendOpAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FriendOpAck) */ {
 public:
  inline FriendOpAck() : FriendOpAck(nullptr) {}
  ~FriendOpAck() override;
  explicit PROTOBUF_CONSTEXPR FriendOpAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendOpAck(const FriendOpAck& from);
  FriendOpAck(FriendOpAck&& from) noexcept
    : FriendOpAck() {
    *this = ::std::move(from);
  }

  inline FriendOpAck& operator=(const FriendOpAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendOpAck& operator=(FriendOpAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendOpAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendOpAck* internal_default_instance() {
    return reinterpret_cast<const FriendOpAck*>(
               &_FriendOpAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    372;

  friend void swap(FriendOpAck& a, FriendOpAck& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendOpAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendOpAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendOpAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendOpAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendOpAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendOpAck& from) {
    FriendOpAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendOpAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FriendOpAck";
  }
  protected:
  explicit FriendOpAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
    kRelationshipAbFieldNumber = 2,
    kRelationshipBaFieldNumber = 3,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // .idlepb.FriendRelationshipType relationship_ab = 2;
  void clear_relationship_ab();
  ::idlepb::FriendRelationshipType relationship_ab() const;
  void set_relationship_ab(::idlepb::FriendRelationshipType value);
  private:
  ::idlepb::FriendRelationshipType _internal_relationship_ab() const;
  void _internal_set_relationship_ab(::idlepb::FriendRelationshipType value);
  public:

  // .idlepb.FriendRelationshipType relationship_ba = 3;
  void clear_relationship_ba();
  ::idlepb::FriendRelationshipType relationship_ba() const;
  void set_relationship_ba(::idlepb::FriendRelationshipType value);
  private:
  ::idlepb::FriendRelationshipType _internal_relationship_ba() const;
  void _internal_set_relationship_ba(::idlepb::FriendRelationshipType value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FriendOpAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    int relationship_ab_;
    int relationship_ba_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReplyFriendRequestReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReplyFriendRequestReq) */ {
 public:
  inline ReplyFriendRequestReq() : ReplyFriendRequestReq(nullptr) {}
  ~ReplyFriendRequestReq() override;
  explicit PROTOBUF_CONSTEXPR ReplyFriendRequestReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplyFriendRequestReq(const ReplyFriendRequestReq& from);
  ReplyFriendRequestReq(ReplyFriendRequestReq&& from) noexcept
    : ReplyFriendRequestReq() {
    *this = ::std::move(from);
  }

  inline ReplyFriendRequestReq& operator=(const ReplyFriendRequestReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplyFriendRequestReq& operator=(ReplyFriendRequestReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplyFriendRequestReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplyFriendRequestReq* internal_default_instance() {
    return reinterpret_cast<const ReplyFriendRequestReq*>(
               &_ReplyFriendRequestReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    373;

  friend void swap(ReplyFriendRequestReq& a, ReplyFriendRequestReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplyFriendRequestReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplyFriendRequestReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplyFriendRequestReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplyFriendRequestReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplyFriendRequestReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplyFriendRequestReq& from) {
    ReplyFriendRequestReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplyFriendRequestReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReplyFriendRequestReq";
  }
  protected:
  explicit ReplyFriendRequestReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
    kAgreeFieldNumber = 2,
    kOneClickFieldNumber = 3,
  };
  // int64 role_id = 1;
  void clear_role_id();
  int64_t role_id() const;
  void set_role_id(int64_t value);
  private:
  int64_t _internal_role_id() const;
  void _internal_set_role_id(int64_t value);
  public:

  // bool agree = 2;
  void clear_agree();
  bool agree() const;
  void set_agree(bool value);
  private:
  bool _internal_agree() const;
  void _internal_set_agree(bool value);
  public:

  // bool one_click = 3;
  void clear_one_click();
  bool one_click() const;
  void set_one_click(bool value);
  private:
  bool _internal_one_click() const;
  void _internal_set_one_click(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReplyFriendRequestReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t role_id_;
    bool agree_;
    bool one_click_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReplyFriendRequestAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReplyFriendRequestAck) */ {
 public:
  inline ReplyFriendRequestAck() : ReplyFriendRequestAck(nullptr) {}
  ~ReplyFriendRequestAck() override;
  explicit PROTOBUF_CONSTEXPR ReplyFriendRequestAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplyFriendRequestAck(const ReplyFriendRequestAck& from);
  ReplyFriendRequestAck(ReplyFriendRequestAck&& from) noexcept
    : ReplyFriendRequestAck() {
    *this = ::std::move(from);
  }

  inline ReplyFriendRequestAck& operator=(const ReplyFriendRequestAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplyFriendRequestAck& operator=(ReplyFriendRequestAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplyFriendRequestAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplyFriendRequestAck* internal_default_instance() {
    return reinterpret_cast<const ReplyFriendRequestAck*>(
               &_ReplyFriendRequestAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    374;

  friend void swap(ReplyFriendRequestAck& a, ReplyFriendRequestAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplyFriendRequestAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplyFriendRequestAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplyFriendRequestAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplyFriendRequestAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplyFriendRequestAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplyFriendRequestAck& from) {
    ReplyFriendRequestAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplyFriendRequestAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReplyFriendRequestAck";
  }
  protected:
  explicit ReplyFriendRequestAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelationshipBaFieldNumber = 2,
    kFailedIdsFieldNumber = 3,
    kOkFieldNumber = 1,
  };
  // repeated int32 relationship_ba = 2;
  int relationship_ba_size() const;
  private:
  int _internal_relationship_ba_size() const;
  public:
  void clear_relationship_ba();
  private:
  int32_t _internal_relationship_ba(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_relationship_ba() const;
  void _internal_add_relationship_ba(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_relationship_ba();
  public:
  int32_t relationship_ba(int index) const;
  void set_relationship_ba(int index, int32_t value);
  void add_relationship_ba(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      relationship_ba() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_relationship_ba();

  // repeated int64 failed_ids = 3;
  int failed_ids_size() const;
  private:
  int _internal_failed_ids_size() const;
  public:
  void clear_failed_ids();
  private:
  int64_t _internal_failed_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_failed_ids() const;
  void _internal_add_failed_ids(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_failed_ids();
  public:
  int64_t failed_ids(int index) const;
  void set_failed_ids(int index, int64_t value);
  void add_failed_ids(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      failed_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_failed_ids();

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReplyFriendRequestAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > relationship_ba_;
    mutable std::atomic<int> _relationship_ba_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > failed_ids_;
    mutable std::atomic<int> _failed_ids_cached_byte_size_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FriendSearchRoleInfoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FriendSearchRoleInfoReq) */ {
 public:
  inline FriendSearchRoleInfoReq() : FriendSearchRoleInfoReq(nullptr) {}
  ~FriendSearchRoleInfoReq() override;
  explicit PROTOBUF_CONSTEXPR FriendSearchRoleInfoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendSearchRoleInfoReq(const FriendSearchRoleInfoReq& from);
  FriendSearchRoleInfoReq(FriendSearchRoleInfoReq&& from) noexcept
    : FriendSearchRoleInfoReq() {
    *this = ::std::move(from);
  }

  inline FriendSearchRoleInfoReq& operator=(const FriendSearchRoleInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendSearchRoleInfoReq& operator=(FriendSearchRoleInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendSearchRoleInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendSearchRoleInfoReq* internal_default_instance() {
    return reinterpret_cast<const FriendSearchRoleInfoReq*>(
               &_FriendSearchRoleInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    375;

  friend void swap(FriendSearchRoleInfoReq& a, FriendSearchRoleInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendSearchRoleInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendSearchRoleInfoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendSearchRoleInfoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendSearchRoleInfoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendSearchRoleInfoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendSearchRoleInfoReq& from) {
    FriendSearchRoleInfoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendSearchRoleInfoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FriendSearchRoleInfoReq";
  }
  protected:
  explicit FriendSearchRoleInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleNameFieldNumber = 1,
  };
  // string role_name = 1;
  void clear_role_name();
  const std::string& role_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role_name();
  PROTOBUF_NODISCARD std::string* release_role_name();
  void set_allocated_role_name(std::string* role_name);
  private:
  const std::string& _internal_role_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role_name(const std::string& value);
  std::string* _internal_mutable_role_name();
  public:

  // @@protoc_insertion_point(class_scope:idlepb.FriendSearchRoleInfoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API FriendSearchRoleInfoAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.FriendSearchRoleInfoAck) */ {
 public:
  inline FriendSearchRoleInfoAck() : FriendSearchRoleInfoAck(nullptr) {}
  ~FriendSearchRoleInfoAck() override;
  explicit PROTOBUF_CONSTEXPR FriendSearchRoleInfoAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendSearchRoleInfoAck(const FriendSearchRoleInfoAck& from);
  FriendSearchRoleInfoAck(FriendSearchRoleInfoAck&& from) noexcept
    : FriendSearchRoleInfoAck() {
    *this = ::std::move(from);
  }

  inline FriendSearchRoleInfoAck& operator=(const FriendSearchRoleInfoAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendSearchRoleInfoAck& operator=(FriendSearchRoleInfoAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendSearchRoleInfoAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendSearchRoleInfoAck* internal_default_instance() {
    return reinterpret_cast<const FriendSearchRoleInfoAck*>(
               &_FriendSearchRoleInfoAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    376;

  friend void swap(FriendSearchRoleInfoAck& a, FriendSearchRoleInfoAck& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendSearchRoleInfoAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendSearchRoleInfoAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendSearchRoleInfoAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendSearchRoleInfoAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendSearchRoleInfoAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendSearchRoleInfoAck& from) {
    FriendSearchRoleInfoAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendSearchRoleInfoAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.FriendSearchRoleInfoAck";
  }
  protected:
  explicit FriendSearchRoleInfoAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleInfosFieldNumber = 2,
  };
  // repeated .idlepb.SimpleRoleInfo role_infos = 2;
  int role_infos_size() const;
  private:
  int _internal_role_infos_size() const;
  public:
  void clear_role_infos();
  ::idlepb::SimpleRoleInfo* mutable_role_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo >*
      mutable_role_infos();
  private:
  const ::idlepb::SimpleRoleInfo& _internal_role_infos(int index) const;
  ::idlepb::SimpleRoleInfo* _internal_add_role_infos();
  public:
  const ::idlepb::SimpleRoleInfo& role_infos(int index) const;
  ::idlepb::SimpleRoleInfo* add_role_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo >&
      role_infos() const;

  // @@protoc_insertion_point(class_scope:idlepb.FriendSearchRoleInfoAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo > role_infos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyFriendMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.NotifyFriendMessage) */ {
 public:
  inline NotifyFriendMessage() : NotifyFriendMessage(nullptr) {}
  ~NotifyFriendMessage() override;
  explicit PROTOBUF_CONSTEXPR NotifyFriendMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyFriendMessage(const NotifyFriendMessage& from);
  NotifyFriendMessage(NotifyFriendMessage&& from) noexcept
    : NotifyFriendMessage() {
    *this = ::std::move(from);
  }

  inline NotifyFriendMessage& operator=(const NotifyFriendMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyFriendMessage& operator=(NotifyFriendMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyFriendMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyFriendMessage* internal_default_instance() {
    return reinterpret_cast<const NotifyFriendMessage*>(
               &_NotifyFriendMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    377;

  friend void swap(NotifyFriendMessage& a, NotifyFriendMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyFriendMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyFriendMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyFriendMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyFriendMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyFriendMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyFriendMessage& from) {
    NotifyFriendMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyFriendMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyFriendMessage";
  }
  protected:
  explicit NotifyFriendMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleInfoFieldNumber = 1,
    kFriendEventFieldNumber = 4,
    kIsUpdateStateFieldNumber = 2,
    kBRefusedFieldNumber = 3,
    kOnlineFieldNumber = 5,
  };
  // .idlepb.SimpleRoleInfo role_info = 1;
  bool has_role_info() const;
  private:
  bool _internal_has_role_info() const;
  public:
  void clear_role_info();
  const ::idlepb::SimpleRoleInfo& role_info() const;
  PROTOBUF_NODISCARD ::idlepb::SimpleRoleInfo* release_role_info();
  ::idlepb::SimpleRoleInfo* mutable_role_info();
  void set_allocated_role_info(::idlepb::SimpleRoleInfo* role_info);
  private:
  const ::idlepb::SimpleRoleInfo& _internal_role_info() const;
  ::idlepb::SimpleRoleInfo* _internal_mutable_role_info();
  public:
  void unsafe_arena_set_allocated_role_info(
      ::idlepb::SimpleRoleInfo* role_info);
  ::idlepb::SimpleRoleInfo* unsafe_arena_release_role_info();

  // .idlepb.FriendListItem friend_event = 4;
  bool has_friend_event() const;
  private:
  bool _internal_has_friend_event() const;
  public:
  void clear_friend_event();
  const ::idlepb::FriendListItem& friend_event() const;
  PROTOBUF_NODISCARD ::idlepb::FriendListItem* release_friend_event();
  ::idlepb::FriendListItem* mutable_friend_event();
  void set_allocated_friend_event(::idlepb::FriendListItem* friend_event);
  private:
  const ::idlepb::FriendListItem& _internal_friend_event() const;
  ::idlepb::FriendListItem* _internal_mutable_friend_event();
  public:
  void unsafe_arena_set_allocated_friend_event(
      ::idlepb::FriendListItem* friend_event);
  ::idlepb::FriendListItem* unsafe_arena_release_friend_event();

  // bool is_update_state = 2;
  void clear_is_update_state();
  bool is_update_state() const;
  void set_is_update_state(bool value);
  private:
  bool _internal_is_update_state() const;
  void _internal_set_is_update_state(bool value);
  public:

  // bool b_refused = 3;
  void clear_b_refused();
  bool b_refused() const;
  void set_b_refused(bool value);
  private:
  bool _internal_b_refused() const;
  void _internal_set_b_refused(bool value);
  public:

  // bool online = 5;
  void clear_online();
  bool online() const;
  void set_online(bool value);
  private:
  bool _internal_online() const;
  void _internal_set_online(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.NotifyFriendMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::SimpleRoleInfo* role_info_;
    ::idlepb::FriendListItem* friend_event_;
    bool is_update_state_;
    bool b_refused_;
    bool online_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleAvatarDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleAvatarDataReq) */ {
 public:
  inline GetRoleAvatarDataReq() : GetRoleAvatarDataReq(nullptr) {}
  ~GetRoleAvatarDataReq() override;
  explicit PROTOBUF_CONSTEXPR GetRoleAvatarDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleAvatarDataReq(const GetRoleAvatarDataReq& from);
  GetRoleAvatarDataReq(GetRoleAvatarDataReq&& from) noexcept
    : GetRoleAvatarDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleAvatarDataReq& operator=(const GetRoleAvatarDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleAvatarDataReq& operator=(GetRoleAvatarDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleAvatarDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleAvatarDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleAvatarDataReq*>(
               &_GetRoleAvatarDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    378;

  friend void swap(GetRoleAvatarDataReq& a, GetRoleAvatarDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleAvatarDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleAvatarDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleAvatarDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleAvatarDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleAvatarDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleAvatarDataReq& from) {
    GetRoleAvatarDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleAvatarDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleAvatarDataReq";
  }
  protected:
  explicit GetRoleAvatarDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawThisTimeFieldNumber = 1,
  };
  // bool draw_this_time = 1;
  void clear_draw_this_time();
  bool draw_this_time() const;
  void set_draw_this_time(bool value);
  private:
  bool _internal_draw_this_time() const;
  void _internal_set_draw_this_time(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleAvatarDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool draw_this_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleAvatarDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleAvatarDataAck) */ {
 public:
  inline GetRoleAvatarDataAck() : GetRoleAvatarDataAck(nullptr) {}
  ~GetRoleAvatarDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleAvatarDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleAvatarDataAck(const GetRoleAvatarDataAck& from);
  GetRoleAvatarDataAck(GetRoleAvatarDataAck&& from) noexcept
    : GetRoleAvatarDataAck() {
    *this = ::std::move(from);
  }

  inline GetRoleAvatarDataAck& operator=(const GetRoleAvatarDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleAvatarDataAck& operator=(GetRoleAvatarDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleAvatarDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleAvatarDataAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleAvatarDataAck*>(
               &_GetRoleAvatarDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    379;

  friend void swap(GetRoleAvatarDataAck& a, GetRoleAvatarDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleAvatarDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleAvatarDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleAvatarDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleAvatarDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleAvatarDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleAvatarDataAck& from) {
    GetRoleAvatarDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleAvatarDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleAvatarDataAck";
  }
  protected:
  explicit GetRoleAvatarDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleAvatarData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleAvatarData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleAvatarData* release_data();
  ::idlepb::RoleAvatarData* mutable_data();
  void set_allocated_data(::idlepb::RoleAvatarData* data);
  private:
  const ::idlepb::RoleAvatarData& _internal_data() const;
  ::idlepb::RoleAvatarData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleAvatarData* data);
  ::idlepb::RoleAvatarData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleAvatarDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleAvatarData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DispatchAvatarReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DispatchAvatarReq) */ {
 public:
  inline DispatchAvatarReq() : DispatchAvatarReq(nullptr) {}
  ~DispatchAvatarReq() override;
  explicit PROTOBUF_CONSTEXPR DispatchAvatarReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DispatchAvatarReq(const DispatchAvatarReq& from);
  DispatchAvatarReq(DispatchAvatarReq&& from) noexcept
    : DispatchAvatarReq() {
    *this = ::std::move(from);
  }

  inline DispatchAvatarReq& operator=(const DispatchAvatarReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DispatchAvatarReq& operator=(DispatchAvatarReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DispatchAvatarReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DispatchAvatarReq* internal_default_instance() {
    return reinterpret_cast<const DispatchAvatarReq*>(
               &_DispatchAvatarReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    380;

  friend void swap(DispatchAvatarReq& a, DispatchAvatarReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DispatchAvatarReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DispatchAvatarReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DispatchAvatarReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DispatchAvatarReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DispatchAvatarReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DispatchAvatarReq& from) {
    DispatchAvatarReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DispatchAvatarReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DispatchAvatarReq";
  }
  protected:
  explicit DispatchAvatarReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldIndexFieldNumber = 1,
  };
  // int32 world_index = 1;
  void clear_world_index();
  int32_t world_index() const;
  void set_world_index(int32_t value);
  private:
  int32_t _internal_world_index() const;
  void _internal_set_world_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.DispatchAvatarReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t world_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API DispatchAvatarAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.DispatchAvatarAck) */ {
 public:
  inline DispatchAvatarAck() : DispatchAvatarAck(nullptr) {}
  ~DispatchAvatarAck() override;
  explicit PROTOBUF_CONSTEXPR DispatchAvatarAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DispatchAvatarAck(const DispatchAvatarAck& from);
  DispatchAvatarAck(DispatchAvatarAck&& from) noexcept
    : DispatchAvatarAck() {
    *this = ::std::move(from);
  }

  inline DispatchAvatarAck& operator=(const DispatchAvatarAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline DispatchAvatarAck& operator=(DispatchAvatarAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DispatchAvatarAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const DispatchAvatarAck* internal_default_instance() {
    return reinterpret_cast<const DispatchAvatarAck*>(
               &_DispatchAvatarAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    381;

  friend void swap(DispatchAvatarAck& a, DispatchAvatarAck& b) {
    a.Swap(&b);
  }
  inline void Swap(DispatchAvatarAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DispatchAvatarAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DispatchAvatarAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DispatchAvatarAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DispatchAvatarAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DispatchAvatarAck& from) {
    DispatchAvatarAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DispatchAvatarAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.DispatchAvatarAck";
  }
  protected:
  explicit DispatchAvatarAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleAvatarData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleAvatarData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleAvatarData* release_data();
  ::idlepb::RoleAvatarData* mutable_data();
  void set_allocated_data(::idlepb::RoleAvatarData* data);
  private:
  const ::idlepb::RoleAvatarData& _internal_data() const;
  ::idlepb::RoleAvatarData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleAvatarData* data);
  ::idlepb::RoleAvatarData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.DispatchAvatarAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleAvatarData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AvatarRankUpReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.AvatarRankUpReq) */ {
 public:
  inline AvatarRankUpReq() : AvatarRankUpReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AvatarRankUpReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvatarRankUpReq(const AvatarRankUpReq& from);
  AvatarRankUpReq(AvatarRankUpReq&& from) noexcept
    : AvatarRankUpReq() {
    *this = ::std::move(from);
  }

  inline AvatarRankUpReq& operator=(const AvatarRankUpReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvatarRankUpReq& operator=(AvatarRankUpReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvatarRankUpReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvatarRankUpReq* internal_default_instance() {
    return reinterpret_cast<const AvatarRankUpReq*>(
               &_AvatarRankUpReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    382;

  friend void swap(AvatarRankUpReq& a, AvatarRankUpReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AvatarRankUpReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvatarRankUpReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvatarRankUpReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvatarRankUpReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AvatarRankUpReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AvatarRankUpReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AvatarRankUpReq";
  }
  protected:
  explicit AvatarRankUpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.AvatarRankUpReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AvatarRankUpAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AvatarRankUpAck) */ {
 public:
  inline AvatarRankUpAck() : AvatarRankUpAck(nullptr) {}
  ~AvatarRankUpAck() override;
  explicit PROTOBUF_CONSTEXPR AvatarRankUpAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvatarRankUpAck(const AvatarRankUpAck& from);
  AvatarRankUpAck(AvatarRankUpAck&& from) noexcept
    : AvatarRankUpAck() {
    *this = ::std::move(from);
  }

  inline AvatarRankUpAck& operator=(const AvatarRankUpAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvatarRankUpAck& operator=(AvatarRankUpAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvatarRankUpAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvatarRankUpAck* internal_default_instance() {
    return reinterpret_cast<const AvatarRankUpAck*>(
               &_AvatarRankUpAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    383;

  friend void swap(AvatarRankUpAck& a, AvatarRankUpAck& b) {
    a.Swap(&b);
  }
  inline void Swap(AvatarRankUpAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvatarRankUpAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvatarRankUpAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvatarRankUpAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvatarRankUpAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AvatarRankUpAck& from) {
    AvatarRankUpAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvatarRankUpAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AvatarRankUpAck";
  }
  protected:
  explicit AvatarRankUpAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleAvatarData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleAvatarData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleAvatarData* release_data();
  ::idlepb::RoleAvatarData* mutable_data();
  void set_allocated_data(::idlepb::RoleAvatarData* data);
  private:
  const ::idlepb::RoleAvatarData& _internal_data() const;
  ::idlepb::RoleAvatarData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleAvatarData* data);
  ::idlepb::RoleAvatarData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.AvatarRankUpAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleAvatarData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReceiveAvatarTempPackageReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.ReceiveAvatarTempPackageReq) */ {
 public:
  inline ReceiveAvatarTempPackageReq() : ReceiveAvatarTempPackageReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReceiveAvatarTempPackageReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveAvatarTempPackageReq(const ReceiveAvatarTempPackageReq& from);
  ReceiveAvatarTempPackageReq(ReceiveAvatarTempPackageReq&& from) noexcept
    : ReceiveAvatarTempPackageReq() {
    *this = ::std::move(from);
  }

  inline ReceiveAvatarTempPackageReq& operator=(const ReceiveAvatarTempPackageReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveAvatarTempPackageReq& operator=(ReceiveAvatarTempPackageReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveAvatarTempPackageReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveAvatarTempPackageReq* internal_default_instance() {
    return reinterpret_cast<const ReceiveAvatarTempPackageReq*>(
               &_ReceiveAvatarTempPackageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    384;

  friend void swap(ReceiveAvatarTempPackageReq& a, ReceiveAvatarTempPackageReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveAvatarTempPackageReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveAvatarTempPackageReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveAvatarTempPackageReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveAvatarTempPackageReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReceiveAvatarTempPackageReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReceiveAvatarTempPackageReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReceiveAvatarTempPackageReq";
  }
  protected:
  explicit ReceiveAvatarTempPackageReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.ReceiveAvatarTempPackageReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReceiveAvatarTempPackageAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReceiveAvatarTempPackageAck) */ {
 public:
  inline ReceiveAvatarTempPackageAck() : ReceiveAvatarTempPackageAck(nullptr) {}
  ~ReceiveAvatarTempPackageAck() override;
  explicit PROTOBUF_CONSTEXPR ReceiveAvatarTempPackageAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveAvatarTempPackageAck(const ReceiveAvatarTempPackageAck& from);
  ReceiveAvatarTempPackageAck(ReceiveAvatarTempPackageAck&& from) noexcept
    : ReceiveAvatarTempPackageAck() {
    *this = ::std::move(from);
  }

  inline ReceiveAvatarTempPackageAck& operator=(const ReceiveAvatarTempPackageAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveAvatarTempPackageAck& operator=(ReceiveAvatarTempPackageAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveAvatarTempPackageAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveAvatarTempPackageAck* internal_default_instance() {
    return reinterpret_cast<const ReceiveAvatarTempPackageAck*>(
               &_ReceiveAvatarTempPackageAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    385;

  friend void swap(ReceiveAvatarTempPackageAck& a, ReceiveAvatarTempPackageAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveAvatarTempPackageAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveAvatarTempPackageAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveAvatarTempPackageAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveAvatarTempPackageAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveAvatarTempPackageAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiveAvatarTempPackageAck& from) {
    ReceiveAvatarTempPackageAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveAvatarTempPackageAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReceiveAvatarTempPackageAck";
  }
  protected:
  explicit ReceiveAvatarTempPackageAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleAvatarData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleAvatarData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleAvatarData* release_data();
  ::idlepb::RoleAvatarData* mutable_data();
  void set_allocated_data(::idlepb::RoleAvatarData* data);
  private:
  const ::idlepb::RoleAvatarData& _internal_data() const;
  ::idlepb::RoleAvatarData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleAvatarData* data);
  ::idlepb::RoleAvatarData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.ReceiveAvatarTempPackageAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleAvatarData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleBiographyDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetRoleBiographyDataReq) */ {
 public:
  inline GetRoleBiographyDataReq() : GetRoleBiographyDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetRoleBiographyDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleBiographyDataReq(const GetRoleBiographyDataReq& from);
  GetRoleBiographyDataReq(GetRoleBiographyDataReq&& from) noexcept
    : GetRoleBiographyDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleBiographyDataReq& operator=(const GetRoleBiographyDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleBiographyDataReq& operator=(GetRoleBiographyDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleBiographyDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleBiographyDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleBiographyDataReq*>(
               &_GetRoleBiographyDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    386;

  friend void swap(GetRoleBiographyDataReq& a, GetRoleBiographyDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleBiographyDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleBiographyDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleBiographyDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleBiographyDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetRoleBiographyDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetRoleBiographyDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleBiographyDataReq";
  }
  protected:
  explicit GetRoleBiographyDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleBiographyDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleBiographyDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleBiographyDataAck) */ {
 public:
  inline GetRoleBiographyDataAck() : GetRoleBiographyDataAck(nullptr) {}
  ~GetRoleBiographyDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleBiographyDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleBiographyDataAck(const GetRoleBiographyDataAck& from);
  GetRoleBiographyDataAck(GetRoleBiographyDataAck&& from) noexcept
    : GetRoleBiographyDataAck() {
    *this = ::std::move(from);
  }

  inline GetRoleBiographyDataAck& operator=(const GetRoleBiographyDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleBiographyDataAck& operator=(GetRoleBiographyDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleBiographyDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleBiographyDataAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleBiographyDataAck*>(
               &_GetRoleBiographyDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    387;

  friend void swap(GetRoleBiographyDataAck& a, GetRoleBiographyDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleBiographyDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleBiographyDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleBiographyDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleBiographyDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleBiographyDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleBiographyDataAck& from) {
    GetRoleBiographyDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleBiographyDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleBiographyDataAck";
  }
  protected:
  explicit GetRoleBiographyDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleBiographyData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleBiographyData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleBiographyData* release_data();
  ::idlepb::RoleBiographyData* mutable_data();
  void set_allocated_data(::idlepb::RoleBiographyData* data);
  private:
  const ::idlepb::RoleBiographyData& _internal_data() const;
  ::idlepb::RoleBiographyData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleBiographyData* data);
  ::idlepb::RoleBiographyData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleBiographyDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleBiographyData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReceiveBiographyItemReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReceiveBiographyItemReq) */ {
 public:
  inline ReceiveBiographyItemReq() : ReceiveBiographyItemReq(nullptr) {}
  ~ReceiveBiographyItemReq() override;
  explicit PROTOBUF_CONSTEXPR ReceiveBiographyItemReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveBiographyItemReq(const ReceiveBiographyItemReq& from);
  ReceiveBiographyItemReq(ReceiveBiographyItemReq&& from) noexcept
    : ReceiveBiographyItemReq() {
    *this = ::std::move(from);
  }

  inline ReceiveBiographyItemReq& operator=(const ReceiveBiographyItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveBiographyItemReq& operator=(ReceiveBiographyItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveBiographyItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveBiographyItemReq* internal_default_instance() {
    return reinterpret_cast<const ReceiveBiographyItemReq*>(
               &_ReceiveBiographyItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    388;

  friend void swap(ReceiveBiographyItemReq& a, ReceiveBiographyItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveBiographyItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveBiographyItemReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveBiographyItemReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveBiographyItemReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveBiographyItemReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiveBiographyItemReq& from) {
    ReceiveBiographyItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveBiographyItemReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReceiveBiographyItemReq";
  }
  protected:
  explicit ReceiveBiographyItemReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCfgIdsFieldNumber = 1,
  };
  // repeated int32 cfg_ids = 1;
  int cfg_ids_size() const;
  private:
  int _internal_cfg_ids_size() const;
  public:
  void clear_cfg_ids();
  private:
  int32_t _internal_cfg_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_cfg_ids() const;
  void _internal_add_cfg_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_cfg_ids();
  public:
  int32_t cfg_ids(int index) const;
  void set_cfg_ids(int index, int32_t value);
  void add_cfg_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      cfg_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_cfg_ids();

  // @@protoc_insertion_point(class_scope:idlepb.ReceiveBiographyItemReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > cfg_ids_;
    mutable std::atomic<int> _cfg_ids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReceiveBiographyItemAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReceiveBiographyItemAck) */ {
 public:
  inline ReceiveBiographyItemAck() : ReceiveBiographyItemAck(nullptr) {}
  ~ReceiveBiographyItemAck() override;
  explicit PROTOBUF_CONSTEXPR ReceiveBiographyItemAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveBiographyItemAck(const ReceiveBiographyItemAck& from);
  ReceiveBiographyItemAck(ReceiveBiographyItemAck&& from) noexcept
    : ReceiveBiographyItemAck() {
    *this = ::std::move(from);
  }

  inline ReceiveBiographyItemAck& operator=(const ReceiveBiographyItemAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveBiographyItemAck& operator=(ReceiveBiographyItemAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveBiographyItemAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveBiographyItemAck* internal_default_instance() {
    return reinterpret_cast<const ReceiveBiographyItemAck*>(
               &_ReceiveBiographyItemAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    389;

  friend void swap(ReceiveBiographyItemAck& a, ReceiveBiographyItemAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveBiographyItemAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveBiographyItemAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveBiographyItemAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveBiographyItemAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveBiographyItemAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiveBiographyItemAck& from) {
    ReceiveBiographyItemAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveBiographyItemAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReceiveBiographyItemAck";
  }
  protected:
  explicit ReceiveBiographyItemAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReceiveBiographyItemAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API NotifyBiographyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.NotifyBiographyMessage) */ {
 public:
  inline NotifyBiographyMessage() : NotifyBiographyMessage(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NotifyBiographyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyBiographyMessage(const NotifyBiographyMessage& from);
  NotifyBiographyMessage(NotifyBiographyMessage&& from) noexcept
    : NotifyBiographyMessage() {
    *this = ::std::move(from);
  }

  inline NotifyBiographyMessage& operator=(const NotifyBiographyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyBiographyMessage& operator=(NotifyBiographyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyBiographyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyBiographyMessage* internal_default_instance() {
    return reinterpret_cast<const NotifyBiographyMessage*>(
               &_NotifyBiographyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    390;

  friend void swap(NotifyBiographyMessage& a, NotifyBiographyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyBiographyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyBiographyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyBiographyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyBiographyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NotifyBiographyMessage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NotifyBiographyMessage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.NotifyBiographyMessage";
  }
  protected:
  explicit NotifyBiographyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.NotifyBiographyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetBiographyEventDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetBiographyEventDataReq) */ {
 public:
  inline GetBiographyEventDataReq() : GetBiographyEventDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetBiographyEventDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBiographyEventDataReq(const GetBiographyEventDataReq& from);
  GetBiographyEventDataReq(GetBiographyEventDataReq&& from) noexcept
    : GetBiographyEventDataReq() {
    *this = ::std::move(from);
  }

  inline GetBiographyEventDataReq& operator=(const GetBiographyEventDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBiographyEventDataReq& operator=(GetBiographyEventDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBiographyEventDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBiographyEventDataReq* internal_default_instance() {
    return reinterpret_cast<const GetBiographyEventDataReq*>(
               &_GetBiographyEventDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    391;

  friend void swap(GetBiographyEventDataReq& a, GetBiographyEventDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBiographyEventDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBiographyEventDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBiographyEventDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBiographyEventDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetBiographyEventDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetBiographyEventDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetBiographyEventDataReq";
  }
  protected:
  explicit GetBiographyEventDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetBiographyEventDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetBiographyEventDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetBiographyEventDataAck) */ {
 public:
  inline GetBiographyEventDataAck() : GetBiographyEventDataAck(nullptr) {}
  ~GetBiographyEventDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetBiographyEventDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBiographyEventDataAck(const GetBiographyEventDataAck& from);
  GetBiographyEventDataAck(GetBiographyEventDataAck&& from) noexcept
    : GetBiographyEventDataAck() {
    *this = ::std::move(from);
  }

  inline GetBiographyEventDataAck& operator=(const GetBiographyEventDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBiographyEventDataAck& operator=(GetBiographyEventDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBiographyEventDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBiographyEventDataAck* internal_default_instance() {
    return reinterpret_cast<const GetBiographyEventDataAck*>(
               &_GetBiographyEventDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    392;

  friend void swap(GetBiographyEventDataAck& a, GetBiographyEventDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBiographyEventDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBiographyEventDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBiographyEventDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBiographyEventDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBiographyEventDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBiographyEventDataAck& from) {
    GetBiographyEventDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBiographyEventDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetBiographyEventDataAck";
  }
  protected:
  explicit GetBiographyEventDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBiographyListsFieldNumber = 1,
    kServerCounterDataFieldNumber = 2,
  };
  // repeated .idlepb.BiographyEventLeaderboardList biography_lists = 1;
  int biography_lists_size() const;
  private:
  int _internal_biography_lists_size() const;
  public:
  void clear_biography_lists();
  ::idlepb::BiographyEventLeaderboardList* mutable_biography_lists(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::BiographyEventLeaderboardList >*
      mutable_biography_lists();
  private:
  const ::idlepb::BiographyEventLeaderboardList& _internal_biography_lists(int index) const;
  ::idlepb::BiographyEventLeaderboardList* _internal_add_biography_lists();
  public:
  const ::idlepb::BiographyEventLeaderboardList& biography_lists(int index) const;
  ::idlepb::BiographyEventLeaderboardList* add_biography_lists();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::BiographyEventLeaderboardList >&
      biography_lists() const;

  // .idlepb.ServerCounterData server_counter_data = 2;
  bool has_server_counter_data() const;
  private:
  bool _internal_has_server_counter_data() const;
  public:
  void clear_server_counter_data();
  const ::idlepb::ServerCounterData& server_counter_data() const;
  PROTOBUF_NODISCARD ::idlepb::ServerCounterData* release_server_counter_data();
  ::idlepb::ServerCounterData* mutable_server_counter_data();
  void set_allocated_server_counter_data(::idlepb::ServerCounterData* server_counter_data);
  private:
  const ::idlepb::ServerCounterData& _internal_server_counter_data() const;
  ::idlepb::ServerCounterData* _internal_mutable_server_counter_data();
  public:
  void unsafe_arena_set_allocated_server_counter_data(
      ::idlepb::ServerCounterData* server_counter_data);
  ::idlepb::ServerCounterData* unsafe_arena_release_server_counter_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetBiographyEventDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::BiographyEventLeaderboardList > biography_lists_;
    ::idlepb::ServerCounterData* server_counter_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReceiveBiographyEventItemReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReceiveBiographyEventItemReq) */ {
 public:
  inline ReceiveBiographyEventItemReq() : ReceiveBiographyEventItemReq(nullptr) {}
  ~ReceiveBiographyEventItemReq() override;
  explicit PROTOBUF_CONSTEXPR ReceiveBiographyEventItemReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveBiographyEventItemReq(const ReceiveBiographyEventItemReq& from);
  ReceiveBiographyEventItemReq(ReceiveBiographyEventItemReq&& from) noexcept
    : ReceiveBiographyEventItemReq() {
    *this = ::std::move(from);
  }

  inline ReceiveBiographyEventItemReq& operator=(const ReceiveBiographyEventItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveBiographyEventItemReq& operator=(ReceiveBiographyEventItemReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveBiographyEventItemReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveBiographyEventItemReq* internal_default_instance() {
    return reinterpret_cast<const ReceiveBiographyEventItemReq*>(
               &_ReceiveBiographyEventItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    393;

  friend void swap(ReceiveBiographyEventItemReq& a, ReceiveBiographyEventItemReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveBiographyEventItemReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveBiographyEventItemReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveBiographyEventItemReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveBiographyEventItemReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveBiographyEventItemReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiveBiographyEventItemReq& from) {
    ReceiveBiographyEventItemReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveBiographyEventItemReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReceiveBiographyEventItemReq";
  }
  protected:
  explicit ReceiveBiographyEventItemReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCfgIdFieldNumber = 1,
  };
  // int32 cfg_id = 1;
  void clear_cfg_id();
  int32_t cfg_id() const;
  void set_cfg_id(int32_t value);
  private:
  int32_t _internal_cfg_id() const;
  void _internal_set_cfg_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.ReceiveBiographyEventItemReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t cfg_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API ReceiveBiographyEventItemAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.ReceiveBiographyEventItemAck) */ {
 public:
  inline ReceiveBiographyEventItemAck() : ReceiveBiographyEventItemAck(nullptr) {}
  ~ReceiveBiographyEventItemAck() override;
  explicit PROTOBUF_CONSTEXPR ReceiveBiographyEventItemAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveBiographyEventItemAck(const ReceiveBiographyEventItemAck& from);
  ReceiveBiographyEventItemAck(ReceiveBiographyEventItemAck&& from) noexcept
    : ReceiveBiographyEventItemAck() {
    *this = ::std::move(from);
  }

  inline ReceiveBiographyEventItemAck& operator=(const ReceiveBiographyEventItemAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveBiographyEventItemAck& operator=(ReceiveBiographyEventItemAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveBiographyEventItemAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveBiographyEventItemAck* internal_default_instance() {
    return reinterpret_cast<const ReceiveBiographyEventItemAck*>(
               &_ReceiveBiographyEventItemAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    394;

  friend void swap(ReceiveBiographyEventItemAck& a, ReceiveBiographyEventItemAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveBiographyEventItemAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveBiographyEventItemAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveBiographyEventItemAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveBiographyEventItemAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveBiographyEventItemAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiveBiographyEventItemAck& from) {
    ReceiveBiographyEventItemAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveBiographyEventItemAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.ReceiveBiographyEventItemAck";
  }
  protected:
  explicit ReceiveBiographyEventItemAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .idlepb.SimpleItemData items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::idlepb::SimpleItemData* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
      mutable_items();
  private:
  const ::idlepb::SimpleItemData& _internal_items(int index) const;
  ::idlepb::SimpleItemData* _internal_add_items();
  public:
  const ::idlepb::SimpleItemData& items(int index) const;
  ::idlepb::SimpleItemData* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
      items() const;

  // @@protoc_insertion_point(class_scope:idlepb.ReceiveBiographyEventItemAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AddBiographyRoleLogReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AddBiographyRoleLogReq) */ {
 public:
  inline AddBiographyRoleLogReq() : AddBiographyRoleLogReq(nullptr) {}
  ~AddBiographyRoleLogReq() override;
  explicit PROTOBUF_CONSTEXPR AddBiographyRoleLogReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddBiographyRoleLogReq(const AddBiographyRoleLogReq& from);
  AddBiographyRoleLogReq(AddBiographyRoleLogReq&& from) noexcept
    : AddBiographyRoleLogReq() {
    *this = ::std::move(from);
  }

  inline AddBiographyRoleLogReq& operator=(const AddBiographyRoleLogReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddBiographyRoleLogReq& operator=(AddBiographyRoleLogReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddBiographyRoleLogReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddBiographyRoleLogReq* internal_default_instance() {
    return reinterpret_cast<const AddBiographyRoleLogReq*>(
               &_AddBiographyRoleLogReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    395;

  friend void swap(AddBiographyRoleLogReq& a, AddBiographyRoleLogReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AddBiographyRoleLogReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddBiographyRoleLogReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddBiographyRoleLogReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddBiographyRoleLogReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddBiographyRoleLogReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddBiographyRoleLogReq& from) {
    AddBiographyRoleLogReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddBiographyRoleLogReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AddBiographyRoleLogReq";
  }
  protected:
  explicit AddBiographyRoleLogReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogFieldNumber = 1,
  };
  // .idlepb.BiographyRoleLog log = 1;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const ::idlepb::BiographyRoleLog& log() const;
  PROTOBUF_NODISCARD ::idlepb::BiographyRoleLog* release_log();
  ::idlepb::BiographyRoleLog* mutable_log();
  void set_allocated_log(::idlepb::BiographyRoleLog* log);
  private:
  const ::idlepb::BiographyRoleLog& _internal_log() const;
  ::idlepb::BiographyRoleLog* _internal_mutable_log();
  public:
  void unsafe_arena_set_allocated_log(
      ::idlepb::BiographyRoleLog* log);
  ::idlepb::BiographyRoleLog* unsafe_arena_release_log();

  // @@protoc_insertion_point(class_scope:idlepb.AddBiographyRoleLogReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::BiographyRoleLog* log_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API AddBiographyRoleLogAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.AddBiographyRoleLogAck) */ {
 public:
  inline AddBiographyRoleLogAck() : AddBiographyRoleLogAck(nullptr) {}
  ~AddBiographyRoleLogAck() override;
  explicit PROTOBUF_CONSTEXPR AddBiographyRoleLogAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddBiographyRoleLogAck(const AddBiographyRoleLogAck& from);
  AddBiographyRoleLogAck(AddBiographyRoleLogAck&& from) noexcept
    : AddBiographyRoleLogAck() {
    *this = ::std::move(from);
  }

  inline AddBiographyRoleLogAck& operator=(const AddBiographyRoleLogAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddBiographyRoleLogAck& operator=(AddBiographyRoleLogAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddBiographyRoleLogAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddBiographyRoleLogAck* internal_default_instance() {
    return reinterpret_cast<const AddBiographyRoleLogAck*>(
               &_AddBiographyRoleLogAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    396;

  friend void swap(AddBiographyRoleLogAck& a, AddBiographyRoleLogAck& b) {
    a.Swap(&b);
  }
  inline void Swap(AddBiographyRoleLogAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddBiographyRoleLogAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddBiographyRoleLogAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddBiographyRoleLogAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddBiographyRoleLogAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddBiographyRoleLogAck& from) {
    AddBiographyRoleLogAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddBiographyRoleLogAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.AddBiographyRoleLogAck";
  }
  protected:
  explicit AddBiographyRoleLogAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogFieldNumber = 1,
  };
  // .idlepb.BiographyRoleLog log = 1;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const ::idlepb::BiographyRoleLog& log() const;
  PROTOBUF_NODISCARD ::idlepb::BiographyRoleLog* release_log();
  ::idlepb::BiographyRoleLog* mutable_log();
  void set_allocated_log(::idlepb::BiographyRoleLog* log);
  private:
  const ::idlepb::BiographyRoleLog& _internal_log() const;
  ::idlepb::BiographyRoleLog* _internal_mutable_log();
  public:
  void unsafe_arena_set_allocated_log(
      ::idlepb::BiographyRoleLog* log);
  ::idlepb::BiographyRoleLog* unsafe_arena_release_log();

  // @@protoc_insertion_point(class_scope:idlepb.AddBiographyRoleLogAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::BiographyRoleLog* log_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleVipShopDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:idlepb.GetRoleVipShopDataReq) */ {
 public:
  inline GetRoleVipShopDataReq() : GetRoleVipShopDataReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetRoleVipShopDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleVipShopDataReq(const GetRoleVipShopDataReq& from);
  GetRoleVipShopDataReq(GetRoleVipShopDataReq&& from) noexcept
    : GetRoleVipShopDataReq() {
    *this = ::std::move(from);
  }

  inline GetRoleVipShopDataReq& operator=(const GetRoleVipShopDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleVipShopDataReq& operator=(GetRoleVipShopDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleVipShopDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleVipShopDataReq* internal_default_instance() {
    return reinterpret_cast<const GetRoleVipShopDataReq*>(
               &_GetRoleVipShopDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    397;

  friend void swap(GetRoleVipShopDataReq& a, GetRoleVipShopDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleVipShopDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleVipShopDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleVipShopDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleVipShopDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetRoleVipShopDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetRoleVipShopDataReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleVipShopDataReq";
  }
  protected:
  explicit GetRoleVipShopDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleVipShopDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API GetRoleVipShopDataAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.GetRoleVipShopDataAck) */ {
 public:
  inline GetRoleVipShopDataAck() : GetRoleVipShopDataAck(nullptr) {}
  ~GetRoleVipShopDataAck() override;
  explicit PROTOBUF_CONSTEXPR GetRoleVipShopDataAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoleVipShopDataAck(const GetRoleVipShopDataAck& from);
  GetRoleVipShopDataAck(GetRoleVipShopDataAck&& from) noexcept
    : GetRoleVipShopDataAck() {
    *this = ::std::move(from);
  }

  inline GetRoleVipShopDataAck& operator=(const GetRoleVipShopDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoleVipShopDataAck& operator=(GetRoleVipShopDataAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoleVipShopDataAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoleVipShopDataAck* internal_default_instance() {
    return reinterpret_cast<const GetRoleVipShopDataAck*>(
               &_GetRoleVipShopDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    398;

  friend void swap(GetRoleVipShopDataAck& a, GetRoleVipShopDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoleVipShopDataAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoleVipShopDataAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoleVipShopDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoleVipShopDataAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoleVipShopDataAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRoleVipShopDataAck& from) {
    GetRoleVipShopDataAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoleVipShopDataAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.GetRoleVipShopDataAck";
  }
  protected:
  explicit GetRoleVipShopDataAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .idlepb.RoleVipShopData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::idlepb::RoleVipShopData& data() const;
  PROTOBUF_NODISCARD ::idlepb::RoleVipShopData* release_data();
  ::idlepb::RoleVipShopData* mutable_data();
  void set_allocated_data(::idlepb::RoleVipShopData* data);
  private:
  const ::idlepb::RoleVipShopData& _internal_data() const;
  ::idlepb::RoleVipShopData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::idlepb::RoleVipShopData* data);
  ::idlepb::RoleVipShopData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:idlepb.GetRoleVipShopDataAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::idlepb::RoleVipShopData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API VipShopBuyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.VipShopBuyReq) */ {
 public:
  inline VipShopBuyReq() : VipShopBuyReq(nullptr) {}
  ~VipShopBuyReq() override;
  explicit PROTOBUF_CONSTEXPR VipShopBuyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VipShopBuyReq(const VipShopBuyReq& from);
  VipShopBuyReq(VipShopBuyReq&& from) noexcept
    : VipShopBuyReq() {
    *this = ::std::move(from);
  }

  inline VipShopBuyReq& operator=(const VipShopBuyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline VipShopBuyReq& operator=(VipShopBuyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VipShopBuyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const VipShopBuyReq* internal_default_instance() {
    return reinterpret_cast<const VipShopBuyReq*>(
               &_VipShopBuyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    399;

  friend void swap(VipShopBuyReq& a, VipShopBuyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(VipShopBuyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VipShopBuyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VipShopBuyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VipShopBuyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VipShopBuyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VipShopBuyReq& from) {
    VipShopBuyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VipShopBuyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.VipShopBuyReq";
  }
  protected:
  explicit VipShopBuyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kNumFieldNumber = 2,
  };
  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // int32 num = 2;
  void clear_num();
  int32_t num() const;
  void set_num(int32_t value);
  private:
  int32_t _internal_num() const;
  void _internal_set_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.VipShopBuyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t index_;
    int32_t num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MPROTOCOL_API VipShopBuyAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:idlepb.VipShopBuyAck) */ {
 public:
  inline VipShopBuyAck() : VipShopBuyAck(nullptr) {}
  ~VipShopBuyAck() override;
  explicit PROTOBUF_CONSTEXPR VipShopBuyAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VipShopBuyAck(const VipShopBuyAck& from);
  VipShopBuyAck(VipShopBuyAck&& from) noexcept
    : VipShopBuyAck() {
    *this = ::std::move(from);
  }

  inline VipShopBuyAck& operator=(const VipShopBuyAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline VipShopBuyAck& operator=(VipShopBuyAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VipShopBuyAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const VipShopBuyAck* internal_default_instance() {
    return reinterpret_cast<const VipShopBuyAck*>(
               &_VipShopBuyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    400;

  friend void swap(VipShopBuyAck& a, VipShopBuyAck& b) {
    a.Swap(&b);
  }
  inline void Swap(VipShopBuyAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VipShopBuyAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VipShopBuyAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VipShopBuyAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VipShopBuyAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VipShopBuyAck& from) {
    VipShopBuyAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VipShopBuyAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "idlepb.VipShopBuyAck";
  }
  protected:
  explicit VipShopBuyAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:idlepb.VipShopBuyAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Ping

// int64 req_ticks = 1;
inline void Ping::clear_req_ticks() {
  _impl_.req_ticks_ = int64_t{0};
}
inline int64_t Ping::_internal_req_ticks() const {
  return _impl_.req_ticks_;
}
inline int64_t Ping::req_ticks() const {
  // @@protoc_insertion_point(field_get:idlepb.Ping.req_ticks)
  return _internal_req_ticks();
}
inline void Ping::_internal_set_req_ticks(int64_t value) {
  
  _impl_.req_ticks_ = value;
}
inline void Ping::set_req_ticks(int64_t value) {
  _internal_set_req_ticks(value);
  // @@protoc_insertion_point(field_set:idlepb.Ping.req_ticks)
}

// -------------------------------------------------------------------

// Pong

// int64 req_ticks = 1;
inline void Pong::clear_req_ticks() {
  _impl_.req_ticks_ = int64_t{0};
}
inline int64_t Pong::_internal_req_ticks() const {
  return _impl_.req_ticks_;
}
inline int64_t Pong::req_ticks() const {
  // @@protoc_insertion_point(field_get:idlepb.Pong.req_ticks)
  return _internal_req_ticks();
}
inline void Pong::_internal_set_req_ticks(int64_t value) {
  
  _impl_.req_ticks_ = value;
}
inline void Pong::set_req_ticks(int64_t value) {
  _internal_set_req_ticks(value);
  // @@protoc_insertion_point(field_set:idlepb.Pong.req_ticks)
}

// int64 rsp_ticks = 2;
inline void Pong::clear_rsp_ticks() {
  _impl_.rsp_ticks_ = int64_t{0};
}
inline int64_t Pong::_internal_rsp_ticks() const {
  return _impl_.rsp_ticks_;
}
inline int64_t Pong::rsp_ticks() const {
  // @@protoc_insertion_point(field_get:idlepb.Pong.rsp_ticks)
  return _internal_rsp_ticks();
}
inline void Pong::_internal_set_rsp_ticks(int64_t value) {
  
  _impl_.rsp_ticks_ = value;
}
inline void Pong::set_rsp_ticks(int64_t value) {
  _internal_set_rsp_ticks(value);
  // @@protoc_insertion_point(field_set:idlepb.Pong.rsp_ticks)
}

// -------------------------------------------------------------------

// DoGmCommand

// string command = 1;
inline void DoGmCommand::clear_command() {
  _impl_.command_.ClearToEmpty();
}
inline const std::string& DoGmCommand::command() const {
  // @@protoc_insertion_point(field_get:idlepb.DoGmCommand.command)
  return _internal_command();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DoGmCommand::set_command(ArgT0&& arg0, ArgT... args) {
 
 _impl_.command_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.DoGmCommand.command)
}
inline std::string* DoGmCommand::mutable_command() {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:idlepb.DoGmCommand.command)
  return _s;
}
inline const std::string& DoGmCommand::_internal_command() const {
  return _impl_.command_.Get();
}
inline void DoGmCommand::_internal_set_command(const std::string& value) {
  
  _impl_.command_.Set(value, GetArenaForAllocation());
}
inline std::string* DoGmCommand::_internal_mutable_command() {
  
  return _impl_.command_.Mutable(GetArenaForAllocation());
}
inline std::string* DoGmCommand::release_command() {
  // @@protoc_insertion_point(field_release:idlepb.DoGmCommand.command)
  return _impl_.command_.Release();
}
inline void DoGmCommand::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  _impl_.command_.SetAllocated(command, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.command_.IsDefault()) {
    _impl_.command_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.DoGmCommand.command)
}

// -------------------------------------------------------------------

// ReportError

// string text = 1;
inline void ReportError::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& ReportError::text() const {
  // @@protoc_insertion_point(field_get:idlepb.ReportError.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReportError::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.ReportError.text)
}
inline std::string* ReportError::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:idlepb.ReportError.text)
  return _s;
}
inline const std::string& ReportError::_internal_text() const {
  return _impl_.text_.Get();
}
inline void ReportError::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* ReportError::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* ReportError::release_text() {
  // @@protoc_insertion_point(field_release:idlepb.ReportError.text)
  return _impl_.text_.Release();
}
inline void ReportError::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.ReportError.text)
}

// -------------------------------------------------------------------

// LoginGameReq

// string account = 1;
inline void LoginGameReq::clear_account() {
  _impl_.account_.ClearToEmpty();
}
inline const std::string& LoginGameReq::account() const {
  // @@protoc_insertion_point(field_get:idlepb.LoginGameReq.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginGameReq::set_account(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.LoginGameReq.account)
}
inline std::string* LoginGameReq::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:idlepb.LoginGameReq.account)
  return _s;
}
inline const std::string& LoginGameReq::_internal_account() const {
  return _impl_.account_.Get();
}
inline void LoginGameReq::_internal_set_account(const std::string& value) {
  
  _impl_.account_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginGameReq::_internal_mutable_account() {
  
  return _impl_.account_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginGameReq::release_account() {
  // @@protoc_insertion_point(field_release:idlepb.LoginGameReq.account)
  return _impl_.account_.Release();
}
inline void LoginGameReq::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  _impl_.account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_.IsDefault()) {
    _impl_.account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.LoginGameReq.account)
}

// string client_version = 2;
inline void LoginGameReq::clear_client_version() {
  _impl_.client_version_.ClearToEmpty();
}
inline const std::string& LoginGameReq::client_version() const {
  // @@protoc_insertion_point(field_get:idlepb.LoginGameReq.client_version)
  return _internal_client_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginGameReq::set_client_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.LoginGameReq.client_version)
}
inline std::string* LoginGameReq::mutable_client_version() {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:idlepb.LoginGameReq.client_version)
  return _s;
}
inline const std::string& LoginGameReq::_internal_client_version() const {
  return _impl_.client_version_.Get();
}
inline void LoginGameReq::_internal_set_client_version(const std::string& value) {
  
  _impl_.client_version_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginGameReq::_internal_mutable_client_version() {
  
  return _impl_.client_version_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginGameReq::release_client_version() {
  // @@protoc_insertion_point(field_release:idlepb.LoginGameReq.client_version)
  return _impl_.client_version_.Release();
}
inline void LoginGameReq::set_allocated_client_version(std::string* client_version) {
  if (client_version != nullptr) {
    
  } else {
    
  }
  _impl_.client_version_.SetAllocated(client_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_version_.IsDefault()) {
    _impl_.client_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.LoginGameReq.client_version)
}

// -------------------------------------------------------------------

// LoginGameAck

// .idlepb.LoginGameRetCode ret = 1;
inline void LoginGameAck::clear_ret() {
  _impl_.ret_ = 0;
}
inline ::idlepb::LoginGameRetCode LoginGameAck::_internal_ret() const {
  return static_cast< ::idlepb::LoginGameRetCode >(_impl_.ret_);
}
inline ::idlepb::LoginGameRetCode LoginGameAck::ret() const {
  // @@protoc_insertion_point(field_get:idlepb.LoginGameAck.ret)
  return _internal_ret();
}
inline void LoginGameAck::_internal_set_ret(::idlepb::LoginGameRetCode value) {
  
  _impl_.ret_ = value;
}
inline void LoginGameAck::set_ret(::idlepb::LoginGameRetCode value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:idlepb.LoginGameAck.ret)
}

// .idlepb.RoleData role_data = 2;
inline bool LoginGameAck::_internal_has_role_data() const {
  return this != internal_default_instance() && _impl_.role_data_ != nullptr;
}
inline bool LoginGameAck::has_role_data() const {
  return _internal_has_role_data();
}
inline const ::idlepb::RoleData& LoginGameAck::_internal_role_data() const {
  const ::idlepb::RoleData* p = _impl_.role_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleData&>(
      ::idlepb::_RoleData_default_instance_);
}
inline const ::idlepb::RoleData& LoginGameAck::role_data() const {
  // @@protoc_insertion_point(field_get:idlepb.LoginGameAck.role_data)
  return _internal_role_data();
}
inline void LoginGameAck::unsafe_arena_set_allocated_role_data(
    ::idlepb::RoleData* role_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.role_data_);
  }
  _impl_.role_data_ = role_data;
  if (role_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.LoginGameAck.role_data)
}
inline ::idlepb::RoleData* LoginGameAck::release_role_data() {
  
  ::idlepb::RoleData* temp = _impl_.role_data_;
  _impl_.role_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleData* LoginGameAck::unsafe_arena_release_role_data() {
  // @@protoc_insertion_point(field_release:idlepb.LoginGameAck.role_data)
  
  ::idlepb::RoleData* temp = _impl_.role_data_;
  _impl_.role_data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleData* LoginGameAck::_internal_mutable_role_data() {
  
  if (_impl_.role_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleData>(GetArenaForAllocation());
    _impl_.role_data_ = p;
  }
  return _impl_.role_data_;
}
inline ::idlepb::RoleData* LoginGameAck::mutable_role_data() {
  ::idlepb::RoleData* _msg = _internal_mutable_role_data();
  // @@protoc_insertion_point(field_mutable:idlepb.LoginGameAck.role_data)
  return _msg;
}
inline void LoginGameAck::set_allocated_role_data(::idlepb::RoleData* role_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.role_data_);
  }
  if (role_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_data));
    if (message_arena != submessage_arena) {
      role_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.role_data_ = role_data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.LoginGameAck.role_data)
}

// bool is_relogin = 3;
inline void LoginGameAck::clear_is_relogin() {
  _impl_.is_relogin_ = false;
}
inline bool LoginGameAck::_internal_is_relogin() const {
  return _impl_.is_relogin_;
}
inline bool LoginGameAck::is_relogin() const {
  // @@protoc_insertion_point(field_get:idlepb.LoginGameAck.is_relogin)
  return _internal_is_relogin();
}
inline void LoginGameAck::_internal_set_is_relogin(bool value) {
  
  _impl_.is_relogin_ = value;
}
inline void LoginGameAck::set_is_relogin(bool value) {
  _internal_set_is_relogin(value);
  // @@protoc_insertion_point(field_set:idlepb.LoginGameAck.is_relogin)
}

// .idlepb.OfflineAwardSummary offline_award_summary = 4;
inline bool LoginGameAck::_internal_has_offline_award_summary() const {
  return this != internal_default_instance() && _impl_.offline_award_summary_ != nullptr;
}
inline bool LoginGameAck::has_offline_award_summary() const {
  return _internal_has_offline_award_summary();
}
inline const ::idlepb::OfflineAwardSummary& LoginGameAck::_internal_offline_award_summary() const {
  const ::idlepb::OfflineAwardSummary* p = _impl_.offline_award_summary_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::OfflineAwardSummary&>(
      ::idlepb::_OfflineAwardSummary_default_instance_);
}
inline const ::idlepb::OfflineAwardSummary& LoginGameAck::offline_award_summary() const {
  // @@protoc_insertion_point(field_get:idlepb.LoginGameAck.offline_award_summary)
  return _internal_offline_award_summary();
}
inline void LoginGameAck::unsafe_arena_set_allocated_offline_award_summary(
    ::idlepb::OfflineAwardSummary* offline_award_summary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offline_award_summary_);
  }
  _impl_.offline_award_summary_ = offline_award_summary;
  if (offline_award_summary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.LoginGameAck.offline_award_summary)
}
inline ::idlepb::OfflineAwardSummary* LoginGameAck::release_offline_award_summary() {
  
  ::idlepb::OfflineAwardSummary* temp = _impl_.offline_award_summary_;
  _impl_.offline_award_summary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::OfflineAwardSummary* LoginGameAck::unsafe_arena_release_offline_award_summary() {
  // @@protoc_insertion_point(field_release:idlepb.LoginGameAck.offline_award_summary)
  
  ::idlepb::OfflineAwardSummary* temp = _impl_.offline_award_summary_;
  _impl_.offline_award_summary_ = nullptr;
  return temp;
}
inline ::idlepb::OfflineAwardSummary* LoginGameAck::_internal_mutable_offline_award_summary() {
  
  if (_impl_.offline_award_summary_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::OfflineAwardSummary>(GetArenaForAllocation());
    _impl_.offline_award_summary_ = p;
  }
  return _impl_.offline_award_summary_;
}
inline ::idlepb::OfflineAwardSummary* LoginGameAck::mutable_offline_award_summary() {
  ::idlepb::OfflineAwardSummary* _msg = _internal_mutable_offline_award_summary();
  // @@protoc_insertion_point(field_mutable:idlepb.LoginGameAck.offline_award_summary)
  return _msg;
}
inline void LoginGameAck::set_allocated_offline_award_summary(::idlepb::OfflineAwardSummary* offline_award_summary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offline_award_summary_);
  }
  if (offline_award_summary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offline_award_summary));
    if (message_arena != submessage_arena) {
      offline_award_summary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offline_award_summary, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.offline_award_summary_ = offline_award_summary;
  // @@protoc_insertion_point(field_set_allocated:idlepb.LoginGameAck.offline_award_summary)
}

// .idlepb.SelfSeptInfo sept_info = 5;
inline bool LoginGameAck::_internal_has_sept_info() const {
  return this != internal_default_instance() && _impl_.sept_info_ != nullptr;
}
inline bool LoginGameAck::has_sept_info() const {
  return _internal_has_sept_info();
}
inline const ::idlepb::SelfSeptInfo& LoginGameAck::_internal_sept_info() const {
  const ::idlepb::SelfSeptInfo* p = _impl_.sept_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::SelfSeptInfo&>(
      ::idlepb::_SelfSeptInfo_default_instance_);
}
inline const ::idlepb::SelfSeptInfo& LoginGameAck::sept_info() const {
  // @@protoc_insertion_point(field_get:idlepb.LoginGameAck.sept_info)
  return _internal_sept_info();
}
inline void LoginGameAck::unsafe_arena_set_allocated_sept_info(
    ::idlepb::SelfSeptInfo* sept_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sept_info_);
  }
  _impl_.sept_info_ = sept_info;
  if (sept_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.LoginGameAck.sept_info)
}
inline ::idlepb::SelfSeptInfo* LoginGameAck::release_sept_info() {
  
  ::idlepb::SelfSeptInfo* temp = _impl_.sept_info_;
  _impl_.sept_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::SelfSeptInfo* LoginGameAck::unsafe_arena_release_sept_info() {
  // @@protoc_insertion_point(field_release:idlepb.LoginGameAck.sept_info)
  
  ::idlepb::SelfSeptInfo* temp = _impl_.sept_info_;
  _impl_.sept_info_ = nullptr;
  return temp;
}
inline ::idlepb::SelfSeptInfo* LoginGameAck::_internal_mutable_sept_info() {
  
  if (_impl_.sept_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::SelfSeptInfo>(GetArenaForAllocation());
    _impl_.sept_info_ = p;
  }
  return _impl_.sept_info_;
}
inline ::idlepb::SelfSeptInfo* LoginGameAck::mutable_sept_info() {
  ::idlepb::SelfSeptInfo* _msg = _internal_mutable_sept_info();
  // @@protoc_insertion_point(field_mutable:idlepb.LoginGameAck.sept_info)
  return _msg;
}
inline void LoginGameAck::set_allocated_sept_info(::idlepb::SelfSeptInfo* sept_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sept_info_);
  }
  if (sept_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sept_info));
    if (message_arena != submessage_arena) {
      sept_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sept_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sept_info_ = sept_info;
  // @@protoc_insertion_point(field_set_allocated:idlepb.LoginGameAck.sept_info)
}

// -------------------------------------------------------------------

// RefreshInventoryData

// repeated .idlepb.ItemData items = 1;
inline int RefreshInventoryData::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int RefreshInventoryData::items_size() const {
  return _internal_items_size();
}
inline ::idlepb::ItemData* RefreshInventoryData::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshInventoryData.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >*
RefreshInventoryData::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.RefreshInventoryData.items)
  return &_impl_.items_;
}
inline const ::idlepb::ItemData& RefreshInventoryData::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::ItemData& RefreshInventoryData::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshInventoryData.items)
  return _internal_items(index);
}
inline ::idlepb::ItemData* RefreshInventoryData::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::ItemData* RefreshInventoryData::add_items() {
  ::idlepb::ItemData* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.RefreshInventoryData.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >&
RefreshInventoryData::items() const {
  // @@protoc_insertion_point(field_list:idlepb.RefreshInventoryData.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// SetCurrentCultivationDirectionReq

// .idlepb.CultivationDirection dir = 1;
inline void SetCurrentCultivationDirectionReq::clear_dir() {
  _impl_.dir_ = 0;
}
inline ::idlepb::CultivationDirection SetCurrentCultivationDirectionReq::_internal_dir() const {
  return static_cast< ::idlepb::CultivationDirection >(_impl_.dir_);
}
inline ::idlepb::CultivationDirection SetCurrentCultivationDirectionReq::dir() const {
  // @@protoc_insertion_point(field_get:idlepb.SetCurrentCultivationDirectionReq.dir)
  return _internal_dir();
}
inline void SetCurrentCultivationDirectionReq::_internal_set_dir(::idlepb::CultivationDirection value) {
  
  _impl_.dir_ = value;
}
inline void SetCurrentCultivationDirectionReq::set_dir(::idlepb::CultivationDirection value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:idlepb.SetCurrentCultivationDirectionReq.dir)
}

// -------------------------------------------------------------------

// SetCurrentCultivationDirectionAck

// .idlepb.CultivationDirection dir = 1;
inline void SetCurrentCultivationDirectionAck::clear_dir() {
  _impl_.dir_ = 0;
}
inline ::idlepb::CultivationDirection SetCurrentCultivationDirectionAck::_internal_dir() const {
  return static_cast< ::idlepb::CultivationDirection >(_impl_.dir_);
}
inline ::idlepb::CultivationDirection SetCurrentCultivationDirectionAck::dir() const {
  // @@protoc_insertion_point(field_get:idlepb.SetCurrentCultivationDirectionAck.dir)
  return _internal_dir();
}
inline void SetCurrentCultivationDirectionAck::_internal_set_dir(::idlepb::CultivationDirection value) {
  
  _impl_.dir_ = value;
}
inline void SetCurrentCultivationDirectionAck::set_dir(::idlepb::CultivationDirection value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:idlepb.SetCurrentCultivationDirectionAck.dir)
}

// -------------------------------------------------------------------

// RefreshCurrentCultivationDirection

// .idlepb.CultivationDirection dir = 1;
inline void RefreshCurrentCultivationDirection::clear_dir() {
  _impl_.dir_ = 0;
}
inline ::idlepb::CultivationDirection RefreshCurrentCultivationDirection::_internal_dir() const {
  return static_cast< ::idlepb::CultivationDirection >(_impl_.dir_);
}
inline ::idlepb::CultivationDirection RefreshCurrentCultivationDirection::dir() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshCurrentCultivationDirection.dir)
  return _internal_dir();
}
inline void RefreshCurrentCultivationDirection::_internal_set_dir(::idlepb::CultivationDirection value) {
  
  _impl_.dir_ = value;
}
inline void RefreshCurrentCultivationDirection::set_dir(::idlepb::CultivationDirection value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshCurrentCultivationDirection.dir)
}

// -------------------------------------------------------------------

// RefreshCultivationRankData

// .idlepb.RankData rank_data = 1;
inline bool RefreshCultivationRankData::_internal_has_rank_data() const {
  return this != internal_default_instance() && _impl_.rank_data_ != nullptr;
}
inline bool RefreshCultivationRankData::has_rank_data() const {
  return _internal_has_rank_data();
}
inline const ::idlepb::RankData& RefreshCultivationRankData::_internal_rank_data() const {
  const ::idlepb::RankData* p = _impl_.rank_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RankData&>(
      ::idlepb::_RankData_default_instance_);
}
inline const ::idlepb::RankData& RefreshCultivationRankData::rank_data() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshCultivationRankData.rank_data)
  return _internal_rank_data();
}
inline void RefreshCultivationRankData::unsafe_arena_set_allocated_rank_data(
    ::idlepb::RankData* rank_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rank_data_);
  }
  _impl_.rank_data_ = rank_data;
  if (rank_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RefreshCultivationRankData.rank_data)
}
inline ::idlepb::RankData* RefreshCultivationRankData::release_rank_data() {
  
  ::idlepb::RankData* temp = _impl_.rank_data_;
  _impl_.rank_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RankData* RefreshCultivationRankData::unsafe_arena_release_rank_data() {
  // @@protoc_insertion_point(field_release:idlepb.RefreshCultivationRankData.rank_data)
  
  ::idlepb::RankData* temp = _impl_.rank_data_;
  _impl_.rank_data_ = nullptr;
  return temp;
}
inline ::idlepb::RankData* RefreshCultivationRankData::_internal_mutable_rank_data() {
  
  if (_impl_.rank_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RankData>(GetArenaForAllocation());
    _impl_.rank_data_ = p;
  }
  return _impl_.rank_data_;
}
inline ::idlepb::RankData* RefreshCultivationRankData::mutable_rank_data() {
  ::idlepb::RankData* _msg = _internal_mutable_rank_data();
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshCultivationRankData.rank_data)
  return _msg;
}
inline void RefreshCultivationRankData::set_allocated_rank_data(::idlepb::RankData* rank_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rank_data_);
  }
  if (rank_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rank_data));
    if (message_arena != submessage_arena) {
      rank_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rank_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rank_data_ = rank_data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RefreshCultivationRankData.rank_data)
}

// .idlepb.CultivationDirection dir = 2;
inline void RefreshCultivationRankData::clear_dir() {
  _impl_.dir_ = 0;
}
inline ::idlepb::CultivationDirection RefreshCultivationRankData::_internal_dir() const {
  return static_cast< ::idlepb::CultivationDirection >(_impl_.dir_);
}
inline ::idlepb::CultivationDirection RefreshCultivationRankData::dir() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshCultivationRankData.dir)
  return _internal_dir();
}
inline void RefreshCultivationRankData::_internal_set_dir(::idlepb::CultivationDirection value) {
  
  _impl_.dir_ = value;
}
inline void RefreshCultivationRankData::set_dir(::idlepb::CultivationDirection value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshCultivationRankData.dir)
}

// int64 last_exp_cycle_timestamp = 3;
inline void RefreshCultivationRankData::clear_last_exp_cycle_timestamp() {
  _impl_.last_exp_cycle_timestamp_ = int64_t{0};
}
inline int64_t RefreshCultivationRankData::_internal_last_exp_cycle_timestamp() const {
  return _impl_.last_exp_cycle_timestamp_;
}
inline int64_t RefreshCultivationRankData::last_exp_cycle_timestamp() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshCultivationRankData.last_exp_cycle_timestamp)
  return _internal_last_exp_cycle_timestamp();
}
inline void RefreshCultivationRankData::_internal_set_last_exp_cycle_timestamp(int64_t value) {
  
  _impl_.last_exp_cycle_timestamp_ = value;
}
inline void RefreshCultivationRankData::set_last_exp_cycle_timestamp(int64_t value) {
  _internal_set_last_exp_cycle_timestamp(value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshCultivationRankData.last_exp_cycle_timestamp)
}

// -------------------------------------------------------------------

// RefreshCultivationData

// .idlepb.CultivationData cultivation_data = 1;
inline bool RefreshCultivationData::_internal_has_cultivation_data() const {
  return this != internal_default_instance() && _impl_.cultivation_data_ != nullptr;
}
inline bool RefreshCultivationData::has_cultivation_data() const {
  return _internal_has_cultivation_data();
}
inline const ::idlepb::CultivationData& RefreshCultivationData::_internal_cultivation_data() const {
  const ::idlepb::CultivationData* p = _impl_.cultivation_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::CultivationData&>(
      ::idlepb::_CultivationData_default_instance_);
}
inline const ::idlepb::CultivationData& RefreshCultivationData::cultivation_data() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshCultivationData.cultivation_data)
  return _internal_cultivation_data();
}
inline void RefreshCultivationData::unsafe_arena_set_allocated_cultivation_data(
    ::idlepb::CultivationData* cultivation_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cultivation_data_);
  }
  _impl_.cultivation_data_ = cultivation_data;
  if (cultivation_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RefreshCultivationData.cultivation_data)
}
inline ::idlepb::CultivationData* RefreshCultivationData::release_cultivation_data() {
  
  ::idlepb::CultivationData* temp = _impl_.cultivation_data_;
  _impl_.cultivation_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::CultivationData* RefreshCultivationData::unsafe_arena_release_cultivation_data() {
  // @@protoc_insertion_point(field_release:idlepb.RefreshCultivationData.cultivation_data)
  
  ::idlepb::CultivationData* temp = _impl_.cultivation_data_;
  _impl_.cultivation_data_ = nullptr;
  return temp;
}
inline ::idlepb::CultivationData* RefreshCultivationData::_internal_mutable_cultivation_data() {
  
  if (_impl_.cultivation_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::CultivationData>(GetArenaForAllocation());
    _impl_.cultivation_data_ = p;
  }
  return _impl_.cultivation_data_;
}
inline ::idlepb::CultivationData* RefreshCultivationData::mutable_cultivation_data() {
  ::idlepb::CultivationData* _msg = _internal_mutable_cultivation_data();
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshCultivationData.cultivation_data)
  return _msg;
}
inline void RefreshCultivationData::set_allocated_cultivation_data(::idlepb::CultivationData* cultivation_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cultivation_data_);
  }
  if (cultivation_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cultivation_data));
    if (message_arena != submessage_arena) {
      cultivation_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cultivation_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cultivation_data_ = cultivation_data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RefreshCultivationData.cultivation_data)
}

// .idlepb.CultivationDirection dir = 2;
inline void RefreshCultivationData::clear_dir() {
  _impl_.dir_ = 0;
}
inline ::idlepb::CultivationDirection RefreshCultivationData::_internal_dir() const {
  return static_cast< ::idlepb::CultivationDirection >(_impl_.dir_);
}
inline ::idlepb::CultivationDirection RefreshCultivationData::dir() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshCultivationData.dir)
  return _internal_dir();
}
inline void RefreshCultivationData::_internal_set_dir(::idlepb::CultivationDirection value) {
  
  _impl_.dir_ = value;
}
inline void RefreshCultivationData::set_dir(::idlepb::CultivationDirection value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshCultivationData.dir)
}

// -------------------------------------------------------------------

// RefreshCurrencyData

// .idlepb.CurrencyData data = 1;
inline bool RefreshCurrencyData::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool RefreshCurrencyData::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::CurrencyData& RefreshCurrencyData::_internal_data() const {
  const ::idlepb::CurrencyData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::CurrencyData&>(
      ::idlepb::_CurrencyData_default_instance_);
}
inline const ::idlepb::CurrencyData& RefreshCurrencyData::data() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshCurrencyData.data)
  return _internal_data();
}
inline void RefreshCurrencyData::unsafe_arena_set_allocated_data(
    ::idlepb::CurrencyData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RefreshCurrencyData.data)
}
inline ::idlepb::CurrencyData* RefreshCurrencyData::release_data() {
  
  ::idlepb::CurrencyData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::CurrencyData* RefreshCurrencyData::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.RefreshCurrencyData.data)
  
  ::idlepb::CurrencyData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::CurrencyData* RefreshCurrencyData::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::CurrencyData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::CurrencyData* RefreshCurrencyData::mutable_data() {
  ::idlepb::CurrencyData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshCurrencyData.data)
  return _msg;
}
inline void RefreshCurrencyData::set_allocated_data(::idlepb::CurrencyData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RefreshCurrencyData.data)
}

// -------------------------------------------------------------------

// RefreshDailyCounterData

// .idlepb.RoleDailyCounter daily_counter = 1;
inline bool RefreshDailyCounterData::_internal_has_daily_counter() const {
  return this != internal_default_instance() && _impl_.daily_counter_ != nullptr;
}
inline bool RefreshDailyCounterData::has_daily_counter() const {
  return _internal_has_daily_counter();
}
inline const ::idlepb::RoleDailyCounter& RefreshDailyCounterData::_internal_daily_counter() const {
  const ::idlepb::RoleDailyCounter* p = _impl_.daily_counter_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleDailyCounter&>(
      ::idlepb::_RoleDailyCounter_default_instance_);
}
inline const ::idlepb::RoleDailyCounter& RefreshDailyCounterData::daily_counter() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshDailyCounterData.daily_counter)
  return _internal_daily_counter();
}
inline void RefreshDailyCounterData::unsafe_arena_set_allocated_daily_counter(
    ::idlepb::RoleDailyCounter* daily_counter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.daily_counter_);
  }
  _impl_.daily_counter_ = daily_counter;
  if (daily_counter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RefreshDailyCounterData.daily_counter)
}
inline ::idlepb::RoleDailyCounter* RefreshDailyCounterData::release_daily_counter() {
  
  ::idlepb::RoleDailyCounter* temp = _impl_.daily_counter_;
  _impl_.daily_counter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleDailyCounter* RefreshDailyCounterData::unsafe_arena_release_daily_counter() {
  // @@protoc_insertion_point(field_release:idlepb.RefreshDailyCounterData.daily_counter)
  
  ::idlepb::RoleDailyCounter* temp = _impl_.daily_counter_;
  _impl_.daily_counter_ = nullptr;
  return temp;
}
inline ::idlepb::RoleDailyCounter* RefreshDailyCounterData::_internal_mutable_daily_counter() {
  
  if (_impl_.daily_counter_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleDailyCounter>(GetArenaForAllocation());
    _impl_.daily_counter_ = p;
  }
  return _impl_.daily_counter_;
}
inline ::idlepb::RoleDailyCounter* RefreshDailyCounterData::mutable_daily_counter() {
  ::idlepb::RoleDailyCounter* _msg = _internal_mutable_daily_counter();
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshDailyCounterData.daily_counter)
  return _msg;
}
inline void RefreshDailyCounterData::set_allocated_daily_counter(::idlepb::RoleDailyCounter* daily_counter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.daily_counter_);
  }
  if (daily_counter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(daily_counter));
    if (message_arena != submessage_arena) {
      daily_counter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, daily_counter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.daily_counter_ = daily_counter;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RefreshDailyCounterData.daily_counter)
}

// .idlepb.RoleWeeklyCounter weekly_counter = 2;
inline bool RefreshDailyCounterData::_internal_has_weekly_counter() const {
  return this != internal_default_instance() && _impl_.weekly_counter_ != nullptr;
}
inline bool RefreshDailyCounterData::has_weekly_counter() const {
  return _internal_has_weekly_counter();
}
inline const ::idlepb::RoleWeeklyCounter& RefreshDailyCounterData::_internal_weekly_counter() const {
  const ::idlepb::RoleWeeklyCounter* p = _impl_.weekly_counter_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleWeeklyCounter&>(
      ::idlepb::_RoleWeeklyCounter_default_instance_);
}
inline const ::idlepb::RoleWeeklyCounter& RefreshDailyCounterData::weekly_counter() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshDailyCounterData.weekly_counter)
  return _internal_weekly_counter();
}
inline void RefreshDailyCounterData::unsafe_arena_set_allocated_weekly_counter(
    ::idlepb::RoleWeeklyCounter* weekly_counter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.weekly_counter_);
  }
  _impl_.weekly_counter_ = weekly_counter;
  if (weekly_counter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RefreshDailyCounterData.weekly_counter)
}
inline ::idlepb::RoleWeeklyCounter* RefreshDailyCounterData::release_weekly_counter() {
  
  ::idlepb::RoleWeeklyCounter* temp = _impl_.weekly_counter_;
  _impl_.weekly_counter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleWeeklyCounter* RefreshDailyCounterData::unsafe_arena_release_weekly_counter() {
  // @@protoc_insertion_point(field_release:idlepb.RefreshDailyCounterData.weekly_counter)
  
  ::idlepb::RoleWeeklyCounter* temp = _impl_.weekly_counter_;
  _impl_.weekly_counter_ = nullptr;
  return temp;
}
inline ::idlepb::RoleWeeklyCounter* RefreshDailyCounterData::_internal_mutable_weekly_counter() {
  
  if (_impl_.weekly_counter_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleWeeklyCounter>(GetArenaForAllocation());
    _impl_.weekly_counter_ = p;
  }
  return _impl_.weekly_counter_;
}
inline ::idlepb::RoleWeeklyCounter* RefreshDailyCounterData::mutable_weekly_counter() {
  ::idlepb::RoleWeeklyCounter* _msg = _internal_mutable_weekly_counter();
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshDailyCounterData.weekly_counter)
  return _msg;
}
inline void RefreshDailyCounterData::set_allocated_weekly_counter(::idlepb::RoleWeeklyCounter* weekly_counter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.weekly_counter_);
  }
  if (weekly_counter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(weekly_counter));
    if (message_arena != submessage_arena) {
      weekly_counter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, weekly_counter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.weekly_counter_ = weekly_counter;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RefreshDailyCounterData.weekly_counter)
}

// -------------------------------------------------------------------

// RefreshLastUnlockArenaId

// int32 last_unlock_arena_id = 1;
inline void RefreshLastUnlockArenaId::clear_last_unlock_arena_id() {
  _impl_.last_unlock_arena_id_ = 0;
}
inline int32_t RefreshLastUnlockArenaId::_internal_last_unlock_arena_id() const {
  return _impl_.last_unlock_arena_id_;
}
inline int32_t RefreshLastUnlockArenaId::last_unlock_arena_id() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshLastUnlockArenaId.last_unlock_arena_id)
  return _internal_last_unlock_arena_id();
}
inline void RefreshLastUnlockArenaId::_internal_set_last_unlock_arena_id(int32_t value) {
  
  _impl_.last_unlock_arena_id_ = value;
}
inline void RefreshLastUnlockArenaId::set_last_unlock_arena_id(int32_t value) {
  _internal_set_last_unlock_arena_id(value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshLastUnlockArenaId.last_unlock_arena_id)
}

// -------------------------------------------------------------------

// RefreshUnlockedEquipmentSlots

// repeated int32 slots = 1;
inline int RefreshUnlockedEquipmentSlots::_internal_slots_size() const {
  return _impl_.slots_.size();
}
inline int RefreshUnlockedEquipmentSlots::slots_size() const {
  return _internal_slots_size();
}
inline void RefreshUnlockedEquipmentSlots::clear_slots() {
  _impl_.slots_.Clear();
}
inline int32_t RefreshUnlockedEquipmentSlots::_internal_slots(int index) const {
  return _impl_.slots_.Get(index);
}
inline int32_t RefreshUnlockedEquipmentSlots::slots(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshUnlockedEquipmentSlots.slots)
  return _internal_slots(index);
}
inline void RefreshUnlockedEquipmentSlots::set_slots(int index, int32_t value) {
  _impl_.slots_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshUnlockedEquipmentSlots.slots)
}
inline void RefreshUnlockedEquipmentSlots::_internal_add_slots(int32_t value) {
  _impl_.slots_.Add(value);
}
inline void RefreshUnlockedEquipmentSlots::add_slots(int32_t value) {
  _internal_add_slots(value);
  // @@protoc_insertion_point(field_add:idlepb.RefreshUnlockedEquipmentSlots.slots)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RefreshUnlockedEquipmentSlots::_internal_slots() const {
  return _impl_.slots_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RefreshUnlockedEquipmentSlots::slots() const {
  // @@protoc_insertion_point(field_list:idlepb.RefreshUnlockedEquipmentSlots.slots)
  return _internal_slots();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RefreshUnlockedEquipmentSlots::_internal_mutable_slots() {
  return &_impl_.slots_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RefreshUnlockedEquipmentSlots::mutable_slots() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.RefreshUnlockedEquipmentSlots.slots)
  return _internal_mutable_slots();
}

// -------------------------------------------------------------------

// UnlockEquipmentSlotReq

// int32 index = 1;
inline void UnlockEquipmentSlotReq::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t UnlockEquipmentSlotReq::_internal_index() const {
  return _impl_.index_;
}
inline int32_t UnlockEquipmentSlotReq::index() const {
  // @@protoc_insertion_point(field_get:idlepb.UnlockEquipmentSlotReq.index)
  return _internal_index();
}
inline void UnlockEquipmentSlotReq::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void UnlockEquipmentSlotReq::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:idlepb.UnlockEquipmentSlotReq.index)
}

// -------------------------------------------------------------------

// UnlockEquipmentSlotAck

// bool ok = 1;
inline void UnlockEquipmentSlotAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool UnlockEquipmentSlotAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool UnlockEquipmentSlotAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.UnlockEquipmentSlotAck.ok)
  return _internal_ok();
}
inline void UnlockEquipmentSlotAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void UnlockEquipmentSlotAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.UnlockEquipmentSlotAck.ok)
}

// -------------------------------------------------------------------

// ThunderTestRoundData

// int32 round = 1;
inline void ThunderTestRoundData::clear_round() {
  _impl_.round_ = 0;
}
inline int32_t ThunderTestRoundData::_internal_round() const {
  return _impl_.round_;
}
inline int32_t ThunderTestRoundData::round() const {
  // @@protoc_insertion_point(field_get:idlepb.ThunderTestRoundData.round)
  return _internal_round();
}
inline void ThunderTestRoundData::_internal_set_round(int32_t value) {
  
  _impl_.round_ = value;
}
inline void ThunderTestRoundData::set_round(int32_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:idlepb.ThunderTestRoundData.round)
}

// float damage = 2;
inline void ThunderTestRoundData::clear_damage() {
  _impl_.damage_ = 0;
}
inline float ThunderTestRoundData::_internal_damage() const {
  return _impl_.damage_;
}
inline float ThunderTestRoundData::damage() const {
  // @@protoc_insertion_point(field_get:idlepb.ThunderTestRoundData.damage)
  return _internal_damage();
}
inline void ThunderTestRoundData::_internal_set_damage(float value) {
  
  _impl_.damage_ = value;
}
inline void ThunderTestRoundData::set_damage(float value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:idlepb.ThunderTestRoundData.damage)
}

// float hp = 3;
inline void ThunderTestRoundData::clear_hp() {
  _impl_.hp_ = 0;
}
inline float ThunderTestRoundData::_internal_hp() const {
  return _impl_.hp_;
}
inline float ThunderTestRoundData::hp() const {
  // @@protoc_insertion_point(field_get:idlepb.ThunderTestRoundData.hp)
  return _internal_hp();
}
inline void ThunderTestRoundData::_internal_set_hp(float value) {
  
  _impl_.hp_ = value;
}
inline void ThunderTestRoundData::set_hp(float value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:idlepb.ThunderTestRoundData.hp)
}

// float mp = 4;
inline void ThunderTestRoundData::clear_mp() {
  _impl_.mp_ = 0;
}
inline float ThunderTestRoundData::_internal_mp() const {
  return _impl_.mp_;
}
inline float ThunderTestRoundData::mp() const {
  // @@protoc_insertion_point(field_get:idlepb.ThunderTestRoundData.mp)
  return _internal_mp();
}
inline void ThunderTestRoundData::_internal_set_mp(float value) {
  
  _impl_.mp_ = value;
}
inline void ThunderTestRoundData::set_mp(float value) {
  _internal_set_mp(value);
  // @@protoc_insertion_point(field_set:idlepb.ThunderTestRoundData.mp)
}

// -------------------------------------------------------------------

// ThunderTestData

// float hp = 1;
inline void ThunderTestData::clear_hp() {
  _impl_.hp_ = 0;
}
inline float ThunderTestData::_internal_hp() const {
  return _impl_.hp_;
}
inline float ThunderTestData::hp() const {
  // @@protoc_insertion_point(field_get:idlepb.ThunderTestData.hp)
  return _internal_hp();
}
inline void ThunderTestData::_internal_set_hp(float value) {
  
  _impl_.hp_ = value;
}
inline void ThunderTestData::set_hp(float value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:idlepb.ThunderTestData.hp)
}

// float mp = 2;
inline void ThunderTestData::clear_mp() {
  _impl_.mp_ = 0;
}
inline float ThunderTestData::_internal_mp() const {
  return _impl_.mp_;
}
inline float ThunderTestData::mp() const {
  // @@protoc_insertion_point(field_get:idlepb.ThunderTestData.mp)
  return _internal_mp();
}
inline void ThunderTestData::_internal_set_mp(float value) {
  
  _impl_.mp_ = value;
}
inline void ThunderTestData::set_mp(float value) {
  _internal_set_mp(value);
  // @@protoc_insertion_point(field_set:idlepb.ThunderTestData.mp)
}

// repeated .idlepb.ThunderTestRoundData rounds = 3;
inline int ThunderTestData::_internal_rounds_size() const {
  return _impl_.rounds_.size();
}
inline int ThunderTestData::rounds_size() const {
  return _internal_rounds_size();
}
inline void ThunderTestData::clear_rounds() {
  _impl_.rounds_.Clear();
}
inline ::idlepb::ThunderTestRoundData* ThunderTestData::mutable_rounds(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.ThunderTestData.rounds)
  return _impl_.rounds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ThunderTestRoundData >*
ThunderTestData::mutable_rounds() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.ThunderTestData.rounds)
  return &_impl_.rounds_;
}
inline const ::idlepb::ThunderTestRoundData& ThunderTestData::_internal_rounds(int index) const {
  return _impl_.rounds_.Get(index);
}
inline const ::idlepb::ThunderTestRoundData& ThunderTestData::rounds(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.ThunderTestData.rounds)
  return _internal_rounds(index);
}
inline ::idlepb::ThunderTestRoundData* ThunderTestData::_internal_add_rounds() {
  return _impl_.rounds_.Add();
}
inline ::idlepb::ThunderTestRoundData* ThunderTestData::add_rounds() {
  ::idlepb::ThunderTestRoundData* _add = _internal_add_rounds();
  // @@protoc_insertion_point(field_add:idlepb.ThunderTestData.rounds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ThunderTestRoundData >&
ThunderTestData::rounds() const {
  // @@protoc_insertion_point(field_list:idlepb.ThunderTestData.rounds)
  return _impl_.rounds_;
}

// -------------------------------------------------------------------

// DoBreakthroughReq

// int64 item_id = 1;
inline void DoBreakthroughReq::clear_item_id() {
  _impl_.item_id_ = int64_t{0};
}
inline int64_t DoBreakthroughReq::_internal_item_id() const {
  return _impl_.item_id_;
}
inline int64_t DoBreakthroughReq::item_id() const {
  // @@protoc_insertion_point(field_get:idlepb.DoBreakthroughReq.item_id)
  return _internal_item_id();
}
inline void DoBreakthroughReq::_internal_set_item_id(int64_t value) {
  
  _impl_.item_id_ = value;
}
inline void DoBreakthroughReq::set_item_id(int64_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:idlepb.DoBreakthroughReq.item_id)
}

// -------------------------------------------------------------------

// DoBreakthroughAck

// bool success = 1;
inline void DoBreakthroughAck::clear_success() {
  _impl_.success_ = false;
}
inline bool DoBreakthroughAck::_internal_success() const {
  return _impl_.success_;
}
inline bool DoBreakthroughAck::success() const {
  // @@protoc_insertion_point(field_get:idlepb.DoBreakthroughAck.success)
  return _internal_success();
}
inline void DoBreakthroughAck::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void DoBreakthroughAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:idlepb.DoBreakthroughAck.success)
}

// .idlepb.BreakthroughType old_type = 2;
inline void DoBreakthroughAck::clear_old_type() {
  _impl_.old_type_ = 0;
}
inline ::idlepb::BreakthroughType DoBreakthroughAck::_internal_old_type() const {
  return static_cast< ::idlepb::BreakthroughType >(_impl_.old_type_);
}
inline ::idlepb::BreakthroughType DoBreakthroughAck::old_type() const {
  // @@protoc_insertion_point(field_get:idlepb.DoBreakthroughAck.old_type)
  return _internal_old_type();
}
inline void DoBreakthroughAck::_internal_set_old_type(::idlepb::BreakthroughType value) {
  
  _impl_.old_type_ = value;
}
inline void DoBreakthroughAck::set_old_type(::idlepb::BreakthroughType value) {
  _internal_set_old_type(value);
  // @@protoc_insertion_point(field_set:idlepb.DoBreakthroughAck.old_type)
}

// .idlepb.BreakthroughType new_type = 3;
inline void DoBreakthroughAck::clear_new_type() {
  _impl_.new_type_ = 0;
}
inline ::idlepb::BreakthroughType DoBreakthroughAck::_internal_new_type() const {
  return static_cast< ::idlepb::BreakthroughType >(_impl_.new_type_);
}
inline ::idlepb::BreakthroughType DoBreakthroughAck::new_type() const {
  // @@protoc_insertion_point(field_get:idlepb.DoBreakthroughAck.new_type)
  return _internal_new_type();
}
inline void DoBreakthroughAck::_internal_set_new_type(::idlepb::BreakthroughType value) {
  
  _impl_.new_type_ = value;
}
inline void DoBreakthroughAck::set_new_type(::idlepb::BreakthroughType value) {
  _internal_set_new_type(value);
  // @@protoc_insertion_point(field_set:idlepb.DoBreakthroughAck.new_type)
}

// bool is_bottleneck = 4;
inline void DoBreakthroughAck::clear_is_bottleneck() {
  _impl_.is_bottleneck_ = false;
}
inline bool DoBreakthroughAck::_internal_is_bottleneck() const {
  return _impl_.is_bottleneck_;
}
inline bool DoBreakthroughAck::is_bottleneck() const {
  // @@protoc_insertion_point(field_get:idlepb.DoBreakthroughAck.is_bottleneck)
  return _internal_is_bottleneck();
}
inline void DoBreakthroughAck::_internal_set_is_bottleneck(bool value) {
  
  _impl_.is_bottleneck_ = value;
}
inline void DoBreakthroughAck::set_is_bottleneck(bool value) {
  _internal_set_is_bottleneck(value);
  // @@protoc_insertion_point(field_set:idlepb.DoBreakthroughAck.is_bottleneck)
}

// .idlepb.ThunderTestData thunder_test_data = 5;
inline bool DoBreakthroughAck::_internal_has_thunder_test_data() const {
  return this != internal_default_instance() && _impl_.thunder_test_data_ != nullptr;
}
inline bool DoBreakthroughAck::has_thunder_test_data() const {
  return _internal_has_thunder_test_data();
}
inline void DoBreakthroughAck::clear_thunder_test_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.thunder_test_data_ != nullptr) {
    delete _impl_.thunder_test_data_;
  }
  _impl_.thunder_test_data_ = nullptr;
}
inline const ::idlepb::ThunderTestData& DoBreakthroughAck::_internal_thunder_test_data() const {
  const ::idlepb::ThunderTestData* p = _impl_.thunder_test_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::ThunderTestData&>(
      ::idlepb::_ThunderTestData_default_instance_);
}
inline const ::idlepb::ThunderTestData& DoBreakthroughAck::thunder_test_data() const {
  // @@protoc_insertion_point(field_get:idlepb.DoBreakthroughAck.thunder_test_data)
  return _internal_thunder_test_data();
}
inline void DoBreakthroughAck::unsafe_arena_set_allocated_thunder_test_data(
    ::idlepb::ThunderTestData* thunder_test_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.thunder_test_data_);
  }
  _impl_.thunder_test_data_ = thunder_test_data;
  if (thunder_test_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.DoBreakthroughAck.thunder_test_data)
}
inline ::idlepb::ThunderTestData* DoBreakthroughAck::release_thunder_test_data() {
  
  ::idlepb::ThunderTestData* temp = _impl_.thunder_test_data_;
  _impl_.thunder_test_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::ThunderTestData* DoBreakthroughAck::unsafe_arena_release_thunder_test_data() {
  // @@protoc_insertion_point(field_release:idlepb.DoBreakthroughAck.thunder_test_data)
  
  ::idlepb::ThunderTestData* temp = _impl_.thunder_test_data_;
  _impl_.thunder_test_data_ = nullptr;
  return temp;
}
inline ::idlepb::ThunderTestData* DoBreakthroughAck::_internal_mutable_thunder_test_data() {
  
  if (_impl_.thunder_test_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::ThunderTestData>(GetArenaForAllocation());
    _impl_.thunder_test_data_ = p;
  }
  return _impl_.thunder_test_data_;
}
inline ::idlepb::ThunderTestData* DoBreakthroughAck::mutable_thunder_test_data() {
  ::idlepb::ThunderTestData* _msg = _internal_mutable_thunder_test_data();
  // @@protoc_insertion_point(field_mutable:idlepb.DoBreakthroughAck.thunder_test_data)
  return _msg;
}
inline void DoBreakthroughAck::set_allocated_thunder_test_data(::idlepb::ThunderTestData* thunder_test_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.thunder_test_data_;
  }
  if (thunder_test_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(thunder_test_data);
    if (message_arena != submessage_arena) {
      thunder_test_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thunder_test_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.thunder_test_data_ = thunder_test_data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.DoBreakthroughAck.thunder_test_data)
}

// -------------------------------------------------------------------

// RefreshItems

// repeated .idlepb.ItemData items = 1;
inline int RefreshItems::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int RefreshItems::items_size() const {
  return _internal_items_size();
}
inline ::idlepb::ItemData* RefreshItems::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshItems.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >*
RefreshItems::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.RefreshItems.items)
  return &_impl_.items_;
}
inline const ::idlepb::ItemData& RefreshItems::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::ItemData& RefreshItems::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshItems.items)
  return _internal_items(index);
}
inline ::idlepb::ItemData* RefreshItems::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::ItemData* RefreshItems::add_items() {
  ::idlepb::ItemData* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.RefreshItems.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >&
RefreshItems::items() const {
  // @@protoc_insertion_point(field_list:idlepb.RefreshItems.items)
  return _impl_.items_;
}

// repeated int64 junks = 2;
inline int RefreshItems::_internal_junks_size() const {
  return _impl_.junks_.size();
}
inline int RefreshItems::junks_size() const {
  return _internal_junks_size();
}
inline void RefreshItems::clear_junks() {
  _impl_.junks_.Clear();
}
inline int64_t RefreshItems::_internal_junks(int index) const {
  return _impl_.junks_.Get(index);
}
inline int64_t RefreshItems::junks(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshItems.junks)
  return _internal_junks(index);
}
inline void RefreshItems::set_junks(int index, int64_t value) {
  _impl_.junks_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshItems.junks)
}
inline void RefreshItems::_internal_add_junks(int64_t value) {
  _impl_.junks_.Add(value);
}
inline void RefreshItems::add_junks(int64_t value) {
  _internal_add_junks(value);
  // @@protoc_insertion_point(field_add:idlepb.RefreshItems.junks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
RefreshItems::_internal_junks() const {
  return _impl_.junks_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
RefreshItems::junks() const {
  // @@protoc_insertion_point(field_list:idlepb.RefreshItems.junks)
  return _internal_junks();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
RefreshItems::_internal_mutable_junks() {
  return &_impl_.junks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
RefreshItems::mutable_junks() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.RefreshItems.junks)
  return _internal_mutable_junks();
}

// repeated .idlepb.SimpleItemData others = 3;
inline int RefreshItems::_internal_others_size() const {
  return _impl_.others_.size();
}
inline int RefreshItems::others_size() const {
  return _internal_others_size();
}
inline ::idlepb::SimpleItemData* RefreshItems::mutable_others(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshItems.others)
  return _impl_.others_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
RefreshItems::mutable_others() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.RefreshItems.others)
  return &_impl_.others_;
}
inline const ::idlepb::SimpleItemData& RefreshItems::_internal_others(int index) const {
  return _impl_.others_.Get(index);
}
inline const ::idlepb::SimpleItemData& RefreshItems::others(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshItems.others)
  return _internal_others(index);
}
inline ::idlepb::SimpleItemData* RefreshItems::_internal_add_others() {
  return _impl_.others_.Add();
}
inline ::idlepb::SimpleItemData* RefreshItems::add_others() {
  ::idlepb::SimpleItemData* _add = _internal_add_others();
  // @@protoc_insertion_point(field_add:idlepb.RefreshItems.others)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
RefreshItems::others() const {
  // @@protoc_insertion_point(field_list:idlepb.RefreshItems.others)
  return _impl_.others_;
}

// repeated .idlepb.ItemData quiet_items = 4;
inline int RefreshItems::_internal_quiet_items_size() const {
  return _impl_.quiet_items_.size();
}
inline int RefreshItems::quiet_items_size() const {
  return _internal_quiet_items_size();
}
inline ::idlepb::ItemData* RefreshItems::mutable_quiet_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshItems.quiet_items)
  return _impl_.quiet_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >*
RefreshItems::mutable_quiet_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.RefreshItems.quiet_items)
  return &_impl_.quiet_items_;
}
inline const ::idlepb::ItemData& RefreshItems::_internal_quiet_items(int index) const {
  return _impl_.quiet_items_.Get(index);
}
inline const ::idlepb::ItemData& RefreshItems::quiet_items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshItems.quiet_items)
  return _internal_quiet_items(index);
}
inline ::idlepb::ItemData* RefreshItems::_internal_add_quiet_items() {
  return _impl_.quiet_items_.Add();
}
inline ::idlepb::ItemData* RefreshItems::add_quiet_items() {
  ::idlepb::ItemData* _add = _internal_add_quiet_items();
  // @@protoc_insertion_point(field_add:idlepb.RefreshItems.quiet_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >&
RefreshItems::quiet_items() const {
  // @@protoc_insertion_point(field_list:idlepb.RefreshItems.quiet_items)
  return _impl_.quiet_items_;
}

// -------------------------------------------------------------------

// RefreshTemporaryPackageItems

// repeated .idlepb.TemporaryPackageItem items = 1;
inline int RefreshTemporaryPackageItems::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int RefreshTemporaryPackageItems::items_size() const {
  return _internal_items_size();
}
inline ::idlepb::TemporaryPackageItem* RefreshTemporaryPackageItems::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshTemporaryPackageItems.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TemporaryPackageItem >*
RefreshTemporaryPackageItems::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.RefreshTemporaryPackageItems.items)
  return &_impl_.items_;
}
inline const ::idlepb::TemporaryPackageItem& RefreshTemporaryPackageItems::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::TemporaryPackageItem& RefreshTemporaryPackageItems::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshTemporaryPackageItems.items)
  return _internal_items(index);
}
inline ::idlepb::TemporaryPackageItem* RefreshTemporaryPackageItems::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::TemporaryPackageItem* RefreshTemporaryPackageItems::add_items() {
  ::idlepb::TemporaryPackageItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.RefreshTemporaryPackageItems.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TemporaryPackageItem >&
RefreshTemporaryPackageItems::items() const {
  // @@protoc_insertion_point(field_list:idlepb.RefreshTemporaryPackageItems.items)
  return _impl_.items_;
}

// int32 total_num = 2;
inline void RefreshTemporaryPackageItems::clear_total_num() {
  _impl_.total_num_ = 0;
}
inline int32_t RefreshTemporaryPackageItems::_internal_total_num() const {
  return _impl_.total_num_;
}
inline int32_t RefreshTemporaryPackageItems::total_num() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshTemporaryPackageItems.total_num)
  return _internal_total_num();
}
inline void RefreshTemporaryPackageItems::_internal_set_total_num(int32_t value) {
  
  _impl_.total_num_ = value;
}
inline void RefreshTemporaryPackageItems::set_total_num(int32_t value) {
  _internal_set_total_num(value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshTemporaryPackageItems.total_num)
}

// int64 last_extract_time = 3;
inline void RefreshTemporaryPackageItems::clear_last_extract_time() {
  _impl_.last_extract_time_ = int64_t{0};
}
inline int64_t RefreshTemporaryPackageItems::_internal_last_extract_time() const {
  return _impl_.last_extract_time_;
}
inline int64_t RefreshTemporaryPackageItems::last_extract_time() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshTemporaryPackageItems.last_extract_time)
  return _internal_last_extract_time();
}
inline void RefreshTemporaryPackageItems::_internal_set_last_extract_time(int64_t value) {
  
  _impl_.last_extract_time_ = value;
}
inline void RefreshTemporaryPackageItems::set_last_extract_time(int64_t value) {
  _internal_set_last_extract_time(value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshTemporaryPackageItems.last_extract_time)
}

// -------------------------------------------------------------------

// ExtractTemporaryPackageItemsReq

// -------------------------------------------------------------------

// ExtractTemporaryPackageItemsAck

// -------------------------------------------------------------------

// GetTemporaryPackageDataReq

// -------------------------------------------------------------------

// GetTemporaryPackageDataAck

// repeated .idlepb.TemporaryPackageItem items = 1;
inline int GetTemporaryPackageDataAck::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int GetTemporaryPackageDataAck::items_size() const {
  return _internal_items_size();
}
inline ::idlepb::TemporaryPackageItem* GetTemporaryPackageDataAck::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetTemporaryPackageDataAck.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TemporaryPackageItem >*
GetTemporaryPackageDataAck::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetTemporaryPackageDataAck.items)
  return &_impl_.items_;
}
inline const ::idlepb::TemporaryPackageItem& GetTemporaryPackageDataAck::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::TemporaryPackageItem& GetTemporaryPackageDataAck::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetTemporaryPackageDataAck.items)
  return _internal_items(index);
}
inline ::idlepb::TemporaryPackageItem* GetTemporaryPackageDataAck::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::TemporaryPackageItem* GetTemporaryPackageDataAck::add_items() {
  ::idlepb::TemporaryPackageItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.GetTemporaryPackageDataAck.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TemporaryPackageItem >&
GetTemporaryPackageDataAck::items() const {
  // @@protoc_insertion_point(field_list:idlepb.GetTemporaryPackageDataAck.items)
  return _impl_.items_;
}

// int64 last_extract_time = 2;
inline void GetTemporaryPackageDataAck::clear_last_extract_time() {
  _impl_.last_extract_time_ = int64_t{0};
}
inline int64_t GetTemporaryPackageDataAck::_internal_last_extract_time() const {
  return _impl_.last_extract_time_;
}
inline int64_t GetTemporaryPackageDataAck::last_extract_time() const {
  // @@protoc_insertion_point(field_get:idlepb.GetTemporaryPackageDataAck.last_extract_time)
  return _internal_last_extract_time();
}
inline void GetTemporaryPackageDataAck::_internal_set_last_extract_time(int64_t value) {
  
  _impl_.last_extract_time_ = value;
}
inline void GetTemporaryPackageDataAck::set_last_extract_time(int64_t value) {
  _internal_set_last_extract_time(value);
  // @@protoc_insertion_point(field_set:idlepb.GetTemporaryPackageDataAck.last_extract_time)
}

// -------------------------------------------------------------------

// GetArenaExplorationStatisticalDataReq

// -------------------------------------------------------------------

// GetArenaExplorationStatisticalDataAck

// .idlepb.RoleArenaExplorationStatisticalData data = 1;
inline bool GetArenaExplorationStatisticalDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetArenaExplorationStatisticalDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleArenaExplorationStatisticalData& GetArenaExplorationStatisticalDataAck::_internal_data() const {
  const ::idlepb::RoleArenaExplorationStatisticalData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleArenaExplorationStatisticalData&>(
      ::idlepb::_RoleArenaExplorationStatisticalData_default_instance_);
}
inline const ::idlepb::RoleArenaExplorationStatisticalData& GetArenaExplorationStatisticalDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetArenaExplorationStatisticalDataAck.data)
  return _internal_data();
}
inline void GetArenaExplorationStatisticalDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleArenaExplorationStatisticalData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetArenaExplorationStatisticalDataAck.data)
}
inline ::idlepb::RoleArenaExplorationStatisticalData* GetArenaExplorationStatisticalDataAck::release_data() {
  
  ::idlepb::RoleArenaExplorationStatisticalData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleArenaExplorationStatisticalData* GetArenaExplorationStatisticalDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetArenaExplorationStatisticalDataAck.data)
  
  ::idlepb::RoleArenaExplorationStatisticalData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleArenaExplorationStatisticalData* GetArenaExplorationStatisticalDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleArenaExplorationStatisticalData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleArenaExplorationStatisticalData* GetArenaExplorationStatisticalDataAck::mutable_data() {
  ::idlepb::RoleArenaExplorationStatisticalData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetArenaExplorationStatisticalDataAck.data)
  return _msg;
}
inline void GetArenaExplorationStatisticalDataAck::set_allocated_data(::idlepb::RoleArenaExplorationStatisticalData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetArenaExplorationStatisticalDataAck.data)
}

// -------------------------------------------------------------------

// DoBreathingExerciseReq

// float percet = 1;
inline void DoBreathingExerciseReq::clear_percet() {
  _impl_.percet_ = 0;
}
inline float DoBreathingExerciseReq::_internal_percet() const {
  return _impl_.percet_;
}
inline float DoBreathingExerciseReq::percet() const {
  // @@protoc_insertion_point(field_get:idlepb.DoBreathingExerciseReq.percet)
  return _internal_percet();
}
inline void DoBreathingExerciseReq::_internal_set_percet(float value) {
  
  _impl_.percet_ = value;
}
inline void DoBreathingExerciseReq::set_percet(float value) {
  _internal_set_percet(value);
  // @@protoc_insertion_point(field_set:idlepb.DoBreathingExerciseReq.percet)
}

// -------------------------------------------------------------------

// DoBreathingExerciseAck

// .idlepb.DoBreathingExerciseResult result = 1;
inline bool DoBreathingExerciseAck::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool DoBreathingExerciseAck::has_result() const {
  return _internal_has_result();
}
inline const ::idlepb::DoBreathingExerciseResult& DoBreathingExerciseAck::_internal_result() const {
  const ::idlepb::DoBreathingExerciseResult* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::DoBreathingExerciseResult&>(
      ::idlepb::_DoBreathingExerciseResult_default_instance_);
}
inline const ::idlepb::DoBreathingExerciseResult& DoBreathingExerciseAck::result() const {
  // @@protoc_insertion_point(field_get:idlepb.DoBreathingExerciseAck.result)
  return _internal_result();
}
inline void DoBreathingExerciseAck::unsafe_arena_set_allocated_result(
    ::idlepb::DoBreathingExerciseResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.DoBreathingExerciseAck.result)
}
inline ::idlepb::DoBreathingExerciseResult* DoBreathingExerciseAck::release_result() {
  
  ::idlepb::DoBreathingExerciseResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::DoBreathingExerciseResult* DoBreathingExerciseAck::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:idlepb.DoBreathingExerciseAck.result)
  
  ::idlepb::DoBreathingExerciseResult* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::idlepb::DoBreathingExerciseResult* DoBreathingExerciseAck::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::DoBreathingExerciseResult>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::idlepb::DoBreathingExerciseResult* DoBreathingExerciseAck::mutable_result() {
  ::idlepb::DoBreathingExerciseResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:idlepb.DoBreathingExerciseAck.result)
  return _msg;
}
inline void DoBreathingExerciseAck::set_allocated_result(::idlepb::DoBreathingExerciseResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result));
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:idlepb.DoBreathingExerciseAck.result)
}

// -------------------------------------------------------------------

// OneClickMergeBreathingReq

// -------------------------------------------------------------------

// OneClickMergeBreathingAck

// repeated float exp = 1;
inline int OneClickMergeBreathingAck::_internal_exp_size() const {
  return _impl_.exp_.size();
}
inline int OneClickMergeBreathingAck::exp_size() const {
  return _internal_exp_size();
}
inline void OneClickMergeBreathingAck::clear_exp() {
  _impl_.exp_.Clear();
}
inline float OneClickMergeBreathingAck::_internal_exp(int index) const {
  return _impl_.exp_.Get(index);
}
inline float OneClickMergeBreathingAck::exp(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.OneClickMergeBreathingAck.exp)
  return _internal_exp(index);
}
inline void OneClickMergeBreathingAck::set_exp(int index, float value) {
  _impl_.exp_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.OneClickMergeBreathingAck.exp)
}
inline void OneClickMergeBreathingAck::_internal_add_exp(float value) {
  _impl_.exp_.Add(value);
}
inline void OneClickMergeBreathingAck::add_exp(float value) {
  _internal_add_exp(value);
  // @@protoc_insertion_point(field_add:idlepb.OneClickMergeBreathingAck.exp)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
OneClickMergeBreathingAck::_internal_exp() const {
  return _impl_.exp_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
OneClickMergeBreathingAck::exp() const {
  // @@protoc_insertion_point(field_list:idlepb.OneClickMergeBreathingAck.exp)
  return _internal_exp();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
OneClickMergeBreathingAck::_internal_mutable_exp() {
  return &_impl_.exp_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
OneClickMergeBreathingAck::mutable_exp() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.OneClickMergeBreathingAck.exp)
  return _internal_mutable_exp();
}

// repeated float ret = 2;
inline int OneClickMergeBreathingAck::_internal_ret_size() const {
  return _impl_.ret_.size();
}
inline int OneClickMergeBreathingAck::ret_size() const {
  return _internal_ret_size();
}
inline void OneClickMergeBreathingAck::clear_ret() {
  _impl_.ret_.Clear();
}
inline float OneClickMergeBreathingAck::_internal_ret(int index) const {
  return _impl_.ret_.Get(index);
}
inline float OneClickMergeBreathingAck::ret(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.OneClickMergeBreathingAck.ret)
  return _internal_ret(index);
}
inline void OneClickMergeBreathingAck::set_ret(int index, float value) {
  _impl_.ret_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.OneClickMergeBreathingAck.ret)
}
inline void OneClickMergeBreathingAck::_internal_add_ret(float value) {
  _impl_.ret_.Add(value);
}
inline void OneClickMergeBreathingAck::add_ret(float value) {
  _internal_add_ret(value);
  // @@protoc_insertion_point(field_add:idlepb.OneClickMergeBreathingAck.ret)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
OneClickMergeBreathingAck::_internal_ret() const {
  return _impl_.ret_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
OneClickMergeBreathingAck::ret() const {
  // @@protoc_insertion_point(field_list:idlepb.OneClickMergeBreathingAck.ret)
  return _internal_ret();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
OneClickMergeBreathingAck::_internal_mutable_ret() {
  return &_impl_.ret_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
OneClickMergeBreathingAck::mutable_ret() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.OneClickMergeBreathingAck.ret)
  return _internal_mutable_ret();
}

// -------------------------------------------------------------------

// RequestCommonCultivationDataReq

// -------------------------------------------------------------------

// RequestCommonCultivationDataAck

// .idlepb.CommonCultivationData data = 1;
inline bool RequestCommonCultivationDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool RequestCommonCultivationDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::CommonCultivationData& RequestCommonCultivationDataAck::_internal_data() const {
  const ::idlepb::CommonCultivationData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::CommonCultivationData&>(
      ::idlepb::_CommonCultivationData_default_instance_);
}
inline const ::idlepb::CommonCultivationData& RequestCommonCultivationDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestCommonCultivationDataAck.data)
  return _internal_data();
}
inline void RequestCommonCultivationDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::CommonCultivationData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RequestCommonCultivationDataAck.data)
}
inline ::idlepb::CommonCultivationData* RequestCommonCultivationDataAck::release_data() {
  
  ::idlepb::CommonCultivationData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::CommonCultivationData* RequestCommonCultivationDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.RequestCommonCultivationDataAck.data)
  
  ::idlepb::CommonCultivationData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::CommonCultivationData* RequestCommonCultivationDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::CommonCultivationData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::CommonCultivationData* RequestCommonCultivationDataAck::mutable_data() {
  ::idlepb::CommonCultivationData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.RequestCommonCultivationDataAck.data)
  return _msg;
}
inline void RequestCommonCultivationDataAck::set_allocated_data(::idlepb::CommonCultivationData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RequestCommonCultivationDataAck.data)
}

// -------------------------------------------------------------------

// ReceiveBreathingExerciseRewardReq

// int32 index = 1;
inline void ReceiveBreathingExerciseRewardReq::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t ReceiveBreathingExerciseRewardReq::_internal_index() const {
  return _impl_.index_;
}
inline int32_t ReceiveBreathingExerciseRewardReq::index() const {
  // @@protoc_insertion_point(field_get:idlepb.ReceiveBreathingExerciseRewardReq.index)
  return _internal_index();
}
inline void ReceiveBreathingExerciseRewardReq::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void ReceiveBreathingExerciseRewardReq::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:idlepb.ReceiveBreathingExerciseRewardReq.index)
}

// -------------------------------------------------------------------

// ReceiveBreathingExerciseRewardAck

// bool ok = 1;
inline void ReceiveBreathingExerciseRewardAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ReceiveBreathingExerciseRewardAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ReceiveBreathingExerciseRewardAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ReceiveBreathingExerciseRewardAck.ok)
  return _internal_ok();
}
inline void ReceiveBreathingExerciseRewardAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ReceiveBreathingExerciseRewardAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ReceiveBreathingExerciseRewardAck.ok)
}

// -------------------------------------------------------------------

// UseItemReq

// int64 id = 1;
inline void UseItemReq::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t UseItemReq::_internal_id() const {
  return _impl_.id_;
}
inline int64_t UseItemReq::id() const {
  // @@protoc_insertion_point(field_get:idlepb.UseItemReq.id)
  return _internal_id();
}
inline void UseItemReq::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void UseItemReq::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:idlepb.UseItemReq.id)
}

// int32 cfg_id = 2;
inline void UseItemReq::clear_cfg_id() {
  _impl_.cfg_id_ = 0;
}
inline int32_t UseItemReq::_internal_cfg_id() const {
  return _impl_.cfg_id_;
}
inline int32_t UseItemReq::cfg_id() const {
  // @@protoc_insertion_point(field_get:idlepb.UseItemReq.cfg_id)
  return _internal_cfg_id();
}
inline void UseItemReq::_internal_set_cfg_id(int32_t value) {
  
  _impl_.cfg_id_ = value;
}
inline void UseItemReq::set_cfg_id(int32_t value) {
  _internal_set_cfg_id(value);
  // @@protoc_insertion_point(field_set:idlepb.UseItemReq.cfg_id)
}

// int32 num = 3;
inline void UseItemReq::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t UseItemReq::_internal_num() const {
  return _impl_.num_;
}
inline int32_t UseItemReq::num() const {
  // @@protoc_insertion_point(field_get:idlepb.UseItemReq.num)
  return _internal_num();
}
inline void UseItemReq::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void UseItemReq::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.UseItemReq.num)
}

// -------------------------------------------------------------------

// UseItemAck

// .idlepb.UseItemResult error_code = 11;
inline void UseItemAck::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::idlepb::UseItemResult UseItemAck::_internal_error_code() const {
  return static_cast< ::idlepb::UseItemResult >(_impl_.error_code_);
}
inline ::idlepb::UseItemResult UseItemAck::error_code() const {
  // @@protoc_insertion_point(field_get:idlepb.UseItemAck.error_code)
  return _internal_error_code();
}
inline void UseItemAck::_internal_set_error_code(::idlepb::UseItemResult value) {
  
  _impl_.error_code_ = value;
}
inline void UseItemAck::set_error_code(::idlepb::UseItemResult value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:idlepb.UseItemAck.error_code)
}

// -------------------------------------------------------------------

// UseSelectGiftReq

// int64 uid = 1;
inline void UseSelectGiftReq::clear_uid() {
  _impl_.uid_ = int64_t{0};
}
inline int64_t UseSelectGiftReq::_internal_uid() const {
  return _impl_.uid_;
}
inline int64_t UseSelectGiftReq::uid() const {
  // @@protoc_insertion_point(field_get:idlepb.UseSelectGiftReq.uid)
  return _internal_uid();
}
inline void UseSelectGiftReq::_internal_set_uid(int64_t value) {
  
  _impl_.uid_ = value;
}
inline void UseSelectGiftReq::set_uid(int64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.UseSelectGiftReq.uid)
}

// int32 choose_id = 2;
inline void UseSelectGiftReq::clear_choose_id() {
  _impl_.choose_id_ = 0;
}
inline int32_t UseSelectGiftReq::_internal_choose_id() const {
  return _impl_.choose_id_;
}
inline int32_t UseSelectGiftReq::choose_id() const {
  // @@protoc_insertion_point(field_get:idlepb.UseSelectGiftReq.choose_id)
  return _internal_choose_id();
}
inline void UseSelectGiftReq::_internal_set_choose_id(int32_t value) {
  
  _impl_.choose_id_ = value;
}
inline void UseSelectGiftReq::set_choose_id(int32_t value) {
  _internal_set_choose_id(value);
  // @@protoc_insertion_point(field_set:idlepb.UseSelectGiftReq.choose_id)
}

// int32 num = 3;
inline void UseSelectGiftReq::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t UseSelectGiftReq::_internal_num() const {
  return _impl_.num_;
}
inline int32_t UseSelectGiftReq::num() const {
  // @@protoc_insertion_point(field_get:idlepb.UseSelectGiftReq.num)
  return _internal_num();
}
inline void UseSelectGiftReq::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void UseSelectGiftReq::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.UseSelectGiftReq.num)
}

// -------------------------------------------------------------------

// UseSelectGiftAck

// .idlepb.UseItemResult error_code = 11;
inline void UseSelectGiftAck::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::idlepb::UseItemResult UseSelectGiftAck::_internal_error_code() const {
  return static_cast< ::idlepb::UseItemResult >(_impl_.error_code_);
}
inline ::idlepb::UseItemResult UseSelectGiftAck::error_code() const {
  // @@protoc_insertion_point(field_get:idlepb.UseSelectGiftAck.error_code)
  return _internal_error_code();
}
inline void UseSelectGiftAck::_internal_set_error_code(::idlepb::UseItemResult value) {
  
  _impl_.error_code_ = value;
}
inline void UseSelectGiftAck::set_error_code(::idlepb::UseItemResult value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:idlepb.UseSelectGiftAck.error_code)
}

// -------------------------------------------------------------------

// SellItemInfo

// int64 item_id = 1;
inline void SellItemInfo::clear_item_id() {
  _impl_.item_id_ = int64_t{0};
}
inline int64_t SellItemInfo::_internal_item_id() const {
  return _impl_.item_id_;
}
inline int64_t SellItemInfo::item_id() const {
  // @@protoc_insertion_point(field_get:idlepb.SellItemInfo.item_id)
  return _internal_item_id();
}
inline void SellItemInfo::_internal_set_item_id(int64_t value) {
  
  _impl_.item_id_ = value;
}
inline void SellItemInfo::set_item_id(int64_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:idlepb.SellItemInfo.item_id)
}

// int32 num = 2;
inline void SellItemInfo::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t SellItemInfo::_internal_num() const {
  return _impl_.num_;
}
inline int32_t SellItemInfo::num() const {
  // @@protoc_insertion_point(field_get:idlepb.SellItemInfo.num)
  return _internal_num();
}
inline void SellItemInfo::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void SellItemInfo::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.SellItemInfo.num)
}

// bool ok = 3;
inline void SellItemInfo::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SellItemInfo::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SellItemInfo::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.SellItemInfo.ok)
  return _internal_ok();
}
inline void SellItemInfo::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SellItemInfo::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.SellItemInfo.ok)
}

// -------------------------------------------------------------------

// SellItemReq

// repeated .idlepb.SellItemInfo items = 1;
inline int SellItemReq::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int SellItemReq::items_size() const {
  return _internal_items_size();
}
inline void SellItemReq::clear_items() {
  _impl_.items_.Clear();
}
inline ::idlepb::SellItemInfo* SellItemReq::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.SellItemReq.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SellItemInfo >*
SellItemReq::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.SellItemReq.items)
  return &_impl_.items_;
}
inline const ::idlepb::SellItemInfo& SellItemReq::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::SellItemInfo& SellItemReq::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.SellItemReq.items)
  return _internal_items(index);
}
inline ::idlepb::SellItemInfo* SellItemReq::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::SellItemInfo* SellItemReq::add_items() {
  ::idlepb::SellItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.SellItemReq.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SellItemInfo >&
SellItemReq::items() const {
  // @@protoc_insertion_point(field_list:idlepb.SellItemReq.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// SellItemAck

// repeated .idlepb.SellItemInfo items = 1;
inline int SellItemAck::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int SellItemAck::items_size() const {
  return _internal_items_size();
}
inline void SellItemAck::clear_items() {
  _impl_.items_.Clear();
}
inline ::idlepb::SellItemInfo* SellItemAck::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.SellItemAck.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SellItemInfo >*
SellItemAck::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.SellItemAck.items)
  return &_impl_.items_;
}
inline const ::idlepb::SellItemInfo& SellItemAck::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::SellItemInfo& SellItemAck::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.SellItemAck.items)
  return _internal_items(index);
}
inline ::idlepb::SellItemInfo* SellItemAck::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::SellItemInfo* SellItemAck::add_items() {
  ::idlepb::SellItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.SellItemAck.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SellItemInfo >&
SellItemAck::items() const {
  // @@protoc_insertion_point(field_list:idlepb.SellItemAck.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// RefreshAlchemyData

// .idlepb.RoleAlchemyData data = 1;
inline bool RefreshAlchemyData::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool RefreshAlchemyData::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleAlchemyData& RefreshAlchemyData::_internal_data() const {
  const ::idlepb::RoleAlchemyData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleAlchemyData&>(
      ::idlepb::_RoleAlchemyData_default_instance_);
}
inline const ::idlepb::RoleAlchemyData& RefreshAlchemyData::data() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshAlchemyData.data)
  return _internal_data();
}
inline void RefreshAlchemyData::unsafe_arena_set_allocated_data(
    ::idlepb::RoleAlchemyData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RefreshAlchemyData.data)
}
inline ::idlepb::RoleAlchemyData* RefreshAlchemyData::release_data() {
  
  ::idlepb::RoleAlchemyData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleAlchemyData* RefreshAlchemyData::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.RefreshAlchemyData.data)
  
  ::idlepb::RoleAlchemyData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleAlchemyData* RefreshAlchemyData::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleAlchemyData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleAlchemyData* RefreshAlchemyData::mutable_data() {
  ::idlepb::RoleAlchemyData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshAlchemyData.data)
  return _msg;
}
inline void RefreshAlchemyData::set_allocated_data(::idlepb::RoleAlchemyData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RefreshAlchemyData.data)
}

// -------------------------------------------------------------------

// NotifyAlchemyRefineResult

// .idlepb.ItemQuality quality = 1;
inline void NotifyAlchemyRefineResult::clear_quality() {
  _impl_.quality_ = 0;
}
inline ::idlepb::ItemQuality NotifyAlchemyRefineResult::_internal_quality() const {
  return static_cast< ::idlepb::ItemQuality >(_impl_.quality_);
}
inline ::idlepb::ItemQuality NotifyAlchemyRefineResult::quality() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyAlchemyRefineResult.quality)
  return _internal_quality();
}
inline void NotifyAlchemyRefineResult::_internal_set_quality(::idlepb::ItemQuality value) {
  
  _impl_.quality_ = value;
}
inline void NotifyAlchemyRefineResult::set_quality(::idlepb::ItemQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyAlchemyRefineResult.quality)
}

// int32 item_cfg_id = 2;
inline void NotifyAlchemyRefineResult::clear_item_cfg_id() {
  _impl_.item_cfg_id_ = 0;
}
inline int32_t NotifyAlchemyRefineResult::_internal_item_cfg_id() const {
  return _impl_.item_cfg_id_;
}
inline int32_t NotifyAlchemyRefineResult::item_cfg_id() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyAlchemyRefineResult.item_cfg_id)
  return _internal_item_cfg_id();
}
inline void NotifyAlchemyRefineResult::_internal_set_item_cfg_id(int32_t value) {
  
  _impl_.item_cfg_id_ = value;
}
inline void NotifyAlchemyRefineResult::set_item_cfg_id(int32_t value) {
  _internal_set_item_cfg_id(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyAlchemyRefineResult.item_cfg_id)
}

// int32 item_num = 3;
inline void NotifyAlchemyRefineResult::clear_item_num() {
  _impl_.item_num_ = 0;
}
inline int32_t NotifyAlchemyRefineResult::_internal_item_num() const {
  return _impl_.item_num_;
}
inline int32_t NotifyAlchemyRefineResult::item_num() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyAlchemyRefineResult.item_num)
  return _internal_item_num();
}
inline void NotifyAlchemyRefineResult::_internal_set_item_num(int32_t value) {
  
  _impl_.item_num_ = value;
}
inline void NotifyAlchemyRefineResult::set_item_num(int32_t value) {
  _internal_set_item_num(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyAlchemyRefineResult.item_num)
}

// int32 exp = 4;
inline void NotifyAlchemyRefineResult::clear_exp() {
  _impl_.exp_ = 0;
}
inline int32_t NotifyAlchemyRefineResult::_internal_exp() const {
  return _impl_.exp_;
}
inline int32_t NotifyAlchemyRefineResult::exp() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyAlchemyRefineResult.exp)
  return _internal_exp();
}
inline void NotifyAlchemyRefineResult::_internal_set_exp(int32_t value) {
  
  _impl_.exp_ = value;
}
inline void NotifyAlchemyRefineResult::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyAlchemyRefineResult.exp)
}

// .idlepb.AlchemyChanceType chance_type = 5;
inline void NotifyAlchemyRefineResult::clear_chance_type() {
  _impl_.chance_type_ = 0;
}
inline ::idlepb::AlchemyChanceType NotifyAlchemyRefineResult::_internal_chance_type() const {
  return static_cast< ::idlepb::AlchemyChanceType >(_impl_.chance_type_);
}
inline ::idlepb::AlchemyChanceType NotifyAlchemyRefineResult::chance_type() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyAlchemyRefineResult.chance_type)
  return _internal_chance_type();
}
inline void NotifyAlchemyRefineResult::_internal_set_chance_type(::idlepb::AlchemyChanceType value) {
  
  _impl_.chance_type_ = value;
}
inline void NotifyAlchemyRefineResult::set_chance_type(::idlepb::AlchemyChanceType value) {
  _internal_set_chance_type(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyAlchemyRefineResult.chance_type)
}

// -------------------------------------------------------------------

// RefreshForgeData

// .idlepb.RoleForgeData data = 1;
inline bool RefreshForgeData::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool RefreshForgeData::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleForgeData& RefreshForgeData::_internal_data() const {
  const ::idlepb::RoleForgeData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleForgeData&>(
      ::idlepb::_RoleForgeData_default_instance_);
}
inline const ::idlepb::RoleForgeData& RefreshForgeData::data() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshForgeData.data)
  return _internal_data();
}
inline void RefreshForgeData::unsafe_arena_set_allocated_data(
    ::idlepb::RoleForgeData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RefreshForgeData.data)
}
inline ::idlepb::RoleForgeData* RefreshForgeData::release_data() {
  
  ::idlepb::RoleForgeData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleForgeData* RefreshForgeData::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.RefreshForgeData.data)
  
  ::idlepb::RoleForgeData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleForgeData* RefreshForgeData::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleForgeData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleForgeData* RefreshForgeData::mutable_data() {
  ::idlepb::RoleForgeData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshForgeData.data)
  return _msg;
}
inline void RefreshForgeData::set_allocated_data(::idlepb::RoleForgeData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RefreshForgeData.data)
}

// -------------------------------------------------------------------

// NotifyForgeRefineResult

// .idlepb.ItemQuality quality = 1;
inline void NotifyForgeRefineResult::clear_quality() {
  _impl_.quality_ = 0;
}
inline ::idlepb::ItemQuality NotifyForgeRefineResult::_internal_quality() const {
  return static_cast< ::idlepb::ItemQuality >(_impl_.quality_);
}
inline ::idlepb::ItemQuality NotifyForgeRefineResult::quality() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyForgeRefineResult.quality)
  return _internal_quality();
}
inline void NotifyForgeRefineResult::_internal_set_quality(::idlepb::ItemQuality value) {
  
  _impl_.quality_ = value;
}
inline void NotifyForgeRefineResult::set_quality(::idlepb::ItemQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyForgeRefineResult.quality)
}

// int32 item_cfg_id = 2;
inline void NotifyForgeRefineResult::clear_item_cfg_id() {
  _impl_.item_cfg_id_ = 0;
}
inline int32_t NotifyForgeRefineResult::_internal_item_cfg_id() const {
  return _impl_.item_cfg_id_;
}
inline int32_t NotifyForgeRefineResult::item_cfg_id() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyForgeRefineResult.item_cfg_id)
  return _internal_item_cfg_id();
}
inline void NotifyForgeRefineResult::_internal_set_item_cfg_id(int32_t value) {
  
  _impl_.item_cfg_id_ = value;
}
inline void NotifyForgeRefineResult::set_item_cfg_id(int32_t value) {
  _internal_set_item_cfg_id(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyForgeRefineResult.item_cfg_id)
}

// int32 item_num = 3;
inline void NotifyForgeRefineResult::clear_item_num() {
  _impl_.item_num_ = 0;
}
inline int32_t NotifyForgeRefineResult::_internal_item_num() const {
  return _impl_.item_num_;
}
inline int32_t NotifyForgeRefineResult::item_num() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyForgeRefineResult.item_num)
  return _internal_item_num();
}
inline void NotifyForgeRefineResult::_internal_set_item_num(int32_t value) {
  
  _impl_.item_num_ = value;
}
inline void NotifyForgeRefineResult::set_item_num(int32_t value) {
  _internal_set_item_num(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyForgeRefineResult.item_num)
}

// int32 exp = 4;
inline void NotifyForgeRefineResult::clear_exp() {
  _impl_.exp_ = 0;
}
inline int32_t NotifyForgeRefineResult::_internal_exp() const {
  return _impl_.exp_;
}
inline int32_t NotifyForgeRefineResult::exp() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyForgeRefineResult.exp)
  return _internal_exp();
}
inline void NotifyForgeRefineResult::_internal_set_exp(int32_t value) {
  
  _impl_.exp_ = value;
}
inline void NotifyForgeRefineResult::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyForgeRefineResult.exp)
}

// .idlepb.ForgeChanceType chance_type = 5;
inline void NotifyForgeRefineResult::clear_chance_type() {
  _impl_.chance_type_ = 0;
}
inline ::idlepb::ForgeChanceType NotifyForgeRefineResult::_internal_chance_type() const {
  return static_cast< ::idlepb::ForgeChanceType >(_impl_.chance_type_);
}
inline ::idlepb::ForgeChanceType NotifyForgeRefineResult::chance_type() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyForgeRefineResult.chance_type)
  return _internal_chance_type();
}
inline void NotifyForgeRefineResult::_internal_set_chance_type(::idlepb::ForgeChanceType value) {
  
  _impl_.chance_type_ = value;
}
inline void NotifyForgeRefineResult::set_chance_type(::idlepb::ForgeChanceType value) {
  _internal_set_chance_type(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyForgeRefineResult.chance_type)
}

// -------------------------------------------------------------------

// EquipmentPutOnReq

// int32 slot_idx = 1;
inline void EquipmentPutOnReq::clear_slot_idx() {
  _impl_.slot_idx_ = 0;
}
inline int32_t EquipmentPutOnReq::_internal_slot_idx() const {
  return _impl_.slot_idx_;
}
inline int32_t EquipmentPutOnReq::slot_idx() const {
  // @@protoc_insertion_point(field_get:idlepb.EquipmentPutOnReq.slot_idx)
  return _internal_slot_idx();
}
inline void EquipmentPutOnReq::_internal_set_slot_idx(int32_t value) {
  
  _impl_.slot_idx_ = value;
}
inline void EquipmentPutOnReq::set_slot_idx(int32_t value) {
  _internal_set_slot_idx(value);
  // @@protoc_insertion_point(field_set:idlepb.EquipmentPutOnReq.slot_idx)
}

// uint64 item_id = 2;
inline void EquipmentPutOnReq::clear_item_id() {
  _impl_.item_id_ = uint64_t{0u};
}
inline uint64_t EquipmentPutOnReq::_internal_item_id() const {
  return _impl_.item_id_;
}
inline uint64_t EquipmentPutOnReq::item_id() const {
  // @@protoc_insertion_point(field_get:idlepb.EquipmentPutOnReq.item_id)
  return _internal_item_id();
}
inline void EquipmentPutOnReq::_internal_set_item_id(uint64_t value) {
  
  _impl_.item_id_ = value;
}
inline void EquipmentPutOnReq::set_item_id(uint64_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:idlepb.EquipmentPutOnReq.item_id)
}

// -------------------------------------------------------------------

// EquipmentPutOnAck

// bool ok = 1;
inline void EquipmentPutOnAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool EquipmentPutOnAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool EquipmentPutOnAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.EquipmentPutOnAck.ok)
  return _internal_ok();
}
inline void EquipmentPutOnAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void EquipmentPutOnAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.EquipmentPutOnAck.ok)
}

// -------------------------------------------------------------------

// EquipmentTakeOffReq

// int32 slot_idx = 1;
inline void EquipmentTakeOffReq::clear_slot_idx() {
  _impl_.slot_idx_ = 0;
}
inline int32_t EquipmentTakeOffReq::_internal_slot_idx() const {
  return _impl_.slot_idx_;
}
inline int32_t EquipmentTakeOffReq::slot_idx() const {
  // @@protoc_insertion_point(field_get:idlepb.EquipmentTakeOffReq.slot_idx)
  return _internal_slot_idx();
}
inline void EquipmentTakeOffReq::_internal_set_slot_idx(int32_t value) {
  
  _impl_.slot_idx_ = value;
}
inline void EquipmentTakeOffReq::set_slot_idx(int32_t value) {
  _internal_set_slot_idx(value);
  // @@protoc_insertion_point(field_set:idlepb.EquipmentTakeOffReq.slot_idx)
}

// -------------------------------------------------------------------

// EquipmentTakeOffAck

// bool ok = 1;
inline void EquipmentTakeOffAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool EquipmentTakeOffAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool EquipmentTakeOffAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.EquipmentTakeOffAck.ok)
  return _internal_ok();
}
inline void EquipmentTakeOffAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void EquipmentTakeOffAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.EquipmentTakeOffAck.ok)
}

// -------------------------------------------------------------------

// GetInventoryDataReq

// -------------------------------------------------------------------

// GetInventoryDataAck

// repeated .idlepb.ItemData items = 1;
inline int GetInventoryDataAck::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int GetInventoryDataAck::items_size() const {
  return _internal_items_size();
}
inline ::idlepb::ItemData* GetInventoryDataAck::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetInventoryDataAck.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >*
GetInventoryDataAck::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetInventoryDataAck.items)
  return &_impl_.items_;
}
inline const ::idlepb::ItemData& GetInventoryDataAck::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::ItemData& GetInventoryDataAck::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetInventoryDataAck.items)
  return _internal_items(index);
}
inline ::idlepb::ItemData* GetInventoryDataAck::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::ItemData* GetInventoryDataAck::add_items() {
  ::idlepb::ItemData* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.GetInventoryDataAck.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >&
GetInventoryDataAck::items() const {
  // @@protoc_insertion_point(field_list:idlepb.GetInventoryDataAck.items)
  return _impl_.items_;
}

// repeated int32 unlocked_equipment_slots = 2;
inline int GetInventoryDataAck::_internal_unlocked_equipment_slots_size() const {
  return _impl_.unlocked_equipment_slots_.size();
}
inline int GetInventoryDataAck::unlocked_equipment_slots_size() const {
  return _internal_unlocked_equipment_slots_size();
}
inline void GetInventoryDataAck::clear_unlocked_equipment_slots() {
  _impl_.unlocked_equipment_slots_.Clear();
}
inline int32_t GetInventoryDataAck::_internal_unlocked_equipment_slots(int index) const {
  return _impl_.unlocked_equipment_slots_.Get(index);
}
inline int32_t GetInventoryDataAck::unlocked_equipment_slots(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetInventoryDataAck.unlocked_equipment_slots)
  return _internal_unlocked_equipment_slots(index);
}
inline void GetInventoryDataAck::set_unlocked_equipment_slots(int index, int32_t value) {
  _impl_.unlocked_equipment_slots_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.GetInventoryDataAck.unlocked_equipment_slots)
}
inline void GetInventoryDataAck::_internal_add_unlocked_equipment_slots(int32_t value) {
  _impl_.unlocked_equipment_slots_.Add(value);
}
inline void GetInventoryDataAck::add_unlocked_equipment_slots(int32_t value) {
  _internal_add_unlocked_equipment_slots(value);
  // @@protoc_insertion_point(field_add:idlepb.GetInventoryDataAck.unlocked_equipment_slots)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetInventoryDataAck::_internal_unlocked_equipment_slots() const {
  return _impl_.unlocked_equipment_slots_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetInventoryDataAck::unlocked_equipment_slots() const {
  // @@protoc_insertion_point(field_list:idlepb.GetInventoryDataAck.unlocked_equipment_slots)
  return _internal_unlocked_equipment_slots();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetInventoryDataAck::_internal_mutable_unlocked_equipment_slots() {
  return &_impl_.unlocked_equipment_slots_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetInventoryDataAck::mutable_unlocked_equipment_slots() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetInventoryDataAck.unlocked_equipment_slots)
  return _internal_mutable_unlocked_equipment_slots();
}

// int32 inventory_space_num = 3;
inline void GetInventoryDataAck::clear_inventory_space_num() {
  _impl_.inventory_space_num_ = 0;
}
inline int32_t GetInventoryDataAck::_internal_inventory_space_num() const {
  return _impl_.inventory_space_num_;
}
inline int32_t GetInventoryDataAck::inventory_space_num() const {
  // @@protoc_insertion_point(field_get:idlepb.GetInventoryDataAck.inventory_space_num)
  return _internal_inventory_space_num();
}
inline void GetInventoryDataAck::_internal_set_inventory_space_num(int32_t value) {
  
  _impl_.inventory_space_num_ = value;
}
inline void GetInventoryDataAck::set_inventory_space_num(int32_t value) {
  _internal_set_inventory_space_num(value);
  // @@protoc_insertion_point(field_set:idlepb.GetInventoryDataAck.inventory_space_num)
}

// -------------------------------------------------------------------

// AlchemyRefineStartReq

// int32 recipe_id = 1;
inline void AlchemyRefineStartReq::clear_recipe_id() {
  _impl_.recipe_id_ = 0;
}
inline int32_t AlchemyRefineStartReq::_internal_recipe_id() const {
  return _impl_.recipe_id_;
}
inline int32_t AlchemyRefineStartReq::recipe_id() const {
  // @@protoc_insertion_point(field_get:idlepb.AlchemyRefineStartReq.recipe_id)
  return _internal_recipe_id();
}
inline void AlchemyRefineStartReq::_internal_set_recipe_id(int32_t value) {
  
  _impl_.recipe_id_ = value;
}
inline void AlchemyRefineStartReq::set_recipe_id(int32_t value) {
  _internal_set_recipe_id(value);
  // @@protoc_insertion_point(field_set:idlepb.AlchemyRefineStartReq.recipe_id)
}

// int32 material_id = 2;
inline void AlchemyRefineStartReq::clear_material_id() {
  _impl_.material_id_ = 0;
}
inline int32_t AlchemyRefineStartReq::_internal_material_id() const {
  return _impl_.material_id_;
}
inline int32_t AlchemyRefineStartReq::material_id() const {
  // @@protoc_insertion_point(field_get:idlepb.AlchemyRefineStartReq.material_id)
  return _internal_material_id();
}
inline void AlchemyRefineStartReq::_internal_set_material_id(int32_t value) {
  
  _impl_.material_id_ = value;
}
inline void AlchemyRefineStartReq::set_material_id(int32_t value) {
  _internal_set_material_id(value);
  // @@protoc_insertion_point(field_set:idlepb.AlchemyRefineStartReq.material_id)
}

// int32 target_num = 3;
inline void AlchemyRefineStartReq::clear_target_num() {
  _impl_.target_num_ = 0;
}
inline int32_t AlchemyRefineStartReq::_internal_target_num() const {
  return _impl_.target_num_;
}
inline int32_t AlchemyRefineStartReq::target_num() const {
  // @@protoc_insertion_point(field_get:idlepb.AlchemyRefineStartReq.target_num)
  return _internal_target_num();
}
inline void AlchemyRefineStartReq::_internal_set_target_num(int32_t value) {
  
  _impl_.target_num_ = value;
}
inline void AlchemyRefineStartReq::set_target_num(int32_t value) {
  _internal_set_target_num(value);
  // @@protoc_insertion_point(field_set:idlepb.AlchemyRefineStartReq.target_num)
}

// -------------------------------------------------------------------

// AlchemyRefineStartAck

// bool ok = 1;
inline void AlchemyRefineStartAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool AlchemyRefineStartAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool AlchemyRefineStartAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.AlchemyRefineStartAck.ok)
  return _internal_ok();
}
inline void AlchemyRefineStartAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void AlchemyRefineStartAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.AlchemyRefineStartAck.ok)
}

// -------------------------------------------------------------------

// AlchemyRefineCancelReq

// -------------------------------------------------------------------

// AlchemyRefineCancelAck

// bool ok = 1;
inline void AlchemyRefineCancelAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool AlchemyRefineCancelAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool AlchemyRefineCancelAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.AlchemyRefineCancelAck.ok)
  return _internal_ok();
}
inline void AlchemyRefineCancelAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void AlchemyRefineCancelAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.AlchemyRefineCancelAck.ok)
}

// -------------------------------------------------------------------

// AlchemyRefineExtractReq

// -------------------------------------------------------------------

// AlchemyRefineExtractAck

// bool ok = 1;
inline void AlchemyRefineExtractAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool AlchemyRefineExtractAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool AlchemyRefineExtractAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.AlchemyRefineExtractAck.ok)
  return _internal_ok();
}
inline void AlchemyRefineExtractAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void AlchemyRefineExtractAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.AlchemyRefineExtractAck.ok)
}

// -------------------------------------------------------------------

// CreateCharacterReq

// string hero_name = 1;
inline void CreateCharacterReq::clear_hero_name() {
  _impl_.hero_name_.ClearToEmpty();
}
inline const std::string& CreateCharacterReq::hero_name() const {
  // @@protoc_insertion_point(field_get:idlepb.CreateCharacterReq.hero_name)
  return _internal_hero_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCharacterReq::set_hero_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hero_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.CreateCharacterReq.hero_name)
}
inline std::string* CreateCharacterReq::mutable_hero_name() {
  std::string* _s = _internal_mutable_hero_name();
  // @@protoc_insertion_point(field_mutable:idlepb.CreateCharacterReq.hero_name)
  return _s;
}
inline const std::string& CreateCharacterReq::_internal_hero_name() const {
  return _impl_.hero_name_.Get();
}
inline void CreateCharacterReq::_internal_set_hero_name(const std::string& value) {
  
  _impl_.hero_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateCharacterReq::_internal_mutable_hero_name() {
  
  return _impl_.hero_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateCharacterReq::release_hero_name() {
  // @@protoc_insertion_point(field_release:idlepb.CreateCharacterReq.hero_name)
  return _impl_.hero_name_.Release();
}
inline void CreateCharacterReq::set_allocated_hero_name(std::string* hero_name) {
  if (hero_name != nullptr) {
    
  } else {
    
  }
  _impl_.hero_name_.SetAllocated(hero_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hero_name_.IsDefault()) {
    _impl_.hero_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.CreateCharacterReq.hero_name)
}

// .idlepb.CharacterModelConfig data = 2;
inline bool CreateCharacterReq::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool CreateCharacterReq::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::CharacterModelConfig& CreateCharacterReq::_internal_data() const {
  const ::idlepb::CharacterModelConfig* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::CharacterModelConfig&>(
      ::idlepb::_CharacterModelConfig_default_instance_);
}
inline const ::idlepb::CharacterModelConfig& CreateCharacterReq::data() const {
  // @@protoc_insertion_point(field_get:idlepb.CreateCharacterReq.data)
  return _internal_data();
}
inline void CreateCharacterReq::unsafe_arena_set_allocated_data(
    ::idlepb::CharacterModelConfig* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.CreateCharacterReq.data)
}
inline ::idlepb::CharacterModelConfig* CreateCharacterReq::release_data() {
  
  ::idlepb::CharacterModelConfig* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::CharacterModelConfig* CreateCharacterReq::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.CreateCharacterReq.data)
  
  ::idlepb::CharacterModelConfig* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::CharacterModelConfig* CreateCharacterReq::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::CharacterModelConfig>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::CharacterModelConfig* CreateCharacterReq::mutable_data() {
  ::idlepb::CharacterModelConfig* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.CreateCharacterReq.data)
  return _msg;
}
inline void CreateCharacterReq::set_allocated_data(::idlepb::CharacterModelConfig* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.CreateCharacterReq.data)
}

// int32 skeleton_type = 6;
inline void CreateCharacterReq::clear_skeleton_type() {
  _impl_.skeleton_type_ = 0;
}
inline int32_t CreateCharacterReq::_internal_skeleton_type() const {
  return _impl_.skeleton_type_;
}
inline int32_t CreateCharacterReq::skeleton_type() const {
  // @@protoc_insertion_point(field_get:idlepb.CreateCharacterReq.skeleton_type)
  return _internal_skeleton_type();
}
inline void CreateCharacterReq::_internal_set_skeleton_type(int32_t value) {
  
  _impl_.skeleton_type_ = value;
}
inline void CreateCharacterReq::set_skeleton_type(int32_t value) {
  _internal_set_skeleton_type(value);
  // @@protoc_insertion_point(field_set:idlepb.CreateCharacterReq.skeleton_type)
}

// repeated int32 model_data = 7;
inline int CreateCharacterReq::_internal_model_data_size() const {
  return _impl_.model_data_.size();
}
inline int CreateCharacterReq::model_data_size() const {
  return _internal_model_data_size();
}
inline void CreateCharacterReq::clear_model_data() {
  _impl_.model_data_.Clear();
}
inline int32_t CreateCharacterReq::_internal_model_data(int index) const {
  return _impl_.model_data_.Get(index);
}
inline int32_t CreateCharacterReq::model_data(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.CreateCharacterReq.model_data)
  return _internal_model_data(index);
}
inline void CreateCharacterReq::set_model_data(int index, int32_t value) {
  _impl_.model_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.CreateCharacterReq.model_data)
}
inline void CreateCharacterReq::_internal_add_model_data(int32_t value) {
  _impl_.model_data_.Add(value);
}
inline void CreateCharacterReq::add_model_data(int32_t value) {
  _internal_add_model_data(value);
  // @@protoc_insertion_point(field_add:idlepb.CreateCharacterReq.model_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
CreateCharacterReq::_internal_model_data() const {
  return _impl_.model_data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
CreateCharacterReq::model_data() const {
  // @@protoc_insertion_point(field_list:idlepb.CreateCharacterReq.model_data)
  return _internal_model_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
CreateCharacterReq::_internal_mutable_model_data() {
  return &_impl_.model_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
CreateCharacterReq::mutable_model_data() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.CreateCharacterReq.model_data)
  return _internal_mutable_model_data();
}

// -------------------------------------------------------------------

// CreateCharacterAck

// bool ok = 1;
inline void CreateCharacterAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool CreateCharacterAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool CreateCharacterAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.CreateCharacterAck.ok)
  return _internal_ok();
}
inline void CreateCharacterAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void CreateCharacterAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.CreateCharacterAck.ok)
}

// -------------------------------------------------------------------

// SystemNotice

// int32 style = 1;
inline void SystemNotice::clear_style() {
  _impl_.style_ = 0;
}
inline int32_t SystemNotice::_internal_style() const {
  return _impl_.style_;
}
inline int32_t SystemNotice::style() const {
  // @@protoc_insertion_point(field_get:idlepb.SystemNotice.style)
  return _internal_style();
}
inline void SystemNotice::_internal_set_style(int32_t value) {
  
  _impl_.style_ = value;
}
inline void SystemNotice::set_style(int32_t value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:idlepb.SystemNotice.style)
}

// string text = 2;
inline void SystemNotice::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& SystemNotice::text() const {
  // @@protoc_insertion_point(field_get:idlepb.SystemNotice.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemNotice::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.SystemNotice.text)
}
inline std::string* SystemNotice::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:idlepb.SystemNotice.text)
  return _s;
}
inline const std::string& SystemNotice::_internal_text() const {
  return _impl_.text_.Get();
}
inline void SystemNotice::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemNotice::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemNotice::release_text() {
  // @@protoc_insertion_point(field_release:idlepb.SystemNotice.text)
  return _impl_.text_.Release();
}
inline void SystemNotice::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.SystemNotice.text)
}

// string s1 = 10;
inline void SystemNotice::clear_s1() {
  _impl_.s1_.ClearToEmpty();
}
inline const std::string& SystemNotice::s1() const {
  // @@protoc_insertion_point(field_get:idlepb.SystemNotice.s1)
  return _internal_s1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemNotice::set_s1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.s1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.SystemNotice.s1)
}
inline std::string* SystemNotice::mutable_s1() {
  std::string* _s = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:idlepb.SystemNotice.s1)
  return _s;
}
inline const std::string& SystemNotice::_internal_s1() const {
  return _impl_.s1_.Get();
}
inline void SystemNotice::_internal_set_s1(const std::string& value) {
  
  _impl_.s1_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemNotice::_internal_mutable_s1() {
  
  return _impl_.s1_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemNotice::release_s1() {
  // @@protoc_insertion_point(field_release:idlepb.SystemNotice.s1)
  return _impl_.s1_.Release();
}
inline void SystemNotice::set_allocated_s1(std::string* s1) {
  if (s1 != nullptr) {
    
  } else {
    
  }
  _impl_.s1_.SetAllocated(s1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s1_.IsDefault()) {
    _impl_.s1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.SystemNotice.s1)
}

// string s2 = 11;
inline void SystemNotice::clear_s2() {
  _impl_.s2_.ClearToEmpty();
}
inline const std::string& SystemNotice::s2() const {
  // @@protoc_insertion_point(field_get:idlepb.SystemNotice.s2)
  return _internal_s2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemNotice::set_s2(ArgT0&& arg0, ArgT... args) {
 
 _impl_.s2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.SystemNotice.s2)
}
inline std::string* SystemNotice::mutable_s2() {
  std::string* _s = _internal_mutable_s2();
  // @@protoc_insertion_point(field_mutable:idlepb.SystemNotice.s2)
  return _s;
}
inline const std::string& SystemNotice::_internal_s2() const {
  return _impl_.s2_.Get();
}
inline void SystemNotice::_internal_set_s2(const std::string& value) {
  
  _impl_.s2_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemNotice::_internal_mutable_s2() {
  
  return _impl_.s2_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemNotice::release_s2() {
  // @@protoc_insertion_point(field_release:idlepb.SystemNotice.s2)
  return _impl_.s2_.Release();
}
inline void SystemNotice::set_allocated_s2(std::string* s2) {
  if (s2 != nullptr) {
    
  } else {
    
  }
  _impl_.s2_.SetAllocated(s2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s2_.IsDefault()) {
    _impl_.s2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.SystemNotice.s2)
}

// string s3 = 12;
inline void SystemNotice::clear_s3() {
  _impl_.s3_.ClearToEmpty();
}
inline const std::string& SystemNotice::s3() const {
  // @@protoc_insertion_point(field_get:idlepb.SystemNotice.s3)
  return _internal_s3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemNotice::set_s3(ArgT0&& arg0, ArgT... args) {
 
 _impl_.s3_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.SystemNotice.s3)
}
inline std::string* SystemNotice::mutable_s3() {
  std::string* _s = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:idlepb.SystemNotice.s3)
  return _s;
}
inline const std::string& SystemNotice::_internal_s3() const {
  return _impl_.s3_.Get();
}
inline void SystemNotice::_internal_set_s3(const std::string& value) {
  
  _impl_.s3_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemNotice::_internal_mutable_s3() {
  
  return _impl_.s3_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemNotice::release_s3() {
  // @@protoc_insertion_point(field_release:idlepb.SystemNotice.s3)
  return _impl_.s3_.Release();
}
inline void SystemNotice::set_allocated_s3(std::string* s3) {
  if (s3 != nullptr) {
    
  } else {
    
  }
  _impl_.s3_.SetAllocated(s3, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s3_.IsDefault()) {
    _impl_.s3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.SystemNotice.s3)
}

// int64 n1 = 20;
inline void SystemNotice::clear_n1() {
  _impl_.n1_ = int64_t{0};
}
inline int64_t SystemNotice::_internal_n1() const {
  return _impl_.n1_;
}
inline int64_t SystemNotice::n1() const {
  // @@protoc_insertion_point(field_get:idlepb.SystemNotice.n1)
  return _internal_n1();
}
inline void SystemNotice::_internal_set_n1(int64_t value) {
  
  _impl_.n1_ = value;
}
inline void SystemNotice::set_n1(int64_t value) {
  _internal_set_n1(value);
  // @@protoc_insertion_point(field_set:idlepb.SystemNotice.n1)
}

// int64 n2 = 21;
inline void SystemNotice::clear_n2() {
  _impl_.n2_ = int64_t{0};
}
inline int64_t SystemNotice::_internal_n2() const {
  return _impl_.n2_;
}
inline int64_t SystemNotice::n2() const {
  // @@protoc_insertion_point(field_get:idlepb.SystemNotice.n2)
  return _internal_n2();
}
inline void SystemNotice::_internal_set_n2(int64_t value) {
  
  _impl_.n2_ = value;
}
inline void SystemNotice::set_n2(int64_t value) {
  _internal_set_n2(value);
  // @@protoc_insertion_point(field_set:idlepb.SystemNotice.n2)
}

// int64 n3 = 22;
inline void SystemNotice::clear_n3() {
  _impl_.n3_ = int64_t{0};
}
inline int64_t SystemNotice::_internal_n3() const {
  return _impl_.n3_;
}
inline int64_t SystemNotice::n3() const {
  // @@protoc_insertion_point(field_get:idlepb.SystemNotice.n3)
  return _internal_n3();
}
inline void SystemNotice::_internal_set_n3(int64_t value) {
  
  _impl_.n3_ = value;
}
inline void SystemNotice::set_n3(int64_t value) {
  _internal_set_n3(value);
  // @@protoc_insertion_point(field_set:idlepb.SystemNotice.n3)
}

// -------------------------------------------------------------------

// GetRoleShopDataReq

// -------------------------------------------------------------------

// GetRoleShopDataAck

// .idlepb.RoleShopData data = 1;
inline bool GetRoleShopDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetRoleShopDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleShopData& GetRoleShopDataAck::_internal_data() const {
  const ::idlepb::RoleShopData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleShopData&>(
      ::idlepb::_RoleShopData_default_instance_);
}
inline const ::idlepb::RoleShopData& GetRoleShopDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleShopDataAck.data)
  return _internal_data();
}
inline void GetRoleShopDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleShopData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleShopDataAck.data)
}
inline ::idlepb::RoleShopData* GetRoleShopDataAck::release_data() {
  
  ::idlepb::RoleShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleShopData* GetRoleShopDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleShopDataAck.data)
  
  ::idlepb::RoleShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleShopData* GetRoleShopDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleShopData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleShopData* GetRoleShopDataAck::mutable_data() {
  ::idlepb::RoleShopData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleShopDataAck.data)
  return _msg;
}
inline void GetRoleShopDataAck::set_allocated_data(::idlepb::RoleShopData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleShopDataAck.data)
}

// -------------------------------------------------------------------

// RefreshShopReq

// -------------------------------------------------------------------

// RefreshShopAck

// bool ok = 1;
inline void RefreshShopAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool RefreshShopAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool RefreshShopAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshShopAck.ok)
  return _internal_ok();
}
inline void RefreshShopAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void RefreshShopAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshShopAck.ok)
}

// .idlepb.RoleShopData data = 2;
inline bool RefreshShopAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool RefreshShopAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleShopData& RefreshShopAck::_internal_data() const {
  const ::idlepb::RoleShopData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleShopData&>(
      ::idlepb::_RoleShopData_default_instance_);
}
inline const ::idlepb::RoleShopData& RefreshShopAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshShopAck.data)
  return _internal_data();
}
inline void RefreshShopAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleShopData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RefreshShopAck.data)
}
inline ::idlepb::RoleShopData* RefreshShopAck::release_data() {
  
  ::idlepb::RoleShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleShopData* RefreshShopAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.RefreshShopAck.data)
  
  ::idlepb::RoleShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleShopData* RefreshShopAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleShopData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleShopData* RefreshShopAck::mutable_data() {
  ::idlepb::RoleShopData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshShopAck.data)
  return _msg;
}
inline void RefreshShopAck::set_allocated_data(::idlepb::RoleShopData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RefreshShopAck.data)
}

// -------------------------------------------------------------------

// BuyShopItemReq

// int32 index = 1;
inline void BuyShopItemReq::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t BuyShopItemReq::_internal_index() const {
  return _impl_.index_;
}
inline int32_t BuyShopItemReq::index() const {
  // @@protoc_insertion_point(field_get:idlepb.BuyShopItemReq.index)
  return _internal_index();
}
inline void BuyShopItemReq::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void BuyShopItemReq::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:idlepb.BuyShopItemReq.index)
}

// -------------------------------------------------------------------

// BuyShopItemAck

// bool ok = 1;
inline void BuyShopItemAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool BuyShopItemAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool BuyShopItemAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.BuyShopItemAck.ok)
  return _internal_ok();
}
inline void BuyShopItemAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void BuyShopItemAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.BuyShopItemAck.ok)
}

// -------------------------------------------------------------------

// GetRoleDeluxeShopDataReq

// -------------------------------------------------------------------

// GetRoleDeluxeShopDataAck

// .idlepb.RoleDeluxeShopData data = 1;
inline bool GetRoleDeluxeShopDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetRoleDeluxeShopDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleDeluxeShopData& GetRoleDeluxeShopDataAck::_internal_data() const {
  const ::idlepb::RoleDeluxeShopData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleDeluxeShopData&>(
      ::idlepb::_RoleDeluxeShopData_default_instance_);
}
inline const ::idlepb::RoleDeluxeShopData& GetRoleDeluxeShopDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleDeluxeShopDataAck.data)
  return _internal_data();
}
inline void GetRoleDeluxeShopDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleDeluxeShopData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleDeluxeShopDataAck.data)
}
inline ::idlepb::RoleDeluxeShopData* GetRoleDeluxeShopDataAck::release_data() {
  
  ::idlepb::RoleDeluxeShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleDeluxeShopData* GetRoleDeluxeShopDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleDeluxeShopDataAck.data)
  
  ::idlepb::RoleDeluxeShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleDeluxeShopData* GetRoleDeluxeShopDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleDeluxeShopData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleDeluxeShopData* GetRoleDeluxeShopDataAck::mutable_data() {
  ::idlepb::RoleDeluxeShopData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleDeluxeShopDataAck.data)
  return _msg;
}
inline void GetRoleDeluxeShopDataAck::set_allocated_data(::idlepb::RoleDeluxeShopData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleDeluxeShopDataAck.data)
}

// -------------------------------------------------------------------

// RefreshDeluxeShopReq

// -------------------------------------------------------------------

// RefreshDeluxeShopAck

// bool ok = 1;
inline void RefreshDeluxeShopAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool RefreshDeluxeShopAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool RefreshDeluxeShopAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshDeluxeShopAck.ok)
  return _internal_ok();
}
inline void RefreshDeluxeShopAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void RefreshDeluxeShopAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshDeluxeShopAck.ok)
}

// .idlepb.RoleDeluxeShopData data = 2;
inline bool RefreshDeluxeShopAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool RefreshDeluxeShopAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleDeluxeShopData& RefreshDeluxeShopAck::_internal_data() const {
  const ::idlepb::RoleDeluxeShopData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleDeluxeShopData&>(
      ::idlepb::_RoleDeluxeShopData_default_instance_);
}
inline const ::idlepb::RoleDeluxeShopData& RefreshDeluxeShopAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshDeluxeShopAck.data)
  return _internal_data();
}
inline void RefreshDeluxeShopAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleDeluxeShopData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RefreshDeluxeShopAck.data)
}
inline ::idlepb::RoleDeluxeShopData* RefreshDeluxeShopAck::release_data() {
  
  ::idlepb::RoleDeluxeShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleDeluxeShopData* RefreshDeluxeShopAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.RefreshDeluxeShopAck.data)
  
  ::idlepb::RoleDeluxeShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleDeluxeShopData* RefreshDeluxeShopAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleDeluxeShopData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleDeluxeShopData* RefreshDeluxeShopAck::mutable_data() {
  ::idlepb::RoleDeluxeShopData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshDeluxeShopAck.data)
  return _msg;
}
inline void RefreshDeluxeShopAck::set_allocated_data(::idlepb::RoleDeluxeShopData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RefreshDeluxeShopAck.data)
}

// -------------------------------------------------------------------

// BuyDeluxeShopItemReq

// int32 index = 1;
inline void BuyDeluxeShopItemReq::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t BuyDeluxeShopItemReq::_internal_index() const {
  return _impl_.index_;
}
inline int32_t BuyDeluxeShopItemReq::index() const {
  // @@protoc_insertion_point(field_get:idlepb.BuyDeluxeShopItemReq.index)
  return _internal_index();
}
inline void BuyDeluxeShopItemReq::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void BuyDeluxeShopItemReq::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:idlepb.BuyDeluxeShopItemReq.index)
}

// -------------------------------------------------------------------

// BuyDeluxeShopItemAck

// bool ok = 1;
inline void BuyDeluxeShopItemAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool BuyDeluxeShopItemAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool BuyDeluxeShopItemAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.BuyDeluxeShopItemAck.ok)
  return _internal_ok();
}
inline void BuyDeluxeShopItemAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void BuyDeluxeShopItemAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.BuyDeluxeShopItemAck.ok)
}

// -------------------------------------------------------------------

// UnlockDeluxeShopReq

// -------------------------------------------------------------------

// UnlockDeluxeShopAck

// bool ok = 1;
inline void UnlockDeluxeShopAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool UnlockDeluxeShopAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool UnlockDeluxeShopAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.UnlockDeluxeShopAck.ok)
  return _internal_ok();
}
inline void UnlockDeluxeShopAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void UnlockDeluxeShopAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.UnlockDeluxeShopAck.ok)
}

// .idlepb.RoleDeluxeShopData data = 2;
inline bool UnlockDeluxeShopAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool UnlockDeluxeShopAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleDeluxeShopData& UnlockDeluxeShopAck::_internal_data() const {
  const ::idlepb::RoleDeluxeShopData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleDeluxeShopData&>(
      ::idlepb::_RoleDeluxeShopData_default_instance_);
}
inline const ::idlepb::RoleDeluxeShopData& UnlockDeluxeShopAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.UnlockDeluxeShopAck.data)
  return _internal_data();
}
inline void UnlockDeluxeShopAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleDeluxeShopData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.UnlockDeluxeShopAck.data)
}
inline ::idlepb::RoleDeluxeShopData* UnlockDeluxeShopAck::release_data() {
  
  ::idlepb::RoleDeluxeShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleDeluxeShopData* UnlockDeluxeShopAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.UnlockDeluxeShopAck.data)
  
  ::idlepb::RoleDeluxeShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleDeluxeShopData* UnlockDeluxeShopAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleDeluxeShopData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleDeluxeShopData* UnlockDeluxeShopAck::mutable_data() {
  ::idlepb::RoleDeluxeShopData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.UnlockDeluxeShopAck.data)
  return _msg;
}
inline void UnlockDeluxeShopAck::set_allocated_data(::idlepb::RoleDeluxeShopData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.UnlockDeluxeShopAck.data)
}

// -------------------------------------------------------------------

// RefreshDeluxeShopUnlocked

// bool is_unlocked = 1;
inline void RefreshDeluxeShopUnlocked::clear_is_unlocked() {
  _impl_.is_unlocked_ = false;
}
inline bool RefreshDeluxeShopUnlocked::_internal_is_unlocked() const {
  return _impl_.is_unlocked_;
}
inline bool RefreshDeluxeShopUnlocked::is_unlocked() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshDeluxeShopUnlocked.is_unlocked)
  return _internal_is_unlocked();
}
inline void RefreshDeluxeShopUnlocked::_internal_set_is_unlocked(bool value) {
  
  _impl_.is_unlocked_ = value;
}
inline void RefreshDeluxeShopUnlocked::set_is_unlocked(bool value) {
  _internal_set_is_unlocked(value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshDeluxeShopUnlocked.is_unlocked)
}

// -------------------------------------------------------------------

// UnlockArenaReq

// int32 arena_id = 1;
inline void UnlockArenaReq::clear_arena_id() {
  _impl_.arena_id_ = 0;
}
inline int32_t UnlockArenaReq::_internal_arena_id() const {
  return _impl_.arena_id_;
}
inline int32_t UnlockArenaReq::arena_id() const {
  // @@protoc_insertion_point(field_get:idlepb.UnlockArenaReq.arena_id)
  return _internal_arena_id();
}
inline void UnlockArenaReq::_internal_set_arena_id(int32_t value) {
  
  _impl_.arena_id_ = value;
}
inline void UnlockArenaReq::set_arena_id(int32_t value) {
  _internal_set_arena_id(value);
  // @@protoc_insertion_point(field_set:idlepb.UnlockArenaReq.arena_id)
}

// -------------------------------------------------------------------

// UnlockArenaAck

// bool ok = 1;
inline void UnlockArenaAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool UnlockArenaAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool UnlockArenaAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.UnlockArenaAck.ok)
  return _internal_ok();
}
inline void UnlockArenaAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void UnlockArenaAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.UnlockArenaAck.ok)
}

// -------------------------------------------------------------------

// NotifyUnlockArenaChallengeResult

// int32 arena_id = 1;
inline void NotifyUnlockArenaChallengeResult::clear_arena_id() {
  _impl_.arena_id_ = 0;
}
inline int32_t NotifyUnlockArenaChallengeResult::_internal_arena_id() const {
  return _impl_.arena_id_;
}
inline int32_t NotifyUnlockArenaChallengeResult::arena_id() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyUnlockArenaChallengeResult.arena_id)
  return _internal_arena_id();
}
inline void NotifyUnlockArenaChallengeResult::_internal_set_arena_id(int32_t value) {
  
  _impl_.arena_id_ = value;
}
inline void NotifyUnlockArenaChallengeResult::set_arena_id(int32_t value) {
  _internal_set_arena_id(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyUnlockArenaChallengeResult.arena_id)
}

// int32 door_id = 2;
inline void NotifyUnlockArenaChallengeResult::clear_door_id() {
  _impl_.door_id_ = 0;
}
inline int32_t NotifyUnlockArenaChallengeResult::_internal_door_id() const {
  return _impl_.door_id_;
}
inline int32_t NotifyUnlockArenaChallengeResult::door_id() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyUnlockArenaChallengeResult.door_id)
  return _internal_door_id();
}
inline void NotifyUnlockArenaChallengeResult::_internal_set_door_id(int32_t value) {
  
  _impl_.door_id_ = value;
}
inline void NotifyUnlockArenaChallengeResult::set_door_id(int32_t value) {
  _internal_set_door_id(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyUnlockArenaChallengeResult.door_id)
}

// bool ok = 3;
inline void NotifyUnlockArenaChallengeResult::clear_ok() {
  _impl_.ok_ = false;
}
inline bool NotifyUnlockArenaChallengeResult::_internal_ok() const {
  return _impl_.ok_;
}
inline bool NotifyUnlockArenaChallengeResult::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyUnlockArenaChallengeResult.ok)
  return _internal_ok();
}
inline void NotifyUnlockArenaChallengeResult::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void NotifyUnlockArenaChallengeResult::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyUnlockArenaChallengeResult.ok)
}

// -------------------------------------------------------------------

// RequestRefreshRoleCombatPower

// -------------------------------------------------------------------

// NotifyRoleCombatPower

// int64 old_value = 1;
inline void NotifyRoleCombatPower::clear_old_value() {
  _impl_.old_value_ = int64_t{0};
}
inline int64_t NotifyRoleCombatPower::_internal_old_value() const {
  return _impl_.old_value_;
}
inline int64_t NotifyRoleCombatPower::old_value() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyRoleCombatPower.old_value)
  return _internal_old_value();
}
inline void NotifyRoleCombatPower::_internal_set_old_value(int64_t value) {
  
  _impl_.old_value_ = value;
}
inline void NotifyRoleCombatPower::set_old_value(int64_t value) {
  _internal_set_old_value(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyRoleCombatPower.old_value)
}

// int64 new_value = 2;
inline void NotifyRoleCombatPower::clear_new_value() {
  _impl_.new_value_ = int64_t{0};
}
inline int64_t NotifyRoleCombatPower::_internal_new_value() const {
  return _impl_.new_value_;
}
inline int64_t NotifyRoleCombatPower::new_value() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyRoleCombatPower.new_value)
  return _internal_new_value();
}
inline void NotifyRoleCombatPower::_internal_set_new_value(int64_t value) {
  
  _impl_.new_value_ = value;
}
inline void NotifyRoleCombatPower::set_new_value(int64_t value) {
  _internal_set_new_value(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyRoleCombatPower.new_value)
}

// bool show_notice = 3;
inline void NotifyRoleCombatPower::clear_show_notice() {
  _impl_.show_notice_ = false;
}
inline bool NotifyRoleCombatPower::_internal_show_notice() const {
  return _impl_.show_notice_;
}
inline bool NotifyRoleCombatPower::show_notice() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyRoleCombatPower.show_notice)
  return _internal_show_notice();
}
inline void NotifyRoleCombatPower::_internal_set_show_notice(bool value) {
  
  _impl_.show_notice_ = value;
}
inline void NotifyRoleCombatPower::set_show_notice(bool value) {
  _internal_set_show_notice(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyRoleCombatPower.show_notice)
}

// -------------------------------------------------------------------

// GameSystemChatMessage

// int32 chat_type = 1;
inline void GameSystemChatMessage::clear_chat_type() {
  _impl_.chat_type_ = 0;
}
inline int32_t GameSystemChatMessage::_internal_chat_type() const {
  return _impl_.chat_type_;
}
inline int32_t GameSystemChatMessage::chat_type() const {
  // @@protoc_insertion_point(field_get:idlepb.GameSystemChatMessage.chat_type)
  return _internal_chat_type();
}
inline void GameSystemChatMessage::_internal_set_chat_type(int32_t value) {
  
  _impl_.chat_type_ = value;
}
inline void GameSystemChatMessage::set_chat_type(int32_t value) {
  _internal_set_chat_type(value);
  // @@protoc_insertion_point(field_set:idlepb.GameSystemChatMessage.chat_type)
}

// bytes chat_content = 10;
inline void GameSystemChatMessage::clear_chat_content() {
  _impl_.chat_content_.ClearToEmpty();
}
inline const std::string& GameSystemChatMessage::chat_content() const {
  // @@protoc_insertion_point(field_get:idlepb.GameSystemChatMessage.chat_content)
  return _internal_chat_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSystemChatMessage::set_chat_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.GameSystemChatMessage.chat_content)
}
inline std::string* GameSystemChatMessage::mutable_chat_content() {
  std::string* _s = _internal_mutable_chat_content();
  // @@protoc_insertion_point(field_mutable:idlepb.GameSystemChatMessage.chat_content)
  return _s;
}
inline const std::string& GameSystemChatMessage::_internal_chat_content() const {
  return _impl_.chat_content_.Get();
}
inline void GameSystemChatMessage::_internal_set_chat_content(const std::string& value) {
  
  _impl_.chat_content_.Set(value, GetArenaForAllocation());
}
inline std::string* GameSystemChatMessage::_internal_mutable_chat_content() {
  
  return _impl_.chat_content_.Mutable(GetArenaForAllocation());
}
inline std::string* GameSystemChatMessage::release_chat_content() {
  // @@protoc_insertion_point(field_release:idlepb.GameSystemChatMessage.chat_content)
  return _impl_.chat_content_.Release();
}
inline void GameSystemChatMessage::set_allocated_chat_content(std::string* chat_content) {
  if (chat_content != nullptr) {
    
  } else {
    
  }
  _impl_.chat_content_.SetAllocated(chat_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_content_.IsDefault()) {
    _impl_.chat_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.GameSystemChatMessage.chat_content)
}

// -------------------------------------------------------------------

// ReplicateQuestProgressChange

// int32 quest_id = 1;
inline void ReplicateQuestProgressChange::clear_quest_id() {
  _impl_.quest_id_ = 0;
}
inline int32_t ReplicateQuestProgressChange::_internal_quest_id() const {
  return _impl_.quest_id_;
}
inline int32_t ReplicateQuestProgressChange::quest_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ReplicateQuestProgressChange.quest_id)
  return _internal_quest_id();
}
inline void ReplicateQuestProgressChange::_internal_set_quest_id(int32_t value) {
  
  _impl_.quest_id_ = value;
}
inline void ReplicateQuestProgressChange::set_quest_id(int32_t value) {
  _internal_set_quest_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ReplicateQuestProgressChange.quest_id)
}

// .idlepb.QuestRequirementType type = 2;
inline void ReplicateQuestProgressChange::clear_type() {
  _impl_.type_ = 0;
}
inline ::idlepb::QuestRequirementType ReplicateQuestProgressChange::_internal_type() const {
  return static_cast< ::idlepb::QuestRequirementType >(_impl_.type_);
}
inline ::idlepb::QuestRequirementType ReplicateQuestProgressChange::type() const {
  // @@protoc_insertion_point(field_get:idlepb.ReplicateQuestProgressChange.type)
  return _internal_type();
}
inline void ReplicateQuestProgressChange::_internal_set_type(::idlepb::QuestRequirementType value) {
  
  _impl_.type_ = value;
}
inline void ReplicateQuestProgressChange::set_type(::idlepb::QuestRequirementType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:idlepb.ReplicateQuestProgressChange.type)
}

// int32 target_id = 3;
inline void ReplicateQuestProgressChange::clear_target_id() {
  _impl_.target_id_ = 0;
}
inline int32_t ReplicateQuestProgressChange::_internal_target_id() const {
  return _impl_.target_id_;
}
inline int32_t ReplicateQuestProgressChange::target_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ReplicateQuestProgressChange.target_id)
  return _internal_target_id();
}
inline void ReplicateQuestProgressChange::_internal_set_target_id(int32_t value) {
  
  _impl_.target_id_ = value;
}
inline void ReplicateQuestProgressChange::set_target_id(int32_t value) {
  _internal_set_target_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ReplicateQuestProgressChange.target_id)
}

// int32 amount = 4;
inline void ReplicateQuestProgressChange::clear_amount() {
  _impl_.amount_ = 0;
}
inline int32_t ReplicateQuestProgressChange::_internal_amount() const {
  return _impl_.amount_;
}
inline int32_t ReplicateQuestProgressChange::amount() const {
  // @@protoc_insertion_point(field_get:idlepb.ReplicateQuestProgressChange.amount)
  return _internal_amount();
}
inline void ReplicateQuestProgressChange::_internal_set_amount(int32_t value) {
  
  _impl_.amount_ = value;
}
inline void ReplicateQuestProgressChange::set_amount(int32_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:idlepb.ReplicateQuestProgressChange.amount)
}

// -------------------------------------------------------------------

// QuestOpReq

// .idlepb.QuestOpType operation = 1;
inline void QuestOpReq::clear_operation() {
  _impl_.operation_ = 0;
}
inline ::idlepb::QuestOpType QuestOpReq::_internal_operation() const {
  return static_cast< ::idlepb::QuestOpType >(_impl_.operation_);
}
inline ::idlepb::QuestOpType QuestOpReq::operation() const {
  // @@protoc_insertion_point(field_get:idlepb.QuestOpReq.operation)
  return _internal_operation();
}
inline void QuestOpReq::_internal_set_operation(::idlepb::QuestOpType value) {
  
  _impl_.operation_ = value;
}
inline void QuestOpReq::set_operation(::idlepb::QuestOpType value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:idlepb.QuestOpReq.operation)
}

// int32 quest_id = 2;
inline void QuestOpReq::clear_quest_id() {
  _impl_.quest_id_ = 0;
}
inline int32_t QuestOpReq::_internal_quest_id() const {
  return _impl_.quest_id_;
}
inline int32_t QuestOpReq::quest_id() const {
  // @@protoc_insertion_point(field_get:idlepb.QuestOpReq.quest_id)
  return _internal_quest_id();
}
inline void QuestOpReq::_internal_set_quest_id(int32_t value) {
  
  _impl_.quest_id_ = value;
}
inline void QuestOpReq::set_quest_id(int32_t value) {
  _internal_set_quest_id(value);
  // @@protoc_insertion_point(field_set:idlepb.QuestOpReq.quest_id)
}

// -------------------------------------------------------------------

// QuestOpAck

// bool ok = 1;
inline void QuestOpAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool QuestOpAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool QuestOpAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.QuestOpAck.ok)
  return _internal_ok();
}
inline void QuestOpAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void QuestOpAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.QuestOpAck.ok)
}

// repeated .idlepb.ReplicateQuestProgressChange init_progress = 2;
inline int QuestOpAck::_internal_init_progress_size() const {
  return _impl_.init_progress_.size();
}
inline int QuestOpAck::init_progress_size() const {
  return _internal_init_progress_size();
}
inline void QuestOpAck::clear_init_progress() {
  _impl_.init_progress_.Clear();
}
inline ::idlepb::ReplicateQuestProgressChange* QuestOpAck::mutable_init_progress(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.QuestOpAck.init_progress)
  return _impl_.init_progress_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ReplicateQuestProgressChange >*
QuestOpAck::mutable_init_progress() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.QuestOpAck.init_progress)
  return &_impl_.init_progress_;
}
inline const ::idlepb::ReplicateQuestProgressChange& QuestOpAck::_internal_init_progress(int index) const {
  return _impl_.init_progress_.Get(index);
}
inline const ::idlepb::ReplicateQuestProgressChange& QuestOpAck::init_progress(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.QuestOpAck.init_progress)
  return _internal_init_progress(index);
}
inline ::idlepb::ReplicateQuestProgressChange* QuestOpAck::_internal_add_init_progress() {
  return _impl_.init_progress_.Add();
}
inline ::idlepb::ReplicateQuestProgressChange* QuestOpAck::add_init_progress() {
  ::idlepb::ReplicateQuestProgressChange* _add = _internal_add_init_progress();
  // @@protoc_insertion_point(field_add:idlepb.QuestOpAck.init_progress)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ReplicateQuestProgressChange >&
QuestOpAck::init_progress() const {
  // @@protoc_insertion_point(field_list:idlepb.QuestOpAck.init_progress)
  return _impl_.init_progress_;
}

// -------------------------------------------------------------------

// GetQuestDataReq

// -------------------------------------------------------------------

// GetQuestDataAck

// .idlepb.RoleQuestData data = 1;
inline bool GetQuestDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetQuestDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleQuestData& GetQuestDataAck::_internal_data() const {
  const ::idlepb::RoleQuestData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleQuestData&>(
      ::idlepb::_RoleQuestData_default_instance_);
}
inline const ::idlepb::RoleQuestData& GetQuestDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetQuestDataAck.data)
  return _internal_data();
}
inline void GetQuestDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleQuestData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetQuestDataAck.data)
}
inline ::idlepb::RoleQuestData* GetQuestDataAck::release_data() {
  
  ::idlepb::RoleQuestData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleQuestData* GetQuestDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetQuestDataAck.data)
  
  ::idlepb::RoleQuestData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleQuestData* GetQuestDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleQuestData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleQuestData* GetQuestDataAck::mutable_data() {
  ::idlepb::RoleQuestData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetQuestDataAck.data)
  return _msg;
}
inline void GetQuestDataAck::set_allocated_data(::idlepb::RoleQuestData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetQuestDataAck.data)
}

// -------------------------------------------------------------------

// GetRoleLeaderboardDataReq

// int64 role_id = 1;
inline void GetRoleLeaderboardDataReq::clear_role_id() {
  _impl_.role_id_ = int64_t{0};
}
inline int64_t GetRoleLeaderboardDataReq::_internal_role_id() const {
  return _impl_.role_id_;
}
inline int64_t GetRoleLeaderboardDataReq::role_id() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleLeaderboardDataReq.role_id)
  return _internal_role_id();
}
inline void GetRoleLeaderboardDataReq::_internal_set_role_id(int64_t value) {
  
  _impl_.role_id_ = value;
}
inline void GetRoleLeaderboardDataReq::set_role_id(int64_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleLeaderboardDataReq.role_id)
}

// -------------------------------------------------------------------

// GetRoleLeaderboardDataAck

// .idlepb.RoleLeaderboardData data = 1;
inline bool GetRoleLeaderboardDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetRoleLeaderboardDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleLeaderboardData& GetRoleLeaderboardDataAck::_internal_data() const {
  const ::idlepb::RoleLeaderboardData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleLeaderboardData&>(
      ::idlepb::_RoleLeaderboardData_default_instance_);
}
inline const ::idlepb::RoleLeaderboardData& GetRoleLeaderboardDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleLeaderboardDataAck.data)
  return _internal_data();
}
inline void GetRoleLeaderboardDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleLeaderboardData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleLeaderboardDataAck.data)
}
inline ::idlepb::RoleLeaderboardData* GetRoleLeaderboardDataAck::release_data() {
  
  ::idlepb::RoleLeaderboardData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleLeaderboardData* GetRoleLeaderboardDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleLeaderboardDataAck.data)
  
  ::idlepb::RoleLeaderboardData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleLeaderboardData* GetRoleLeaderboardDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleLeaderboardData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleLeaderboardData* GetRoleLeaderboardDataAck::mutable_data() {
  ::idlepb::RoleLeaderboardData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleLeaderboardDataAck.data)
  return _msg;
}
inline void GetRoleLeaderboardDataAck::set_allocated_data(::idlepb::RoleLeaderboardData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleLeaderboardDataAck.data)
}

// int64 param_n1 = 11;
inline void GetRoleLeaderboardDataAck::clear_param_n1() {
  _impl_.param_n1_ = int64_t{0};
}
inline int64_t GetRoleLeaderboardDataAck::_internal_param_n1() const {
  return _impl_.param_n1_;
}
inline int64_t GetRoleLeaderboardDataAck::param_n1() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleLeaderboardDataAck.param_n1)
  return _internal_param_n1();
}
inline void GetRoleLeaderboardDataAck::_internal_set_param_n1(int64_t value) {
  
  _impl_.param_n1_ = value;
}
inline void GetRoleLeaderboardDataAck::set_param_n1(int64_t value) {
  _internal_set_param_n1(value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleLeaderboardDataAck.param_n1)
}

// repeated int32 leaderboard_rank = 12;
inline int GetRoleLeaderboardDataAck::_internal_leaderboard_rank_size() const {
  return _impl_.leaderboard_rank_.size();
}
inline int GetRoleLeaderboardDataAck::leaderboard_rank_size() const {
  return _internal_leaderboard_rank_size();
}
inline void GetRoleLeaderboardDataAck::clear_leaderboard_rank() {
  _impl_.leaderboard_rank_.Clear();
}
inline int32_t GetRoleLeaderboardDataAck::_internal_leaderboard_rank(int index) const {
  return _impl_.leaderboard_rank_.Get(index);
}
inline int32_t GetRoleLeaderboardDataAck::leaderboard_rank(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleLeaderboardDataAck.leaderboard_rank)
  return _internal_leaderboard_rank(index);
}
inline void GetRoleLeaderboardDataAck::set_leaderboard_rank(int index, int32_t value) {
  _impl_.leaderboard_rank_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleLeaderboardDataAck.leaderboard_rank)
}
inline void GetRoleLeaderboardDataAck::_internal_add_leaderboard_rank(int32_t value) {
  _impl_.leaderboard_rank_.Add(value);
}
inline void GetRoleLeaderboardDataAck::add_leaderboard_rank(int32_t value) {
  _internal_add_leaderboard_rank(value);
  // @@protoc_insertion_point(field_add:idlepb.GetRoleLeaderboardDataAck.leaderboard_rank)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetRoleLeaderboardDataAck::_internal_leaderboard_rank() const {
  return _impl_.leaderboard_rank_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetRoleLeaderboardDataAck::leaderboard_rank() const {
  // @@protoc_insertion_point(field_list:idlepb.GetRoleLeaderboardDataAck.leaderboard_rank)
  return _internal_leaderboard_rank();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetRoleLeaderboardDataAck::_internal_mutable_leaderboard_rank() {
  return &_impl_.leaderboard_rank_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetRoleLeaderboardDataAck::mutable_leaderboard_rank() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetRoleLeaderboardDataAck.leaderboard_rank)
  return _internal_mutable_leaderboard_rank();
}

// -------------------------------------------------------------------

// GetLeaderboardPreviewReq

// -------------------------------------------------------------------

// GetLeaderboardPreviewAck

// repeated .idlepb.LeaderboardListItem champions = 1;
inline int GetLeaderboardPreviewAck::_internal_champions_size() const {
  return _impl_.champions_.size();
}
inline int GetLeaderboardPreviewAck::champions_size() const {
  return _internal_champions_size();
}
inline ::idlepb::LeaderboardListItem* GetLeaderboardPreviewAck::mutable_champions(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetLeaderboardPreviewAck.champions)
  return _impl_.champions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem >*
GetLeaderboardPreviewAck::mutable_champions() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetLeaderboardPreviewAck.champions)
  return &_impl_.champions_;
}
inline const ::idlepb::LeaderboardListItem& GetLeaderboardPreviewAck::_internal_champions(int index) const {
  return _impl_.champions_.Get(index);
}
inline const ::idlepb::LeaderboardListItem& GetLeaderboardPreviewAck::champions(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardPreviewAck.champions)
  return _internal_champions(index);
}
inline ::idlepb::LeaderboardListItem* GetLeaderboardPreviewAck::_internal_add_champions() {
  return _impl_.champions_.Add();
}
inline ::idlepb::LeaderboardListItem* GetLeaderboardPreviewAck::add_champions() {
  ::idlepb::LeaderboardListItem* _add = _internal_add_champions();
  // @@protoc_insertion_point(field_add:idlepb.GetLeaderboardPreviewAck.champions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem >&
GetLeaderboardPreviewAck::champions() const {
  // @@protoc_insertion_point(field_list:idlepb.GetLeaderboardPreviewAck.champions)
  return _impl_.champions_;
}

// repeated .idlepb.CharacterModelConfig role_model_configs = 2;
inline int GetLeaderboardPreviewAck::_internal_role_model_configs_size() const {
  return _impl_.role_model_configs_.size();
}
inline int GetLeaderboardPreviewAck::role_model_configs_size() const {
  return _internal_role_model_configs_size();
}
inline ::idlepb::CharacterModelConfig* GetLeaderboardPreviewAck::mutable_role_model_configs(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetLeaderboardPreviewAck.role_model_configs)
  return _impl_.role_model_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig >*
GetLeaderboardPreviewAck::mutable_role_model_configs() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetLeaderboardPreviewAck.role_model_configs)
  return &_impl_.role_model_configs_;
}
inline const ::idlepb::CharacterModelConfig& GetLeaderboardPreviewAck::_internal_role_model_configs(int index) const {
  return _impl_.role_model_configs_.Get(index);
}
inline const ::idlepb::CharacterModelConfig& GetLeaderboardPreviewAck::role_model_configs(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardPreviewAck.role_model_configs)
  return _internal_role_model_configs(index);
}
inline ::idlepb::CharacterModelConfig* GetLeaderboardPreviewAck::_internal_add_role_model_configs() {
  return _impl_.role_model_configs_.Add();
}
inline ::idlepb::CharacterModelConfig* GetLeaderboardPreviewAck::add_role_model_configs() {
  ::idlepb::CharacterModelConfig* _add = _internal_add_role_model_configs();
  // @@protoc_insertion_point(field_add:idlepb.GetLeaderboardPreviewAck.role_model_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig >&
GetLeaderboardPreviewAck::role_model_configs() const {
  // @@protoc_insertion_point(field_list:idlepb.GetLeaderboardPreviewAck.role_model_configs)
  return _impl_.role_model_configs_;
}

// .idlepb.RoleLeaderboardData my_data = 3;
inline bool GetLeaderboardPreviewAck::_internal_has_my_data() const {
  return this != internal_default_instance() && _impl_.my_data_ != nullptr;
}
inline bool GetLeaderboardPreviewAck::has_my_data() const {
  return _internal_has_my_data();
}
inline const ::idlepb::RoleLeaderboardData& GetLeaderboardPreviewAck::_internal_my_data() const {
  const ::idlepb::RoleLeaderboardData* p = _impl_.my_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleLeaderboardData&>(
      ::idlepb::_RoleLeaderboardData_default_instance_);
}
inline const ::idlepb::RoleLeaderboardData& GetLeaderboardPreviewAck::my_data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardPreviewAck.my_data)
  return _internal_my_data();
}
inline void GetLeaderboardPreviewAck::unsafe_arena_set_allocated_my_data(
    ::idlepb::RoleLeaderboardData* my_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.my_data_);
  }
  _impl_.my_data_ = my_data;
  if (my_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetLeaderboardPreviewAck.my_data)
}
inline ::idlepb::RoleLeaderboardData* GetLeaderboardPreviewAck::release_my_data() {
  
  ::idlepb::RoleLeaderboardData* temp = _impl_.my_data_;
  _impl_.my_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleLeaderboardData* GetLeaderboardPreviewAck::unsafe_arena_release_my_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetLeaderboardPreviewAck.my_data)
  
  ::idlepb::RoleLeaderboardData* temp = _impl_.my_data_;
  _impl_.my_data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleLeaderboardData* GetLeaderboardPreviewAck::_internal_mutable_my_data() {
  
  if (_impl_.my_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleLeaderboardData>(GetArenaForAllocation());
    _impl_.my_data_ = p;
  }
  return _impl_.my_data_;
}
inline ::idlepb::RoleLeaderboardData* GetLeaderboardPreviewAck::mutable_my_data() {
  ::idlepb::RoleLeaderboardData* _msg = _internal_mutable_my_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetLeaderboardPreviewAck.my_data)
  return _msg;
}
inline void GetLeaderboardPreviewAck::set_allocated_my_data(::idlepb::RoleLeaderboardData* my_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.my_data_);
  }
  if (my_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(my_data));
    if (message_arena != submessage_arena) {
      my_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, my_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.my_data_ = my_data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetLeaderboardPreviewAck.my_data)
}

// repeated .idlepb.ItemData equipments = 4;
inline int GetLeaderboardPreviewAck::_internal_equipments_size() const {
  return _impl_.equipments_.size();
}
inline int GetLeaderboardPreviewAck::equipments_size() const {
  return _internal_equipments_size();
}
inline ::idlepb::ItemData* GetLeaderboardPreviewAck::mutable_equipments(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetLeaderboardPreviewAck.equipments)
  return _impl_.equipments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >*
GetLeaderboardPreviewAck::mutable_equipments() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetLeaderboardPreviewAck.equipments)
  return &_impl_.equipments_;
}
inline const ::idlepb::ItemData& GetLeaderboardPreviewAck::_internal_equipments(int index) const {
  return _impl_.equipments_.Get(index);
}
inline const ::idlepb::ItemData& GetLeaderboardPreviewAck::equipments(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardPreviewAck.equipments)
  return _internal_equipments(index);
}
inline ::idlepb::ItemData* GetLeaderboardPreviewAck::_internal_add_equipments() {
  return _impl_.equipments_.Add();
}
inline ::idlepb::ItemData* GetLeaderboardPreviewAck::add_equipments() {
  ::idlepb::ItemData* _add = _internal_add_equipments();
  // @@protoc_insertion_point(field_add:idlepb.GetLeaderboardPreviewAck.equipments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >&
GetLeaderboardPreviewAck::equipments() const {
  // @@protoc_insertion_point(field_list:idlepb.GetLeaderboardPreviewAck.equipments)
  return _impl_.equipments_;
}

// .idlepb.SeptDataOnLeaderboard sept = 5;
inline bool GetLeaderboardPreviewAck::_internal_has_sept() const {
  return this != internal_default_instance() && _impl_.sept_ != nullptr;
}
inline bool GetLeaderboardPreviewAck::has_sept() const {
  return _internal_has_sept();
}
inline const ::idlepb::SeptDataOnLeaderboard& GetLeaderboardPreviewAck::_internal_sept() const {
  const ::idlepb::SeptDataOnLeaderboard* p = _impl_.sept_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::SeptDataOnLeaderboard&>(
      ::idlepb::_SeptDataOnLeaderboard_default_instance_);
}
inline const ::idlepb::SeptDataOnLeaderboard& GetLeaderboardPreviewAck::sept() const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardPreviewAck.sept)
  return _internal_sept();
}
inline void GetLeaderboardPreviewAck::unsafe_arena_set_allocated_sept(
    ::idlepb::SeptDataOnLeaderboard* sept) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sept_);
  }
  _impl_.sept_ = sept;
  if (sept) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetLeaderboardPreviewAck.sept)
}
inline ::idlepb::SeptDataOnLeaderboard* GetLeaderboardPreviewAck::release_sept() {
  
  ::idlepb::SeptDataOnLeaderboard* temp = _impl_.sept_;
  _impl_.sept_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::SeptDataOnLeaderboard* GetLeaderboardPreviewAck::unsafe_arena_release_sept() {
  // @@protoc_insertion_point(field_release:idlepb.GetLeaderboardPreviewAck.sept)
  
  ::idlepb::SeptDataOnLeaderboard* temp = _impl_.sept_;
  _impl_.sept_ = nullptr;
  return temp;
}
inline ::idlepb::SeptDataOnLeaderboard* GetLeaderboardPreviewAck::_internal_mutable_sept() {
  
  if (_impl_.sept_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::SeptDataOnLeaderboard>(GetArenaForAllocation());
    _impl_.sept_ = p;
  }
  return _impl_.sept_;
}
inline ::idlepb::SeptDataOnLeaderboard* GetLeaderboardPreviewAck::mutable_sept() {
  ::idlepb::SeptDataOnLeaderboard* _msg = _internal_mutable_sept();
  // @@protoc_insertion_point(field_mutable:idlepb.GetLeaderboardPreviewAck.sept)
  return _msg;
}
inline void GetLeaderboardPreviewAck::set_allocated_sept(::idlepb::SeptDataOnLeaderboard* sept) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sept_);
  }
  if (sept) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sept));
    if (message_arena != submessage_arena) {
      sept = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sept, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sept_ = sept;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetLeaderboardPreviewAck.sept)
}

// int64 last_refresh_time = 6;
inline void GetLeaderboardPreviewAck::clear_last_refresh_time() {
  _impl_.last_refresh_time_ = int64_t{0};
}
inline int64_t GetLeaderboardPreviewAck::_internal_last_refresh_time() const {
  return _impl_.last_refresh_time_;
}
inline int64_t GetLeaderboardPreviewAck::last_refresh_time() const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardPreviewAck.last_refresh_time)
  return _internal_last_refresh_time();
}
inline void GetLeaderboardPreviewAck::_internal_set_last_refresh_time(int64_t value) {
  
  _impl_.last_refresh_time_ = value;
}
inline void GetLeaderboardPreviewAck::set_last_refresh_time(int64_t value) {
  _internal_set_last_refresh_time(value);
  // @@protoc_insertion_point(field_set:idlepb.GetLeaderboardPreviewAck.last_refresh_time)
}

// -------------------------------------------------------------------

// GetLeaderboardDataReq

// .idlepb.LeaderboardType type = 1;
inline void GetLeaderboardDataReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::idlepb::LeaderboardType GetLeaderboardDataReq::_internal_type() const {
  return static_cast< ::idlepb::LeaderboardType >(_impl_.type_);
}
inline ::idlepb::LeaderboardType GetLeaderboardDataReq::type() const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardDataReq.type)
  return _internal_type();
}
inline void GetLeaderboardDataReq::_internal_set_type(::idlepb::LeaderboardType value) {
  
  _impl_.type_ = value;
}
inline void GetLeaderboardDataReq::set_type(::idlepb::LeaderboardType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:idlepb.GetLeaderboardDataReq.type)
}

// -------------------------------------------------------------------

// GetLeaderboardDataAck

// int64 last_refresh_time = 1;
inline void GetLeaderboardDataAck::clear_last_refresh_time() {
  _impl_.last_refresh_time_ = int64_t{0};
}
inline int64_t GetLeaderboardDataAck::_internal_last_refresh_time() const {
  return _impl_.last_refresh_time_;
}
inline int64_t GetLeaderboardDataAck::last_refresh_time() const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardDataAck.last_refresh_time)
  return _internal_last_refresh_time();
}
inline void GetLeaderboardDataAck::_internal_set_last_refresh_time(int64_t value) {
  
  _impl_.last_refresh_time_ = value;
}
inline void GetLeaderboardDataAck::set_last_refresh_time(int64_t value) {
  _internal_set_last_refresh_time(value);
  // @@protoc_insertion_point(field_set:idlepb.GetLeaderboardDataAck.last_refresh_time)
}

// repeated .idlepb.LeaderboardListItem data = 2;
inline int GetLeaderboardDataAck::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int GetLeaderboardDataAck::data_size() const {
  return _internal_data_size();
}
inline ::idlepb::LeaderboardListItem* GetLeaderboardDataAck::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetLeaderboardDataAck.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem >*
GetLeaderboardDataAck::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetLeaderboardDataAck.data)
  return &_impl_.data_;
}
inline const ::idlepb::LeaderboardListItem& GetLeaderboardDataAck::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::idlepb::LeaderboardListItem& GetLeaderboardDataAck::data(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardDataAck.data)
  return _internal_data(index);
}
inline ::idlepb::LeaderboardListItem* GetLeaderboardDataAck::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::idlepb::LeaderboardListItem* GetLeaderboardDataAck::add_data() {
  ::idlepb::LeaderboardListItem* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:idlepb.GetLeaderboardDataAck.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem >&
GetLeaderboardDataAck::data() const {
  // @@protoc_insertion_point(field_list:idlepb.GetLeaderboardDataAck.data)
  return _impl_.data_;
}

// int32 my_rank = 6;
inline void GetLeaderboardDataAck::clear_my_rank() {
  _impl_.my_rank_ = 0;
}
inline int32_t GetLeaderboardDataAck::_internal_my_rank() const {
  return _impl_.my_rank_;
}
inline int32_t GetLeaderboardDataAck::my_rank() const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardDataAck.my_rank)
  return _internal_my_rank();
}
inline void GetLeaderboardDataAck::_internal_set_my_rank(int32_t value) {
  
  _impl_.my_rank_ = value;
}
inline void GetLeaderboardDataAck::set_my_rank(int32_t value) {
  _internal_set_my_rank(value);
  // @@protoc_insertion_point(field_set:idlepb.GetLeaderboardDataAck.my_rank)
}

// string rank1_message = 7;
inline void GetLeaderboardDataAck::clear_rank1_message() {
  _impl_.rank1_message_.ClearToEmpty();
}
inline const std::string& GetLeaderboardDataAck::rank1_message() const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardDataAck.rank1_message)
  return _internal_rank1_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLeaderboardDataAck::set_rank1_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rank1_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.GetLeaderboardDataAck.rank1_message)
}
inline std::string* GetLeaderboardDataAck::mutable_rank1_message() {
  std::string* _s = _internal_mutable_rank1_message();
  // @@protoc_insertion_point(field_mutable:idlepb.GetLeaderboardDataAck.rank1_message)
  return _s;
}
inline const std::string& GetLeaderboardDataAck::_internal_rank1_message() const {
  return _impl_.rank1_message_.Get();
}
inline void GetLeaderboardDataAck::_internal_set_rank1_message(const std::string& value) {
  
  _impl_.rank1_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLeaderboardDataAck::_internal_mutable_rank1_message() {
  
  return _impl_.rank1_message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLeaderboardDataAck::release_rank1_message() {
  // @@protoc_insertion_point(field_release:idlepb.GetLeaderboardDataAck.rank1_message)
  return _impl_.rank1_message_.Release();
}
inline void GetLeaderboardDataAck::set_allocated_rank1_message(std::string* rank1_message) {
  if (rank1_message != nullptr) {
    
  } else {
    
  }
  _impl_.rank1_message_.SetAllocated(rank1_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rank1_message_.IsDefault()) {
    _impl_.rank1_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetLeaderboardDataAck.rank1_message)
}

// repeated .idlepb.CharacterModelConfig role_model_configs = 9;
inline int GetLeaderboardDataAck::_internal_role_model_configs_size() const {
  return _impl_.role_model_configs_.size();
}
inline int GetLeaderboardDataAck::role_model_configs_size() const {
  return _internal_role_model_configs_size();
}
inline ::idlepb::CharacterModelConfig* GetLeaderboardDataAck::mutable_role_model_configs(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetLeaderboardDataAck.role_model_configs)
  return _impl_.role_model_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig >*
GetLeaderboardDataAck::mutable_role_model_configs() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetLeaderboardDataAck.role_model_configs)
  return &_impl_.role_model_configs_;
}
inline const ::idlepb::CharacterModelConfig& GetLeaderboardDataAck::_internal_role_model_configs(int index) const {
  return _impl_.role_model_configs_.Get(index);
}
inline const ::idlepb::CharacterModelConfig& GetLeaderboardDataAck::role_model_configs(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardDataAck.role_model_configs)
  return _internal_role_model_configs(index);
}
inline ::idlepb::CharacterModelConfig* GetLeaderboardDataAck::_internal_add_role_model_configs() {
  return _impl_.role_model_configs_.Add();
}
inline ::idlepb::CharacterModelConfig* GetLeaderboardDataAck::add_role_model_configs() {
  ::idlepb::CharacterModelConfig* _add = _internal_add_role_model_configs();
  // @@protoc_insertion_point(field_add:idlepb.GetLeaderboardDataAck.role_model_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig >&
GetLeaderboardDataAck::role_model_configs() const {
  // @@protoc_insertion_point(field_list:idlepb.GetLeaderboardDataAck.role_model_configs)
  return _impl_.role_model_configs_;
}

// repeated .idlepb.ItemData equipments = 10;
inline int GetLeaderboardDataAck::_internal_equipments_size() const {
  return _impl_.equipments_.size();
}
inline int GetLeaderboardDataAck::equipments_size() const {
  return _internal_equipments_size();
}
inline ::idlepb::ItemData* GetLeaderboardDataAck::mutable_equipments(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetLeaderboardDataAck.equipments)
  return _impl_.equipments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >*
GetLeaderboardDataAck::mutable_equipments() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetLeaderboardDataAck.equipments)
  return &_impl_.equipments_;
}
inline const ::idlepb::ItemData& GetLeaderboardDataAck::_internal_equipments(int index) const {
  return _impl_.equipments_.Get(index);
}
inline const ::idlepb::ItemData& GetLeaderboardDataAck::equipments(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardDataAck.equipments)
  return _internal_equipments(index);
}
inline ::idlepb::ItemData* GetLeaderboardDataAck::_internal_add_equipments() {
  return _impl_.equipments_.Add();
}
inline ::idlepb::ItemData* GetLeaderboardDataAck::add_equipments() {
  ::idlepb::ItemData* _add = _internal_add_equipments();
  // @@protoc_insertion_point(field_add:idlepb.GetLeaderboardDataAck.equipments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ItemData >&
GetLeaderboardDataAck::equipments() const {
  // @@protoc_insertion_point(field_list:idlepb.GetLeaderboardDataAck.equipments)
  return _impl_.equipments_;
}

// repeated .idlepb.ShanhetuRecord shanghetu_records = 11;
inline int GetLeaderboardDataAck::_internal_shanghetu_records_size() const {
  return _impl_.shanghetu_records_.size();
}
inline int GetLeaderboardDataAck::shanghetu_records_size() const {
  return _internal_shanghetu_records_size();
}
inline ::idlepb::ShanhetuRecord* GetLeaderboardDataAck::mutable_shanghetu_records(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetLeaderboardDataAck.shanghetu_records)
  return _impl_.shanghetu_records_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ShanhetuRecord >*
GetLeaderboardDataAck::mutable_shanghetu_records() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetLeaderboardDataAck.shanghetu_records)
  return &_impl_.shanghetu_records_;
}
inline const ::idlepb::ShanhetuRecord& GetLeaderboardDataAck::_internal_shanghetu_records(int index) const {
  return _impl_.shanghetu_records_.Get(index);
}
inline const ::idlepb::ShanhetuRecord& GetLeaderboardDataAck::shanghetu_records(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardDataAck.shanghetu_records)
  return _internal_shanghetu_records(index);
}
inline ::idlepb::ShanhetuRecord* GetLeaderboardDataAck::_internal_add_shanghetu_records() {
  return _impl_.shanghetu_records_.Add();
}
inline ::idlepb::ShanhetuRecord* GetLeaderboardDataAck::add_shanghetu_records() {
  ::idlepb::ShanhetuRecord* _add = _internal_add_shanghetu_records();
  // @@protoc_insertion_point(field_add:idlepb.GetLeaderboardDataAck.shanghetu_records)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ShanhetuRecord >&
GetLeaderboardDataAck::shanghetu_records() const {
  // @@protoc_insertion_point(field_list:idlepb.GetLeaderboardDataAck.shanghetu_records)
  return _impl_.shanghetu_records_;
}

// repeated int32 top3_clicklike_num = 12;
inline int GetLeaderboardDataAck::_internal_top3_clicklike_num_size() const {
  return _impl_.top3_clicklike_num_.size();
}
inline int GetLeaderboardDataAck::top3_clicklike_num_size() const {
  return _internal_top3_clicklike_num_size();
}
inline void GetLeaderboardDataAck::clear_top3_clicklike_num() {
  _impl_.top3_clicklike_num_.Clear();
}
inline int32_t GetLeaderboardDataAck::_internal_top3_clicklike_num(int index) const {
  return _impl_.top3_clicklike_num_.Get(index);
}
inline int32_t GetLeaderboardDataAck::top3_clicklike_num(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardDataAck.top3_clicklike_num)
  return _internal_top3_clicklike_num(index);
}
inline void GetLeaderboardDataAck::set_top3_clicklike_num(int index, int32_t value) {
  _impl_.top3_clicklike_num_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.GetLeaderboardDataAck.top3_clicklike_num)
}
inline void GetLeaderboardDataAck::_internal_add_top3_clicklike_num(int32_t value) {
  _impl_.top3_clicklike_num_.Add(value);
}
inline void GetLeaderboardDataAck::add_top3_clicklike_num(int32_t value) {
  _internal_add_top3_clicklike_num(value);
  // @@protoc_insertion_point(field_add:idlepb.GetLeaderboardDataAck.top3_clicklike_num)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetLeaderboardDataAck::_internal_top3_clicklike_num() const {
  return _impl_.top3_clicklike_num_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetLeaderboardDataAck::top3_clicklike_num() const {
  // @@protoc_insertion_point(field_list:idlepb.GetLeaderboardDataAck.top3_clicklike_num)
  return _internal_top3_clicklike_num();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetLeaderboardDataAck::_internal_mutable_top3_clicklike_num() {
  return &_impl_.top3_clicklike_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetLeaderboardDataAck::mutable_top3_clicklike_num() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetLeaderboardDataAck.top3_clicklike_num)
  return _internal_mutable_top3_clicklike_num();
}

// repeated .idlepb.SeptDataOnLeaderboard septs = 13;
inline int GetLeaderboardDataAck::_internal_septs_size() const {
  return _impl_.septs_.size();
}
inline int GetLeaderboardDataAck::septs_size() const {
  return _internal_septs_size();
}
inline ::idlepb::SeptDataOnLeaderboard* GetLeaderboardDataAck::mutable_septs(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetLeaderboardDataAck.septs)
  return _impl_.septs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SeptDataOnLeaderboard >*
GetLeaderboardDataAck::mutable_septs() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetLeaderboardDataAck.septs)
  return &_impl_.septs_;
}
inline const ::idlepb::SeptDataOnLeaderboard& GetLeaderboardDataAck::_internal_septs(int index) const {
  return _impl_.septs_.Get(index);
}
inline const ::idlepb::SeptDataOnLeaderboard& GetLeaderboardDataAck::septs(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetLeaderboardDataAck.septs)
  return _internal_septs(index);
}
inline ::idlepb::SeptDataOnLeaderboard* GetLeaderboardDataAck::_internal_add_septs() {
  return _impl_.septs_.Add();
}
inline ::idlepb::SeptDataOnLeaderboard* GetLeaderboardDataAck::add_septs() {
  ::idlepb::SeptDataOnLeaderboard* _add = _internal_add_septs();
  // @@protoc_insertion_point(field_add:idlepb.GetLeaderboardDataAck.septs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SeptDataOnLeaderboard >&
GetLeaderboardDataAck::septs() const {
  // @@protoc_insertion_point(field_list:idlepb.GetLeaderboardDataAck.septs)
  return _impl_.septs_;
}

// -------------------------------------------------------------------

// LeaderboardClickLikeReq

// int64 role_id = 1;
inline void LeaderboardClickLikeReq::clear_role_id() {
  _impl_.role_id_ = int64_t{0};
}
inline int64_t LeaderboardClickLikeReq::_internal_role_id() const {
  return _impl_.role_id_;
}
inline int64_t LeaderboardClickLikeReq::role_id() const {
  // @@protoc_insertion_point(field_get:idlepb.LeaderboardClickLikeReq.role_id)
  return _internal_role_id();
}
inline void LeaderboardClickLikeReq::_internal_set_role_id(int64_t value) {
  
  _impl_.role_id_ = value;
}
inline void LeaderboardClickLikeReq::set_role_id(int64_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:idlepb.LeaderboardClickLikeReq.role_id)
}

// .idlepb.LeaderboardType type = 2;
inline void LeaderboardClickLikeReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::idlepb::LeaderboardType LeaderboardClickLikeReq::_internal_type() const {
  return static_cast< ::idlepb::LeaderboardType >(_impl_.type_);
}
inline ::idlepb::LeaderboardType LeaderboardClickLikeReq::type() const {
  // @@protoc_insertion_point(field_get:idlepb.LeaderboardClickLikeReq.type)
  return _internal_type();
}
inline void LeaderboardClickLikeReq::_internal_set_type(::idlepb::LeaderboardType value) {
  
  _impl_.type_ = value;
}
inline void LeaderboardClickLikeReq::set_type(::idlepb::LeaderboardType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:idlepb.LeaderboardClickLikeReq.type)
}

// -------------------------------------------------------------------

// LeaderboardClickLikeAck

// bool ok = 1;
inline void LeaderboardClickLikeAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool LeaderboardClickLikeAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool LeaderboardClickLikeAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.LeaderboardClickLikeAck.ok)
  return _internal_ok();
}
inline void LeaderboardClickLikeAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void LeaderboardClickLikeAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.LeaderboardClickLikeAck.ok)
}

// -------------------------------------------------------------------

// LeaderboardUpdateMessageReq

// string new_message = 1;
inline void LeaderboardUpdateMessageReq::clear_new_message() {
  _impl_.new_message_.ClearToEmpty();
}
inline const std::string& LeaderboardUpdateMessageReq::new_message() const {
  // @@protoc_insertion_point(field_get:idlepb.LeaderboardUpdateMessageReq.new_message)
  return _internal_new_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LeaderboardUpdateMessageReq::set_new_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.LeaderboardUpdateMessageReq.new_message)
}
inline std::string* LeaderboardUpdateMessageReq::mutable_new_message() {
  std::string* _s = _internal_mutable_new_message();
  // @@protoc_insertion_point(field_mutable:idlepb.LeaderboardUpdateMessageReq.new_message)
  return _s;
}
inline const std::string& LeaderboardUpdateMessageReq::_internal_new_message() const {
  return _impl_.new_message_.Get();
}
inline void LeaderboardUpdateMessageReq::_internal_set_new_message(const std::string& value) {
  
  _impl_.new_message_.Set(value, GetArenaForAllocation());
}
inline std::string* LeaderboardUpdateMessageReq::_internal_mutable_new_message() {
  
  return _impl_.new_message_.Mutable(GetArenaForAllocation());
}
inline std::string* LeaderboardUpdateMessageReq::release_new_message() {
  // @@protoc_insertion_point(field_release:idlepb.LeaderboardUpdateMessageReq.new_message)
  return _impl_.new_message_.Release();
}
inline void LeaderboardUpdateMessageReq::set_allocated_new_message(std::string* new_message) {
  if (new_message != nullptr) {
    
  } else {
    
  }
  _impl_.new_message_.SetAllocated(new_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_message_.IsDefault()) {
    _impl_.new_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.LeaderboardUpdateMessageReq.new_message)
}

// -------------------------------------------------------------------

// LeaderboardUpdateMessageAck

// bool ok = 1;
inline void LeaderboardUpdateMessageAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool LeaderboardUpdateMessageAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool LeaderboardUpdateMessageAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.LeaderboardUpdateMessageAck.ok)
  return _internal_ok();
}
inline void LeaderboardUpdateMessageAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void LeaderboardUpdateMessageAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.LeaderboardUpdateMessageAck.ok)
}

// -------------------------------------------------------------------

// GetMonsterTowerChallengeListReq

// int32 challenge_id = 1;
inline void GetMonsterTowerChallengeListReq::clear_challenge_id() {
  _impl_.challenge_id_ = 0;
}
inline int32_t GetMonsterTowerChallengeListReq::_internal_challenge_id() const {
  return _impl_.challenge_id_;
}
inline int32_t GetMonsterTowerChallengeListReq::challenge_id() const {
  // @@protoc_insertion_point(field_get:idlepb.GetMonsterTowerChallengeListReq.challenge_id)
  return _internal_challenge_id();
}
inline void GetMonsterTowerChallengeListReq::_internal_set_challenge_id(int32_t value) {
  
  _impl_.challenge_id_ = value;
}
inline void GetMonsterTowerChallengeListReq::set_challenge_id(int32_t value) {
  _internal_set_challenge_id(value);
  // @@protoc_insertion_point(field_set:idlepb.GetMonsterTowerChallengeListReq.challenge_id)
}

// -------------------------------------------------------------------

// GetMonsterTowerChallengeListAck

// repeated .idlepb.LeaderboardListItem data = 1;
inline int GetMonsterTowerChallengeListAck::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int GetMonsterTowerChallengeListAck::data_size() const {
  return _internal_data_size();
}
inline ::idlepb::LeaderboardListItem* GetMonsterTowerChallengeListAck::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetMonsterTowerChallengeListAck.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem >*
GetMonsterTowerChallengeListAck::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetMonsterTowerChallengeListAck.data)
  return &_impl_.data_;
}
inline const ::idlepb::LeaderboardListItem& GetMonsterTowerChallengeListAck::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::idlepb::LeaderboardListItem& GetMonsterTowerChallengeListAck::data(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetMonsterTowerChallengeListAck.data)
  return _internal_data(index);
}
inline ::idlepb::LeaderboardListItem* GetMonsterTowerChallengeListAck::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::idlepb::LeaderboardListItem* GetMonsterTowerChallengeListAck::add_data() {
  ::idlepb::LeaderboardListItem* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:idlepb.GetMonsterTowerChallengeListAck.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LeaderboardListItem >&
GetMonsterTowerChallengeListAck::data() const {
  // @@protoc_insertion_point(field_list:idlepb.GetMonsterTowerChallengeListAck.data)
  return _impl_.data_;
}

// repeated .idlepb.CharacterModelConfig model_configs = 2;
inline int GetMonsterTowerChallengeListAck::_internal_model_configs_size() const {
  return _impl_.model_configs_.size();
}
inline int GetMonsterTowerChallengeListAck::model_configs_size() const {
  return _internal_model_configs_size();
}
inline ::idlepb::CharacterModelConfig* GetMonsterTowerChallengeListAck::mutable_model_configs(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetMonsterTowerChallengeListAck.model_configs)
  return _impl_.model_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig >*
GetMonsterTowerChallengeListAck::mutable_model_configs() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetMonsterTowerChallengeListAck.model_configs)
  return &_impl_.model_configs_;
}
inline const ::idlepb::CharacterModelConfig& GetMonsterTowerChallengeListAck::_internal_model_configs(int index) const {
  return _impl_.model_configs_.Get(index);
}
inline const ::idlepb::CharacterModelConfig& GetMonsterTowerChallengeListAck::model_configs(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetMonsterTowerChallengeListAck.model_configs)
  return _internal_model_configs(index);
}
inline ::idlepb::CharacterModelConfig* GetMonsterTowerChallengeListAck::_internal_add_model_configs() {
  return _impl_.model_configs_.Add();
}
inline ::idlepb::CharacterModelConfig* GetMonsterTowerChallengeListAck::add_model_configs() {
  ::idlepb::CharacterModelConfig* _add = _internal_add_model_configs();
  // @@protoc_insertion_point(field_add:idlepb.GetMonsterTowerChallengeListAck.model_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CharacterModelConfig >&
GetMonsterTowerChallengeListAck::model_configs() const {
  // @@protoc_insertion_point(field_list:idlepb.GetMonsterTowerChallengeListAck.model_configs)
  return _impl_.model_configs_;
}

// repeated int32 all_list_progress = 3;
inline int GetMonsterTowerChallengeListAck::_internal_all_list_progress_size() const {
  return _impl_.all_list_progress_.size();
}
inline int GetMonsterTowerChallengeListAck::all_list_progress_size() const {
  return _internal_all_list_progress_size();
}
inline void GetMonsterTowerChallengeListAck::clear_all_list_progress() {
  _impl_.all_list_progress_.Clear();
}
inline int32_t GetMonsterTowerChallengeListAck::_internal_all_list_progress(int index) const {
  return _impl_.all_list_progress_.Get(index);
}
inline int32_t GetMonsterTowerChallengeListAck::all_list_progress(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetMonsterTowerChallengeListAck.all_list_progress)
  return _internal_all_list_progress(index);
}
inline void GetMonsterTowerChallengeListAck::set_all_list_progress(int index, int32_t value) {
  _impl_.all_list_progress_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.GetMonsterTowerChallengeListAck.all_list_progress)
}
inline void GetMonsterTowerChallengeListAck::_internal_add_all_list_progress(int32_t value) {
  _impl_.all_list_progress_.Add(value);
}
inline void GetMonsterTowerChallengeListAck::add_all_list_progress(int32_t value) {
  _internal_add_all_list_progress(value);
  // @@protoc_insertion_point(field_add:idlepb.GetMonsterTowerChallengeListAck.all_list_progress)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetMonsterTowerChallengeListAck::_internal_all_list_progress() const {
  return _impl_.all_list_progress_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetMonsterTowerChallengeListAck::all_list_progress() const {
  // @@protoc_insertion_point(field_list:idlepb.GetMonsterTowerChallengeListAck.all_list_progress)
  return _internal_all_list_progress();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetMonsterTowerChallengeListAck::_internal_mutable_all_list_progress() {
  return &_impl_.all_list_progress_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetMonsterTowerChallengeListAck::mutable_all_list_progress() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetMonsterTowerChallengeListAck.all_list_progress)
  return _internal_mutable_all_list_progress();
}

// -------------------------------------------------------------------

// GetMonsterTowerChallengeRewardReq

// int32 challenge_id = 1;
inline void GetMonsterTowerChallengeRewardReq::clear_challenge_id() {
  _impl_.challenge_id_ = 0;
}
inline int32_t GetMonsterTowerChallengeRewardReq::_internal_challenge_id() const {
  return _impl_.challenge_id_;
}
inline int32_t GetMonsterTowerChallengeRewardReq::challenge_id() const {
  // @@protoc_insertion_point(field_get:idlepb.GetMonsterTowerChallengeRewardReq.challenge_id)
  return _internal_challenge_id();
}
inline void GetMonsterTowerChallengeRewardReq::_internal_set_challenge_id(int32_t value) {
  
  _impl_.challenge_id_ = value;
}
inline void GetMonsterTowerChallengeRewardReq::set_challenge_id(int32_t value) {
  _internal_set_challenge_id(value);
  // @@protoc_insertion_point(field_set:idlepb.GetMonsterTowerChallengeRewardReq.challenge_id)
}

// -------------------------------------------------------------------

// GetMonsterTowerChallengeRewardAck

// bool ok = 1;
inline void GetMonsterTowerChallengeRewardAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool GetMonsterTowerChallengeRewardAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool GetMonsterTowerChallengeRewardAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.GetMonsterTowerChallengeRewardAck.ok)
  return _internal_ok();
}
inline void GetMonsterTowerChallengeRewardAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void GetMonsterTowerChallengeRewardAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.GetMonsterTowerChallengeRewardAck.ok)
}

// -------------------------------------------------------------------

// GetFuZeRewardReq

// -------------------------------------------------------------------

// GetFuZeRewardAck

// bool ok = 1;
inline void GetFuZeRewardAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool GetFuZeRewardAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool GetFuZeRewardAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.GetFuZeRewardAck.ok)
  return _internal_ok();
}
inline void GetFuZeRewardAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void GetFuZeRewardAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.GetFuZeRewardAck.ok)
}

// -------------------------------------------------------------------

// GetRoleMailDataReq

// bool only_num = 1;
inline void GetRoleMailDataReq::clear_only_num() {
  _impl_.only_num_ = false;
}
inline bool GetRoleMailDataReq::_internal_only_num() const {
  return _impl_.only_num_;
}
inline bool GetRoleMailDataReq::only_num() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleMailDataReq.only_num)
  return _internal_only_num();
}
inline void GetRoleMailDataReq::_internal_set_only_num(bool value) {
  
  _impl_.only_num_ = value;
}
inline void GetRoleMailDataReq::set_only_num(bool value) {
  _internal_set_only_num(value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleMailDataReq.only_num)
}

// -------------------------------------------------------------------

// GetRoleMailDataAck

// int32 unread_mail_num = 1;
inline void GetRoleMailDataAck::clear_unread_mail_num() {
  _impl_.unread_mail_num_ = 0;
}
inline int32_t GetRoleMailDataAck::_internal_unread_mail_num() const {
  return _impl_.unread_mail_num_;
}
inline int32_t GetRoleMailDataAck::unread_mail_num() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleMailDataAck.unread_mail_num)
  return _internal_unread_mail_num();
}
inline void GetRoleMailDataAck::_internal_set_unread_mail_num(int32_t value) {
  
  _impl_.unread_mail_num_ = value;
}
inline void GetRoleMailDataAck::set_unread_mail_num(int32_t value) {
  _internal_set_unread_mail_num(value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleMailDataAck.unread_mail_num)
}

// repeated .idlepb.Mail mail_box = 2;
inline int GetRoleMailDataAck::_internal_mail_box_size() const {
  return _impl_.mail_box_.size();
}
inline int GetRoleMailDataAck::mail_box_size() const {
  return _internal_mail_box_size();
}
inline ::idlepb::Mail* GetRoleMailDataAck::mutable_mail_box(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleMailDataAck.mail_box)
  return _impl_.mail_box_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Mail >*
GetRoleMailDataAck::mutable_mail_box() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetRoleMailDataAck.mail_box)
  return &_impl_.mail_box_;
}
inline const ::idlepb::Mail& GetRoleMailDataAck::_internal_mail_box(int index) const {
  return _impl_.mail_box_.Get(index);
}
inline const ::idlepb::Mail& GetRoleMailDataAck::mail_box(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleMailDataAck.mail_box)
  return _internal_mail_box(index);
}
inline ::idlepb::Mail* GetRoleMailDataAck::_internal_add_mail_box() {
  return _impl_.mail_box_.Add();
}
inline ::idlepb::Mail* GetRoleMailDataAck::add_mail_box() {
  ::idlepb::Mail* _add = _internal_add_mail_box();
  // @@protoc_insertion_point(field_add:idlepb.GetRoleMailDataAck.mail_box)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Mail >&
GetRoleMailDataAck::mail_box() const {
  // @@protoc_insertion_point(field_list:idlepb.GetRoleMailDataAck.mail_box)
  return _impl_.mail_box_;
}

// -------------------------------------------------------------------

// UpdateRoleMail

// -------------------------------------------------------------------

// ReadMailReq

// int32 index = 1;
inline void ReadMailReq::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t ReadMailReq::_internal_index() const {
  return _impl_.index_;
}
inline int32_t ReadMailReq::index() const {
  // @@protoc_insertion_point(field_get:idlepb.ReadMailReq.index)
  return _internal_index();
}
inline void ReadMailReq::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void ReadMailReq::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:idlepb.ReadMailReq.index)
}

// -------------------------------------------------------------------

// ReadMailAck

// bool ok = 1;
inline void ReadMailAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ReadMailAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ReadMailAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ReadMailAck.ok)
  return _internal_ok();
}
inline void ReadMailAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ReadMailAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ReadMailAck.ok)
}

// .idlepb.Mail mail = 2;
inline bool ReadMailAck::_internal_has_mail() const {
  return this != internal_default_instance() && _impl_.mail_ != nullptr;
}
inline bool ReadMailAck::has_mail() const {
  return _internal_has_mail();
}
inline const ::idlepb::Mail& ReadMailAck::_internal_mail() const {
  const ::idlepb::Mail* p = _impl_.mail_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::Mail&>(
      ::idlepb::_Mail_default_instance_);
}
inline const ::idlepb::Mail& ReadMailAck::mail() const {
  // @@protoc_insertion_point(field_get:idlepb.ReadMailAck.mail)
  return _internal_mail();
}
inline void ReadMailAck::unsafe_arena_set_allocated_mail(
    ::idlepb::Mail* mail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mail_);
  }
  _impl_.mail_ = mail;
  if (mail) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.ReadMailAck.mail)
}
inline ::idlepb::Mail* ReadMailAck::release_mail() {
  
  ::idlepb::Mail* temp = _impl_.mail_;
  _impl_.mail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::Mail* ReadMailAck::unsafe_arena_release_mail() {
  // @@protoc_insertion_point(field_release:idlepb.ReadMailAck.mail)
  
  ::idlepb::Mail* temp = _impl_.mail_;
  _impl_.mail_ = nullptr;
  return temp;
}
inline ::idlepb::Mail* ReadMailAck::_internal_mutable_mail() {
  
  if (_impl_.mail_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::Mail>(GetArenaForAllocation());
    _impl_.mail_ = p;
  }
  return _impl_.mail_;
}
inline ::idlepb::Mail* ReadMailAck::mutable_mail() {
  ::idlepb::Mail* _msg = _internal_mutable_mail();
  // @@protoc_insertion_point(field_mutable:idlepb.ReadMailAck.mail)
  return _msg;
}
inline void ReadMailAck::set_allocated_mail(::idlepb::Mail* mail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mail_);
  }
  if (mail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mail));
    if (message_arena != submessage_arena) {
      mail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mail, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mail_ = mail;
  // @@protoc_insertion_point(field_set_allocated:idlepb.ReadMailAck.mail)
}

// -------------------------------------------------------------------

// GetMailAttachmentReq

// int32 index = 1;
inline void GetMailAttachmentReq::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t GetMailAttachmentReq::_internal_index() const {
  return _impl_.index_;
}
inline int32_t GetMailAttachmentReq::index() const {
  // @@protoc_insertion_point(field_get:idlepb.GetMailAttachmentReq.index)
  return _internal_index();
}
inline void GetMailAttachmentReq::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void GetMailAttachmentReq::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:idlepb.GetMailAttachmentReq.index)
}

// -------------------------------------------------------------------

// GetMailAttachmentAck

// .idlepb.MailOperation result = 1;
inline void GetMailAttachmentAck::clear_result() {
  _impl_.result_ = 0;
}
inline ::idlepb::MailOperation GetMailAttachmentAck::_internal_result() const {
  return static_cast< ::idlepb::MailOperation >(_impl_.result_);
}
inline ::idlepb::MailOperation GetMailAttachmentAck::result() const {
  // @@protoc_insertion_point(field_get:idlepb.GetMailAttachmentAck.result)
  return _internal_result();
}
inline void GetMailAttachmentAck::_internal_set_result(::idlepb::MailOperation value) {
  
  _impl_.result_ = value;
}
inline void GetMailAttachmentAck::set_result(::idlepb::MailOperation value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:idlepb.GetMailAttachmentAck.result)
}

// .idlepb.Mail mail_data = 2;
inline bool GetMailAttachmentAck::_internal_has_mail_data() const {
  return this != internal_default_instance() && _impl_.mail_data_ != nullptr;
}
inline bool GetMailAttachmentAck::has_mail_data() const {
  return _internal_has_mail_data();
}
inline const ::idlepb::Mail& GetMailAttachmentAck::_internal_mail_data() const {
  const ::idlepb::Mail* p = _impl_.mail_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::Mail&>(
      ::idlepb::_Mail_default_instance_);
}
inline const ::idlepb::Mail& GetMailAttachmentAck::mail_data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetMailAttachmentAck.mail_data)
  return _internal_mail_data();
}
inline void GetMailAttachmentAck::unsafe_arena_set_allocated_mail_data(
    ::idlepb::Mail* mail_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mail_data_);
  }
  _impl_.mail_data_ = mail_data;
  if (mail_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetMailAttachmentAck.mail_data)
}
inline ::idlepb::Mail* GetMailAttachmentAck::release_mail_data() {
  
  ::idlepb::Mail* temp = _impl_.mail_data_;
  _impl_.mail_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::Mail* GetMailAttachmentAck::unsafe_arena_release_mail_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetMailAttachmentAck.mail_data)
  
  ::idlepb::Mail* temp = _impl_.mail_data_;
  _impl_.mail_data_ = nullptr;
  return temp;
}
inline ::idlepb::Mail* GetMailAttachmentAck::_internal_mutable_mail_data() {
  
  if (_impl_.mail_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::Mail>(GetArenaForAllocation());
    _impl_.mail_data_ = p;
  }
  return _impl_.mail_data_;
}
inline ::idlepb::Mail* GetMailAttachmentAck::mutable_mail_data() {
  ::idlepb::Mail* _msg = _internal_mutable_mail_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetMailAttachmentAck.mail_data)
  return _msg;
}
inline void GetMailAttachmentAck::set_allocated_mail_data(::idlepb::Mail* mail_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mail_data_);
  }
  if (mail_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mail_data));
    if (message_arena != submessage_arena) {
      mail_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mail_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mail_data_ = mail_data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetMailAttachmentAck.mail_data)
}

// -------------------------------------------------------------------

// DeleteMailReq

// int32 index = 1;
inline void DeleteMailReq::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t DeleteMailReq::_internal_index() const {
  return _impl_.index_;
}
inline int32_t DeleteMailReq::index() const {
  // @@protoc_insertion_point(field_get:idlepb.DeleteMailReq.index)
  return _internal_index();
}
inline void DeleteMailReq::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void DeleteMailReq::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:idlepb.DeleteMailReq.index)
}

// -------------------------------------------------------------------

// DeleteMailAck

// bool ok = 1;
inline void DeleteMailAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool DeleteMailAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool DeleteMailAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.DeleteMailAck.ok)
  return _internal_ok();
}
inline void DeleteMailAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void DeleteMailAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.DeleteMailAck.ok)
}

// -------------------------------------------------------------------

// OneClickGetMailAttachmentReq

// -------------------------------------------------------------------

// OneClickGetMailAttachmentAck

// .idlepb.MailOperation result = 1;
inline void OneClickGetMailAttachmentAck::clear_result() {
  _impl_.result_ = 0;
}
inline ::idlepb::MailOperation OneClickGetMailAttachmentAck::_internal_result() const {
  return static_cast< ::idlepb::MailOperation >(_impl_.result_);
}
inline ::idlepb::MailOperation OneClickGetMailAttachmentAck::result() const {
  // @@protoc_insertion_point(field_get:idlepb.OneClickGetMailAttachmentAck.result)
  return _internal_result();
}
inline void OneClickGetMailAttachmentAck::_internal_set_result(::idlepb::MailOperation value) {
  
  _impl_.result_ = value;
}
inline void OneClickGetMailAttachmentAck::set_result(::idlepb::MailOperation value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:idlepb.OneClickGetMailAttachmentAck.result)
}

// int32 unread_mail_num = 2;
inline void OneClickGetMailAttachmentAck::clear_unread_mail_num() {
  _impl_.unread_mail_num_ = 0;
}
inline int32_t OneClickGetMailAttachmentAck::_internal_unread_mail_num() const {
  return _impl_.unread_mail_num_;
}
inline int32_t OneClickGetMailAttachmentAck::unread_mail_num() const {
  // @@protoc_insertion_point(field_get:idlepb.OneClickGetMailAttachmentAck.unread_mail_num)
  return _internal_unread_mail_num();
}
inline void OneClickGetMailAttachmentAck::_internal_set_unread_mail_num(int32_t value) {
  
  _impl_.unread_mail_num_ = value;
}
inline void OneClickGetMailAttachmentAck::set_unread_mail_num(int32_t value) {
  _internal_set_unread_mail_num(value);
  // @@protoc_insertion_point(field_set:idlepb.OneClickGetMailAttachmentAck.unread_mail_num)
}

// repeated .idlepb.Mail mail_box = 3;
inline int OneClickGetMailAttachmentAck::_internal_mail_box_size() const {
  return _impl_.mail_box_.size();
}
inline int OneClickGetMailAttachmentAck::mail_box_size() const {
  return _internal_mail_box_size();
}
inline ::idlepb::Mail* OneClickGetMailAttachmentAck::mutable_mail_box(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.OneClickGetMailAttachmentAck.mail_box)
  return _impl_.mail_box_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Mail >*
OneClickGetMailAttachmentAck::mutable_mail_box() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.OneClickGetMailAttachmentAck.mail_box)
  return &_impl_.mail_box_;
}
inline const ::idlepb::Mail& OneClickGetMailAttachmentAck::_internal_mail_box(int index) const {
  return _impl_.mail_box_.Get(index);
}
inline const ::idlepb::Mail& OneClickGetMailAttachmentAck::mail_box(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.OneClickGetMailAttachmentAck.mail_box)
  return _internal_mail_box(index);
}
inline ::idlepb::Mail* OneClickGetMailAttachmentAck::_internal_add_mail_box() {
  return _impl_.mail_box_.Add();
}
inline ::idlepb::Mail* OneClickGetMailAttachmentAck::add_mail_box() {
  ::idlepb::Mail* _add = _internal_add_mail_box();
  // @@protoc_insertion_point(field_add:idlepb.OneClickGetMailAttachmentAck.mail_box)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Mail >&
OneClickGetMailAttachmentAck::mail_box() const {
  // @@protoc_insertion_point(field_list:idlepb.OneClickGetMailAttachmentAck.mail_box)
  return _impl_.mail_box_;
}

// -------------------------------------------------------------------

// OneClickReadMailReq

// -------------------------------------------------------------------

// OneClickReadMailAck

// bool ok = 1;
inline void OneClickReadMailAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool OneClickReadMailAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool OneClickReadMailAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.OneClickReadMailAck.ok)
  return _internal_ok();
}
inline void OneClickReadMailAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void OneClickReadMailAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.OneClickReadMailAck.ok)
}

// -------------------------------------------------------------------

// OneClickDeleteMailReq

// -------------------------------------------------------------------

// OneClickDeleteMailAck

// repeated int32 deleted_index = 1;
inline int OneClickDeleteMailAck::_internal_deleted_index_size() const {
  return _impl_.deleted_index_.size();
}
inline int OneClickDeleteMailAck::deleted_index_size() const {
  return _internal_deleted_index_size();
}
inline void OneClickDeleteMailAck::clear_deleted_index() {
  _impl_.deleted_index_.Clear();
}
inline int32_t OneClickDeleteMailAck::_internal_deleted_index(int index) const {
  return _impl_.deleted_index_.Get(index);
}
inline int32_t OneClickDeleteMailAck::deleted_index(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.OneClickDeleteMailAck.deleted_index)
  return _internal_deleted_index(index);
}
inline void OneClickDeleteMailAck::set_deleted_index(int index, int32_t value) {
  _impl_.deleted_index_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.OneClickDeleteMailAck.deleted_index)
}
inline void OneClickDeleteMailAck::_internal_add_deleted_index(int32_t value) {
  _impl_.deleted_index_.Add(value);
}
inline void OneClickDeleteMailAck::add_deleted_index(int32_t value) {
  _internal_add_deleted_index(value);
  // @@protoc_insertion_point(field_add:idlepb.OneClickDeleteMailAck.deleted_index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
OneClickDeleteMailAck::_internal_deleted_index() const {
  return _impl_.deleted_index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
OneClickDeleteMailAck::deleted_index() const {
  // @@protoc_insertion_point(field_list:idlepb.OneClickDeleteMailAck.deleted_index)
  return _internal_deleted_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
OneClickDeleteMailAck::_internal_mutable_deleted_index() {
  return &_impl_.deleted_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
OneClickDeleteMailAck::mutable_deleted_index() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.OneClickDeleteMailAck.deleted_index)
  return _internal_mutable_deleted_index();
}

// -------------------------------------------------------------------

// UnlockFunctionModuleReq

// .idlepb.FunctionModuleType type = 1;
inline void UnlockFunctionModuleReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::idlepb::FunctionModuleType UnlockFunctionModuleReq::_internal_type() const {
  return static_cast< ::idlepb::FunctionModuleType >(_impl_.type_);
}
inline ::idlepb::FunctionModuleType UnlockFunctionModuleReq::type() const {
  // @@protoc_insertion_point(field_get:idlepb.UnlockFunctionModuleReq.type)
  return _internal_type();
}
inline void UnlockFunctionModuleReq::_internal_set_type(::idlepb::FunctionModuleType value) {
  
  _impl_.type_ = value;
}
inline void UnlockFunctionModuleReq::set_type(::idlepb::FunctionModuleType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:idlepb.UnlockFunctionModuleReq.type)
}

// -------------------------------------------------------------------

// UnlockFunctionModuleAck

// bool ok = 1;
inline void UnlockFunctionModuleAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool UnlockFunctionModuleAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool UnlockFunctionModuleAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.UnlockFunctionModuleAck.ok)
  return _internal_ok();
}
inline void UnlockFunctionModuleAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void UnlockFunctionModuleAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.UnlockFunctionModuleAck.ok)
}

// -------------------------------------------------------------------

// NotifyUnlockedModuels

// repeated int32 unlocked_modules = 1;
inline int NotifyUnlockedModuels::_internal_unlocked_modules_size() const {
  return _impl_.unlocked_modules_.size();
}
inline int NotifyUnlockedModuels::unlocked_modules_size() const {
  return _internal_unlocked_modules_size();
}
inline void NotifyUnlockedModuels::clear_unlocked_modules() {
  _impl_.unlocked_modules_.Clear();
}
inline int32_t NotifyUnlockedModuels::_internal_unlocked_modules(int index) const {
  return _impl_.unlocked_modules_.Get(index);
}
inline int32_t NotifyUnlockedModuels::unlocked_modules(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyUnlockedModuels.unlocked_modules)
  return _internal_unlocked_modules(index);
}
inline void NotifyUnlockedModuels::set_unlocked_modules(int index, int32_t value) {
  _impl_.unlocked_modules_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyUnlockedModuels.unlocked_modules)
}
inline void NotifyUnlockedModuels::_internal_add_unlocked_modules(int32_t value) {
  _impl_.unlocked_modules_.Add(value);
}
inline void NotifyUnlockedModuels::add_unlocked_modules(int32_t value) {
  _internal_add_unlocked_modules(value);
  // @@protoc_insertion_point(field_add:idlepb.NotifyUnlockedModuels.unlocked_modules)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
NotifyUnlockedModuels::_internal_unlocked_modules() const {
  return _impl_.unlocked_modules_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
NotifyUnlockedModuels::unlocked_modules() const {
  // @@protoc_insertion_point(field_list:idlepb.NotifyUnlockedModuels.unlocked_modules)
  return _internal_unlocked_modules();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
NotifyUnlockedModuels::_internal_mutable_unlocked_modules() {
  return &_impl_.unlocked_modules_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
NotifyUnlockedModuels::mutable_unlocked_modules() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.NotifyUnlockedModuels.unlocked_modules)
  return _internal_mutable_unlocked_modules();
}

// -------------------------------------------------------------------

// UpdateChat

// .idlepb.ChatMessageChannel channel = 1;
inline void UpdateChat::clear_channel() {
  _impl_.channel_ = 0;
}
inline ::idlepb::ChatMessageChannel UpdateChat::_internal_channel() const {
  return static_cast< ::idlepb::ChatMessageChannel >(_impl_.channel_);
}
inline ::idlepb::ChatMessageChannel UpdateChat::channel() const {
  // @@protoc_insertion_point(field_get:idlepb.UpdateChat.channel)
  return _internal_channel();
}
inline void UpdateChat::_internal_set_channel(::idlepb::ChatMessageChannel value) {
  
  _impl_.channel_ = value;
}
inline void UpdateChat::set_channel(::idlepb::ChatMessageChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:idlepb.UpdateChat.channel)
}

// .idlepb.ChatMessage chat_message = 2;
inline bool UpdateChat::_internal_has_chat_message() const {
  return this != internal_default_instance() && _impl_.chat_message_ != nullptr;
}
inline bool UpdateChat::has_chat_message() const {
  return _internal_has_chat_message();
}
inline const ::idlepb::ChatMessage& UpdateChat::_internal_chat_message() const {
  const ::idlepb::ChatMessage* p = _impl_.chat_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::ChatMessage&>(
      ::idlepb::_ChatMessage_default_instance_);
}
inline const ::idlepb::ChatMessage& UpdateChat::chat_message() const {
  // @@protoc_insertion_point(field_get:idlepb.UpdateChat.chat_message)
  return _internal_chat_message();
}
inline void UpdateChat::unsafe_arena_set_allocated_chat_message(
    ::idlepb::ChatMessage* chat_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chat_message_);
  }
  _impl_.chat_message_ = chat_message;
  if (chat_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.UpdateChat.chat_message)
}
inline ::idlepb::ChatMessage* UpdateChat::release_chat_message() {
  
  ::idlepb::ChatMessage* temp = _impl_.chat_message_;
  _impl_.chat_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::ChatMessage* UpdateChat::unsafe_arena_release_chat_message() {
  // @@protoc_insertion_point(field_release:idlepb.UpdateChat.chat_message)
  
  ::idlepb::ChatMessage* temp = _impl_.chat_message_;
  _impl_.chat_message_ = nullptr;
  return temp;
}
inline ::idlepb::ChatMessage* UpdateChat::_internal_mutable_chat_message() {
  
  if (_impl_.chat_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::ChatMessage>(GetArenaForAllocation());
    _impl_.chat_message_ = p;
  }
  return _impl_.chat_message_;
}
inline ::idlepb::ChatMessage* UpdateChat::mutable_chat_message() {
  ::idlepb::ChatMessage* _msg = _internal_mutable_chat_message();
  // @@protoc_insertion_point(field_mutable:idlepb.UpdateChat.chat_message)
  return _msg;
}
inline void UpdateChat::set_allocated_chat_message(::idlepb::ChatMessage* chat_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chat_message_);
  }
  if (chat_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chat_message));
    if (message_arena != submessage_arena) {
      chat_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chat_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chat_message_ = chat_message;
  // @@protoc_insertion_point(field_set_allocated:idlepb.UpdateChat.chat_message)
}

// -------------------------------------------------------------------

// SendChatMessageReq

// uint64 role_id = 1;
inline void SendChatMessageReq::clear_role_id() {
  _impl_.role_id_ = uint64_t{0u};
}
inline uint64_t SendChatMessageReq::_internal_role_id() const {
  return _impl_.role_id_;
}
inline uint64_t SendChatMessageReq::role_id() const {
  // @@protoc_insertion_point(field_get:idlepb.SendChatMessageReq.role_id)
  return _internal_role_id();
}
inline void SendChatMessageReq::_internal_set_role_id(uint64_t value) {
  
  _impl_.role_id_ = value;
}
inline void SendChatMessageReq::set_role_id(uint64_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:idlepb.SendChatMessageReq.role_id)
}

// .idlepb.ChatMessageChannel channel = 2;
inline void SendChatMessageReq::clear_channel() {
  _impl_.channel_ = 0;
}
inline ::idlepb::ChatMessageChannel SendChatMessageReq::_internal_channel() const {
  return static_cast< ::idlepb::ChatMessageChannel >(_impl_.channel_);
}
inline ::idlepb::ChatMessageChannel SendChatMessageReq::channel() const {
  // @@protoc_insertion_point(field_get:idlepb.SendChatMessageReq.channel)
  return _internal_channel();
}
inline void SendChatMessageReq::_internal_set_channel(::idlepb::ChatMessageChannel value) {
  
  _impl_.channel_ = value;
}
inline void SendChatMessageReq::set_channel(::idlepb::ChatMessageChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:idlepb.SendChatMessageReq.channel)
}

// string text = 3;
inline void SendChatMessageReq::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& SendChatMessageReq::text() const {
  // @@protoc_insertion_point(field_get:idlepb.SendChatMessageReq.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendChatMessageReq::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.SendChatMessageReq.text)
}
inline std::string* SendChatMessageReq::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:idlepb.SendChatMessageReq.text)
  return _s;
}
inline const std::string& SendChatMessageReq::_internal_text() const {
  return _impl_.text_.Get();
}
inline void SendChatMessageReq::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* SendChatMessageReq::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* SendChatMessageReq::release_text() {
  // @@protoc_insertion_point(field_release:idlepb.SendChatMessageReq.text)
  return _impl_.text_.Release();
}
inline void SendChatMessageReq::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.SendChatMessageReq.text)
}

// .idlepb.ChatMessageType type = 4;
inline void SendChatMessageReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::idlepb::ChatMessageType SendChatMessageReq::_internal_type() const {
  return static_cast< ::idlepb::ChatMessageType >(_impl_.type_);
}
inline ::idlepb::ChatMessageType SendChatMessageReq::type() const {
  // @@protoc_insertion_point(field_get:idlepb.SendChatMessageReq.type)
  return _internal_type();
}
inline void SendChatMessageReq::_internal_set_type(::idlepb::ChatMessageType value) {
  
  _impl_.type_ = value;
}
inline void SendChatMessageReq::set_type(::idlepb::ChatMessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:idlepb.SendChatMessageReq.type)
}

// -------------------------------------------------------------------

// SendChatMessageAck

// bool ok = 1;
inline void SendChatMessageAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SendChatMessageAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SendChatMessageAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.SendChatMessageAck.ok)
  return _internal_ok();
}
inline void SendChatMessageAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SendChatMessageAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.SendChatMessageAck.ok)
}

// -------------------------------------------------------------------

// GetChatRecordReq

// -------------------------------------------------------------------

// GetChatRecordAck

// .idlepb.ChatData public_chat_record = 1;
inline bool GetChatRecordAck::_internal_has_public_chat_record() const {
  return this != internal_default_instance() && _impl_.public_chat_record_ != nullptr;
}
inline bool GetChatRecordAck::has_public_chat_record() const {
  return _internal_has_public_chat_record();
}
inline const ::idlepb::ChatData& GetChatRecordAck::_internal_public_chat_record() const {
  const ::idlepb::ChatData* p = _impl_.public_chat_record_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::ChatData&>(
      ::idlepb::_ChatData_default_instance_);
}
inline const ::idlepb::ChatData& GetChatRecordAck::public_chat_record() const {
  // @@protoc_insertion_point(field_get:idlepb.GetChatRecordAck.public_chat_record)
  return _internal_public_chat_record();
}
inline void GetChatRecordAck::unsafe_arena_set_allocated_public_chat_record(
    ::idlepb::ChatData* public_chat_record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_chat_record_);
  }
  _impl_.public_chat_record_ = public_chat_record;
  if (public_chat_record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetChatRecordAck.public_chat_record)
}
inline ::idlepb::ChatData* GetChatRecordAck::release_public_chat_record() {
  
  ::idlepb::ChatData* temp = _impl_.public_chat_record_;
  _impl_.public_chat_record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::ChatData* GetChatRecordAck::unsafe_arena_release_public_chat_record() {
  // @@protoc_insertion_point(field_release:idlepb.GetChatRecordAck.public_chat_record)
  
  ::idlepb::ChatData* temp = _impl_.public_chat_record_;
  _impl_.public_chat_record_ = nullptr;
  return temp;
}
inline ::idlepb::ChatData* GetChatRecordAck::_internal_mutable_public_chat_record() {
  
  if (_impl_.public_chat_record_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::ChatData>(GetArenaForAllocation());
    _impl_.public_chat_record_ = p;
  }
  return _impl_.public_chat_record_;
}
inline ::idlepb::ChatData* GetChatRecordAck::mutable_public_chat_record() {
  ::idlepb::ChatData* _msg = _internal_mutable_public_chat_record();
  // @@protoc_insertion_point(field_mutable:idlepb.GetChatRecordAck.public_chat_record)
  return _msg;
}
inline void GetChatRecordAck::set_allocated_public_chat_record(::idlepb::ChatData* public_chat_record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_chat_record_);
  }
  if (public_chat_record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_chat_record));
    if (message_arena != submessage_arena) {
      public_chat_record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_chat_record, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.public_chat_record_ = public_chat_record;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetChatRecordAck.public_chat_record)
}

// .idlepb.RolePrivateChatRecord private_chat_record = 2;
inline bool GetChatRecordAck::_internal_has_private_chat_record() const {
  return this != internal_default_instance() && _impl_.private_chat_record_ != nullptr;
}
inline bool GetChatRecordAck::has_private_chat_record() const {
  return _internal_has_private_chat_record();
}
inline const ::idlepb::RolePrivateChatRecord& GetChatRecordAck::_internal_private_chat_record() const {
  const ::idlepb::RolePrivateChatRecord* p = _impl_.private_chat_record_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RolePrivateChatRecord&>(
      ::idlepb::_RolePrivateChatRecord_default_instance_);
}
inline const ::idlepb::RolePrivateChatRecord& GetChatRecordAck::private_chat_record() const {
  // @@protoc_insertion_point(field_get:idlepb.GetChatRecordAck.private_chat_record)
  return _internal_private_chat_record();
}
inline void GetChatRecordAck::unsafe_arena_set_allocated_private_chat_record(
    ::idlepb::RolePrivateChatRecord* private_chat_record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.private_chat_record_);
  }
  _impl_.private_chat_record_ = private_chat_record;
  if (private_chat_record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetChatRecordAck.private_chat_record)
}
inline ::idlepb::RolePrivateChatRecord* GetChatRecordAck::release_private_chat_record() {
  
  ::idlepb::RolePrivateChatRecord* temp = _impl_.private_chat_record_;
  _impl_.private_chat_record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RolePrivateChatRecord* GetChatRecordAck::unsafe_arena_release_private_chat_record() {
  // @@protoc_insertion_point(field_release:idlepb.GetChatRecordAck.private_chat_record)
  
  ::idlepb::RolePrivateChatRecord* temp = _impl_.private_chat_record_;
  _impl_.private_chat_record_ = nullptr;
  return temp;
}
inline ::idlepb::RolePrivateChatRecord* GetChatRecordAck::_internal_mutable_private_chat_record() {
  
  if (_impl_.private_chat_record_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RolePrivateChatRecord>(GetArenaForAllocation());
    _impl_.private_chat_record_ = p;
  }
  return _impl_.private_chat_record_;
}
inline ::idlepb::RolePrivateChatRecord* GetChatRecordAck::mutable_private_chat_record() {
  ::idlepb::RolePrivateChatRecord* _msg = _internal_mutable_private_chat_record();
  // @@protoc_insertion_point(field_mutable:idlepb.GetChatRecordAck.private_chat_record)
  return _msg;
}
inline void GetChatRecordAck::set_allocated_private_chat_record(::idlepb::RolePrivateChatRecord* private_chat_record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.private_chat_record_);
  }
  if (private_chat_record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(private_chat_record));
    if (message_arena != submessage_arena) {
      private_chat_record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, private_chat_record, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.private_chat_record_ = private_chat_record;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetChatRecordAck.private_chat_record)
}

// repeated .idlepb.ChatMessage sept_record = 3;
inline int GetChatRecordAck::_internal_sept_record_size() const {
  return _impl_.sept_record_.size();
}
inline int GetChatRecordAck::sept_record_size() const {
  return _internal_sept_record_size();
}
inline ::idlepb::ChatMessage* GetChatRecordAck::mutable_sept_record(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetChatRecordAck.sept_record)
  return _impl_.sept_record_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ChatMessage >*
GetChatRecordAck::mutable_sept_record() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetChatRecordAck.sept_record)
  return &_impl_.sept_record_;
}
inline const ::idlepb::ChatMessage& GetChatRecordAck::_internal_sept_record(int index) const {
  return _impl_.sept_record_.Get(index);
}
inline const ::idlepb::ChatMessage& GetChatRecordAck::sept_record(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetChatRecordAck.sept_record)
  return _internal_sept_record(index);
}
inline ::idlepb::ChatMessage* GetChatRecordAck::_internal_add_sept_record() {
  return _impl_.sept_record_.Add();
}
inline ::idlepb::ChatMessage* GetChatRecordAck::add_sept_record() {
  ::idlepb::ChatMessage* _add = _internal_add_sept_record();
  // @@protoc_insertion_point(field_add:idlepb.GetChatRecordAck.sept_record)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::ChatMessage >&
GetChatRecordAck::sept_record() const {
  // @@protoc_insertion_point(field_list:idlepb.GetChatRecordAck.sept_record)
  return _impl_.sept_record_;
}

// -------------------------------------------------------------------

// DeletePrivateChatRecordReq

// uint64 role_id = 1;
inline void DeletePrivateChatRecordReq::clear_role_id() {
  _impl_.role_id_ = uint64_t{0u};
}
inline uint64_t DeletePrivateChatRecordReq::_internal_role_id() const {
  return _impl_.role_id_;
}
inline uint64_t DeletePrivateChatRecordReq::role_id() const {
  // @@protoc_insertion_point(field_get:idlepb.DeletePrivateChatRecordReq.role_id)
  return _internal_role_id();
}
inline void DeletePrivateChatRecordReq::_internal_set_role_id(uint64_t value) {
  
  _impl_.role_id_ = value;
}
inline void DeletePrivateChatRecordReq::set_role_id(uint64_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:idlepb.DeletePrivateChatRecordReq.role_id)
}

// -------------------------------------------------------------------

// DeletePrivateChatRecordAck

// bool ok = 1;
inline void DeletePrivateChatRecordAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool DeletePrivateChatRecordAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool DeletePrivateChatRecordAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.DeletePrivateChatRecordAck.ok)
  return _internal_ok();
}
inline void DeletePrivateChatRecordAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void DeletePrivateChatRecordAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.DeletePrivateChatRecordAck.ok)
}

// -------------------------------------------------------------------

// ClearChatUnreadNumReq

// uint64 role_id = 1;
inline void ClearChatUnreadNumReq::clear_role_id() {
  _impl_.role_id_ = uint64_t{0u};
}
inline uint64_t ClearChatUnreadNumReq::_internal_role_id() const {
  return _impl_.role_id_;
}
inline uint64_t ClearChatUnreadNumReq::role_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ClearChatUnreadNumReq.role_id)
  return _internal_role_id();
}
inline void ClearChatUnreadNumReq::_internal_set_role_id(uint64_t value) {
  
  _impl_.role_id_ = value;
}
inline void ClearChatUnreadNumReq::set_role_id(uint64_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ClearChatUnreadNumReq.role_id)
}

// -------------------------------------------------------------------

// ClearChatUnreadNumAck

// -------------------------------------------------------------------

// GetRoleInfoCacheReq

// repeated uint64 role_ids = 1;
inline int GetRoleInfoCacheReq::_internal_role_ids_size() const {
  return _impl_.role_ids_.size();
}
inline int GetRoleInfoCacheReq::role_ids_size() const {
  return _internal_role_ids_size();
}
inline void GetRoleInfoCacheReq::clear_role_ids() {
  _impl_.role_ids_.Clear();
}
inline uint64_t GetRoleInfoCacheReq::_internal_role_ids(int index) const {
  return _impl_.role_ids_.Get(index);
}
inline uint64_t GetRoleInfoCacheReq::role_ids(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleInfoCacheReq.role_ids)
  return _internal_role_ids(index);
}
inline void GetRoleInfoCacheReq::set_role_ids(int index, uint64_t value) {
  _impl_.role_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleInfoCacheReq.role_ids)
}
inline void GetRoleInfoCacheReq::_internal_add_role_ids(uint64_t value) {
  _impl_.role_ids_.Add(value);
}
inline void GetRoleInfoCacheReq::add_role_ids(uint64_t value) {
  _internal_add_role_ids(value);
  // @@protoc_insertion_point(field_add:idlepb.GetRoleInfoCacheReq.role_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
GetRoleInfoCacheReq::_internal_role_ids() const {
  return _impl_.role_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
GetRoleInfoCacheReq::role_ids() const {
  // @@protoc_insertion_point(field_list:idlepb.GetRoleInfoCacheReq.role_ids)
  return _internal_role_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
GetRoleInfoCacheReq::_internal_mutable_role_ids() {
  return &_impl_.role_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
GetRoleInfoCacheReq::mutable_role_ids() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetRoleInfoCacheReq.role_ids)
  return _internal_mutable_role_ids();
}

// -------------------------------------------------------------------

// GetRoleInfoCacheAck

// repeated .idlepb.SimpleRoleInfo role_infos = 1;
inline int GetRoleInfoCacheAck::_internal_role_infos_size() const {
  return _impl_.role_infos_.size();
}
inline int GetRoleInfoCacheAck::role_infos_size() const {
  return _internal_role_infos_size();
}
inline ::idlepb::SimpleRoleInfo* GetRoleInfoCacheAck::mutable_role_infos(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleInfoCacheAck.role_infos)
  return _impl_.role_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo >*
GetRoleInfoCacheAck::mutable_role_infos() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetRoleInfoCacheAck.role_infos)
  return &_impl_.role_infos_;
}
inline const ::idlepb::SimpleRoleInfo& GetRoleInfoCacheAck::_internal_role_infos(int index) const {
  return _impl_.role_infos_.Get(index);
}
inline const ::idlepb::SimpleRoleInfo& GetRoleInfoCacheAck::role_infos(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleInfoCacheAck.role_infos)
  return _internal_role_infos(index);
}
inline ::idlepb::SimpleRoleInfo* GetRoleInfoCacheAck::_internal_add_role_infos() {
  return _impl_.role_infos_.Add();
}
inline ::idlepb::SimpleRoleInfo* GetRoleInfoCacheAck::add_role_infos() {
  ::idlepb::SimpleRoleInfo* _add = _internal_add_role_infos();
  // @@protoc_insertion_point(field_add:idlepb.GetRoleInfoCacheAck.role_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo >&
GetRoleInfoCacheAck::role_infos() const {
  // @@protoc_insertion_point(field_list:idlepb.GetRoleInfoCacheAck.role_infos)
  return _impl_.role_infos_;
}

// -------------------------------------------------------------------

// ForgeRefineStartReq

// int32 recipe_id = 1;
inline void ForgeRefineStartReq::clear_recipe_id() {
  _impl_.recipe_id_ = 0;
}
inline int32_t ForgeRefineStartReq::_internal_recipe_id() const {
  return _impl_.recipe_id_;
}
inline int32_t ForgeRefineStartReq::recipe_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeRefineStartReq.recipe_id)
  return _internal_recipe_id();
}
inline void ForgeRefineStartReq::_internal_set_recipe_id(int32_t value) {
  
  _impl_.recipe_id_ = value;
}
inline void ForgeRefineStartReq::set_recipe_id(int32_t value) {
  _internal_set_recipe_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeRefineStartReq.recipe_id)
}

// int32 material_id = 2;
inline void ForgeRefineStartReq::clear_material_id() {
  _impl_.material_id_ = 0;
}
inline int32_t ForgeRefineStartReq::_internal_material_id() const {
  return _impl_.material_id_;
}
inline int32_t ForgeRefineStartReq::material_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeRefineStartReq.material_id)
  return _internal_material_id();
}
inline void ForgeRefineStartReq::_internal_set_material_id(int32_t value) {
  
  _impl_.material_id_ = value;
}
inline void ForgeRefineStartReq::set_material_id(int32_t value) {
  _internal_set_material_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeRefineStartReq.material_id)
}

// int32 ext_material_id = 3;
inline void ForgeRefineStartReq::clear_ext_material_id() {
  _impl_.ext_material_id_ = 0;
}
inline int32_t ForgeRefineStartReq::_internal_ext_material_id() const {
  return _impl_.ext_material_id_;
}
inline int32_t ForgeRefineStartReq::ext_material_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeRefineStartReq.ext_material_id)
  return _internal_ext_material_id();
}
inline void ForgeRefineStartReq::_internal_set_ext_material_id(int32_t value) {
  
  _impl_.ext_material_id_ = value;
}
inline void ForgeRefineStartReq::set_ext_material_id(int32_t value) {
  _internal_set_ext_material_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeRefineStartReq.ext_material_id)
}

// int32 target_num = 4;
inline void ForgeRefineStartReq::clear_target_num() {
  _impl_.target_num_ = 0;
}
inline int32_t ForgeRefineStartReq::_internal_target_num() const {
  return _impl_.target_num_;
}
inline int32_t ForgeRefineStartReq::target_num() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeRefineStartReq.target_num)
  return _internal_target_num();
}
inline void ForgeRefineStartReq::_internal_set_target_num(int32_t value) {
  
  _impl_.target_num_ = value;
}
inline void ForgeRefineStartReq::set_target_num(int32_t value) {
  _internal_set_target_num(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeRefineStartReq.target_num)
}

// bool auto_sell_poor = 5;
inline void ForgeRefineStartReq::clear_auto_sell_poor() {
  _impl_.auto_sell_poor_ = false;
}
inline bool ForgeRefineStartReq::_internal_auto_sell_poor() const {
  return _impl_.auto_sell_poor_;
}
inline bool ForgeRefineStartReq::auto_sell_poor() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeRefineStartReq.auto_sell_poor)
  return _internal_auto_sell_poor();
}
inline void ForgeRefineStartReq::_internal_set_auto_sell_poor(bool value) {
  
  _impl_.auto_sell_poor_ = value;
}
inline void ForgeRefineStartReq::set_auto_sell_poor(bool value) {
  _internal_set_auto_sell_poor(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeRefineStartReq.auto_sell_poor)
}

// bool auto_sell_middle = 6;
inline void ForgeRefineStartReq::clear_auto_sell_middle() {
  _impl_.auto_sell_middle_ = false;
}
inline bool ForgeRefineStartReq::_internal_auto_sell_middle() const {
  return _impl_.auto_sell_middle_;
}
inline bool ForgeRefineStartReq::auto_sell_middle() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeRefineStartReq.auto_sell_middle)
  return _internal_auto_sell_middle();
}
inline void ForgeRefineStartReq::_internal_set_auto_sell_middle(bool value) {
  
  _impl_.auto_sell_middle_ = value;
}
inline void ForgeRefineStartReq::set_auto_sell_middle(bool value) {
  _internal_set_auto_sell_middle(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeRefineStartReq.auto_sell_middle)
}

// -------------------------------------------------------------------

// ForgeRefineStartAck

// bool ok = 1;
inline void ForgeRefineStartAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ForgeRefineStartAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ForgeRefineStartAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeRefineStartAck.ok)
  return _internal_ok();
}
inline void ForgeRefineStartAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ForgeRefineStartAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeRefineStartAck.ok)
}

// -------------------------------------------------------------------

// ForgeRefineCancelReq

// -------------------------------------------------------------------

// ForgeRefineCancelAck

// bool ok = 1;
inline void ForgeRefineCancelAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ForgeRefineCancelAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ForgeRefineCancelAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeRefineCancelAck.ok)
  return _internal_ok();
}
inline void ForgeRefineCancelAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ForgeRefineCancelAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeRefineCancelAck.ok)
}

// -------------------------------------------------------------------

// ForgeRefineExtractReq

// -------------------------------------------------------------------

// ForgeRefineExtractAck

// bool ok = 1;
inline void ForgeRefineExtractAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ForgeRefineExtractAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ForgeRefineExtractAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeRefineExtractAck.ok)
  return _internal_ok();
}
inline void ForgeRefineExtractAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ForgeRefineExtractAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeRefineExtractAck.ok)
}

// repeated int64 items = 2;
inline int ForgeRefineExtractAck::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int ForgeRefineExtractAck::items_size() const {
  return _internal_items_size();
}
inline void ForgeRefineExtractAck::clear_items() {
  _impl_.items_.Clear();
}
inline int64_t ForgeRefineExtractAck::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline int64_t ForgeRefineExtractAck::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeRefineExtractAck.items)
  return _internal_items(index);
}
inline void ForgeRefineExtractAck::set_items(int index, int64_t value) {
  _impl_.items_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeRefineExtractAck.items)
}
inline void ForgeRefineExtractAck::_internal_add_items(int64_t value) {
  _impl_.items_.Add(value);
}
inline void ForgeRefineExtractAck::add_items(int64_t value) {
  _internal_add_items(value);
  // @@protoc_insertion_point(field_add:idlepb.ForgeRefineExtractAck.items)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ForgeRefineExtractAck::_internal_items() const {
  return _impl_.items_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ForgeRefineExtractAck::items() const {
  // @@protoc_insertion_point(field_list:idlepb.ForgeRefineExtractAck.items)
  return _internal_items();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ForgeRefineExtractAck::_internal_mutable_items() {
  return &_impl_.items_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ForgeRefineExtractAck::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.ForgeRefineExtractAck.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// GetForgeLostEquipmentDataReq

// -------------------------------------------------------------------

// GetForgeLostEquipmentDataAck

// repeated .idlepb.LostEquipmentData data = 1;
inline int GetForgeLostEquipmentDataAck::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int GetForgeLostEquipmentDataAck::data_size() const {
  return _internal_data_size();
}
inline ::idlepb::LostEquipmentData* GetForgeLostEquipmentDataAck::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetForgeLostEquipmentDataAck.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LostEquipmentData >*
GetForgeLostEquipmentDataAck::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetForgeLostEquipmentDataAck.data)
  return &_impl_.data_;
}
inline const ::idlepb::LostEquipmentData& GetForgeLostEquipmentDataAck::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::idlepb::LostEquipmentData& GetForgeLostEquipmentDataAck::data(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetForgeLostEquipmentDataAck.data)
  return _internal_data(index);
}
inline ::idlepb::LostEquipmentData* GetForgeLostEquipmentDataAck::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::idlepb::LostEquipmentData* GetForgeLostEquipmentDataAck::add_data() {
  ::idlepb::LostEquipmentData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:idlepb.GetForgeLostEquipmentDataAck.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::LostEquipmentData >&
GetForgeLostEquipmentDataAck::data() const {
  // @@protoc_insertion_point(field_list:idlepb.GetForgeLostEquipmentDataAck.data)
  return _impl_.data_;
}

// -------------------------------------------------------------------

// ForgeDestroyReq

// int64 uid = 1;
inline void ForgeDestroyReq::clear_uid() {
  _impl_.uid_ = int64_t{0};
}
inline int64_t ForgeDestroyReq::_internal_uid() const {
  return _impl_.uid_;
}
inline int64_t ForgeDestroyReq::uid() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeDestroyReq.uid)
  return _internal_uid();
}
inline void ForgeDestroyReq::_internal_set_uid(int64_t value) {
  
  _impl_.uid_ = value;
}
inline void ForgeDestroyReq::set_uid(int64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeDestroyReq.uid)
}

// -------------------------------------------------------------------

// ForgeDestroyAck

// bool ok = 1;
inline void ForgeDestroyAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ForgeDestroyAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ForgeDestroyAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeDestroyAck.ok)
  return _internal_ok();
}
inline void ForgeDestroyAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ForgeDestroyAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeDestroyAck.ok)
}

// -------------------------------------------------------------------

// ForgeFindBackReq

// int32 uid = 1;
inline void ForgeFindBackReq::clear_uid() {
  _impl_.uid_ = 0;
}
inline int32_t ForgeFindBackReq::_internal_uid() const {
  return _impl_.uid_;
}
inline int32_t ForgeFindBackReq::uid() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeFindBackReq.uid)
  return _internal_uid();
}
inline void ForgeFindBackReq::_internal_set_uid(int32_t value) {
  
  _impl_.uid_ = value;
}
inline void ForgeFindBackReq::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeFindBackReq.uid)
}

// -------------------------------------------------------------------

// ForgeFindBackAck

// bool ok = 1;
inline void ForgeFindBackAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ForgeFindBackAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ForgeFindBackAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ForgeFindBackAck.ok)
  return _internal_ok();
}
inline void ForgeFindBackAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ForgeFindBackAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ForgeFindBackAck.ok)
}

// -------------------------------------------------------------------

// RequestPillElixirDataReq

// -------------------------------------------------------------------

// RequestPillElixirDataAck

// .idlepb.RolePillElixirData data = 1;
inline bool RequestPillElixirDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool RequestPillElixirDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RolePillElixirData& RequestPillElixirDataAck::_internal_data() const {
  const ::idlepb::RolePillElixirData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RolePillElixirData&>(
      ::idlepb::_RolePillElixirData_default_instance_);
}
inline const ::idlepb::RolePillElixirData& RequestPillElixirDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestPillElixirDataAck.data)
  return _internal_data();
}
inline void RequestPillElixirDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RolePillElixirData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RequestPillElixirDataAck.data)
}
inline ::idlepb::RolePillElixirData* RequestPillElixirDataAck::release_data() {
  
  ::idlepb::RolePillElixirData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RolePillElixirData* RequestPillElixirDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.RequestPillElixirDataAck.data)
  
  ::idlepb::RolePillElixirData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RolePillElixirData* RequestPillElixirDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RolePillElixirData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RolePillElixirData* RequestPillElixirDataAck::mutable_data() {
  ::idlepb::RolePillElixirData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.RequestPillElixirDataAck.data)
  return _msg;
}
inline void RequestPillElixirDataAck::set_allocated_data(::idlepb::RolePillElixirData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RequestPillElixirDataAck.data)
}

// -------------------------------------------------------------------

// GetOnePillElixirDataReq

// int32 item_cfg_id = 1;
inline void GetOnePillElixirDataReq::clear_item_cfg_id() {
  _impl_.item_cfg_id_ = 0;
}
inline int32_t GetOnePillElixirDataReq::_internal_item_cfg_id() const {
  return _impl_.item_cfg_id_;
}
inline int32_t GetOnePillElixirDataReq::item_cfg_id() const {
  // @@protoc_insertion_point(field_get:idlepb.GetOnePillElixirDataReq.item_cfg_id)
  return _internal_item_cfg_id();
}
inline void GetOnePillElixirDataReq::_internal_set_item_cfg_id(int32_t value) {
  
  _impl_.item_cfg_id_ = value;
}
inline void GetOnePillElixirDataReq::set_item_cfg_id(int32_t value) {
  _internal_set_item_cfg_id(value);
  // @@protoc_insertion_point(field_set:idlepb.GetOnePillElixirDataReq.item_cfg_id)
}

// -------------------------------------------------------------------

// GetOnePillElixirDataAck

// .idlepb.PillElixirData data = 1;
inline bool GetOnePillElixirDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetOnePillElixirDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::PillElixirData& GetOnePillElixirDataAck::_internal_data() const {
  const ::idlepb::PillElixirData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::PillElixirData&>(
      ::idlepb::_PillElixirData_default_instance_);
}
inline const ::idlepb::PillElixirData& GetOnePillElixirDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetOnePillElixirDataAck.data)
  return _internal_data();
}
inline void GetOnePillElixirDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::PillElixirData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetOnePillElixirDataAck.data)
}
inline ::idlepb::PillElixirData* GetOnePillElixirDataAck::release_data() {
  
  ::idlepb::PillElixirData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::PillElixirData* GetOnePillElixirDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetOnePillElixirDataAck.data)
  
  ::idlepb::PillElixirData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::PillElixirData* GetOnePillElixirDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::PillElixirData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::PillElixirData* GetOnePillElixirDataAck::mutable_data() {
  ::idlepb::PillElixirData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetOnePillElixirDataAck.data)
  return _msg;
}
inline void GetOnePillElixirDataAck::set_allocated_data(::idlepb::PillElixirData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetOnePillElixirDataAck.data)
}

// -------------------------------------------------------------------

// RequestModifyPillElixirFilterReq

// int32 limit_double = 1;
inline void RequestModifyPillElixirFilterReq::clear_limit_double() {
  _impl_.limit_double_ = 0;
}
inline int32_t RequestModifyPillElixirFilterReq::_internal_limit_double() const {
  return _impl_.limit_double_;
}
inline int32_t RequestModifyPillElixirFilterReq::limit_double() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestModifyPillElixirFilterReq.limit_double)
  return _internal_limit_double();
}
inline void RequestModifyPillElixirFilterReq::_internal_set_limit_double(int32_t value) {
  
  _impl_.limit_double_ = value;
}
inline void RequestModifyPillElixirFilterReq::set_limit_double(int32_t value) {
  _internal_set_limit_double(value);
  // @@protoc_insertion_point(field_set:idlepb.RequestModifyPillElixirFilterReq.limit_double)
}

// int32 limit_exp = 2;
inline void RequestModifyPillElixirFilterReq::clear_limit_exp() {
  _impl_.limit_exp_ = 0;
}
inline int32_t RequestModifyPillElixirFilterReq::_internal_limit_exp() const {
  return _impl_.limit_exp_;
}
inline int32_t RequestModifyPillElixirFilterReq::limit_exp() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestModifyPillElixirFilterReq.limit_exp)
  return _internal_limit_exp();
}
inline void RequestModifyPillElixirFilterReq::_internal_set_limit_exp(int32_t value) {
  
  _impl_.limit_exp_ = value;
}
inline void RequestModifyPillElixirFilterReq::set_limit_exp(int32_t value) {
  _internal_set_limit_exp(value);
  // @@protoc_insertion_point(field_set:idlepb.RequestModifyPillElixirFilterReq.limit_exp)
}

// int32 limit_property = 3;
inline void RequestModifyPillElixirFilterReq::clear_limit_property() {
  _impl_.limit_property_ = 0;
}
inline int32_t RequestModifyPillElixirFilterReq::_internal_limit_property() const {
  return _impl_.limit_property_;
}
inline int32_t RequestModifyPillElixirFilterReq::limit_property() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestModifyPillElixirFilterReq.limit_property)
  return _internal_limit_property();
}
inline void RequestModifyPillElixirFilterReq::_internal_set_limit_property(int32_t value) {
  
  _impl_.limit_property_ = value;
}
inline void RequestModifyPillElixirFilterReq::set_limit_property(int32_t value) {
  _internal_set_limit_property(value);
  // @@protoc_insertion_point(field_set:idlepb.RequestModifyPillElixirFilterReq.limit_property)
}

// -------------------------------------------------------------------

// RequestModifyPillElixirFilterAck

// bool ok = 1;
inline void RequestModifyPillElixirFilterAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool RequestModifyPillElixirFilterAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool RequestModifyPillElixirFilterAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestModifyPillElixirFilterAck.ok)
  return _internal_ok();
}
inline void RequestModifyPillElixirFilterAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void RequestModifyPillElixirFilterAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.RequestModifyPillElixirFilterAck.ok)
}

// -------------------------------------------------------------------

// UsePillElixirReport

// int32 item_id = 1;
inline void UsePillElixirReport::clear_item_id() {
  _impl_.item_id_ = 0;
}
inline int32_t UsePillElixirReport::_internal_item_id() const {
  return _impl_.item_id_;
}
inline int32_t UsePillElixirReport::item_id() const {
  // @@protoc_insertion_point(field_get:idlepb.UsePillElixirReport.item_id)
  return _internal_item_id();
}
inline void UsePillElixirReport::_internal_set_item_id(int32_t value) {
  
  _impl_.item_id_ = value;
}
inline void UsePillElixirReport::set_item_id(int32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:idlepb.UsePillElixirReport.item_id)
}

// int32 num = 2;
inline void UsePillElixirReport::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t UsePillElixirReport::_internal_num() const {
  return _impl_.num_;
}
inline int32_t UsePillElixirReport::num() const {
  // @@protoc_insertion_point(field_get:idlepb.UsePillElixirReport.num)
  return _internal_num();
}
inline void UsePillElixirReport::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void UsePillElixirReport::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.UsePillElixirReport.num)
}

// float property_num = 3;
inline void UsePillElixirReport::clear_property_num() {
  _impl_.property_num_ = 0;
}
inline float UsePillElixirReport::_internal_property_num() const {
  return _impl_.property_num_;
}
inline float UsePillElixirReport::property_num() const {
  // @@protoc_insertion_point(field_get:idlepb.UsePillElixirReport.property_num)
  return _internal_property_num();
}
inline void UsePillElixirReport::_internal_set_property_num(float value) {
  
  _impl_.property_num_ = value;
}
inline void UsePillElixirReport::set_property_num(float value) {
  _internal_set_property_num(value);
  // @@protoc_insertion_point(field_set:idlepb.UsePillElixirReport.property_num)
}

// -------------------------------------------------------------------

// UsePillElixirReq

// int32 item_id = 1;
inline void UsePillElixirReq::clear_item_id() {
  _impl_.item_id_ = 0;
}
inline int32_t UsePillElixirReq::_internal_item_id() const {
  return _impl_.item_id_;
}
inline int32_t UsePillElixirReq::item_id() const {
  // @@protoc_insertion_point(field_get:idlepb.UsePillElixirReq.item_id)
  return _internal_item_id();
}
inline void UsePillElixirReq::_internal_set_item_id(int32_t value) {
  
  _impl_.item_id_ = value;
}
inline void UsePillElixirReq::set_item_id(int32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:idlepb.UsePillElixirReq.item_id)
}

// -------------------------------------------------------------------

// UsePillElixirAck

// bool ok = 1;
inline void UsePillElixirAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool UsePillElixirAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool UsePillElixirAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.UsePillElixirAck.ok)
  return _internal_ok();
}
inline void UsePillElixirAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void UsePillElixirAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.UsePillElixirAck.ok)
}

// -------------------------------------------------------------------

// OneClickUsePillElixirReq

// -------------------------------------------------------------------

// OneClickUsePillElixirAck

// repeated .idlepb.UsePillElixirReport report = 1;
inline int OneClickUsePillElixirAck::_internal_report_size() const {
  return _impl_.report_.size();
}
inline int OneClickUsePillElixirAck::report_size() const {
  return _internal_report_size();
}
inline void OneClickUsePillElixirAck::clear_report() {
  _impl_.report_.Clear();
}
inline ::idlepb::UsePillElixirReport* OneClickUsePillElixirAck::mutable_report(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.OneClickUsePillElixirAck.report)
  return _impl_.report_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::UsePillElixirReport >*
OneClickUsePillElixirAck::mutable_report() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.OneClickUsePillElixirAck.report)
  return &_impl_.report_;
}
inline const ::idlepb::UsePillElixirReport& OneClickUsePillElixirAck::_internal_report(int index) const {
  return _impl_.report_.Get(index);
}
inline const ::idlepb::UsePillElixirReport& OneClickUsePillElixirAck::report(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.OneClickUsePillElixirAck.report)
  return _internal_report(index);
}
inline ::idlepb::UsePillElixirReport* OneClickUsePillElixirAck::_internal_add_report() {
  return _impl_.report_.Add();
}
inline ::idlepb::UsePillElixirReport* OneClickUsePillElixirAck::add_report() {
  ::idlepb::UsePillElixirReport* _add = _internal_add_report();
  // @@protoc_insertion_point(field_add:idlepb.OneClickUsePillElixirAck.report)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::UsePillElixirReport >&
OneClickUsePillElixirAck::report() const {
  // @@protoc_insertion_point(field_list:idlepb.OneClickUsePillElixirAck.report)
  return _impl_.report_;
}

// -------------------------------------------------------------------

// TradePillElixirReq

// int32 item_id = 1;
inline void TradePillElixirReq::clear_item_id() {
  _impl_.item_id_ = 0;
}
inline int32_t TradePillElixirReq::_internal_item_id() const {
  return _impl_.item_id_;
}
inline int32_t TradePillElixirReq::item_id() const {
  // @@protoc_insertion_point(field_get:idlepb.TradePillElixirReq.item_id)
  return _internal_item_id();
}
inline void TradePillElixirReq::_internal_set_item_id(int32_t value) {
  
  _impl_.item_id_ = value;
}
inline void TradePillElixirReq::set_item_id(int32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:idlepb.TradePillElixirReq.item_id)
}

// int32 num = 2;
inline void TradePillElixirReq::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t TradePillElixirReq::_internal_num() const {
  return _impl_.num_;
}
inline int32_t TradePillElixirReq::num() const {
  // @@protoc_insertion_point(field_get:idlepb.TradePillElixirReq.num)
  return _internal_num();
}
inline void TradePillElixirReq::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void TradePillElixirReq::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.TradePillElixirReq.num)
}

// -------------------------------------------------------------------

// TradePillElixirAck

// bool ok = 1;
inline void TradePillElixirAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool TradePillElixirAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool TradePillElixirAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.TradePillElixirAck.ok)
  return _internal_ok();
}
inline void TradePillElixirAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void TradePillElixirAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.TradePillElixirAck.ok)
}

// -------------------------------------------------------------------

// NotifyAutoModeStatus

// bool enable = 1;
inline void NotifyAutoModeStatus::clear_enable() {
  _impl_.enable_ = false;
}
inline bool NotifyAutoModeStatus::_internal_enable() const {
  return _impl_.enable_;
}
inline bool NotifyAutoModeStatus::enable() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyAutoModeStatus.enable)
  return _internal_enable();
}
inline void NotifyAutoModeStatus::_internal_set_enable(bool value) {
  
  _impl_.enable_ = value;
}
inline void NotifyAutoModeStatus::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyAutoModeStatus.enable)
}

// -------------------------------------------------------------------

// SetAutoMode

// bool enable = 1;
inline void SetAutoMode::clear_enable() {
  _impl_.enable_ = false;
}
inline bool SetAutoMode::_internal_enable() const {
  return _impl_.enable_;
}
inline bool SetAutoMode::enable() const {
  // @@protoc_insertion_point(field_get:idlepb.SetAutoMode.enable)
  return _internal_enable();
}
inline void SetAutoMode::_internal_set_enable(bool value) {
  
  _impl_.enable_ = value;
}
inline void SetAutoMode::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:idlepb.SetAutoMode.enable)
}

// -------------------------------------------------------------------

// ReinforceEquipmentReq

// int64 id = 1;
inline void ReinforceEquipmentReq::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t ReinforceEquipmentReq::_internal_id() const {
  return _impl_.id_;
}
inline int64_t ReinforceEquipmentReq::id() const {
  // @@protoc_insertion_point(field_get:idlepb.ReinforceEquipmentReq.id)
  return _internal_id();
}
inline void ReinforceEquipmentReq::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void ReinforceEquipmentReq::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ReinforceEquipmentReq.id)
}

// -------------------------------------------------------------------

// ReinforceEquipmentAck

// bool ok = 1;
inline void ReinforceEquipmentAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ReinforceEquipmentAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ReinforceEquipmentAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ReinforceEquipmentAck.ok)
  return _internal_ok();
}
inline void ReinforceEquipmentAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ReinforceEquipmentAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ReinforceEquipmentAck.ok)
}

// -------------------------------------------------------------------

// QiWenEquipmentReq

// int64 id = 1;
inline void QiWenEquipmentReq::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t QiWenEquipmentReq::_internal_id() const {
  return _impl_.id_;
}
inline int64_t QiWenEquipmentReq::id() const {
  // @@protoc_insertion_point(field_get:idlepb.QiWenEquipmentReq.id)
  return _internal_id();
}
inline void QiWenEquipmentReq::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void QiWenEquipmentReq::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:idlepb.QiWenEquipmentReq.id)
}

// int32 select_abc = 2;
inline void QiWenEquipmentReq::clear_select_abc() {
  _impl_.select_abc_ = 0;
}
inline int32_t QiWenEquipmentReq::_internal_select_abc() const {
  return _impl_.select_abc_;
}
inline int32_t QiWenEquipmentReq::select_abc() const {
  // @@protoc_insertion_point(field_get:idlepb.QiWenEquipmentReq.select_abc)
  return _internal_select_abc();
}
inline void QiWenEquipmentReq::_internal_set_select_abc(int32_t value) {
  
  _impl_.select_abc_ = value;
}
inline void QiWenEquipmentReq::set_select_abc(int32_t value) {
  _internal_set_select_abc(value);
  // @@protoc_insertion_point(field_set:idlepb.QiWenEquipmentReq.select_abc)
}

// repeated int64 commit_materials = 3;
inline int QiWenEquipmentReq::_internal_commit_materials_size() const {
  return _impl_.commit_materials_.size();
}
inline int QiWenEquipmentReq::commit_materials_size() const {
  return _internal_commit_materials_size();
}
inline void QiWenEquipmentReq::clear_commit_materials() {
  _impl_.commit_materials_.Clear();
}
inline int64_t QiWenEquipmentReq::_internal_commit_materials(int index) const {
  return _impl_.commit_materials_.Get(index);
}
inline int64_t QiWenEquipmentReq::commit_materials(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.QiWenEquipmentReq.commit_materials)
  return _internal_commit_materials(index);
}
inline void QiWenEquipmentReq::set_commit_materials(int index, int64_t value) {
  _impl_.commit_materials_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.QiWenEquipmentReq.commit_materials)
}
inline void QiWenEquipmentReq::_internal_add_commit_materials(int64_t value) {
  _impl_.commit_materials_.Add(value);
}
inline void QiWenEquipmentReq::add_commit_materials(int64_t value) {
  _internal_add_commit_materials(value);
  // @@protoc_insertion_point(field_add:idlepb.QiWenEquipmentReq.commit_materials)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
QiWenEquipmentReq::_internal_commit_materials() const {
  return _impl_.commit_materials_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
QiWenEquipmentReq::commit_materials() const {
  // @@protoc_insertion_point(field_list:idlepb.QiWenEquipmentReq.commit_materials)
  return _internal_commit_materials();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
QiWenEquipmentReq::_internal_mutable_commit_materials() {
  return &_impl_.commit_materials_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
QiWenEquipmentReq::mutable_commit_materials() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.QiWenEquipmentReq.commit_materials)
  return _internal_mutable_commit_materials();
}

// -------------------------------------------------------------------

// QiWenEquipmentAck

// bool ok = 1;
inline void QiWenEquipmentAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool QiWenEquipmentAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool QiWenEquipmentAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.QiWenEquipmentAck.ok)
  return _internal_ok();
}
inline void QiWenEquipmentAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void QiWenEquipmentAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.QiWenEquipmentAck.ok)
}

// -------------------------------------------------------------------

// RefineEquipmentReq

// int64 id = 1;
inline void RefineEquipmentReq::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t RefineEquipmentReq::_internal_id() const {
  return _impl_.id_;
}
inline int64_t RefineEquipmentReq::id() const {
  // @@protoc_insertion_point(field_get:idlepb.RefineEquipmentReq.id)
  return _internal_id();
}
inline void RefineEquipmentReq::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void RefineEquipmentReq::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:idlepb.RefineEquipmentReq.id)
}

// -------------------------------------------------------------------

// RefineEquipmentAck

// bool ok = 1;
inline void RefineEquipmentAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool RefineEquipmentAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool RefineEquipmentAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.RefineEquipmentAck.ok)
  return _internal_ok();
}
inline void RefineEquipmentAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void RefineEquipmentAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.RefineEquipmentAck.ok)
}

// -------------------------------------------------------------------

// ResetEquipmentReq

// repeated int64 id = 1;
inline int ResetEquipmentReq::_internal_id_size() const {
  return _impl_.id_.size();
}
inline int ResetEquipmentReq::id_size() const {
  return _internal_id_size();
}
inline void ResetEquipmentReq::clear_id() {
  _impl_.id_.Clear();
}
inline int64_t ResetEquipmentReq::_internal_id(int index) const {
  return _impl_.id_.Get(index);
}
inline int64_t ResetEquipmentReq::id(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.ResetEquipmentReq.id)
  return _internal_id(index);
}
inline void ResetEquipmentReq::set_id(int index, int64_t value) {
  _impl_.id_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.ResetEquipmentReq.id)
}
inline void ResetEquipmentReq::_internal_add_id(int64_t value) {
  _impl_.id_.Add(value);
}
inline void ResetEquipmentReq::add_id(int64_t value) {
  _internal_add_id(value);
  // @@protoc_insertion_point(field_add:idlepb.ResetEquipmentReq.id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ResetEquipmentReq::_internal_id() const {
  return _impl_.id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ResetEquipmentReq::id() const {
  // @@protoc_insertion_point(field_list:idlepb.ResetEquipmentReq.id)
  return _internal_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ResetEquipmentReq::_internal_mutable_id() {
  return &_impl_.id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ResetEquipmentReq::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.ResetEquipmentReq.id)
  return _internal_mutable_id();
}

// -------------------------------------------------------------------

// ResetEquipmentAck

// bool ok = 1;
inline void ResetEquipmentAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ResetEquipmentAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ResetEquipmentAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ResetEquipmentAck.ok)
  return _internal_ok();
}
inline void ResetEquipmentAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ResetEquipmentAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ResetEquipmentAck.ok)
}

// repeated .idlepb.SimpleItemData items = 2;
inline int ResetEquipmentAck::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int ResetEquipmentAck::items_size() const {
  return _internal_items_size();
}
inline ::idlepb::SimpleItemData* ResetEquipmentAck::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.ResetEquipmentAck.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
ResetEquipmentAck::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.ResetEquipmentAck.items)
  return &_impl_.items_;
}
inline const ::idlepb::SimpleItemData& ResetEquipmentAck::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::SimpleItemData& ResetEquipmentAck::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.ResetEquipmentAck.items)
  return _internal_items(index);
}
inline ::idlepb::SimpleItemData* ResetEquipmentAck::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::SimpleItemData* ResetEquipmentAck::add_items() {
  ::idlepb::SimpleItemData* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.ResetEquipmentAck.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
ResetEquipmentAck::items() const {
  // @@protoc_insertion_point(field_list:idlepb.ResetEquipmentAck.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// InheritEquipmentReq

// int64 equipment_from = 1;
inline void InheritEquipmentReq::clear_equipment_from() {
  _impl_.equipment_from_ = int64_t{0};
}
inline int64_t InheritEquipmentReq::_internal_equipment_from() const {
  return _impl_.equipment_from_;
}
inline int64_t InheritEquipmentReq::equipment_from() const {
  // @@protoc_insertion_point(field_get:idlepb.InheritEquipmentReq.equipment_from)
  return _internal_equipment_from();
}
inline void InheritEquipmentReq::_internal_set_equipment_from(int64_t value) {
  
  _impl_.equipment_from_ = value;
}
inline void InheritEquipmentReq::set_equipment_from(int64_t value) {
  _internal_set_equipment_from(value);
  // @@protoc_insertion_point(field_set:idlepb.InheritEquipmentReq.equipment_from)
}

// int64 equipment_to = 2;
inline void InheritEquipmentReq::clear_equipment_to() {
  _impl_.equipment_to_ = int64_t{0};
}
inline int64_t InheritEquipmentReq::_internal_equipment_to() const {
  return _impl_.equipment_to_;
}
inline int64_t InheritEquipmentReq::equipment_to() const {
  // @@protoc_insertion_point(field_get:idlepb.InheritEquipmentReq.equipment_to)
  return _internal_equipment_to();
}
inline void InheritEquipmentReq::_internal_set_equipment_to(int64_t value) {
  
  _impl_.equipment_to_ = value;
}
inline void InheritEquipmentReq::set_equipment_to(int64_t value) {
  _internal_set_equipment_to(value);
  // @@protoc_insertion_point(field_set:idlepb.InheritEquipmentReq.equipment_to)
}

// -------------------------------------------------------------------

// InheritEquipmentAck

// bool ok = 1;
inline void InheritEquipmentAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool InheritEquipmentAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool InheritEquipmentAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.InheritEquipmentAck.ok)
  return _internal_ok();
}
inline void InheritEquipmentAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void InheritEquipmentAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.InheritEquipmentAck.ok)
}

// repeated .idlepb.SimpleItemData items = 2;
inline int InheritEquipmentAck::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int InheritEquipmentAck::items_size() const {
  return _internal_items_size();
}
inline ::idlepb::SimpleItemData* InheritEquipmentAck::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.InheritEquipmentAck.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
InheritEquipmentAck::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.InheritEquipmentAck.items)
  return &_impl_.items_;
}
inline const ::idlepb::SimpleItemData& InheritEquipmentAck::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::SimpleItemData& InheritEquipmentAck::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.InheritEquipmentAck.items)
  return _internal_items(index);
}
inline ::idlepb::SimpleItemData* InheritEquipmentAck::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::SimpleItemData* InheritEquipmentAck::add_items() {
  ::idlepb::SimpleItemData* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.InheritEquipmentAck.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
InheritEquipmentAck::items() const {
  // @@protoc_insertion_point(field_list:idlepb.InheritEquipmentAck.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// LockItemReq

// int64 id = 1;
inline void LockItemReq::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t LockItemReq::_internal_id() const {
  return _impl_.id_;
}
inline int64_t LockItemReq::id() const {
  // @@protoc_insertion_point(field_get:idlepb.LockItemReq.id)
  return _internal_id();
}
inline void LockItemReq::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void LockItemReq::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:idlepb.LockItemReq.id)
}

// -------------------------------------------------------------------

// LockItemAck

// bool ok = 1;
inline void LockItemAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool LockItemAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool LockItemAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.LockItemAck.ok)
  return _internal_ok();
}
inline void LockItemAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void LockItemAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.LockItemAck.ok)
}

// -------------------------------------------------------------------

// CollectionActivatedSuit

// int32 id = 1;
inline void CollectionActivatedSuit::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t CollectionActivatedSuit::_internal_id() const {
  return _impl_.id_;
}
inline int32_t CollectionActivatedSuit::id() const {
  // @@protoc_insertion_point(field_get:idlepb.CollectionActivatedSuit.id)
  return _internal_id();
}
inline void CollectionActivatedSuit::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void CollectionActivatedSuit::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:idlepb.CollectionActivatedSuit.id)
}

// int32 index = 2;
inline void CollectionActivatedSuit::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t CollectionActivatedSuit::_internal_index() const {
  return _impl_.index_;
}
inline int32_t CollectionActivatedSuit::index() const {
  // @@protoc_insertion_point(field_get:idlepb.CollectionActivatedSuit.index)
  return _internal_index();
}
inline void CollectionActivatedSuit::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void CollectionActivatedSuit::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:idlepb.CollectionActivatedSuit.index)
}

// float combat_power = 3;
inline void CollectionActivatedSuit::clear_combat_power() {
  _impl_.combat_power_ = 0;
}
inline float CollectionActivatedSuit::_internal_combat_power() const {
  return _impl_.combat_power_;
}
inline float CollectionActivatedSuit::combat_power() const {
  // @@protoc_insertion_point(field_get:idlepb.CollectionActivatedSuit.combat_power)
  return _internal_combat_power();
}
inline void CollectionActivatedSuit::_internal_set_combat_power(float value) {
  
  _impl_.combat_power_ = value;
}
inline void CollectionActivatedSuit::set_combat_power(float value) {
  _internal_set_combat_power(value);
  // @@protoc_insertion_point(field_set:idlepb.CollectionActivatedSuit.combat_power)
}

// -------------------------------------------------------------------

// GetRoleCollectionDataReq

// -------------------------------------------------------------------

// GetRoleCollectionDataRsp

// repeated .idlepb.CollectionEntry entries = 1;
inline int GetRoleCollectionDataRsp::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int GetRoleCollectionDataRsp::entries_size() const {
  return _internal_entries_size();
}
inline ::idlepb::CollectionEntry* GetRoleCollectionDataRsp::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleCollectionDataRsp.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionEntry >*
GetRoleCollectionDataRsp::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetRoleCollectionDataRsp.entries)
  return &_impl_.entries_;
}
inline const ::idlepb::CollectionEntry& GetRoleCollectionDataRsp::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::idlepb::CollectionEntry& GetRoleCollectionDataRsp::entries(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleCollectionDataRsp.entries)
  return _internal_entries(index);
}
inline ::idlepb::CollectionEntry* GetRoleCollectionDataRsp::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::idlepb::CollectionEntry* GetRoleCollectionDataRsp::add_entries() {
  ::idlepb::CollectionEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:idlepb.GetRoleCollectionDataRsp.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionEntry >&
GetRoleCollectionDataRsp::entries() const {
  // @@protoc_insertion_point(field_list:idlepb.GetRoleCollectionDataRsp.entries)
  return _impl_.entries_;
}

// repeated .idlepb.CommonCollectionPieceData common_pieces = 2;
inline int GetRoleCollectionDataRsp::_internal_common_pieces_size() const {
  return _impl_.common_pieces_.size();
}
inline int GetRoleCollectionDataRsp::common_pieces_size() const {
  return _internal_common_pieces_size();
}
inline ::idlepb::CommonCollectionPieceData* GetRoleCollectionDataRsp::mutable_common_pieces(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleCollectionDataRsp.common_pieces)
  return _impl_.common_pieces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CommonCollectionPieceData >*
GetRoleCollectionDataRsp::mutable_common_pieces() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetRoleCollectionDataRsp.common_pieces)
  return &_impl_.common_pieces_;
}
inline const ::idlepb::CommonCollectionPieceData& GetRoleCollectionDataRsp::_internal_common_pieces(int index) const {
  return _impl_.common_pieces_.Get(index);
}
inline const ::idlepb::CommonCollectionPieceData& GetRoleCollectionDataRsp::common_pieces(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleCollectionDataRsp.common_pieces)
  return _internal_common_pieces(index);
}
inline ::idlepb::CommonCollectionPieceData* GetRoleCollectionDataRsp::_internal_add_common_pieces() {
  return _impl_.common_pieces_.Add();
}
inline ::idlepb::CommonCollectionPieceData* GetRoleCollectionDataRsp::add_common_pieces() {
  ::idlepb::CommonCollectionPieceData* _add = _internal_add_common_pieces();
  // @@protoc_insertion_point(field_add:idlepb.GetRoleCollectionDataRsp.common_pieces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CommonCollectionPieceData >&
GetRoleCollectionDataRsp::common_pieces() const {
  // @@protoc_insertion_point(field_list:idlepb.GetRoleCollectionDataRsp.common_pieces)
  return _impl_.common_pieces_;
}

// repeated .idlepb.CollectionActivatedSuit actived_suite = 3;
inline int GetRoleCollectionDataRsp::_internal_actived_suite_size() const {
  return _impl_.actived_suite_.size();
}
inline int GetRoleCollectionDataRsp::actived_suite_size() const {
  return _internal_actived_suite_size();
}
inline void GetRoleCollectionDataRsp::clear_actived_suite() {
  _impl_.actived_suite_.Clear();
}
inline ::idlepb::CollectionActivatedSuit* GetRoleCollectionDataRsp::mutable_actived_suite(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleCollectionDataRsp.actived_suite)
  return _impl_.actived_suite_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionActivatedSuit >*
GetRoleCollectionDataRsp::mutable_actived_suite() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetRoleCollectionDataRsp.actived_suite)
  return &_impl_.actived_suite_;
}
inline const ::idlepb::CollectionActivatedSuit& GetRoleCollectionDataRsp::_internal_actived_suite(int index) const {
  return _impl_.actived_suite_.Get(index);
}
inline const ::idlepb::CollectionActivatedSuit& GetRoleCollectionDataRsp::actived_suite(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleCollectionDataRsp.actived_suite)
  return _internal_actived_suite(index);
}
inline ::idlepb::CollectionActivatedSuit* GetRoleCollectionDataRsp::_internal_add_actived_suite() {
  return _impl_.actived_suite_.Add();
}
inline ::idlepb::CollectionActivatedSuit* GetRoleCollectionDataRsp::add_actived_suite() {
  ::idlepb::CollectionActivatedSuit* _add = _internal_add_actived_suite();
  // @@protoc_insertion_point(field_add:idlepb.GetRoleCollectionDataRsp.actived_suite)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionActivatedSuit >&
GetRoleCollectionDataRsp::actived_suite() const {
  // @@protoc_insertion_point(field_list:idlepb.GetRoleCollectionDataRsp.actived_suite)
  return _impl_.actived_suite_;
}

// repeated int32 draw_award_done_histories = 4;
inline int GetRoleCollectionDataRsp::_internal_draw_award_done_histories_size() const {
  return _impl_.draw_award_done_histories_.size();
}
inline int GetRoleCollectionDataRsp::draw_award_done_histories_size() const {
  return _internal_draw_award_done_histories_size();
}
inline void GetRoleCollectionDataRsp::clear_draw_award_done_histories() {
  _impl_.draw_award_done_histories_.Clear();
}
inline int32_t GetRoleCollectionDataRsp::_internal_draw_award_done_histories(int index) const {
  return _impl_.draw_award_done_histories_.Get(index);
}
inline int32_t GetRoleCollectionDataRsp::draw_award_done_histories(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleCollectionDataRsp.draw_award_done_histories)
  return _internal_draw_award_done_histories(index);
}
inline void GetRoleCollectionDataRsp::set_draw_award_done_histories(int index, int32_t value) {
  _impl_.draw_award_done_histories_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleCollectionDataRsp.draw_award_done_histories)
}
inline void GetRoleCollectionDataRsp::_internal_add_draw_award_done_histories(int32_t value) {
  _impl_.draw_award_done_histories_.Add(value);
}
inline void GetRoleCollectionDataRsp::add_draw_award_done_histories(int32_t value) {
  _internal_add_draw_award_done_histories(value);
  // @@protoc_insertion_point(field_add:idlepb.GetRoleCollectionDataRsp.draw_award_done_histories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetRoleCollectionDataRsp::_internal_draw_award_done_histories() const {
  return _impl_.draw_award_done_histories_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetRoleCollectionDataRsp::draw_award_done_histories() const {
  // @@protoc_insertion_point(field_list:idlepb.GetRoleCollectionDataRsp.draw_award_done_histories)
  return _internal_draw_award_done_histories();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetRoleCollectionDataRsp::_internal_mutable_draw_award_done_histories() {
  return &_impl_.draw_award_done_histories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetRoleCollectionDataRsp::mutable_draw_award_done_histories() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetRoleCollectionDataRsp.draw_award_done_histories)
  return _internal_mutable_draw_award_done_histories();
}

// repeated int32 can_award_histories = 5;
inline int GetRoleCollectionDataRsp::_internal_can_award_histories_size() const {
  return _impl_.can_award_histories_.size();
}
inline int GetRoleCollectionDataRsp::can_award_histories_size() const {
  return _internal_can_award_histories_size();
}
inline void GetRoleCollectionDataRsp::clear_can_award_histories() {
  _impl_.can_award_histories_.Clear();
}
inline int32_t GetRoleCollectionDataRsp::_internal_can_award_histories(int index) const {
  return _impl_.can_award_histories_.Get(index);
}
inline int32_t GetRoleCollectionDataRsp::can_award_histories(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleCollectionDataRsp.can_award_histories)
  return _internal_can_award_histories(index);
}
inline void GetRoleCollectionDataRsp::set_can_award_histories(int index, int32_t value) {
  _impl_.can_award_histories_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleCollectionDataRsp.can_award_histories)
}
inline void GetRoleCollectionDataRsp::_internal_add_can_award_histories(int32_t value) {
  _impl_.can_award_histories_.Add(value);
}
inline void GetRoleCollectionDataRsp::add_can_award_histories(int32_t value) {
  _internal_add_can_award_histories(value);
  // @@protoc_insertion_point(field_add:idlepb.GetRoleCollectionDataRsp.can_award_histories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetRoleCollectionDataRsp::_internal_can_award_histories() const {
  return _impl_.can_award_histories_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetRoleCollectionDataRsp::can_award_histories() const {
  // @@protoc_insertion_point(field_list:idlepb.GetRoleCollectionDataRsp.can_award_histories)
  return _internal_can_award_histories();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetRoleCollectionDataRsp::_internal_mutable_can_award_histories() {
  return &_impl_.can_award_histories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetRoleCollectionDataRsp::mutable_can_award_histories() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetRoleCollectionDataRsp.can_award_histories)
  return _internal_mutable_can_award_histories();
}

// repeated .idlepb.CollectionZoneActiveAwardData zone_active_awards = 6;
inline int GetRoleCollectionDataRsp::_internal_zone_active_awards_size() const {
  return _impl_.zone_active_awards_.size();
}
inline int GetRoleCollectionDataRsp::zone_active_awards_size() const {
  return _internal_zone_active_awards_size();
}
inline ::idlepb::CollectionZoneActiveAwardData* GetRoleCollectionDataRsp::mutable_zone_active_awards(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleCollectionDataRsp.zone_active_awards)
  return _impl_.zone_active_awards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionZoneActiveAwardData >*
GetRoleCollectionDataRsp::mutable_zone_active_awards() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetRoleCollectionDataRsp.zone_active_awards)
  return &_impl_.zone_active_awards_;
}
inline const ::idlepb::CollectionZoneActiveAwardData& GetRoleCollectionDataRsp::_internal_zone_active_awards(int index) const {
  return _impl_.zone_active_awards_.Get(index);
}
inline const ::idlepb::CollectionZoneActiveAwardData& GetRoleCollectionDataRsp::zone_active_awards(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleCollectionDataRsp.zone_active_awards)
  return _internal_zone_active_awards(index);
}
inline ::idlepb::CollectionZoneActiveAwardData* GetRoleCollectionDataRsp::_internal_add_zone_active_awards() {
  return _impl_.zone_active_awards_.Add();
}
inline ::idlepb::CollectionZoneActiveAwardData* GetRoleCollectionDataRsp::add_zone_active_awards() {
  ::idlepb::CollectionZoneActiveAwardData* _add = _internal_add_zone_active_awards();
  // @@protoc_insertion_point(field_add:idlepb.GetRoleCollectionDataRsp.zone_active_awards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionZoneActiveAwardData >&
GetRoleCollectionDataRsp::zone_active_awards() const {
  // @@protoc_insertion_point(field_list:idlepb.GetRoleCollectionDataRsp.zone_active_awards)
  return _impl_.zone_active_awards_;
}

// int64 next_reset_enhance_ticks = 7;
inline void GetRoleCollectionDataRsp::clear_next_reset_enhance_ticks() {
  _impl_.next_reset_enhance_ticks_ = int64_t{0};
}
inline int64_t GetRoleCollectionDataRsp::_internal_next_reset_enhance_ticks() const {
  return _impl_.next_reset_enhance_ticks_;
}
inline int64_t GetRoleCollectionDataRsp::next_reset_enhance_ticks() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleCollectionDataRsp.next_reset_enhance_ticks)
  return _internal_next_reset_enhance_ticks();
}
inline void GetRoleCollectionDataRsp::_internal_set_next_reset_enhance_ticks(int64_t value) {
  
  _impl_.next_reset_enhance_ticks_ = value;
}
inline void GetRoleCollectionDataRsp::set_next_reset_enhance_ticks(int64_t value) {
  _internal_set_next_reset_enhance_ticks(value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleCollectionDataRsp.next_reset_enhance_ticks)
}

// -------------------------------------------------------------------

// RoleCollectionOpReq

// .idlepb.RoleCollectionOpType op_type = 1;
inline void RoleCollectionOpReq::clear_op_type() {
  _impl_.op_type_ = 0;
}
inline ::idlepb::RoleCollectionOpType RoleCollectionOpReq::_internal_op_type() const {
  return static_cast< ::idlepb::RoleCollectionOpType >(_impl_.op_type_);
}
inline ::idlepb::RoleCollectionOpType RoleCollectionOpReq::op_type() const {
  // @@protoc_insertion_point(field_get:idlepb.RoleCollectionOpReq.op_type)
  return _internal_op_type();
}
inline void RoleCollectionOpReq::_internal_set_op_type(::idlepb::RoleCollectionOpType value) {
  
  _impl_.op_type_ = value;
}
inline void RoleCollectionOpReq::set_op_type(::idlepb::RoleCollectionOpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:idlepb.RoleCollectionOpReq.op_type)
}

// int32 id = 2;
inline void RoleCollectionOpReq::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t RoleCollectionOpReq::_internal_id() const {
  return _impl_.id_;
}
inline int32_t RoleCollectionOpReq::id() const {
  // @@protoc_insertion_point(field_get:idlepb.RoleCollectionOpReq.id)
  return _internal_id();
}
inline void RoleCollectionOpReq::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void RoleCollectionOpReq::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:idlepb.RoleCollectionOpReq.id)
}

// repeated .idlepb.MapValueInt32 consume_list = 3;
inline int RoleCollectionOpReq::_internal_consume_list_size() const {
  return _impl_.consume_list_.size();
}
inline int RoleCollectionOpReq::consume_list_size() const {
  return _internal_consume_list_size();
}
inline ::idlepb::MapValueInt32* RoleCollectionOpReq::mutable_consume_list(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.RoleCollectionOpReq.consume_list)
  return _impl_.consume_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::MapValueInt32 >*
RoleCollectionOpReq::mutable_consume_list() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.RoleCollectionOpReq.consume_list)
  return &_impl_.consume_list_;
}
inline const ::idlepb::MapValueInt32& RoleCollectionOpReq::_internal_consume_list(int index) const {
  return _impl_.consume_list_.Get(index);
}
inline const ::idlepb::MapValueInt32& RoleCollectionOpReq::consume_list(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.RoleCollectionOpReq.consume_list)
  return _internal_consume_list(index);
}
inline ::idlepb::MapValueInt32* RoleCollectionOpReq::_internal_add_consume_list() {
  return _impl_.consume_list_.Add();
}
inline ::idlepb::MapValueInt32* RoleCollectionOpReq::add_consume_list() {
  ::idlepb::MapValueInt32* _add = _internal_add_consume_list();
  // @@protoc_insertion_point(field_add:idlepb.RoleCollectionOpReq.consume_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::MapValueInt32 >&
RoleCollectionOpReq::consume_list() const {
  // @@protoc_insertion_point(field_list:idlepb.RoleCollectionOpReq.consume_list)
  return _impl_.consume_list_;
}

// bool is_preview = 4;
inline void RoleCollectionOpReq::clear_is_preview() {
  _impl_.is_preview_ = false;
}
inline bool RoleCollectionOpReq::_internal_is_preview() const {
  return _impl_.is_preview_;
}
inline bool RoleCollectionOpReq::is_preview() const {
  // @@protoc_insertion_point(field_get:idlepb.RoleCollectionOpReq.is_preview)
  return _internal_is_preview();
}
inline void RoleCollectionOpReq::_internal_set_is_preview(bool value) {
  
  _impl_.is_preview_ = value;
}
inline void RoleCollectionOpReq::set_is_preview(bool value) {
  _internal_set_is_preview(value);
  // @@protoc_insertion_point(field_set:idlepb.RoleCollectionOpReq.is_preview)
}

// -------------------------------------------------------------------

// RoleCollectionOpAck

// .idlepb.RoleCollectionOpType op_type = 1;
inline void RoleCollectionOpAck::clear_op_type() {
  _impl_.op_type_ = 0;
}
inline ::idlepb::RoleCollectionOpType RoleCollectionOpAck::_internal_op_type() const {
  return static_cast< ::idlepb::RoleCollectionOpType >(_impl_.op_type_);
}
inline ::idlepb::RoleCollectionOpType RoleCollectionOpAck::op_type() const {
  // @@protoc_insertion_point(field_get:idlepb.RoleCollectionOpAck.op_type)
  return _internal_op_type();
}
inline void RoleCollectionOpAck::_internal_set_op_type(::idlepb::RoleCollectionOpType value) {
  
  _impl_.op_type_ = value;
}
inline void RoleCollectionOpAck::set_op_type(::idlepb::RoleCollectionOpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:idlepb.RoleCollectionOpAck.op_type)
}

// bool ok = 2;
inline void RoleCollectionOpAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool RoleCollectionOpAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool RoleCollectionOpAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.RoleCollectionOpAck.ok)
  return _internal_ok();
}
inline void RoleCollectionOpAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void RoleCollectionOpAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.RoleCollectionOpAck.ok)
}

// repeated .idlepb.SimpleItemData items = 3;
inline int RoleCollectionOpAck::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int RoleCollectionOpAck::items_size() const {
  return _internal_items_size();
}
inline ::idlepb::SimpleItemData* RoleCollectionOpAck::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.RoleCollectionOpAck.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
RoleCollectionOpAck::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.RoleCollectionOpAck.items)
  return &_impl_.items_;
}
inline const ::idlepb::SimpleItemData& RoleCollectionOpAck::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::SimpleItemData& RoleCollectionOpAck::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.RoleCollectionOpAck.items)
  return _internal_items(index);
}
inline ::idlepb::SimpleItemData* RoleCollectionOpAck::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::SimpleItemData* RoleCollectionOpAck::add_items() {
  ::idlepb::SimpleItemData* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.RoleCollectionOpAck.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
RoleCollectionOpAck::items() const {
  // @@protoc_insertion_point(field_list:idlepb.RoleCollectionOpAck.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// NotifyRoleCollectionData

// .idlepb.CollectionEntry entry = 1;
inline bool NotifyRoleCollectionData::_internal_has_entry() const {
  return this != internal_default_instance() && _impl_.entry_ != nullptr;
}
inline bool NotifyRoleCollectionData::has_entry() const {
  return _internal_has_entry();
}
inline const ::idlepb::CollectionEntry& NotifyRoleCollectionData::_internal_entry() const {
  const ::idlepb::CollectionEntry* p = _impl_.entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::CollectionEntry&>(
      ::idlepb::_CollectionEntry_default_instance_);
}
inline const ::idlepb::CollectionEntry& NotifyRoleCollectionData::entry() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyRoleCollectionData.entry)
  return _internal_entry();
}
inline void NotifyRoleCollectionData::unsafe_arena_set_allocated_entry(
    ::idlepb::CollectionEntry* entry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entry_);
  }
  _impl_.entry_ = entry;
  if (entry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.NotifyRoleCollectionData.entry)
}
inline ::idlepb::CollectionEntry* NotifyRoleCollectionData::release_entry() {
  
  ::idlepb::CollectionEntry* temp = _impl_.entry_;
  _impl_.entry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::CollectionEntry* NotifyRoleCollectionData::unsafe_arena_release_entry() {
  // @@protoc_insertion_point(field_release:idlepb.NotifyRoleCollectionData.entry)
  
  ::idlepb::CollectionEntry* temp = _impl_.entry_;
  _impl_.entry_ = nullptr;
  return temp;
}
inline ::idlepb::CollectionEntry* NotifyRoleCollectionData::_internal_mutable_entry() {
  
  if (_impl_.entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::CollectionEntry>(GetArenaForAllocation());
    _impl_.entry_ = p;
  }
  return _impl_.entry_;
}
inline ::idlepb::CollectionEntry* NotifyRoleCollectionData::mutable_entry() {
  ::idlepb::CollectionEntry* _msg = _internal_mutable_entry();
  // @@protoc_insertion_point(field_mutable:idlepb.NotifyRoleCollectionData.entry)
  return _msg;
}
inline void NotifyRoleCollectionData::set_allocated_entry(::idlepb::CollectionEntry* entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entry_);
  }
  if (entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entry));
    if (message_arena != submessage_arena) {
      entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.entry_ = entry;
  // @@protoc_insertion_point(field_set_allocated:idlepb.NotifyRoleCollectionData.entry)
}

// -------------------------------------------------------------------

// NotifyCommonCollectionPieceData

// repeated .idlepb.CommonCollectionPieceData common_pieces = 1;
inline int NotifyCommonCollectionPieceData::_internal_common_pieces_size() const {
  return _impl_.common_pieces_.size();
}
inline int NotifyCommonCollectionPieceData::common_pieces_size() const {
  return _internal_common_pieces_size();
}
inline ::idlepb::CommonCollectionPieceData* NotifyCommonCollectionPieceData::mutable_common_pieces(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.NotifyCommonCollectionPieceData.common_pieces)
  return _impl_.common_pieces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CommonCollectionPieceData >*
NotifyCommonCollectionPieceData::mutable_common_pieces() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.NotifyCommonCollectionPieceData.common_pieces)
  return &_impl_.common_pieces_;
}
inline const ::idlepb::CommonCollectionPieceData& NotifyCommonCollectionPieceData::_internal_common_pieces(int index) const {
  return _impl_.common_pieces_.Get(index);
}
inline const ::idlepb::CommonCollectionPieceData& NotifyCommonCollectionPieceData::common_pieces(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyCommonCollectionPieceData.common_pieces)
  return _internal_common_pieces(index);
}
inline ::idlepb::CommonCollectionPieceData* NotifyCommonCollectionPieceData::_internal_add_common_pieces() {
  return _impl_.common_pieces_.Add();
}
inline ::idlepb::CommonCollectionPieceData* NotifyCommonCollectionPieceData::add_common_pieces() {
  ::idlepb::CommonCollectionPieceData* _add = _internal_add_common_pieces();
  // @@protoc_insertion_point(field_add:idlepb.NotifyCommonCollectionPieceData.common_pieces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CommonCollectionPieceData >&
NotifyCommonCollectionPieceData::common_pieces() const {
  // @@protoc_insertion_point(field_list:idlepb.NotifyCommonCollectionPieceData.common_pieces)
  return _impl_.common_pieces_;
}

// -------------------------------------------------------------------

// NotifyCollectionActivatedSuit

// repeated .idlepb.CollectionActivatedSuit actived_suite = 1;
inline int NotifyCollectionActivatedSuit::_internal_actived_suite_size() const {
  return _impl_.actived_suite_.size();
}
inline int NotifyCollectionActivatedSuit::actived_suite_size() const {
  return _internal_actived_suite_size();
}
inline void NotifyCollectionActivatedSuit::clear_actived_suite() {
  _impl_.actived_suite_.Clear();
}
inline ::idlepb::CollectionActivatedSuit* NotifyCollectionActivatedSuit::mutable_actived_suite(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.NotifyCollectionActivatedSuit.actived_suite)
  return _impl_.actived_suite_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionActivatedSuit >*
NotifyCollectionActivatedSuit::mutable_actived_suite() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.NotifyCollectionActivatedSuit.actived_suite)
  return &_impl_.actived_suite_;
}
inline const ::idlepb::CollectionActivatedSuit& NotifyCollectionActivatedSuit::_internal_actived_suite(int index) const {
  return _impl_.actived_suite_.Get(index);
}
inline const ::idlepb::CollectionActivatedSuit& NotifyCollectionActivatedSuit::actived_suite(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyCollectionActivatedSuit.actived_suite)
  return _internal_actived_suite(index);
}
inline ::idlepb::CollectionActivatedSuit* NotifyCollectionActivatedSuit::_internal_add_actived_suite() {
  return _impl_.actived_suite_.Add();
}
inline ::idlepb::CollectionActivatedSuit* NotifyCollectionActivatedSuit::add_actived_suite() {
  ::idlepb::CollectionActivatedSuit* _add = _internal_add_actived_suite();
  // @@protoc_insertion_point(field_add:idlepb.NotifyCollectionActivatedSuit.actived_suite)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionActivatedSuit >&
NotifyCollectionActivatedSuit::actived_suite() const {
  // @@protoc_insertion_point(field_list:idlepb.NotifyCollectionActivatedSuit.actived_suite)
  return _impl_.actived_suite_;
}

// -------------------------------------------------------------------

// ShareSelfRoleCollectionReq

// int32 id = 1;
inline void ShareSelfRoleCollectionReq::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t ShareSelfRoleCollectionReq::_internal_id() const {
  return _impl_.id_;
}
inline int32_t ShareSelfRoleCollectionReq::id() const {
  // @@protoc_insertion_point(field_get:idlepb.ShareSelfRoleCollectionReq.id)
  return _internal_id();
}
inline void ShareSelfRoleCollectionReq::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void ShareSelfRoleCollectionReq::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ShareSelfRoleCollectionReq.id)
}

// -------------------------------------------------------------------

// ShareSelfRoleCollectionRsp

// int64 share_id = 1;
inline void ShareSelfRoleCollectionRsp::clear_share_id() {
  _impl_.share_id_ = int64_t{0};
}
inline int64_t ShareSelfRoleCollectionRsp::_internal_share_id() const {
  return _impl_.share_id_;
}
inline int64_t ShareSelfRoleCollectionRsp::share_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ShareSelfRoleCollectionRsp.share_id)
  return _internal_share_id();
}
inline void ShareSelfRoleCollectionRsp::_internal_set_share_id(int64_t value) {
  
  _impl_.share_id_ = value;
}
inline void ShareSelfRoleCollectionRsp::set_share_id(int64_t value) {
  _internal_set_share_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ShareSelfRoleCollectionRsp.share_id)
}

// -------------------------------------------------------------------

// GetShareRoleCollectionDataReq

// int64 share_id = 1;
inline void GetShareRoleCollectionDataReq::clear_share_id() {
  _impl_.share_id_ = int64_t{0};
}
inline int64_t GetShareRoleCollectionDataReq::_internal_share_id() const {
  return _impl_.share_id_;
}
inline int64_t GetShareRoleCollectionDataReq::share_id() const {
  // @@protoc_insertion_point(field_get:idlepb.GetShareRoleCollectionDataReq.share_id)
  return _internal_share_id();
}
inline void GetShareRoleCollectionDataReq::_internal_set_share_id(int64_t value) {
  
  _impl_.share_id_ = value;
}
inline void GetShareRoleCollectionDataReq::set_share_id(int64_t value) {
  _internal_set_share_id(value);
  // @@protoc_insertion_point(field_set:idlepb.GetShareRoleCollectionDataReq.share_id)
}

// -------------------------------------------------------------------

// GetShareRoleCollectionDataRsp

// bool ok = 1;
inline void GetShareRoleCollectionDataRsp::clear_ok() {
  _impl_.ok_ = false;
}
inline bool GetShareRoleCollectionDataRsp::_internal_ok() const {
  return _impl_.ok_;
}
inline bool GetShareRoleCollectionDataRsp::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.GetShareRoleCollectionDataRsp.ok)
  return _internal_ok();
}
inline void GetShareRoleCollectionDataRsp::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void GetShareRoleCollectionDataRsp::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.GetShareRoleCollectionDataRsp.ok)
}

// .idlepb.CollectionEntry collection_data = 2;
inline bool GetShareRoleCollectionDataRsp::_internal_has_collection_data() const {
  return this != internal_default_instance() && _impl_.collection_data_ != nullptr;
}
inline bool GetShareRoleCollectionDataRsp::has_collection_data() const {
  return _internal_has_collection_data();
}
inline const ::idlepb::CollectionEntry& GetShareRoleCollectionDataRsp::_internal_collection_data() const {
  const ::idlepb::CollectionEntry* p = _impl_.collection_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::CollectionEntry&>(
      ::idlepb::_CollectionEntry_default_instance_);
}
inline const ::idlepb::CollectionEntry& GetShareRoleCollectionDataRsp::collection_data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetShareRoleCollectionDataRsp.collection_data)
  return _internal_collection_data();
}
inline void GetShareRoleCollectionDataRsp::unsafe_arena_set_allocated_collection_data(
    ::idlepb::CollectionEntry* collection_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.collection_data_);
  }
  _impl_.collection_data_ = collection_data;
  if (collection_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetShareRoleCollectionDataRsp.collection_data)
}
inline ::idlepb::CollectionEntry* GetShareRoleCollectionDataRsp::release_collection_data() {
  
  ::idlepb::CollectionEntry* temp = _impl_.collection_data_;
  _impl_.collection_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::CollectionEntry* GetShareRoleCollectionDataRsp::unsafe_arena_release_collection_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetShareRoleCollectionDataRsp.collection_data)
  
  ::idlepb::CollectionEntry* temp = _impl_.collection_data_;
  _impl_.collection_data_ = nullptr;
  return temp;
}
inline ::idlepb::CollectionEntry* GetShareRoleCollectionDataRsp::_internal_mutable_collection_data() {
  
  if (_impl_.collection_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::CollectionEntry>(GetArenaForAllocation());
    _impl_.collection_data_ = p;
  }
  return _impl_.collection_data_;
}
inline ::idlepb::CollectionEntry* GetShareRoleCollectionDataRsp::mutable_collection_data() {
  ::idlepb::CollectionEntry* _msg = _internal_mutable_collection_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetShareRoleCollectionDataRsp.collection_data)
  return _msg;
}
inline void GetShareRoleCollectionDataRsp::set_allocated_collection_data(::idlepb::CollectionEntry* collection_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.collection_data_);
  }
  if (collection_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(collection_data));
    if (message_arena != submessage_arena) {
      collection_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collection_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.collection_data_ = collection_data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetShareRoleCollectionDataRsp.collection_data)
}

// -------------------------------------------------------------------

// NotifyRoleCollectionHistories

// repeated int32 draw_award_done_histories = 1;
inline int NotifyRoleCollectionHistories::_internal_draw_award_done_histories_size() const {
  return _impl_.draw_award_done_histories_.size();
}
inline int NotifyRoleCollectionHistories::draw_award_done_histories_size() const {
  return _internal_draw_award_done_histories_size();
}
inline void NotifyRoleCollectionHistories::clear_draw_award_done_histories() {
  _impl_.draw_award_done_histories_.Clear();
}
inline int32_t NotifyRoleCollectionHistories::_internal_draw_award_done_histories(int index) const {
  return _impl_.draw_award_done_histories_.Get(index);
}
inline int32_t NotifyRoleCollectionHistories::draw_award_done_histories(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyRoleCollectionHistories.draw_award_done_histories)
  return _internal_draw_award_done_histories(index);
}
inline void NotifyRoleCollectionHistories::set_draw_award_done_histories(int index, int32_t value) {
  _impl_.draw_award_done_histories_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyRoleCollectionHistories.draw_award_done_histories)
}
inline void NotifyRoleCollectionHistories::_internal_add_draw_award_done_histories(int32_t value) {
  _impl_.draw_award_done_histories_.Add(value);
}
inline void NotifyRoleCollectionHistories::add_draw_award_done_histories(int32_t value) {
  _internal_add_draw_award_done_histories(value);
  // @@protoc_insertion_point(field_add:idlepb.NotifyRoleCollectionHistories.draw_award_done_histories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
NotifyRoleCollectionHistories::_internal_draw_award_done_histories() const {
  return _impl_.draw_award_done_histories_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
NotifyRoleCollectionHistories::draw_award_done_histories() const {
  // @@protoc_insertion_point(field_list:idlepb.NotifyRoleCollectionHistories.draw_award_done_histories)
  return _internal_draw_award_done_histories();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
NotifyRoleCollectionHistories::_internal_mutable_draw_award_done_histories() {
  return &_impl_.draw_award_done_histories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
NotifyRoleCollectionHistories::mutable_draw_award_done_histories() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.NotifyRoleCollectionHistories.draw_award_done_histories)
  return _internal_mutable_draw_award_done_histories();
}

// repeated int32 can_award_histories = 2;
inline int NotifyRoleCollectionHistories::_internal_can_award_histories_size() const {
  return _impl_.can_award_histories_.size();
}
inline int NotifyRoleCollectionHistories::can_award_histories_size() const {
  return _internal_can_award_histories_size();
}
inline void NotifyRoleCollectionHistories::clear_can_award_histories() {
  _impl_.can_award_histories_.Clear();
}
inline int32_t NotifyRoleCollectionHistories::_internal_can_award_histories(int index) const {
  return _impl_.can_award_histories_.Get(index);
}
inline int32_t NotifyRoleCollectionHistories::can_award_histories(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyRoleCollectionHistories.can_award_histories)
  return _internal_can_award_histories(index);
}
inline void NotifyRoleCollectionHistories::set_can_award_histories(int index, int32_t value) {
  _impl_.can_award_histories_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyRoleCollectionHistories.can_award_histories)
}
inline void NotifyRoleCollectionHistories::_internal_add_can_award_histories(int32_t value) {
  _impl_.can_award_histories_.Add(value);
}
inline void NotifyRoleCollectionHistories::add_can_award_histories(int32_t value) {
  _internal_add_can_award_histories(value);
  // @@protoc_insertion_point(field_add:idlepb.NotifyRoleCollectionHistories.can_award_histories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
NotifyRoleCollectionHistories::_internal_can_award_histories() const {
  return _impl_.can_award_histories_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
NotifyRoleCollectionHistories::can_award_histories() const {
  // @@protoc_insertion_point(field_list:idlepb.NotifyRoleCollectionHistories.can_award_histories)
  return _internal_can_award_histories();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
NotifyRoleCollectionHistories::_internal_mutable_can_award_histories() {
  return &_impl_.can_award_histories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
NotifyRoleCollectionHistories::mutable_can_award_histories() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.NotifyRoleCollectionHistories.can_award_histories)
  return _internal_mutable_can_award_histories();
}

// -------------------------------------------------------------------

// NotifyCollectionZoneActiveAwards

// repeated .idlepb.CollectionZoneActiveAwardData zone_active_awards = 1;
inline int NotifyCollectionZoneActiveAwards::_internal_zone_active_awards_size() const {
  return _impl_.zone_active_awards_.size();
}
inline int NotifyCollectionZoneActiveAwards::zone_active_awards_size() const {
  return _internal_zone_active_awards_size();
}
inline ::idlepb::CollectionZoneActiveAwardData* NotifyCollectionZoneActiveAwards::mutable_zone_active_awards(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.NotifyCollectionZoneActiveAwards.zone_active_awards)
  return _impl_.zone_active_awards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionZoneActiveAwardData >*
NotifyCollectionZoneActiveAwards::mutable_zone_active_awards() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.NotifyCollectionZoneActiveAwards.zone_active_awards)
  return &_impl_.zone_active_awards_;
}
inline const ::idlepb::CollectionZoneActiveAwardData& NotifyCollectionZoneActiveAwards::_internal_zone_active_awards(int index) const {
  return _impl_.zone_active_awards_.Get(index);
}
inline const ::idlepb::CollectionZoneActiveAwardData& NotifyCollectionZoneActiveAwards::zone_active_awards(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyCollectionZoneActiveAwards.zone_active_awards)
  return _internal_zone_active_awards(index);
}
inline ::idlepb::CollectionZoneActiveAwardData* NotifyCollectionZoneActiveAwards::_internal_add_zone_active_awards() {
  return _impl_.zone_active_awards_.Add();
}
inline ::idlepb::CollectionZoneActiveAwardData* NotifyCollectionZoneActiveAwards::add_zone_active_awards() {
  ::idlepb::CollectionZoneActiveAwardData* _add = _internal_add_zone_active_awards();
  // @@protoc_insertion_point(field_add:idlepb.NotifyCollectionZoneActiveAwards.zone_active_awards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::CollectionZoneActiveAwardData >&
NotifyCollectionZoneActiveAwards::zone_active_awards() const {
  // @@protoc_insertion_point(field_list:idlepb.NotifyCollectionZoneActiveAwards.zone_active_awards)
  return _impl_.zone_active_awards_;
}

// -------------------------------------------------------------------

// NotifyRoleCollectionNextResetEnhanceTicks

// int64 next_reset_enhance_ticks = 1;
inline void NotifyRoleCollectionNextResetEnhanceTicks::clear_next_reset_enhance_ticks() {
  _impl_.next_reset_enhance_ticks_ = int64_t{0};
}
inline int64_t NotifyRoleCollectionNextResetEnhanceTicks::_internal_next_reset_enhance_ticks() const {
  return _impl_.next_reset_enhance_ticks_;
}
inline int64_t NotifyRoleCollectionNextResetEnhanceTicks::next_reset_enhance_ticks() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyRoleCollectionNextResetEnhanceTicks.next_reset_enhance_ticks)
  return _internal_next_reset_enhance_ticks();
}
inline void NotifyRoleCollectionNextResetEnhanceTicks::_internal_set_next_reset_enhance_ticks(int64_t value) {
  
  _impl_.next_reset_enhance_ticks_ = value;
}
inline void NotifyRoleCollectionNextResetEnhanceTicks::set_next_reset_enhance_ticks(int64_t value) {
  _internal_set_next_reset_enhance_ticks(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyRoleCollectionNextResetEnhanceTicks.next_reset_enhance_ticks)
}

// -------------------------------------------------------------------

// RoleBattleHistoryList

// repeated .idlepb.RoleBattleInfo entries = 1;
inline int RoleBattleHistoryList::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int RoleBattleHistoryList::entries_size() const {
  return _internal_entries_size();
}
inline ::idlepb::RoleBattleInfo* RoleBattleHistoryList::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.RoleBattleHistoryList.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::RoleBattleInfo >*
RoleBattleHistoryList::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.RoleBattleHistoryList.entries)
  return &_impl_.entries_;
}
inline const ::idlepb::RoleBattleInfo& RoleBattleHistoryList::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::idlepb::RoleBattleInfo& RoleBattleHistoryList::entries(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.RoleBattleHistoryList.entries)
  return _internal_entries(index);
}
inline ::idlepb::RoleBattleInfo* RoleBattleHistoryList::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::idlepb::RoleBattleInfo* RoleBattleHistoryList::add_entries() {
  ::idlepb::RoleBattleInfo* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:idlepb.RoleBattleHistoryList.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::RoleBattleInfo >&
RoleBattleHistoryList::entries() const {
  // @@protoc_insertion_point(field_list:idlepb.RoleBattleHistoryList.entries)
  return _impl_.entries_;
}

// -------------------------------------------------------------------

// NotifySoloArenaChallengeOver

// bool win = 1;
inline void NotifySoloArenaChallengeOver::clear_win() {
  _impl_.win_ = false;
}
inline bool NotifySoloArenaChallengeOver::_internal_win() const {
  return _impl_.win_;
}
inline bool NotifySoloArenaChallengeOver::win() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifySoloArenaChallengeOver.win)
  return _internal_win();
}
inline void NotifySoloArenaChallengeOver::_internal_set_win(bool value) {
  
  _impl_.win_ = value;
}
inline void NotifySoloArenaChallengeOver::set_win(bool value) {
  _internal_set_win(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifySoloArenaChallengeOver.win)
}

// .idlepb.BattleInfo info = 2;
inline bool NotifySoloArenaChallengeOver::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool NotifySoloArenaChallengeOver::has_info() const {
  return _internal_has_info();
}
inline const ::idlepb::BattleInfo& NotifySoloArenaChallengeOver::_internal_info() const {
  const ::idlepb::BattleInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::BattleInfo&>(
      ::idlepb::_BattleInfo_default_instance_);
}
inline const ::idlepb::BattleInfo& NotifySoloArenaChallengeOver::info() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifySoloArenaChallengeOver.info)
  return _internal_info();
}
inline void NotifySoloArenaChallengeOver::unsafe_arena_set_allocated_info(
    ::idlepb::BattleInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.NotifySoloArenaChallengeOver.info)
}
inline ::idlepb::BattleInfo* NotifySoloArenaChallengeOver::release_info() {
  
  ::idlepb::BattleInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::BattleInfo* NotifySoloArenaChallengeOver::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:idlepb.NotifySoloArenaChallengeOver.info)
  
  ::idlepb::BattleInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::idlepb::BattleInfo* NotifySoloArenaChallengeOver::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::BattleInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::idlepb::BattleInfo* NotifySoloArenaChallengeOver::mutable_info() {
  ::idlepb::BattleInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:idlepb.NotifySoloArenaChallengeOver.info)
  return _msg;
}
inline void NotifySoloArenaChallengeOver::set_allocated_info(::idlepb::BattleInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:idlepb.NotifySoloArenaChallengeOver.info)
}

// -------------------------------------------------------------------

// SoloArenaChallengeReq

// int64 target_role_id = 1;
inline void SoloArenaChallengeReq::clear_target_role_id() {
  _impl_.target_role_id_ = int64_t{0};
}
inline int64_t SoloArenaChallengeReq::_internal_target_role_id() const {
  return _impl_.target_role_id_;
}
inline int64_t SoloArenaChallengeReq::target_role_id() const {
  // @@protoc_insertion_point(field_get:idlepb.SoloArenaChallengeReq.target_role_id)
  return _internal_target_role_id();
}
inline void SoloArenaChallengeReq::_internal_set_target_role_id(int64_t value) {
  
  _impl_.target_role_id_ = value;
}
inline void SoloArenaChallengeReq::set_target_role_id(int64_t value) {
  _internal_set_target_role_id(value);
  // @@protoc_insertion_point(field_set:idlepb.SoloArenaChallengeReq.target_role_id)
}

// -------------------------------------------------------------------

// SoloArenaChallengeAck

// bool ok = 1;
inline void SoloArenaChallengeAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SoloArenaChallengeAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SoloArenaChallengeAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.SoloArenaChallengeAck.ok)
  return _internal_ok();
}
inline void SoloArenaChallengeAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SoloArenaChallengeAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.SoloArenaChallengeAck.ok)
}

// -------------------------------------------------------------------

// SoloArenaQuickEndReq

// bool is_exit = 1;
inline void SoloArenaQuickEndReq::clear_is_exit() {
  _impl_.is_exit_ = false;
}
inline bool SoloArenaQuickEndReq::_internal_is_exit() const {
  return _impl_.is_exit_;
}
inline bool SoloArenaQuickEndReq::is_exit() const {
  // @@protoc_insertion_point(field_get:idlepb.SoloArenaQuickEndReq.is_exit)
  return _internal_is_exit();
}
inline void SoloArenaQuickEndReq::_internal_set_is_exit(bool value) {
  
  _impl_.is_exit_ = value;
}
inline void SoloArenaQuickEndReq::set_is_exit(bool value) {
  _internal_set_is_exit(value);
  // @@protoc_insertion_point(field_set:idlepb.SoloArenaQuickEndReq.is_exit)
}

// -------------------------------------------------------------------

// SoloArenaQuickEndAck

// -------------------------------------------------------------------

// GetSoloArenaHistoryListReq

// .idlepb.SoloType type = 1;
inline void GetSoloArenaHistoryListReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::idlepb::SoloType GetSoloArenaHistoryListReq::_internal_type() const {
  return static_cast< ::idlepb::SoloType >(_impl_.type_);
}
inline ::idlepb::SoloType GetSoloArenaHistoryListReq::type() const {
  // @@protoc_insertion_point(field_get:idlepb.GetSoloArenaHistoryListReq.type)
  return _internal_type();
}
inline void GetSoloArenaHistoryListReq::_internal_set_type(::idlepb::SoloType value) {
  
  _impl_.type_ = value;
}
inline void GetSoloArenaHistoryListReq::set_type(::idlepb::SoloType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:idlepb.GetSoloArenaHistoryListReq.type)
}

// -------------------------------------------------------------------

// GetSoloArenaHistoryListAck

// .idlepb.RoleBattleHistoryList data = 1;
inline bool GetSoloArenaHistoryListAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetSoloArenaHistoryListAck::has_data() const {
  return _internal_has_data();
}
inline void GetSoloArenaHistoryListAck::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::idlepb::RoleBattleHistoryList& GetSoloArenaHistoryListAck::_internal_data() const {
  const ::idlepb::RoleBattleHistoryList* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleBattleHistoryList&>(
      ::idlepb::_RoleBattleHistoryList_default_instance_);
}
inline const ::idlepb::RoleBattleHistoryList& GetSoloArenaHistoryListAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetSoloArenaHistoryListAck.data)
  return _internal_data();
}
inline void GetSoloArenaHistoryListAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleBattleHistoryList* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetSoloArenaHistoryListAck.data)
}
inline ::idlepb::RoleBattleHistoryList* GetSoloArenaHistoryListAck::release_data() {
  
  ::idlepb::RoleBattleHistoryList* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleBattleHistoryList* GetSoloArenaHistoryListAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetSoloArenaHistoryListAck.data)
  
  ::idlepb::RoleBattleHistoryList* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleBattleHistoryList* GetSoloArenaHistoryListAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleBattleHistoryList>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleBattleHistoryList* GetSoloArenaHistoryListAck::mutable_data() {
  ::idlepb::RoleBattleHistoryList* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetSoloArenaHistoryListAck.data)
  return _msg;
}
inline void GetSoloArenaHistoryListAck::set_allocated_data(::idlepb::RoleBattleHistoryList* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetSoloArenaHistoryListAck.data)
}

// -------------------------------------------------------------------

// ReplaySoloArenaHistoryReq

// uint64 history_world_id = 1;
inline void ReplaySoloArenaHistoryReq::clear_history_world_id() {
  _impl_.history_world_id_ = uint64_t{0u};
}
inline uint64_t ReplaySoloArenaHistoryReq::_internal_history_world_id() const {
  return _impl_.history_world_id_;
}
inline uint64_t ReplaySoloArenaHistoryReq::history_world_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ReplaySoloArenaHistoryReq.history_world_id)
  return _internal_history_world_id();
}
inline void ReplaySoloArenaHistoryReq::_internal_set_history_world_id(uint64_t value) {
  
  _impl_.history_world_id_ = value;
}
inline void ReplaySoloArenaHistoryReq::set_history_world_id(uint64_t value) {
  _internal_set_history_world_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ReplaySoloArenaHistoryReq.history_world_id)
}

// -------------------------------------------------------------------

// ReplaySoloArenaHistoryAck

// bool ok = 1;
inline void ReplaySoloArenaHistoryAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ReplaySoloArenaHistoryAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ReplaySoloArenaHistoryAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ReplaySoloArenaHistoryAck.ok)
  return _internal_ok();
}
inline void ReplaySoloArenaHistoryAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ReplaySoloArenaHistoryAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ReplaySoloArenaHistoryAck.ok)
}

// .idlepb.CompressedData data = 2;
inline bool ReplaySoloArenaHistoryAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool ReplaySoloArenaHistoryAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::CompressedData& ReplaySoloArenaHistoryAck::_internal_data() const {
  const ::idlepb::CompressedData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::CompressedData&>(
      ::idlepb::_CompressedData_default_instance_);
}
inline const ::idlepb::CompressedData& ReplaySoloArenaHistoryAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.ReplaySoloArenaHistoryAck.data)
  return _internal_data();
}
inline void ReplaySoloArenaHistoryAck::unsafe_arena_set_allocated_data(
    ::idlepb::CompressedData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.ReplaySoloArenaHistoryAck.data)
}
inline ::idlepb::CompressedData* ReplaySoloArenaHistoryAck::release_data() {
  
  ::idlepb::CompressedData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::CompressedData* ReplaySoloArenaHistoryAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.ReplaySoloArenaHistoryAck.data)
  
  ::idlepb::CompressedData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::CompressedData* ReplaySoloArenaHistoryAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::CompressedData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::CompressedData* ReplaySoloArenaHistoryAck::mutable_data() {
  ::idlepb::CompressedData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.ReplaySoloArenaHistoryAck.data)
  return _msg;
}
inline void ReplaySoloArenaHistoryAck::set_allocated_data(::idlepb::CompressedData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.ReplaySoloArenaHistoryAck.data)
}

// -------------------------------------------------------------------

// GetBattleHistoryInfoReq

// uint64 history_world_id = 1;
inline void GetBattleHistoryInfoReq::clear_history_world_id() {
  _impl_.history_world_id_ = uint64_t{0u};
}
inline uint64_t GetBattleHistoryInfoReq::_internal_history_world_id() const {
  return _impl_.history_world_id_;
}
inline uint64_t GetBattleHistoryInfoReq::history_world_id() const {
  // @@protoc_insertion_point(field_get:idlepb.GetBattleHistoryInfoReq.history_world_id)
  return _internal_history_world_id();
}
inline void GetBattleHistoryInfoReq::_internal_set_history_world_id(uint64_t value) {
  
  _impl_.history_world_id_ = value;
}
inline void GetBattleHistoryInfoReq::set_history_world_id(uint64_t value) {
  _internal_set_history_world_id(value);
  // @@protoc_insertion_point(field_set:idlepb.GetBattleHistoryInfoReq.history_world_id)
}

// -------------------------------------------------------------------

// GetBattleHistoryInfoAck

// bool ok = 1;
inline void GetBattleHistoryInfoAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool GetBattleHistoryInfoAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool GetBattleHistoryInfoAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.GetBattleHistoryInfoAck.ok)
  return _internal_ok();
}
inline void GetBattleHistoryInfoAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void GetBattleHistoryInfoAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.GetBattleHistoryInfoAck.ok)
}

// .idlepb.BattleInfo info = 2;
inline bool GetBattleHistoryInfoAck::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool GetBattleHistoryInfoAck::has_info() const {
  return _internal_has_info();
}
inline const ::idlepb::BattleInfo& GetBattleHistoryInfoAck::_internal_info() const {
  const ::idlepb::BattleInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::BattleInfo&>(
      ::idlepb::_BattleInfo_default_instance_);
}
inline const ::idlepb::BattleInfo& GetBattleHistoryInfoAck::info() const {
  // @@protoc_insertion_point(field_get:idlepb.GetBattleHistoryInfoAck.info)
  return _internal_info();
}
inline void GetBattleHistoryInfoAck::unsafe_arena_set_allocated_info(
    ::idlepb::BattleInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetBattleHistoryInfoAck.info)
}
inline ::idlepb::BattleInfo* GetBattleHistoryInfoAck::release_info() {
  
  ::idlepb::BattleInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::BattleInfo* GetBattleHistoryInfoAck::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:idlepb.GetBattleHistoryInfoAck.info)
  
  ::idlepb::BattleInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::idlepb::BattleInfo* GetBattleHistoryInfoAck::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::BattleInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::idlepb::BattleInfo* GetBattleHistoryInfoAck::mutable_info() {
  ::idlepb::BattleInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:idlepb.GetBattleHistoryInfoAck.info)
  return _msg;
}
inline void GetBattleHistoryInfoAck::set_allocated_info(::idlepb::BattleInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetBattleHistoryInfoAck.info)
}

// -------------------------------------------------------------------

// NotifyEnterOpenClientWorld

// int32 world_cfg_id = 1;
inline void NotifyEnterOpenClientWorld::clear_world_cfg_id() {
  _impl_.world_cfg_id_ = 0;
}
inline int32_t NotifyEnterOpenClientWorld::_internal_world_cfg_id() const {
  return _impl_.world_cfg_id_;
}
inline int32_t NotifyEnterOpenClientWorld::world_cfg_id() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyEnterOpenClientWorld.world_cfg_id)
  return _internal_world_cfg_id();
}
inline void NotifyEnterOpenClientWorld::_internal_set_world_cfg_id(int32_t value) {
  
  _impl_.world_cfg_id_ = value;
}
inline void NotifyEnterOpenClientWorld::set_world_cfg_id(int32_t value) {
  _internal_set_world_cfg_id(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyEnterOpenClientWorld.world_cfg_id)
}

// -------------------------------------------------------------------

// NotifyMonsterTowerData

// .idlepb.RoleMonsterTowerData data = 1;
inline bool NotifyMonsterTowerData::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool NotifyMonsterTowerData::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleMonsterTowerData& NotifyMonsterTowerData::_internal_data() const {
  const ::idlepb::RoleMonsterTowerData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleMonsterTowerData&>(
      ::idlepb::_RoleMonsterTowerData_default_instance_);
}
inline const ::idlepb::RoleMonsterTowerData& NotifyMonsterTowerData::data() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyMonsterTowerData.data)
  return _internal_data();
}
inline void NotifyMonsterTowerData::unsafe_arena_set_allocated_data(
    ::idlepb::RoleMonsterTowerData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.NotifyMonsterTowerData.data)
}
inline ::idlepb::RoleMonsterTowerData* NotifyMonsterTowerData::release_data() {
  
  ::idlepb::RoleMonsterTowerData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleMonsterTowerData* NotifyMonsterTowerData::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.NotifyMonsterTowerData.data)
  
  ::idlepb::RoleMonsterTowerData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleMonsterTowerData* NotifyMonsterTowerData::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleMonsterTowerData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleMonsterTowerData* NotifyMonsterTowerData::mutable_data() {
  ::idlepb::RoleMonsterTowerData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.NotifyMonsterTowerData.data)
  return _msg;
}
inline void NotifyMonsterTowerData::set_allocated_data(::idlepb::RoleMonsterTowerData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.NotifyMonsterTowerData.data)
}

// -------------------------------------------------------------------

// NotifyMonsterTowerChallengeOver

// int32 floor = 1;
inline void NotifyMonsterTowerChallengeOver::clear_floor() {
  _impl_.floor_ = 0;
}
inline int32_t NotifyMonsterTowerChallengeOver::_internal_floor() const {
  return _impl_.floor_;
}
inline int32_t NotifyMonsterTowerChallengeOver::floor() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyMonsterTowerChallengeOver.floor)
  return _internal_floor();
}
inline void NotifyMonsterTowerChallengeOver::_internal_set_floor(int32_t value) {
  
  _impl_.floor_ = value;
}
inline void NotifyMonsterTowerChallengeOver::set_floor(int32_t value) {
  _internal_set_floor(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyMonsterTowerChallengeOver.floor)
}

// bool win = 2;
inline void NotifyMonsterTowerChallengeOver::clear_win() {
  _impl_.win_ = false;
}
inline bool NotifyMonsterTowerChallengeOver::_internal_win() const {
  return _impl_.win_;
}
inline bool NotifyMonsterTowerChallengeOver::win() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyMonsterTowerChallengeOver.win)
  return _internal_win();
}
inline void NotifyMonsterTowerChallengeOver::_internal_set_win(bool value) {
  
  _impl_.win_ = value;
}
inline void NotifyMonsterTowerChallengeOver::set_win(bool value) {
  _internal_set_win(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyMonsterTowerChallengeOver.win)
}

// -------------------------------------------------------------------

// MonsterTowerChallengeReq

// -------------------------------------------------------------------

// MonsterTowerChallengeAck

// -------------------------------------------------------------------

// MonsterTowerDrawIdleAwardReq

// -------------------------------------------------------------------

// MonsterTowerDrawIdleAwardAck

// -------------------------------------------------------------------

// MonsterTowerClosedDoorTrainingReq

// -------------------------------------------------------------------

// MonsterTowerClosedDoorTrainingAck

// -------------------------------------------------------------------

// MonsterTowerQuickEndReq

// bool is_exit = 1;
inline void MonsterTowerQuickEndReq::clear_is_exit() {
  _impl_.is_exit_ = false;
}
inline bool MonsterTowerQuickEndReq::_internal_is_exit() const {
  return _impl_.is_exit_;
}
inline bool MonsterTowerQuickEndReq::is_exit() const {
  // @@protoc_insertion_point(field_get:idlepb.MonsterTowerQuickEndReq.is_exit)
  return _internal_is_exit();
}
inline void MonsterTowerQuickEndReq::_internal_set_is_exit(bool value) {
  
  _impl_.is_exit_ = value;
}
inline void MonsterTowerQuickEndReq::set_is_exit(bool value) {
  _internal_set_is_exit(value);
  // @@protoc_insertion_point(field_set:idlepb.MonsterTowerQuickEndReq.is_exit)
}

// -------------------------------------------------------------------

// MonsterTowerQuickEndAck

// -------------------------------------------------------------------

// NotifyFightModeData

// .idlepb.RoleFightModeData data = 1;
inline bool NotifyFightModeData::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool NotifyFightModeData::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleFightModeData& NotifyFightModeData::_internal_data() const {
  const ::idlepb::RoleFightModeData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleFightModeData&>(
      ::idlepb::_RoleFightModeData_default_instance_);
}
inline const ::idlepb::RoleFightModeData& NotifyFightModeData::data() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyFightModeData.data)
  return _internal_data();
}
inline void NotifyFightModeData::unsafe_arena_set_allocated_data(
    ::idlepb::RoleFightModeData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.NotifyFightModeData.data)
}
inline ::idlepb::RoleFightModeData* NotifyFightModeData::release_data() {
  
  ::idlepb::RoleFightModeData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleFightModeData* NotifyFightModeData::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.NotifyFightModeData.data)
  
  ::idlepb::RoleFightModeData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleFightModeData* NotifyFightModeData::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleFightModeData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleFightModeData* NotifyFightModeData::mutable_data() {
  ::idlepb::RoleFightModeData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.NotifyFightModeData.data)
  return _msg;
}
inline void NotifyFightModeData::set_allocated_data(::idlepb::RoleFightModeData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.NotifyFightModeData.data)
}

// -------------------------------------------------------------------

// SetFightModeReq

// .idlepb.FightMode mode = 1;
inline void SetFightModeReq::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::idlepb::FightMode SetFightModeReq::_internal_mode() const {
  return static_cast< ::idlepb::FightMode >(_impl_.mode_);
}
inline ::idlepb::FightMode SetFightModeReq::mode() const {
  // @@protoc_insertion_point(field_get:idlepb.SetFightModeReq.mode)
  return _internal_mode();
}
inline void SetFightModeReq::_internal_set_mode(::idlepb::FightMode value) {
  
  _impl_.mode_ = value;
}
inline void SetFightModeReq::set_mode(::idlepb::FightMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:idlepb.SetFightModeReq.mode)
}

// -------------------------------------------------------------------

// SetFightModeAck

// bool ok = 1;
inline void SetFightModeAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SetFightModeAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SetFightModeAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.SetFightModeAck.ok)
  return _internal_ok();
}
inline void SetFightModeAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SetFightModeAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.SetFightModeAck.ok)
}

// .idlepb.SetFightModeAckErrorCode error_code = 2;
inline void SetFightModeAck::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline ::idlepb::SetFightModeAckErrorCode SetFightModeAck::_internal_error_code() const {
  return static_cast< ::idlepb::SetFightModeAckErrorCode >(_impl_.error_code_);
}
inline ::idlepb::SetFightModeAckErrorCode SetFightModeAck::error_code() const {
  // @@protoc_insertion_point(field_get:idlepb.SetFightModeAck.error_code)
  return _internal_error_code();
}
inline void SetFightModeAck::_internal_set_error_code(::idlepb::SetFightModeAckErrorCode value) {
  
  _impl_.error_code_ = value;
}
inline void SetFightModeAck::set_error_code(::idlepb::SetFightModeAckErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:idlepb.SetFightModeAck.error_code)
}

// -------------------------------------------------------------------

// NotifyInventorySpaceNum

// int32 num = 1;
inline void NotifyInventorySpaceNum::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t NotifyInventorySpaceNum::_internal_num() const {
  return _impl_.num_;
}
inline int32_t NotifyInventorySpaceNum::num() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyInventorySpaceNum.num)
  return _internal_num();
}
inline void NotifyInventorySpaceNum::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void NotifyInventorySpaceNum::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyInventorySpaceNum.num)
}

// -------------------------------------------------------------------

// NotifyInventoryFullMailItem

// -------------------------------------------------------------------

// NotifyQiCollectorRank

// int32 rank = 1;
inline void NotifyQiCollectorRank::clear_rank() {
  _impl_.rank_ = 0;
}
inline int32_t NotifyQiCollectorRank::_internal_rank() const {
  return _impl_.rank_;
}
inline int32_t NotifyQiCollectorRank::rank() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyQiCollectorRank.rank)
  return _internal_rank();
}
inline void NotifyQiCollectorRank::_internal_set_rank(int32_t value) {
  
  _impl_.rank_ = value;
}
inline void NotifyQiCollectorRank::set_rank(int32_t value) {
  _internal_set_rank(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyQiCollectorRank.rank)
}

// -------------------------------------------------------------------

// UpgradeQiCollectorReq

// -------------------------------------------------------------------

// UpgradeQiCollectorAck

// bool ok = 1;
inline void UpgradeQiCollectorAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool UpgradeQiCollectorAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool UpgradeQiCollectorAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.UpgradeQiCollectorAck.ok)
  return _internal_ok();
}
inline void UpgradeQiCollectorAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void UpgradeQiCollectorAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.UpgradeQiCollectorAck.ok)
}

// -------------------------------------------------------------------

// GetRoleAllStatsReq

// -------------------------------------------------------------------

// GetRoleAllStatsAck

// .idlepb.GameStatsAllModuleData all_stats_data = 1;
inline bool GetRoleAllStatsAck::_internal_has_all_stats_data() const {
  return this != internal_default_instance() && _impl_.all_stats_data_ != nullptr;
}
inline bool GetRoleAllStatsAck::has_all_stats_data() const {
  return _internal_has_all_stats_data();
}
inline const ::idlepb::GameStatsAllModuleData& GetRoleAllStatsAck::_internal_all_stats_data() const {
  const ::idlepb::GameStatsAllModuleData* p = _impl_.all_stats_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::GameStatsAllModuleData&>(
      ::idlepb::_GameStatsAllModuleData_default_instance_);
}
inline const ::idlepb::GameStatsAllModuleData& GetRoleAllStatsAck::all_stats_data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleAllStatsAck.all_stats_data)
  return _internal_all_stats_data();
}
inline void GetRoleAllStatsAck::unsafe_arena_set_allocated_all_stats_data(
    ::idlepb::GameStatsAllModuleData* all_stats_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.all_stats_data_);
  }
  _impl_.all_stats_data_ = all_stats_data;
  if (all_stats_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleAllStatsAck.all_stats_data)
}
inline ::idlepb::GameStatsAllModuleData* GetRoleAllStatsAck::release_all_stats_data() {
  
  ::idlepb::GameStatsAllModuleData* temp = _impl_.all_stats_data_;
  _impl_.all_stats_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::GameStatsAllModuleData* GetRoleAllStatsAck::unsafe_arena_release_all_stats_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleAllStatsAck.all_stats_data)
  
  ::idlepb::GameStatsAllModuleData* temp = _impl_.all_stats_data_;
  _impl_.all_stats_data_ = nullptr;
  return temp;
}
inline ::idlepb::GameStatsAllModuleData* GetRoleAllStatsAck::_internal_mutable_all_stats_data() {
  
  if (_impl_.all_stats_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::GameStatsAllModuleData>(GetArenaForAllocation());
    _impl_.all_stats_data_ = p;
  }
  return _impl_.all_stats_data_;
}
inline ::idlepb::GameStatsAllModuleData* GetRoleAllStatsAck::mutable_all_stats_data() {
  ::idlepb::GameStatsAllModuleData* _msg = _internal_mutable_all_stats_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleAllStatsAck.all_stats_data)
  return _msg;
}
inline void GetRoleAllStatsAck::set_allocated_all_stats_data(::idlepb::GameStatsAllModuleData* all_stats_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.all_stats_data_);
  }
  if (all_stats_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(all_stats_data));
    if (message_arena != submessage_arena) {
      all_stats_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, all_stats_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.all_stats_data_ = all_stats_data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleAllStatsAck.all_stats_data)
}

// -------------------------------------------------------------------

// GetShanhetuDataReq

// -------------------------------------------------------------------

// GetShanhetuDataAck

// .idlepb.RoleShanhetuData data = 1;
inline bool GetShanhetuDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetShanhetuDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleShanhetuData& GetShanhetuDataAck::_internal_data() const {
  const ::idlepb::RoleShanhetuData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleShanhetuData&>(
      ::idlepb::_RoleShanhetuData_default_instance_);
}
inline const ::idlepb::RoleShanhetuData& GetShanhetuDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetShanhetuDataAck.data)
  return _internal_data();
}
inline void GetShanhetuDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleShanhetuData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetShanhetuDataAck.data)
}
inline ::idlepb::RoleShanhetuData* GetShanhetuDataAck::release_data() {
  
  ::idlepb::RoleShanhetuData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleShanhetuData* GetShanhetuDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetShanhetuDataAck.data)
  
  ::idlepb::RoleShanhetuData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleShanhetuData* GetShanhetuDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleShanhetuData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleShanhetuData* GetShanhetuDataAck::mutable_data() {
  ::idlepb::RoleShanhetuData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetShanhetuDataAck.data)
  return _msg;
}
inline void GetShanhetuDataAck::set_allocated_data(::idlepb::RoleShanhetuData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetShanhetuDataAck.data)
}

// -------------------------------------------------------------------

// SetShanhetuUseConfigReq

// bool auto_skip_green = 1;
inline void SetShanhetuUseConfigReq::clear_auto_skip_green() {
  _impl_.auto_skip_green_ = false;
}
inline bool SetShanhetuUseConfigReq::_internal_auto_skip_green() const {
  return _impl_.auto_skip_green_;
}
inline bool SetShanhetuUseConfigReq::auto_skip_green() const {
  // @@protoc_insertion_point(field_get:idlepb.SetShanhetuUseConfigReq.auto_skip_green)
  return _internal_auto_skip_green();
}
inline void SetShanhetuUseConfigReq::_internal_set_auto_skip_green(bool value) {
  
  _impl_.auto_skip_green_ = value;
}
inline void SetShanhetuUseConfigReq::set_auto_skip_green(bool value) {
  _internal_set_auto_skip_green(value);
  // @@protoc_insertion_point(field_set:idlepb.SetShanhetuUseConfigReq.auto_skip_green)
}

// bool auto_skip_blue = 2;
inline void SetShanhetuUseConfigReq::clear_auto_skip_blue() {
  _impl_.auto_skip_blue_ = false;
}
inline bool SetShanhetuUseConfigReq::_internal_auto_skip_blue() const {
  return _impl_.auto_skip_blue_;
}
inline bool SetShanhetuUseConfigReq::auto_skip_blue() const {
  // @@protoc_insertion_point(field_get:idlepb.SetShanhetuUseConfigReq.auto_skip_blue)
  return _internal_auto_skip_blue();
}
inline void SetShanhetuUseConfigReq::_internal_set_auto_skip_blue(bool value) {
  
  _impl_.auto_skip_blue_ = value;
}
inline void SetShanhetuUseConfigReq::set_auto_skip_blue(bool value) {
  _internal_set_auto_skip_blue(value);
  // @@protoc_insertion_point(field_set:idlepb.SetShanhetuUseConfigReq.auto_skip_blue)
}

// bool auto_skip_perpo = 3;
inline void SetShanhetuUseConfigReq::clear_auto_skip_perpo() {
  _impl_.auto_skip_perpo_ = false;
}
inline bool SetShanhetuUseConfigReq::_internal_auto_skip_perpo() const {
  return _impl_.auto_skip_perpo_;
}
inline bool SetShanhetuUseConfigReq::auto_skip_perpo() const {
  // @@protoc_insertion_point(field_get:idlepb.SetShanhetuUseConfigReq.auto_skip_perpo)
  return _internal_auto_skip_perpo();
}
inline void SetShanhetuUseConfigReq::_internal_set_auto_skip_perpo(bool value) {
  
  _impl_.auto_skip_perpo_ = value;
}
inline void SetShanhetuUseConfigReq::set_auto_skip_perpo(bool value) {
  _internal_set_auto_skip_perpo(value);
  // @@protoc_insertion_point(field_set:idlepb.SetShanhetuUseConfigReq.auto_skip_perpo)
}

// bool auto_skip_gold = 4;
inline void SetShanhetuUseConfigReq::clear_auto_skip_gold() {
  _impl_.auto_skip_gold_ = false;
}
inline bool SetShanhetuUseConfigReq::_internal_auto_skip_gold() const {
  return _impl_.auto_skip_gold_;
}
inline bool SetShanhetuUseConfigReq::auto_skip_gold() const {
  // @@protoc_insertion_point(field_get:idlepb.SetShanhetuUseConfigReq.auto_skip_gold)
  return _internal_auto_skip_gold();
}
inline void SetShanhetuUseConfigReq::_internal_set_auto_skip_gold(bool value) {
  
  _impl_.auto_skip_gold_ = value;
}
inline void SetShanhetuUseConfigReq::set_auto_skip_gold(bool value) {
  _internal_set_auto_skip_gold(value);
  // @@protoc_insertion_point(field_set:idlepb.SetShanhetuUseConfigReq.auto_skip_gold)
}

// bool auto_skip_red = 5;
inline void SetShanhetuUseConfigReq::clear_auto_skip_red() {
  _impl_.auto_skip_red_ = false;
}
inline bool SetShanhetuUseConfigReq::_internal_auto_skip_red() const {
  return _impl_.auto_skip_red_;
}
inline bool SetShanhetuUseConfigReq::auto_skip_red() const {
  // @@protoc_insertion_point(field_get:idlepb.SetShanhetuUseConfigReq.auto_skip_red)
  return _internal_auto_skip_red();
}
inline void SetShanhetuUseConfigReq::_internal_set_auto_skip_red(bool value) {
  
  _impl_.auto_skip_red_ = value;
}
inline void SetShanhetuUseConfigReq::set_auto_skip_red(bool value) {
  _internal_set_auto_skip_red(value);
  // @@protoc_insertion_point(field_set:idlepb.SetShanhetuUseConfigReq.auto_skip_red)
}

// int32 auto_select = 6;
inline void SetShanhetuUseConfigReq::clear_auto_select() {
  _impl_.auto_select_ = 0;
}
inline int32_t SetShanhetuUseConfigReq::_internal_auto_select() const {
  return _impl_.auto_select_;
}
inline int32_t SetShanhetuUseConfigReq::auto_select() const {
  // @@protoc_insertion_point(field_get:idlepb.SetShanhetuUseConfigReq.auto_select)
  return _internal_auto_select();
}
inline void SetShanhetuUseConfigReq::_internal_set_auto_select(int32_t value) {
  
  _impl_.auto_select_ = value;
}
inline void SetShanhetuUseConfigReq::set_auto_select(int32_t value) {
  _internal_set_auto_select(value);
  // @@protoc_insertion_point(field_set:idlepb.SetShanhetuUseConfigReq.auto_select)
}

// -------------------------------------------------------------------

// SetShanhetuUseConfigAck

// bool ok = 1;
inline void SetShanhetuUseConfigAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SetShanhetuUseConfigAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SetShanhetuUseConfigAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.SetShanhetuUseConfigAck.ok)
  return _internal_ok();
}
inline void SetShanhetuUseConfigAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SetShanhetuUseConfigAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.SetShanhetuUseConfigAck.ok)
}

// -------------------------------------------------------------------

// UseShanhetuReq

// int32 item_id = 1;
inline void UseShanhetuReq::clear_item_id() {
  _impl_.item_id_ = 0;
}
inline int32_t UseShanhetuReq::_internal_item_id() const {
  return _impl_.item_id_;
}
inline int32_t UseShanhetuReq::item_id() const {
  // @@protoc_insertion_point(field_get:idlepb.UseShanhetuReq.item_id)
  return _internal_item_id();
}
inline void UseShanhetuReq::_internal_set_item_id(int32_t value) {
  
  _impl_.item_id_ = value;
}
inline void UseShanhetuReq::set_item_id(int32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:idlepb.UseShanhetuReq.item_id)
}

// bool skip = 2;
inline void UseShanhetuReq::clear_skip() {
  _impl_.skip_ = false;
}
inline bool UseShanhetuReq::_internal_skip() const {
  return _impl_.skip_;
}
inline bool UseShanhetuReq::skip() const {
  // @@protoc_insertion_point(field_get:idlepb.UseShanhetuReq.skip)
  return _internal_skip();
}
inline void UseShanhetuReq::_internal_set_skip(bool value) {
  
  _impl_.skip_ = value;
}
inline void UseShanhetuReq::set_skip(bool value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:idlepb.UseShanhetuReq.skip)
}

// int32 num = 3;
inline void UseShanhetuReq::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t UseShanhetuReq::_internal_num() const {
  return _impl_.num_;
}
inline int32_t UseShanhetuReq::num() const {
  // @@protoc_insertion_point(field_get:idlepb.UseShanhetuReq.num)
  return _internal_num();
}
inline void UseShanhetuReq::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void UseShanhetuReq::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.UseShanhetuReq.num)
}

// -------------------------------------------------------------------

// UseShanhetuAck

// bool ok = 1;
inline void UseShanhetuAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool UseShanhetuAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool UseShanhetuAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.UseShanhetuAck.ok)
  return _internal_ok();
}
inline void UseShanhetuAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void UseShanhetuAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.UseShanhetuAck.ok)
}

// repeated .idlepb.SimpleItemData items = 2;
inline int UseShanhetuAck::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int UseShanhetuAck::items_size() const {
  return _internal_items_size();
}
inline ::idlepb::SimpleItemData* UseShanhetuAck::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.UseShanhetuAck.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
UseShanhetuAck::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.UseShanhetuAck.items)
  return &_impl_.items_;
}
inline const ::idlepb::SimpleItemData& UseShanhetuAck::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::SimpleItemData& UseShanhetuAck::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.UseShanhetuAck.items)
  return _internal_items(index);
}
inline ::idlepb::SimpleItemData* UseShanhetuAck::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::SimpleItemData* UseShanhetuAck::add_items() {
  ::idlepb::SimpleItemData* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.UseShanhetuAck.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
UseShanhetuAck::items() const {
  // @@protoc_insertion_point(field_list:idlepb.UseShanhetuAck.items)
  return _impl_.items_;
}

// .idlepb.ShanhetuMap map = 3;
inline bool UseShanhetuAck::_internal_has_map() const {
  return this != internal_default_instance() && _impl_.map_ != nullptr;
}
inline bool UseShanhetuAck::has_map() const {
  return _internal_has_map();
}
inline const ::idlepb::ShanhetuMap& UseShanhetuAck::_internal_map() const {
  const ::idlepb::ShanhetuMap* p = _impl_.map_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::ShanhetuMap&>(
      ::idlepb::_ShanhetuMap_default_instance_);
}
inline const ::idlepb::ShanhetuMap& UseShanhetuAck::map() const {
  // @@protoc_insertion_point(field_get:idlepb.UseShanhetuAck.map)
  return _internal_map();
}
inline void UseShanhetuAck::unsafe_arena_set_allocated_map(
    ::idlepb::ShanhetuMap* map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_);
  }
  _impl_.map_ = map;
  if (map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.UseShanhetuAck.map)
}
inline ::idlepb::ShanhetuMap* UseShanhetuAck::release_map() {
  
  ::idlepb::ShanhetuMap* temp = _impl_.map_;
  _impl_.map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::ShanhetuMap* UseShanhetuAck::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_release:idlepb.UseShanhetuAck.map)
  
  ::idlepb::ShanhetuMap* temp = _impl_.map_;
  _impl_.map_ = nullptr;
  return temp;
}
inline ::idlepb::ShanhetuMap* UseShanhetuAck::_internal_mutable_map() {
  
  if (_impl_.map_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::ShanhetuMap>(GetArenaForAllocation());
    _impl_.map_ = p;
  }
  return _impl_.map_;
}
inline ::idlepb::ShanhetuMap* UseShanhetuAck::mutable_map() {
  ::idlepb::ShanhetuMap* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:idlepb.UseShanhetuAck.map)
  return _msg;
}
inline void UseShanhetuAck::set_allocated_map(::idlepb::ShanhetuMap* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_);
  }
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(map));
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.map_ = map;
  // @@protoc_insertion_point(field_set_allocated:idlepb.UseShanhetuAck.map)
}

// -------------------------------------------------------------------

// StepShanhetuReq

// int32 choose_event = 1;
inline void StepShanhetuReq::clear_choose_event() {
  _impl_.choose_event_ = 0;
}
inline int32_t StepShanhetuReq::_internal_choose_event() const {
  return _impl_.choose_event_;
}
inline int32_t StepShanhetuReq::choose_event() const {
  // @@protoc_insertion_point(field_get:idlepb.StepShanhetuReq.choose_event)
  return _internal_choose_event();
}
inline void StepShanhetuReq::_internal_set_choose_event(int32_t value) {
  
  _impl_.choose_event_ = value;
}
inline void StepShanhetuReq::set_choose_event(int32_t value) {
  _internal_set_choose_event(value);
  // @@protoc_insertion_point(field_set:idlepb.StepShanhetuReq.choose_event)
}

// -------------------------------------------------------------------

// StepShanhetuAck

// bool done = 1;
inline void StepShanhetuAck::clear_done() {
  _impl_.done_ = false;
}
inline bool StepShanhetuAck::_internal_done() const {
  return _impl_.done_;
}
inline bool StepShanhetuAck::done() const {
  // @@protoc_insertion_point(field_get:idlepb.StepShanhetuAck.done)
  return _internal_done();
}
inline void StepShanhetuAck::_internal_set_done(bool value) {
  
  _impl_.done_ = value;
}
inline void StepShanhetuAck::set_done(bool value) {
  _internal_set_done(value);
  // @@protoc_insertion_point(field_set:idlepb.StepShanhetuAck.done)
}

// int32 current_row = 2;
inline void StepShanhetuAck::clear_current_row() {
  _impl_.current_row_ = 0;
}
inline int32_t StepShanhetuAck::_internal_current_row() const {
  return _impl_.current_row_;
}
inline int32_t StepShanhetuAck::current_row() const {
  // @@protoc_insertion_point(field_get:idlepb.StepShanhetuAck.current_row)
  return _internal_current_row();
}
inline void StepShanhetuAck::_internal_set_current_row(int32_t value) {
  
  _impl_.current_row_ = value;
}
inline void StepShanhetuAck::set_current_row(int32_t value) {
  _internal_set_current_row(value);
  // @@protoc_insertion_point(field_set:idlepb.StepShanhetuAck.current_row)
}

// .idlepb.ShanhetuRecord record = 3;
inline bool StepShanhetuAck::_internal_has_record() const {
  return this != internal_default_instance() && _impl_.record_ != nullptr;
}
inline bool StepShanhetuAck::has_record() const {
  return _internal_has_record();
}
inline const ::idlepb::ShanhetuRecord& StepShanhetuAck::_internal_record() const {
  const ::idlepb::ShanhetuRecord* p = _impl_.record_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::ShanhetuRecord&>(
      ::idlepb::_ShanhetuRecord_default_instance_);
}
inline const ::idlepb::ShanhetuRecord& StepShanhetuAck::record() const {
  // @@protoc_insertion_point(field_get:idlepb.StepShanhetuAck.record)
  return _internal_record();
}
inline void StepShanhetuAck::unsafe_arena_set_allocated_record(
    ::idlepb::ShanhetuRecord* record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.record_);
  }
  _impl_.record_ = record;
  if (record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.StepShanhetuAck.record)
}
inline ::idlepb::ShanhetuRecord* StepShanhetuAck::release_record() {
  
  ::idlepb::ShanhetuRecord* temp = _impl_.record_;
  _impl_.record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::ShanhetuRecord* StepShanhetuAck::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:idlepb.StepShanhetuAck.record)
  
  ::idlepb::ShanhetuRecord* temp = _impl_.record_;
  _impl_.record_ = nullptr;
  return temp;
}
inline ::idlepb::ShanhetuRecord* StepShanhetuAck::_internal_mutable_record() {
  
  if (_impl_.record_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::ShanhetuRecord>(GetArenaForAllocation());
    _impl_.record_ = p;
  }
  return _impl_.record_;
}
inline ::idlepb::ShanhetuRecord* StepShanhetuAck::mutable_record() {
  ::idlepb::ShanhetuRecord* _msg = _internal_mutable_record();
  // @@protoc_insertion_point(field_mutable:idlepb.StepShanhetuAck.record)
  return _msg;
}
inline void StepShanhetuAck::set_allocated_record(::idlepb::ShanhetuRecord* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.record_);
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(record));
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.record_ = record;
  // @@protoc_insertion_point(field_set_allocated:idlepb.StepShanhetuAck.record)
}

// -------------------------------------------------------------------

// GetShanhetuUseRecordReq

// int64 role_id = 1;
inline void GetShanhetuUseRecordReq::clear_role_id() {
  _impl_.role_id_ = int64_t{0};
}
inline int64_t GetShanhetuUseRecordReq::_internal_role_id() const {
  return _impl_.role_id_;
}
inline int64_t GetShanhetuUseRecordReq::role_id() const {
  // @@protoc_insertion_point(field_get:idlepb.GetShanhetuUseRecordReq.role_id)
  return _internal_role_id();
}
inline void GetShanhetuUseRecordReq::_internal_set_role_id(int64_t value) {
  
  _impl_.role_id_ = value;
}
inline void GetShanhetuUseRecordReq::set_role_id(int64_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:idlepb.GetShanhetuUseRecordReq.role_id)
}

// int64 uid = 2;
inline void GetShanhetuUseRecordReq::clear_uid() {
  _impl_.uid_ = int64_t{0};
}
inline int64_t GetShanhetuUseRecordReq::_internal_uid() const {
  return _impl_.uid_;
}
inline int64_t GetShanhetuUseRecordReq::uid() const {
  // @@protoc_insertion_point(field_get:idlepb.GetShanhetuUseRecordReq.uid)
  return _internal_uid();
}
inline void GetShanhetuUseRecordReq::_internal_set_uid(int64_t value) {
  
  _impl_.uid_ = value;
}
inline void GetShanhetuUseRecordReq::set_uid(int64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.GetShanhetuUseRecordReq.uid)
}

// -------------------------------------------------------------------

// GetShanhetuUseRecordAck

// .idlepb.ShanhetuRecord record = 1;
inline bool GetShanhetuUseRecordAck::_internal_has_record() const {
  return this != internal_default_instance() && _impl_.record_ != nullptr;
}
inline bool GetShanhetuUseRecordAck::has_record() const {
  return _internal_has_record();
}
inline const ::idlepb::ShanhetuRecord& GetShanhetuUseRecordAck::_internal_record() const {
  const ::idlepb::ShanhetuRecord* p = _impl_.record_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::ShanhetuRecord&>(
      ::idlepb::_ShanhetuRecord_default_instance_);
}
inline const ::idlepb::ShanhetuRecord& GetShanhetuUseRecordAck::record() const {
  // @@protoc_insertion_point(field_get:idlepb.GetShanhetuUseRecordAck.record)
  return _internal_record();
}
inline void GetShanhetuUseRecordAck::unsafe_arena_set_allocated_record(
    ::idlepb::ShanhetuRecord* record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.record_);
  }
  _impl_.record_ = record;
  if (record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetShanhetuUseRecordAck.record)
}
inline ::idlepb::ShanhetuRecord* GetShanhetuUseRecordAck::release_record() {
  
  ::idlepb::ShanhetuRecord* temp = _impl_.record_;
  _impl_.record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::ShanhetuRecord* GetShanhetuUseRecordAck::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:idlepb.GetShanhetuUseRecordAck.record)
  
  ::idlepb::ShanhetuRecord* temp = _impl_.record_;
  _impl_.record_ = nullptr;
  return temp;
}
inline ::idlepb::ShanhetuRecord* GetShanhetuUseRecordAck::_internal_mutable_record() {
  
  if (_impl_.record_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::ShanhetuRecord>(GetArenaForAllocation());
    _impl_.record_ = p;
  }
  return _impl_.record_;
}
inline ::idlepb::ShanhetuRecord* GetShanhetuUseRecordAck::mutable_record() {
  ::idlepb::ShanhetuRecord* _msg = _internal_mutable_record();
  // @@protoc_insertion_point(field_mutable:idlepb.GetShanhetuUseRecordAck.record)
  return _msg;
}
inline void GetShanhetuUseRecordAck::set_allocated_record(::idlepb::ShanhetuRecord* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.record_);
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(record));
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.record_ = record;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetShanhetuUseRecordAck.record)
}

// -------------------------------------------------------------------

// SetAttackLockTypeReq

// .idlepb.AttackLockType type = 1;
inline void SetAttackLockTypeReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::idlepb::AttackLockType SetAttackLockTypeReq::_internal_type() const {
  return static_cast< ::idlepb::AttackLockType >(_impl_.type_);
}
inline ::idlepb::AttackLockType SetAttackLockTypeReq::type() const {
  // @@protoc_insertion_point(field_get:idlepb.SetAttackLockTypeReq.type)
  return _internal_type();
}
inline void SetAttackLockTypeReq::_internal_set_type(::idlepb::AttackLockType value) {
  
  _impl_.type_ = value;
}
inline void SetAttackLockTypeReq::set_type(::idlepb::AttackLockType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:idlepb.SetAttackLockTypeReq.type)
}

// -------------------------------------------------------------------

// SetAttackLockTypeAck

// bool ok = 1;
inline void SetAttackLockTypeAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SetAttackLockTypeAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SetAttackLockTypeAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.SetAttackLockTypeAck.ok)
  return _internal_ok();
}
inline void SetAttackLockTypeAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SetAttackLockTypeAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.SetAttackLockTypeAck.ok)
}

// -------------------------------------------------------------------

// SetAttackUnlockTypeReq

// .idlepb.AttackUnlockType type = 1;
inline void SetAttackUnlockTypeReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::idlepb::AttackUnlockType SetAttackUnlockTypeReq::_internal_type() const {
  return static_cast< ::idlepb::AttackUnlockType >(_impl_.type_);
}
inline ::idlepb::AttackUnlockType SetAttackUnlockTypeReq::type() const {
  // @@protoc_insertion_point(field_get:idlepb.SetAttackUnlockTypeReq.type)
  return _internal_type();
}
inline void SetAttackUnlockTypeReq::_internal_set_type(::idlepb::AttackUnlockType value) {
  
  _impl_.type_ = value;
}
inline void SetAttackUnlockTypeReq::set_type(::idlepb::AttackUnlockType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:idlepb.SetAttackUnlockTypeReq.type)
}

// -------------------------------------------------------------------

// SetAttackUnlockTypeAck

// bool ok = 1;
inline void SetAttackUnlockTypeAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SetAttackUnlockTypeAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SetAttackUnlockTypeAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.SetAttackUnlockTypeAck.ok)
  return _internal_ok();
}
inline void SetAttackUnlockTypeAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SetAttackUnlockTypeAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.SetAttackUnlockTypeAck.ok)
}

// -------------------------------------------------------------------

// SetShowUnlockButtonReq

// bool enable = 1;
inline void SetShowUnlockButtonReq::clear_enable() {
  _impl_.enable_ = false;
}
inline bool SetShowUnlockButtonReq::_internal_enable() const {
  return _impl_.enable_;
}
inline bool SetShowUnlockButtonReq::enable() const {
  // @@protoc_insertion_point(field_get:idlepb.SetShowUnlockButtonReq.enable)
  return _internal_enable();
}
inline void SetShowUnlockButtonReq::_internal_set_enable(bool value) {
  
  _impl_.enable_ = value;
}
inline void SetShowUnlockButtonReq::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:idlepb.SetShowUnlockButtonReq.enable)
}

// -------------------------------------------------------------------

// SetShowUnlockButtonAck

// bool ok = 1;
inline void SetShowUnlockButtonAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SetShowUnlockButtonAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SetShowUnlockButtonAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.SetShowUnlockButtonAck.ok)
  return _internal_ok();
}
inline void SetShowUnlockButtonAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SetShowUnlockButtonAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.SetShowUnlockButtonAck.ok)
}

// -------------------------------------------------------------------

// RefreshRoleNormalSetting

// .idlepb.RoleNormalSettings settings = 1;
inline bool RefreshRoleNormalSetting::_internal_has_settings() const {
  return this != internal_default_instance() && _impl_.settings_ != nullptr;
}
inline bool RefreshRoleNormalSetting::has_settings() const {
  return _internal_has_settings();
}
inline const ::idlepb::RoleNormalSettings& RefreshRoleNormalSetting::_internal_settings() const {
  const ::idlepb::RoleNormalSettings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleNormalSettings&>(
      ::idlepb::_RoleNormalSettings_default_instance_);
}
inline const ::idlepb::RoleNormalSettings& RefreshRoleNormalSetting::settings() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshRoleNormalSetting.settings)
  return _internal_settings();
}
inline void RefreshRoleNormalSetting::unsafe_arena_set_allocated_settings(
    ::idlepb::RoleNormalSettings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = settings;
  if (settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RefreshRoleNormalSetting.settings)
}
inline ::idlepb::RoleNormalSettings* RefreshRoleNormalSetting::release_settings() {
  
  ::idlepb::RoleNormalSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleNormalSettings* RefreshRoleNormalSetting::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:idlepb.RefreshRoleNormalSetting.settings)
  
  ::idlepb::RoleNormalSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::idlepb::RoleNormalSettings* RefreshRoleNormalSetting::_internal_mutable_settings() {
  
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleNormalSettings>(GetArenaForAllocation());
    _impl_.settings_ = p;
  }
  return _impl_.settings_;
}
inline ::idlepb::RoleNormalSettings* RefreshRoleNormalSetting::mutable_settings() {
  ::idlepb::RoleNormalSettings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshRoleNormalSetting.settings)
  return _msg;
}
inline void RefreshRoleNormalSetting::set_allocated_settings(::idlepb::RoleNormalSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(settings));
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RefreshRoleNormalSetting.settings)
}

// -------------------------------------------------------------------

// GetUserVarReq

// string var_name = 1;
inline void GetUserVarReq::clear_var_name() {
  _impl_.var_name_.ClearToEmpty();
}
inline const std::string& GetUserVarReq::var_name() const {
  // @@protoc_insertion_point(field_get:idlepb.GetUserVarReq.var_name)
  return _internal_var_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserVarReq::set_var_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.GetUserVarReq.var_name)
}
inline std::string* GetUserVarReq::mutable_var_name() {
  std::string* _s = _internal_mutable_var_name();
  // @@protoc_insertion_point(field_mutable:idlepb.GetUserVarReq.var_name)
  return _s;
}
inline const std::string& GetUserVarReq::_internal_var_name() const {
  return _impl_.var_name_.Get();
}
inline void GetUserVarReq::_internal_set_var_name(const std::string& value) {
  
  _impl_.var_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserVarReq::_internal_mutable_var_name() {
  
  return _impl_.var_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserVarReq::release_var_name() {
  // @@protoc_insertion_point(field_release:idlepb.GetUserVarReq.var_name)
  return _impl_.var_name_.Release();
}
inline void GetUserVarReq::set_allocated_var_name(std::string* var_name) {
  if (var_name != nullptr) {
    
  } else {
    
  }
  _impl_.var_name_.SetAllocated(var_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_name_.IsDefault()) {
    _impl_.var_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetUserVarReq.var_name)
}

// -------------------------------------------------------------------

// GetUserVarRsp

// int32 var_value = 1;
inline void GetUserVarRsp::clear_var_value() {
  _impl_.var_value_ = 0;
}
inline int32_t GetUserVarRsp::_internal_var_value() const {
  return _impl_.var_value_;
}
inline int32_t GetUserVarRsp::var_value() const {
  // @@protoc_insertion_point(field_get:idlepb.GetUserVarRsp.var_value)
  return _internal_var_value();
}
inline void GetUserVarRsp::_internal_set_var_value(int32_t value) {
  
  _impl_.var_value_ = value;
}
inline void GetUserVarRsp::set_var_value(int32_t value) {
  _internal_set_var_value(value);
  // @@protoc_insertion_point(field_set:idlepb.GetUserVarRsp.var_value)
}

// -------------------------------------------------------------------

// GetUserVarsReq

// repeated string var_name = 1;
inline int GetUserVarsReq::_internal_var_name_size() const {
  return _impl_.var_name_.size();
}
inline int GetUserVarsReq::var_name_size() const {
  return _internal_var_name_size();
}
inline void GetUserVarsReq::clear_var_name() {
  _impl_.var_name_.Clear();
}
inline std::string* GetUserVarsReq::add_var_name() {
  std::string* _s = _internal_add_var_name();
  // @@protoc_insertion_point(field_add_mutable:idlepb.GetUserVarsReq.var_name)
  return _s;
}
inline const std::string& GetUserVarsReq::_internal_var_name(int index) const {
  return _impl_.var_name_.Get(index);
}
inline const std::string& GetUserVarsReq::var_name(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetUserVarsReq.var_name)
  return _internal_var_name(index);
}
inline std::string* GetUserVarsReq::mutable_var_name(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetUserVarsReq.var_name)
  return _impl_.var_name_.Mutable(index);
}
inline void GetUserVarsReq::set_var_name(int index, const std::string& value) {
  _impl_.var_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:idlepb.GetUserVarsReq.var_name)
}
inline void GetUserVarsReq::set_var_name(int index, std::string&& value) {
  _impl_.var_name_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:idlepb.GetUserVarsReq.var_name)
}
inline void GetUserVarsReq::set_var_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.var_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:idlepb.GetUserVarsReq.var_name)
}
inline void GetUserVarsReq::set_var_name(int index, const char* value, size_t size) {
  _impl_.var_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:idlepb.GetUserVarsReq.var_name)
}
inline std::string* GetUserVarsReq::_internal_add_var_name() {
  return _impl_.var_name_.Add();
}
inline void GetUserVarsReq::add_var_name(const std::string& value) {
  _impl_.var_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:idlepb.GetUserVarsReq.var_name)
}
inline void GetUserVarsReq::add_var_name(std::string&& value) {
  _impl_.var_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:idlepb.GetUserVarsReq.var_name)
}
inline void GetUserVarsReq::add_var_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.var_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:idlepb.GetUserVarsReq.var_name)
}
inline void GetUserVarsReq::add_var_name(const char* value, size_t size) {
  _impl_.var_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:idlepb.GetUserVarsReq.var_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetUserVarsReq::var_name() const {
  // @@protoc_insertion_point(field_list:idlepb.GetUserVarsReq.var_name)
  return _impl_.var_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetUserVarsReq::mutable_var_name() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetUserVarsReq.var_name)
  return &_impl_.var_name_;
}

// -------------------------------------------------------------------

// GetUserVarsRsp

// repeated .idlepb.StringKeyInt32ValueEntry data = 1;
inline int GetUserVarsRsp::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int GetUserVarsRsp::data_size() const {
  return _internal_data_size();
}
inline ::idlepb::StringKeyInt32ValueEntry* GetUserVarsRsp::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetUserVarsRsp.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::StringKeyInt32ValueEntry >*
GetUserVarsRsp::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetUserVarsRsp.data)
  return &_impl_.data_;
}
inline const ::idlepb::StringKeyInt32ValueEntry& GetUserVarsRsp::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::idlepb::StringKeyInt32ValueEntry& GetUserVarsRsp::data(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetUserVarsRsp.data)
  return _internal_data(index);
}
inline ::idlepb::StringKeyInt32ValueEntry* GetUserVarsRsp::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::idlepb::StringKeyInt32ValueEntry* GetUserVarsRsp::add_data() {
  ::idlepb::StringKeyInt32ValueEntry* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:idlepb.GetUserVarsRsp.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::StringKeyInt32ValueEntry >&
GetUserVarsRsp::data() const {
  // @@protoc_insertion_point(field_list:idlepb.GetUserVarsRsp.data)
  return _impl_.data_;
}

// -------------------------------------------------------------------

// SetUserVar

// string var_name = 1;
inline void SetUserVar::clear_var_name() {
  _impl_.var_name_.ClearToEmpty();
}
inline const std::string& SetUserVar::var_name() const {
  // @@protoc_insertion_point(field_get:idlepb.SetUserVar.var_name)
  return _internal_var_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetUserVar::set_var_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.SetUserVar.var_name)
}
inline std::string* SetUserVar::mutable_var_name() {
  std::string* _s = _internal_mutable_var_name();
  // @@protoc_insertion_point(field_mutable:idlepb.SetUserVar.var_name)
  return _s;
}
inline const std::string& SetUserVar::_internal_var_name() const {
  return _impl_.var_name_.Get();
}
inline void SetUserVar::_internal_set_var_name(const std::string& value) {
  
  _impl_.var_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetUserVar::_internal_mutable_var_name() {
  
  return _impl_.var_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SetUserVar::release_var_name() {
  // @@protoc_insertion_point(field_release:idlepb.SetUserVar.var_name)
  return _impl_.var_name_.Release();
}
inline void SetUserVar::set_allocated_var_name(std::string* var_name) {
  if (var_name != nullptr) {
    
  } else {
    
  }
  _impl_.var_name_.SetAllocated(var_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_name_.IsDefault()) {
    _impl_.var_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.SetUserVar.var_name)
}

// int32 var_value = 2;
inline void SetUserVar::clear_var_value() {
  _impl_.var_value_ = 0;
}
inline int32_t SetUserVar::_internal_var_value() const {
  return _impl_.var_value_;
}
inline int32_t SetUserVar::var_value() const {
  // @@protoc_insertion_point(field_get:idlepb.SetUserVar.var_value)
  return _internal_var_value();
}
inline void SetUserVar::_internal_set_var_value(int32_t value) {
  
  _impl_.var_value_ = value;
}
inline void SetUserVar::set_var_value(int32_t value) {
  _internal_set_var_value(value);
  // @@protoc_insertion_point(field_set:idlepb.SetUserVar.var_value)
}

// -------------------------------------------------------------------

// DelUserVar

// string var_name = 1;
inline void DelUserVar::clear_var_name() {
  _impl_.var_name_.ClearToEmpty();
}
inline const std::string& DelUserVar::var_name() const {
  // @@protoc_insertion_point(field_get:idlepb.DelUserVar.var_name)
  return _internal_var_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelUserVar::set_var_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.DelUserVar.var_name)
}
inline std::string* DelUserVar::mutable_var_name() {
  std::string* _s = _internal_mutable_var_name();
  // @@protoc_insertion_point(field_mutable:idlepb.DelUserVar.var_name)
  return _s;
}
inline const std::string& DelUserVar::_internal_var_name() const {
  return _impl_.var_name_.Get();
}
inline void DelUserVar::_internal_set_var_name(const std::string& value) {
  
  _impl_.var_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DelUserVar::_internal_mutable_var_name() {
  
  return _impl_.var_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DelUserVar::release_var_name() {
  // @@protoc_insertion_point(field_release:idlepb.DelUserVar.var_name)
  return _impl_.var_name_.Release();
}
inline void DelUserVar::set_allocated_var_name(std::string* var_name) {
  if (var_name != nullptr) {
    
  } else {
    
  }
  _impl_.var_name_.SetAllocated(var_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_name_.IsDefault()) {
    _impl_.var_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.DelUserVar.var_name)
}

// -------------------------------------------------------------------

// ShareSelfItemReq

// int64 item_id = 1;
inline void ShareSelfItemReq::clear_item_id() {
  _impl_.item_id_ = int64_t{0};
}
inline int64_t ShareSelfItemReq::_internal_item_id() const {
  return _impl_.item_id_;
}
inline int64_t ShareSelfItemReq::item_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ShareSelfItemReq.item_id)
  return _internal_item_id();
}
inline void ShareSelfItemReq::_internal_set_item_id(int64_t value) {
  
  _impl_.item_id_ = value;
}
inline void ShareSelfItemReq::set_item_id(int64_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ShareSelfItemReq.item_id)
}

// -------------------------------------------------------------------

// ShareSelfItemRsp

// int64 share_id = 1;
inline void ShareSelfItemRsp::clear_share_id() {
  _impl_.share_id_ = int64_t{0};
}
inline int64_t ShareSelfItemRsp::_internal_share_id() const {
  return _impl_.share_id_;
}
inline int64_t ShareSelfItemRsp::share_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ShareSelfItemRsp.share_id)
  return _internal_share_id();
}
inline void ShareSelfItemRsp::_internal_set_share_id(int64_t value) {
  
  _impl_.share_id_ = value;
}
inline void ShareSelfItemRsp::set_share_id(int64_t value) {
  _internal_set_share_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ShareSelfItemRsp.share_id)
}

// -------------------------------------------------------------------

// ShareSelfItemsReq

// repeated int64 item_id = 1;
inline int ShareSelfItemsReq::_internal_item_id_size() const {
  return _impl_.item_id_.size();
}
inline int ShareSelfItemsReq::item_id_size() const {
  return _internal_item_id_size();
}
inline void ShareSelfItemsReq::clear_item_id() {
  _impl_.item_id_.Clear();
}
inline int64_t ShareSelfItemsReq::_internal_item_id(int index) const {
  return _impl_.item_id_.Get(index);
}
inline int64_t ShareSelfItemsReq::item_id(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.ShareSelfItemsReq.item_id)
  return _internal_item_id(index);
}
inline void ShareSelfItemsReq::set_item_id(int index, int64_t value) {
  _impl_.item_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.ShareSelfItemsReq.item_id)
}
inline void ShareSelfItemsReq::_internal_add_item_id(int64_t value) {
  _impl_.item_id_.Add(value);
}
inline void ShareSelfItemsReq::add_item_id(int64_t value) {
  _internal_add_item_id(value);
  // @@protoc_insertion_point(field_add:idlepb.ShareSelfItemsReq.item_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ShareSelfItemsReq::_internal_item_id() const {
  return _impl_.item_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ShareSelfItemsReq::item_id() const {
  // @@protoc_insertion_point(field_list:idlepb.ShareSelfItemsReq.item_id)
  return _internal_item_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ShareSelfItemsReq::_internal_mutable_item_id() {
  return &_impl_.item_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ShareSelfItemsReq::mutable_item_id() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.ShareSelfItemsReq.item_id)
  return _internal_mutable_item_id();
}

// -------------------------------------------------------------------

// ShareSelfItemsRsp

// repeated .idlepb.Int64Pair share_id = 1;
inline int ShareSelfItemsRsp::_internal_share_id_size() const {
  return _impl_.share_id_.size();
}
inline int ShareSelfItemsRsp::share_id_size() const {
  return _internal_share_id_size();
}
inline ::idlepb::Int64Pair* ShareSelfItemsRsp::mutable_share_id(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.ShareSelfItemsRsp.share_id)
  return _impl_.share_id_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Int64Pair >*
ShareSelfItemsRsp::mutable_share_id() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.ShareSelfItemsRsp.share_id)
  return &_impl_.share_id_;
}
inline const ::idlepb::Int64Pair& ShareSelfItemsRsp::_internal_share_id(int index) const {
  return _impl_.share_id_.Get(index);
}
inline const ::idlepb::Int64Pair& ShareSelfItemsRsp::share_id(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.ShareSelfItemsRsp.share_id)
  return _internal_share_id(index);
}
inline ::idlepb::Int64Pair* ShareSelfItemsRsp::_internal_add_share_id() {
  return _impl_.share_id_.Add();
}
inline ::idlepb::Int64Pair* ShareSelfItemsRsp::add_share_id() {
  ::idlepb::Int64Pair* _add = _internal_add_share_id();
  // @@protoc_insertion_point(field_add:idlepb.ShareSelfItemsRsp.share_id)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::Int64Pair >&
ShareSelfItemsRsp::share_id() const {
  // @@protoc_insertion_point(field_list:idlepb.ShareSelfItemsRsp.share_id)
  return _impl_.share_id_;
}

// -------------------------------------------------------------------

// GetShareItemDataReq

// int64 share_id = 1;
inline void GetShareItemDataReq::clear_share_id() {
  _impl_.share_id_ = int64_t{0};
}
inline int64_t GetShareItemDataReq::_internal_share_id() const {
  return _impl_.share_id_;
}
inline int64_t GetShareItemDataReq::share_id() const {
  // @@protoc_insertion_point(field_get:idlepb.GetShareItemDataReq.share_id)
  return _internal_share_id();
}
inline void GetShareItemDataReq::_internal_set_share_id(int64_t value) {
  
  _impl_.share_id_ = value;
}
inline void GetShareItemDataReq::set_share_id(int64_t value) {
  _internal_set_share_id(value);
  // @@protoc_insertion_point(field_set:idlepb.GetShareItemDataReq.share_id)
}

// -------------------------------------------------------------------

// GetShareItemDataRsp

// bool ok = 1;
inline void GetShareItemDataRsp::clear_ok() {
  _impl_.ok_ = false;
}
inline bool GetShareItemDataRsp::_internal_ok() const {
  return _impl_.ok_;
}
inline bool GetShareItemDataRsp::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.GetShareItemDataRsp.ok)
  return _internal_ok();
}
inline void GetShareItemDataRsp::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void GetShareItemDataRsp::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.GetShareItemDataRsp.ok)
}

// .idlepb.ItemData item_data = 2;
inline bool GetShareItemDataRsp::_internal_has_item_data() const {
  return this != internal_default_instance() && _impl_.item_data_ != nullptr;
}
inline bool GetShareItemDataRsp::has_item_data() const {
  return _internal_has_item_data();
}
inline const ::idlepb::ItemData& GetShareItemDataRsp::_internal_item_data() const {
  const ::idlepb::ItemData* p = _impl_.item_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::ItemData&>(
      ::idlepb::_ItemData_default_instance_);
}
inline const ::idlepb::ItemData& GetShareItemDataRsp::item_data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetShareItemDataRsp.item_data)
  return _internal_item_data();
}
inline void GetShareItemDataRsp::unsafe_arena_set_allocated_item_data(
    ::idlepb::ItemData* item_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_data_);
  }
  _impl_.item_data_ = item_data;
  if (item_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetShareItemDataRsp.item_data)
}
inline ::idlepb::ItemData* GetShareItemDataRsp::release_item_data() {
  
  ::idlepb::ItemData* temp = _impl_.item_data_;
  _impl_.item_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::ItemData* GetShareItemDataRsp::unsafe_arena_release_item_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetShareItemDataRsp.item_data)
  
  ::idlepb::ItemData* temp = _impl_.item_data_;
  _impl_.item_data_ = nullptr;
  return temp;
}
inline ::idlepb::ItemData* GetShareItemDataRsp::_internal_mutable_item_data() {
  
  if (_impl_.item_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::ItemData>(GetArenaForAllocation());
    _impl_.item_data_ = p;
  }
  return _impl_.item_data_;
}
inline ::idlepb::ItemData* GetShareItemDataRsp::mutable_item_data() {
  ::idlepb::ItemData* _msg = _internal_mutable_item_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetShareItemDataRsp.item_data)
  return _msg;
}
inline void GetShareItemDataRsp::set_allocated_item_data(::idlepb::ItemData* item_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_data_);
  }
  if (item_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_data));
    if (message_arena != submessage_arena) {
      item_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_data_ = item_data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetShareItemDataRsp.item_data)
}

// -------------------------------------------------------------------

// GetChecklistDataReq

// -------------------------------------------------------------------

// GetChecklistDataAck

// .idlepb.RoleChecklistData data = 1;
inline bool GetChecklistDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetChecklistDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleChecklistData& GetChecklistDataAck::_internal_data() const {
  const ::idlepb::RoleChecklistData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleChecklistData&>(
      ::idlepb::_RoleChecklistData_default_instance_);
}
inline const ::idlepb::RoleChecklistData& GetChecklistDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetChecklistDataAck.data)
  return _internal_data();
}
inline void GetChecklistDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleChecklistData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetChecklistDataAck.data)
}
inline ::idlepb::RoleChecklistData* GetChecklistDataAck::release_data() {
  
  ::idlepb::RoleChecklistData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleChecklistData* GetChecklistDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetChecklistDataAck.data)
  
  ::idlepb::RoleChecklistData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleChecklistData* GetChecklistDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleChecklistData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleChecklistData* GetChecklistDataAck::mutable_data() {
  ::idlepb::RoleChecklistData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetChecklistDataAck.data)
  return _msg;
}
inline void GetChecklistDataAck::set_allocated_data(::idlepb::RoleChecklistData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetChecklistDataAck.data)
}

// -------------------------------------------------------------------

// NotifyChecklist

// -------------------------------------------------------------------

// ChecklistOpReq

// bool sumbmit_or_receive = 1;
inline void ChecklistOpReq::clear_sumbmit_or_receive() {
  _impl_.sumbmit_or_receive_ = false;
}
inline bool ChecklistOpReq::_internal_sumbmit_or_receive() const {
  return _impl_.sumbmit_or_receive_;
}
inline bool ChecklistOpReq::sumbmit_or_receive() const {
  // @@protoc_insertion_point(field_get:idlepb.ChecklistOpReq.sumbmit_or_receive)
  return _internal_sumbmit_or_receive();
}
inline void ChecklistOpReq::_internal_set_sumbmit_or_receive(bool value) {
  
  _impl_.sumbmit_or_receive_ = value;
}
inline void ChecklistOpReq::set_sumbmit_or_receive(bool value) {
  _internal_set_sumbmit_or_receive(value);
  // @@protoc_insertion_point(field_set:idlepb.ChecklistOpReq.sumbmit_or_receive)
}

// bool day_or_week = 2;
inline void ChecklistOpReq::clear_day_or_week() {
  _impl_.day_or_week_ = false;
}
inline bool ChecklistOpReq::_internal_day_or_week() const {
  return _impl_.day_or_week_;
}
inline bool ChecklistOpReq::day_or_week() const {
  // @@protoc_insertion_point(field_get:idlepb.ChecklistOpReq.day_or_week)
  return _internal_day_or_week();
}
inline void ChecklistOpReq::_internal_set_day_or_week(bool value) {
  
  _impl_.day_or_week_ = value;
}
inline void ChecklistOpReq::set_day_or_week(bool value) {
  _internal_set_day_or_week(value);
  // @@protoc_insertion_point(field_set:idlepb.ChecklistOpReq.day_or_week)
}

// -------------------------------------------------------------------

// ChecklistOpAck

// bool ok = 1;
inline void ChecklistOpAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ChecklistOpAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ChecklistOpAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ChecklistOpAck.ok)
  return _internal_ok();
}
inline void ChecklistOpAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ChecklistOpAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ChecklistOpAck.ok)
}

// .idlepb.RoleChecklistData data = 2;
inline bool ChecklistOpAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool ChecklistOpAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleChecklistData& ChecklistOpAck::_internal_data() const {
  const ::idlepb::RoleChecklistData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleChecklistData&>(
      ::idlepb::_RoleChecklistData_default_instance_);
}
inline const ::idlepb::RoleChecklistData& ChecklistOpAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.ChecklistOpAck.data)
  return _internal_data();
}
inline void ChecklistOpAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleChecklistData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.ChecklistOpAck.data)
}
inline ::idlepb::RoleChecklistData* ChecklistOpAck::release_data() {
  
  ::idlepb::RoleChecklistData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleChecklistData* ChecklistOpAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.ChecklistOpAck.data)
  
  ::idlepb::RoleChecklistData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleChecklistData* ChecklistOpAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleChecklistData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleChecklistData* ChecklistOpAck::mutable_data() {
  ::idlepb::RoleChecklistData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.ChecklistOpAck.data)
  return _msg;
}
inline void ChecklistOpAck::set_allocated_data(::idlepb::RoleChecklistData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.ChecklistOpAck.data)
}

// -------------------------------------------------------------------

// UpdateChecklistReq

// int32 type = 1;
inline void UpdateChecklistReq::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t UpdateChecklistReq::_internal_type() const {
  return _impl_.type_;
}
inline int32_t UpdateChecklistReq::type() const {
  // @@protoc_insertion_point(field_get:idlepb.UpdateChecklistReq.type)
  return _internal_type();
}
inline void UpdateChecklistReq::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void UpdateChecklistReq::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:idlepb.UpdateChecklistReq.type)
}

// -------------------------------------------------------------------

// UpdateChecklistAck

// bool ok = 1;
inline void UpdateChecklistAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool UpdateChecklistAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool UpdateChecklistAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.UpdateChecklistAck.ok)
  return _internal_ok();
}
inline void UpdateChecklistAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void UpdateChecklistAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.UpdateChecklistAck.ok)
}

// -------------------------------------------------------------------

// GetCommonItemExchangeDataReq

// int32 cfg_id = 1;
inline void GetCommonItemExchangeDataReq::clear_cfg_id() {
  _impl_.cfg_id_ = 0;
}
inline int32_t GetCommonItemExchangeDataReq::_internal_cfg_id() const {
  return _impl_.cfg_id_;
}
inline int32_t GetCommonItemExchangeDataReq::cfg_id() const {
  // @@protoc_insertion_point(field_get:idlepb.GetCommonItemExchangeDataReq.cfg_id)
  return _internal_cfg_id();
}
inline void GetCommonItemExchangeDataReq::_internal_set_cfg_id(int32_t value) {
  
  _impl_.cfg_id_ = value;
}
inline void GetCommonItemExchangeDataReq::set_cfg_id(int32_t value) {
  _internal_set_cfg_id(value);
  // @@protoc_insertion_point(field_set:idlepb.GetCommonItemExchangeDataReq.cfg_id)
}

// -------------------------------------------------------------------

// GetCommonItemExchangeDataAck

// int32 today_exchange_num = 1;
inline void GetCommonItemExchangeDataAck::clear_today_exchange_num() {
  _impl_.today_exchange_num_ = 0;
}
inline int32_t GetCommonItemExchangeDataAck::_internal_today_exchange_num() const {
  return _impl_.today_exchange_num_;
}
inline int32_t GetCommonItemExchangeDataAck::today_exchange_num() const {
  // @@protoc_insertion_point(field_get:idlepb.GetCommonItemExchangeDataAck.today_exchange_num)
  return _internal_today_exchange_num();
}
inline void GetCommonItemExchangeDataAck::_internal_set_today_exchange_num(int32_t value) {
  
  _impl_.today_exchange_num_ = value;
}
inline void GetCommonItemExchangeDataAck::set_today_exchange_num(int32_t value) {
  _internal_set_today_exchange_num(value);
  // @@protoc_insertion_point(field_set:idlepb.GetCommonItemExchangeDataAck.today_exchange_num)
}

// -------------------------------------------------------------------

// ExchangeCommonItemReq

// int32 cfg_id = 1;
inline void ExchangeCommonItemReq::clear_cfg_id() {
  _impl_.cfg_id_ = 0;
}
inline int32_t ExchangeCommonItemReq::_internal_cfg_id() const {
  return _impl_.cfg_id_;
}
inline int32_t ExchangeCommonItemReq::cfg_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ExchangeCommonItemReq.cfg_id)
  return _internal_cfg_id();
}
inline void ExchangeCommonItemReq::_internal_set_cfg_id(int32_t value) {
  
  _impl_.cfg_id_ = value;
}
inline void ExchangeCommonItemReq::set_cfg_id(int32_t value) {
  _internal_set_cfg_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ExchangeCommonItemReq.cfg_id)
}

// int32 num = 2;
inline void ExchangeCommonItemReq::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t ExchangeCommonItemReq::_internal_num() const {
  return _impl_.num_;
}
inline int32_t ExchangeCommonItemReq::num() const {
  // @@protoc_insertion_point(field_get:idlepb.ExchangeCommonItemReq.num)
  return _internal_num();
}
inline void ExchangeCommonItemReq::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void ExchangeCommonItemReq::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.ExchangeCommonItemReq.num)
}

// -------------------------------------------------------------------

// ExchangeCommonItemAck

// bool ok = 1;
inline void ExchangeCommonItemAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ExchangeCommonItemAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ExchangeCommonItemAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ExchangeCommonItemAck.ok)
  return _internal_ok();
}
inline void ExchangeCommonItemAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ExchangeCommonItemAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ExchangeCommonItemAck.ok)
}

// int32 out_num = 2;
inline void ExchangeCommonItemAck::clear_out_num() {
  _impl_.out_num_ = 0;
}
inline int32_t ExchangeCommonItemAck::_internal_out_num() const {
  return _impl_.out_num_;
}
inline int32_t ExchangeCommonItemAck::out_num() const {
  // @@protoc_insertion_point(field_get:idlepb.ExchangeCommonItemAck.out_num)
  return _internal_out_num();
}
inline void ExchangeCommonItemAck::_internal_set_out_num(int32_t value) {
  
  _impl_.out_num_ = value;
}
inline void ExchangeCommonItemAck::set_out_num(int32_t value) {
  _internal_set_out_num(value);
  // @@protoc_insertion_point(field_set:idlepb.ExchangeCommonItemAck.out_num)
}

// -------------------------------------------------------------------

// SynthesisCommonItemReq

// int32 cfg_id = 1;
inline void SynthesisCommonItemReq::clear_cfg_id() {
  _impl_.cfg_id_ = 0;
}
inline int32_t SynthesisCommonItemReq::_internal_cfg_id() const {
  return _impl_.cfg_id_;
}
inline int32_t SynthesisCommonItemReq::cfg_id() const {
  // @@protoc_insertion_point(field_get:idlepb.SynthesisCommonItemReq.cfg_id)
  return _internal_cfg_id();
}
inline void SynthesisCommonItemReq::_internal_set_cfg_id(int32_t value) {
  
  _impl_.cfg_id_ = value;
}
inline void SynthesisCommonItemReq::set_cfg_id(int32_t value) {
  _internal_set_cfg_id(value);
  // @@protoc_insertion_point(field_set:idlepb.SynthesisCommonItemReq.cfg_id)
}

// int32 num = 2;
inline void SynthesisCommonItemReq::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t SynthesisCommonItemReq::_internal_num() const {
  return _impl_.num_;
}
inline int32_t SynthesisCommonItemReq::num() const {
  // @@protoc_insertion_point(field_get:idlepb.SynthesisCommonItemReq.num)
  return _internal_num();
}
inline void SynthesisCommonItemReq::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void SynthesisCommonItemReq::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.SynthesisCommonItemReq.num)
}

// -------------------------------------------------------------------

// SynthesisCommonItemAck

// bool ok = 1;
inline void SynthesisCommonItemAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SynthesisCommonItemAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool SynthesisCommonItemAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.SynthesisCommonItemAck.ok)
  return _internal_ok();
}
inline void SynthesisCommonItemAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void SynthesisCommonItemAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.SynthesisCommonItemAck.ok)
}

// -------------------------------------------------------------------

// GetRoleSeptShopDataReq

// -------------------------------------------------------------------

// GetRoleSeptShopDataAck

// .idlepb.RoleSeptShopData data = 1;
inline bool GetRoleSeptShopDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetRoleSeptShopDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleSeptShopData& GetRoleSeptShopDataAck::_internal_data() const {
  const ::idlepb::RoleSeptShopData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleSeptShopData&>(
      ::idlepb::_RoleSeptShopData_default_instance_);
}
inline const ::idlepb::RoleSeptShopData& GetRoleSeptShopDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleSeptShopDataAck.data)
  return _internal_data();
}
inline void GetRoleSeptShopDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleSeptShopData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleSeptShopDataAck.data)
}
inline ::idlepb::RoleSeptShopData* GetRoleSeptShopDataAck::release_data() {
  
  ::idlepb::RoleSeptShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleSeptShopData* GetRoleSeptShopDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleSeptShopDataAck.data)
  
  ::idlepb::RoleSeptShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleSeptShopData* GetRoleSeptShopDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleSeptShopData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleSeptShopData* GetRoleSeptShopDataAck::mutable_data() {
  ::idlepb::RoleSeptShopData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleSeptShopDataAck.data)
  return _msg;
}
inline void GetRoleSeptShopDataAck::set_allocated_data(::idlepb::RoleSeptShopData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleSeptShopDataAck.data)
}

// -------------------------------------------------------------------

// GetRoleSeptQuestDataReq

// -------------------------------------------------------------------

// GetRoleSeptQuestDataAck

// .idlepb.RoleSeptQuestData data = 1;
inline bool GetRoleSeptQuestDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetRoleSeptQuestDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleSeptQuestData& GetRoleSeptQuestDataAck::_internal_data() const {
  const ::idlepb::RoleSeptQuestData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleSeptQuestData&>(
      ::idlepb::_RoleSeptQuestData_default_instance_);
}
inline const ::idlepb::RoleSeptQuestData& GetRoleSeptQuestDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleSeptQuestDataAck.data)
  return _internal_data();
}
inline void GetRoleSeptQuestDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleSeptQuestData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleSeptQuestDataAck.data)
}
inline ::idlepb::RoleSeptQuestData* GetRoleSeptQuestDataAck::release_data() {
  
  ::idlepb::RoleSeptQuestData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleSeptQuestData* GetRoleSeptQuestDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleSeptQuestDataAck.data)
  
  ::idlepb::RoleSeptQuestData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleSeptQuestData* GetRoleSeptQuestDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleSeptQuestData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleSeptQuestData* GetRoleSeptQuestDataAck::mutable_data() {
  ::idlepb::RoleSeptQuestData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleSeptQuestDataAck.data)
  return _msg;
}
inline void GetRoleSeptQuestDataAck::set_allocated_data(::idlepb::RoleSeptQuestData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleSeptQuestDataAck.data)
}

// -------------------------------------------------------------------

// BuySeptShopItemReq

// int32 id = 1;
inline void BuySeptShopItemReq::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t BuySeptShopItemReq::_internal_id() const {
  return _impl_.id_;
}
inline int32_t BuySeptShopItemReq::id() const {
  // @@protoc_insertion_point(field_get:idlepb.BuySeptShopItemReq.id)
  return _internal_id();
}
inline void BuySeptShopItemReq::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void BuySeptShopItemReq::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:idlepb.BuySeptShopItemReq.id)
}

// int32 num = 2;
inline void BuySeptShopItemReq::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t BuySeptShopItemReq::_internal_num() const {
  return _impl_.num_;
}
inline int32_t BuySeptShopItemReq::num() const {
  // @@protoc_insertion_point(field_get:idlepb.BuySeptShopItemReq.num)
  return _internal_num();
}
inline void BuySeptShopItemReq::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void BuySeptShopItemReq::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.BuySeptShopItemReq.num)
}

// -------------------------------------------------------------------

// BuySeptShopItemAck

// bool ok = 1;
inline void BuySeptShopItemAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool BuySeptShopItemAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool BuySeptShopItemAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.BuySeptShopItemAck.ok)
  return _internal_ok();
}
inline void BuySeptShopItemAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void BuySeptShopItemAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.BuySeptShopItemAck.ok)
}

// -------------------------------------------------------------------

// ReqRoleSeptQuestOpReq

// int32 uid = 1;
inline void ReqRoleSeptQuestOpReq::clear_uid() {
  _impl_.uid_ = 0;
}
inline int32_t ReqRoleSeptQuestOpReq::_internal_uid() const {
  return _impl_.uid_;
}
inline int32_t ReqRoleSeptQuestOpReq::uid() const {
  // @@protoc_insertion_point(field_get:idlepb.ReqRoleSeptQuestOpReq.uid)
  return _internal_uid();
}
inline void ReqRoleSeptQuestOpReq::_internal_set_uid(int32_t value) {
  
  _impl_.uid_ = value;
}
inline void ReqRoleSeptQuestOpReq::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.ReqRoleSeptQuestOpReq.uid)
}

// -------------------------------------------------------------------

// ReqRoleSeptQuestOpAck

// bool ok = 1;
inline void ReqRoleSeptQuestOpAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ReqRoleSeptQuestOpAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ReqRoleSeptQuestOpAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ReqRoleSeptQuestOpAck.ok)
  return _internal_ok();
}
inline void ReqRoleSeptQuestOpAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ReqRoleSeptQuestOpAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ReqRoleSeptQuestOpAck.ok)
}

// -------------------------------------------------------------------

// RefreshSeptQuestReq

// -------------------------------------------------------------------

// RefreshSeptQuestAck

// .idlepb.RoleSeptQuestData data = 1;
inline bool RefreshSeptQuestAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool RefreshSeptQuestAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleSeptQuestData& RefreshSeptQuestAck::_internal_data() const {
  const ::idlepb::RoleSeptQuestData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleSeptQuestData&>(
      ::idlepb::_RoleSeptQuestData_default_instance_);
}
inline const ::idlepb::RoleSeptQuestData& RefreshSeptQuestAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshSeptQuestAck.data)
  return _internal_data();
}
inline void RefreshSeptQuestAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleSeptQuestData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RefreshSeptQuestAck.data)
}
inline ::idlepb::RoleSeptQuestData* RefreshSeptQuestAck::release_data() {
  
  ::idlepb::RoleSeptQuestData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleSeptQuestData* RefreshSeptQuestAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.RefreshSeptQuestAck.data)
  
  ::idlepb::RoleSeptQuestData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleSeptQuestData* RefreshSeptQuestAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleSeptQuestData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleSeptQuestData* RefreshSeptQuestAck::mutable_data() {
  ::idlepb::RoleSeptQuestData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshSeptQuestAck.data)
  return _msg;
}
inline void RefreshSeptQuestAck::set_allocated_data(::idlepb::RoleSeptQuestData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RefreshSeptQuestAck.data)
}

// -------------------------------------------------------------------

// ReqSeptQuestRankUpReq

// -------------------------------------------------------------------

// ReqSeptQuestRankUpAck

// bool ok = 1;
inline void ReqSeptQuestRankUpAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ReqSeptQuestRankUpAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ReqSeptQuestRankUpAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ReqSeptQuestRankUpAck.ok)
  return _internal_ok();
}
inline void ReqSeptQuestRankUpAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ReqSeptQuestRankUpAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ReqSeptQuestRankUpAck.ok)
}

// -------------------------------------------------------------------

// GetGongFaDataReq

// -------------------------------------------------------------------

// GetGongFaDataAck

// .idlepb.RoleGongFaData data = 1;
inline bool GetGongFaDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetGongFaDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleGongFaData& GetGongFaDataAck::_internal_data() const {
  const ::idlepb::RoleGongFaData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleGongFaData&>(
      ::idlepb::_RoleGongFaData_default_instance_);
}
inline const ::idlepb::RoleGongFaData& GetGongFaDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetGongFaDataAck.data)
  return _internal_data();
}
inline void GetGongFaDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleGongFaData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetGongFaDataAck.data)
}
inline ::idlepb::RoleGongFaData* GetGongFaDataAck::release_data() {
  
  ::idlepb::RoleGongFaData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleGongFaData* GetGongFaDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetGongFaDataAck.data)
  
  ::idlepb::RoleGongFaData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleGongFaData* GetGongFaDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleGongFaData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleGongFaData* GetGongFaDataAck::mutable_data() {
  ::idlepb::RoleGongFaData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetGongFaDataAck.data)
  return _msg;
}
inline void GetGongFaDataAck::set_allocated_data(::idlepb::RoleGongFaData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetGongFaDataAck.data)
}

// -------------------------------------------------------------------

// GongFaOpReq

// int32 gongfa_id = 1;
inline void GongFaOpReq::clear_gongfa_id() {
  _impl_.gongfa_id_ = 0;
}
inline int32_t GongFaOpReq::_internal_gongfa_id() const {
  return _impl_.gongfa_id_;
}
inline int32_t GongFaOpReq::gongfa_id() const {
  // @@protoc_insertion_point(field_get:idlepb.GongFaOpReq.gongfa_id)
  return _internal_gongfa_id();
}
inline void GongFaOpReq::_internal_set_gongfa_id(int32_t value) {
  
  _impl_.gongfa_id_ = value;
}
inline void GongFaOpReq::set_gongfa_id(int32_t value) {
  _internal_set_gongfa_id(value);
  // @@protoc_insertion_point(field_set:idlepb.GongFaOpReq.gongfa_id)
}

// -------------------------------------------------------------------

// GongFaOpAck

// bool ok = 1;
inline void GongFaOpAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool GongFaOpAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool GongFaOpAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.GongFaOpAck.ok)
  return _internal_ok();
}
inline void GongFaOpAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void GongFaOpAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.GongFaOpAck.ok)
}

// .idlepb.GongFaData gongfa_data = 2;
inline bool GongFaOpAck::_internal_has_gongfa_data() const {
  return this != internal_default_instance() && _impl_.gongfa_data_ != nullptr;
}
inline bool GongFaOpAck::has_gongfa_data() const {
  return _internal_has_gongfa_data();
}
inline const ::idlepb::GongFaData& GongFaOpAck::_internal_gongfa_data() const {
  const ::idlepb::GongFaData* p = _impl_.gongfa_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::GongFaData&>(
      ::idlepb::_GongFaData_default_instance_);
}
inline const ::idlepb::GongFaData& GongFaOpAck::gongfa_data() const {
  // @@protoc_insertion_point(field_get:idlepb.GongFaOpAck.gongfa_data)
  return _internal_gongfa_data();
}
inline void GongFaOpAck::unsafe_arena_set_allocated_gongfa_data(
    ::idlepb::GongFaData* gongfa_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gongfa_data_);
  }
  _impl_.gongfa_data_ = gongfa_data;
  if (gongfa_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GongFaOpAck.gongfa_data)
}
inline ::idlepb::GongFaData* GongFaOpAck::release_gongfa_data() {
  
  ::idlepb::GongFaData* temp = _impl_.gongfa_data_;
  _impl_.gongfa_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::GongFaData* GongFaOpAck::unsafe_arena_release_gongfa_data() {
  // @@protoc_insertion_point(field_release:idlepb.GongFaOpAck.gongfa_data)
  
  ::idlepb::GongFaData* temp = _impl_.gongfa_data_;
  _impl_.gongfa_data_ = nullptr;
  return temp;
}
inline ::idlepb::GongFaData* GongFaOpAck::_internal_mutable_gongfa_data() {
  
  if (_impl_.gongfa_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::GongFaData>(GetArenaForAllocation());
    _impl_.gongfa_data_ = p;
  }
  return _impl_.gongfa_data_;
}
inline ::idlepb::GongFaData* GongFaOpAck::mutable_gongfa_data() {
  ::idlepb::GongFaData* _msg = _internal_mutable_gongfa_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GongFaOpAck.gongfa_data)
  return _msg;
}
inline void GongFaOpAck::set_allocated_gongfa_data(::idlepb::GongFaData* gongfa_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gongfa_data_);
  }
  if (gongfa_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gongfa_data));
    if (message_arena != submessage_arena) {
      gongfa_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gongfa_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.gongfa_data_ = gongfa_data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GongFaOpAck.gongfa_data)
}

// -------------------------------------------------------------------

// ActivateGongFaMaxEffectReq

// int32 cfg_id = 1;
inline void ActivateGongFaMaxEffectReq::clear_cfg_id() {
  _impl_.cfg_id_ = 0;
}
inline int32_t ActivateGongFaMaxEffectReq::_internal_cfg_id() const {
  return _impl_.cfg_id_;
}
inline int32_t ActivateGongFaMaxEffectReq::cfg_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ActivateGongFaMaxEffectReq.cfg_id)
  return _internal_cfg_id();
}
inline void ActivateGongFaMaxEffectReq::_internal_set_cfg_id(int32_t value) {
  
  _impl_.cfg_id_ = value;
}
inline void ActivateGongFaMaxEffectReq::set_cfg_id(int32_t value) {
  _internal_set_cfg_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ActivateGongFaMaxEffectReq.cfg_id)
}

// -------------------------------------------------------------------

// ActivateGongFaMaxEffectAck

// bool ok = 1;
inline void ActivateGongFaMaxEffectAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ActivateGongFaMaxEffectAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ActivateGongFaMaxEffectAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ActivateGongFaMaxEffectAck.ok)
  return _internal_ok();
}
inline void ActivateGongFaMaxEffectAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ActivateGongFaMaxEffectAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ActivateGongFaMaxEffectAck.ok)
}

// -------------------------------------------------------------------

// ReceiveFuZengRewardsReq

// int32 cfg_id = 1;
inline void ReceiveFuZengRewardsReq::clear_cfg_id() {
  _impl_.cfg_id_ = 0;
}
inline int32_t ReceiveFuZengRewardsReq::_internal_cfg_id() const {
  return _impl_.cfg_id_;
}
inline int32_t ReceiveFuZengRewardsReq::cfg_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ReceiveFuZengRewardsReq.cfg_id)
  return _internal_cfg_id();
}
inline void ReceiveFuZengRewardsReq::_internal_set_cfg_id(int32_t value) {
  
  _impl_.cfg_id_ = value;
}
inline void ReceiveFuZengRewardsReq::set_cfg_id(int32_t value) {
  _internal_set_cfg_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ReceiveFuZengRewardsReq.cfg_id)
}

// .idlepb.FuZengType type = 2;
inline void ReceiveFuZengRewardsReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::idlepb::FuZengType ReceiveFuZengRewardsReq::_internal_type() const {
  return static_cast< ::idlepb::FuZengType >(_impl_.type_);
}
inline ::idlepb::FuZengType ReceiveFuZengRewardsReq::type() const {
  // @@protoc_insertion_point(field_get:idlepb.ReceiveFuZengRewardsReq.type)
  return _internal_type();
}
inline void ReceiveFuZengRewardsReq::_internal_set_type(::idlepb::FuZengType value) {
  
  _impl_.type_ = value;
}
inline void ReceiveFuZengRewardsReq::set_type(::idlepb::FuZengType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:idlepb.ReceiveFuZengRewardsReq.type)
}

// -------------------------------------------------------------------

// ReceiveFuZengRewardsAck

// bool ok = 1;
inline void ReceiveFuZengRewardsAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ReceiveFuZengRewardsAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ReceiveFuZengRewardsAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ReceiveFuZengRewardsAck.ok)
  return _internal_ok();
}
inline void ReceiveFuZengRewardsAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ReceiveFuZengRewardsAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ReceiveFuZengRewardsAck.ok)
}

// .idlepb.FuZengData data = 2;
inline bool ReceiveFuZengRewardsAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool ReceiveFuZengRewardsAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::FuZengData& ReceiveFuZengRewardsAck::_internal_data() const {
  const ::idlepb::FuZengData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::FuZengData&>(
      ::idlepb::_FuZengData_default_instance_);
}
inline const ::idlepb::FuZengData& ReceiveFuZengRewardsAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.ReceiveFuZengRewardsAck.data)
  return _internal_data();
}
inline void ReceiveFuZengRewardsAck::unsafe_arena_set_allocated_data(
    ::idlepb::FuZengData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.ReceiveFuZengRewardsAck.data)
}
inline ::idlepb::FuZengData* ReceiveFuZengRewardsAck::release_data() {
  
  ::idlepb::FuZengData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::FuZengData* ReceiveFuZengRewardsAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.ReceiveFuZengRewardsAck.data)
  
  ::idlepb::FuZengData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::FuZengData* ReceiveFuZengRewardsAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::FuZengData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::FuZengData* ReceiveFuZengRewardsAck::mutable_data() {
  ::idlepb::FuZengData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.ReceiveFuZengRewardsAck.data)
  return _msg;
}
inline void ReceiveFuZengRewardsAck::set_allocated_data(::idlepb::FuZengData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.ReceiveFuZengRewardsAck.data)
}

// -------------------------------------------------------------------

// GetRoleFuZengDataReq

// -------------------------------------------------------------------

// GetRoleFuZengDataAck

// .idlepb.RoleFuZengData data = 1;
inline bool GetRoleFuZengDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetRoleFuZengDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleFuZengData& GetRoleFuZengDataAck::_internal_data() const {
  const ::idlepb::RoleFuZengData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleFuZengData&>(
      ::idlepb::_RoleFuZengData_default_instance_);
}
inline const ::idlepb::RoleFuZengData& GetRoleFuZengDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleFuZengDataAck.data)
  return _internal_data();
}
inline void GetRoleFuZengDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleFuZengData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleFuZengDataAck.data)
}
inline ::idlepb::RoleFuZengData* GetRoleFuZengDataAck::release_data() {
  
  ::idlepb::RoleFuZengData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleFuZengData* GetRoleFuZengDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleFuZengDataAck.data)
  
  ::idlepb::RoleFuZengData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleFuZengData* GetRoleFuZengDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleFuZengData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleFuZengData* GetRoleFuZengDataAck::mutable_data() {
  ::idlepb::RoleFuZengData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleFuZengDataAck.data)
  return _msg;
}
inline void GetRoleFuZengDataAck::set_allocated_data(::idlepb::RoleFuZengData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleFuZengDataAck.data)
}

// -------------------------------------------------------------------

// NotifyFuZeng

// .idlepb.FuZengType type = 1;
inline void NotifyFuZeng::clear_type() {
  _impl_.type_ = 0;
}
inline ::idlepb::FuZengType NotifyFuZeng::_internal_type() const {
  return static_cast< ::idlepb::FuZengType >(_impl_.type_);
}
inline ::idlepb::FuZengType NotifyFuZeng::type() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyFuZeng.type)
  return _internal_type();
}
inline void NotifyFuZeng::_internal_set_type(::idlepb::FuZengType value) {
  
  _impl_.type_ = value;
}
inline void NotifyFuZeng::set_type(::idlepb::FuZengType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyFuZeng.type)
}

// int64 num = 2;
inline void NotifyFuZeng::clear_num() {
  _impl_.num_ = int64_t{0};
}
inline int64_t NotifyFuZeng::_internal_num() const {
  return _impl_.num_;
}
inline int64_t NotifyFuZeng::num() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyFuZeng.num)
  return _internal_num();
}
inline void NotifyFuZeng::_internal_set_num(int64_t value) {
  
  _impl_.num_ = value;
}
inline void NotifyFuZeng::set_num(int64_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyFuZeng.num)
}

// int32 cfg_id = 3;
inline void NotifyFuZeng::clear_cfg_id() {
  _impl_.cfg_id_ = 0;
}
inline int32_t NotifyFuZeng::_internal_cfg_id() const {
  return _impl_.cfg_id_;
}
inline int32_t NotifyFuZeng::cfg_id() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyFuZeng.cfg_id)
  return _internal_cfg_id();
}
inline void NotifyFuZeng::_internal_set_cfg_id(int32_t value) {
  
  _impl_.cfg_id_ = value;
}
inline void NotifyFuZeng::set_cfg_id(int32_t value) {
  _internal_set_cfg_id(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyFuZeng.cfg_id)
}

// -------------------------------------------------------------------

// GetRoleTreasuryDataReq

// bool dirty_flag = 1;
inline void GetRoleTreasuryDataReq::clear_dirty_flag() {
  _impl_.dirty_flag_ = false;
}
inline bool GetRoleTreasuryDataReq::_internal_dirty_flag() const {
  return _impl_.dirty_flag_;
}
inline bool GetRoleTreasuryDataReq::dirty_flag() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleTreasuryDataReq.dirty_flag)
  return _internal_dirty_flag();
}
inline void GetRoleTreasuryDataReq::_internal_set_dirty_flag(bool value) {
  
  _impl_.dirty_flag_ = value;
}
inline void GetRoleTreasuryDataReq::set_dirty_flag(bool value) {
  _internal_set_dirty_flag(value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleTreasuryDataReq.dirty_flag)
}

// -------------------------------------------------------------------

// GetRoleTreasuryDataAck

// .idlepb.RoleTreasurySaveData data = 1;
inline bool GetRoleTreasuryDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetRoleTreasuryDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleTreasurySaveData& GetRoleTreasuryDataAck::_internal_data() const {
  const ::idlepb::RoleTreasurySaveData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleTreasurySaveData&>(
      ::idlepb::_RoleTreasurySaveData_default_instance_);
}
inline const ::idlepb::RoleTreasurySaveData& GetRoleTreasuryDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleTreasuryDataAck.data)
  return _internal_data();
}
inline void GetRoleTreasuryDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleTreasurySaveData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleTreasuryDataAck.data)
}
inline ::idlepb::RoleTreasurySaveData* GetRoleTreasuryDataAck::release_data() {
  
  ::idlepb::RoleTreasurySaveData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleTreasurySaveData* GetRoleTreasuryDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleTreasuryDataAck.data)
  
  ::idlepb::RoleTreasurySaveData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleTreasurySaveData* GetRoleTreasuryDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleTreasurySaveData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleTreasurySaveData* GetRoleTreasuryDataAck::mutable_data() {
  ::idlepb::RoleTreasurySaveData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleTreasuryDataAck.data)
  return _msg;
}
inline void GetRoleTreasuryDataAck::set_allocated_data(::idlepb::RoleTreasurySaveData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleTreasuryDataAck.data)
}

// -------------------------------------------------------------------

// OpenTreasuryChestReq

// int32 chest_type = 1;
inline void OpenTreasuryChestReq::clear_chest_type() {
  _impl_.chest_type_ = 0;
}
inline int32_t OpenTreasuryChestReq::_internal_chest_type() const {
  return _impl_.chest_type_;
}
inline int32_t OpenTreasuryChestReq::chest_type() const {
  // @@protoc_insertion_point(field_get:idlepb.OpenTreasuryChestReq.chest_type)
  return _internal_chest_type();
}
inline void OpenTreasuryChestReq::_internal_set_chest_type(int32_t value) {
  
  _impl_.chest_type_ = value;
}
inline void OpenTreasuryChestReq::set_chest_type(int32_t value) {
  _internal_set_chest_type(value);
  // @@protoc_insertion_point(field_set:idlepb.OpenTreasuryChestReq.chest_type)
}

// int32 num = 2;
inline void OpenTreasuryChestReq::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t OpenTreasuryChestReq::_internal_num() const {
  return _impl_.num_;
}
inline int32_t OpenTreasuryChestReq::num() const {
  // @@protoc_insertion_point(field_get:idlepb.OpenTreasuryChestReq.num)
  return _internal_num();
}
inline void OpenTreasuryChestReq::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void OpenTreasuryChestReq::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.OpenTreasuryChestReq.num)
}

// -------------------------------------------------------------------

// OpenTreasuryChestAck

// bool ok = 1;
inline void OpenTreasuryChestAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool OpenTreasuryChestAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool OpenTreasuryChestAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.OpenTreasuryChestAck.ok)
  return _internal_ok();
}
inline void OpenTreasuryChestAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void OpenTreasuryChestAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.OpenTreasuryChestAck.ok)
}

// -------------------------------------------------------------------

// OneClickOpenTreasuryChestReq

// -------------------------------------------------------------------

// OneClickOpenTreasuryChestAck

// bool ok = 1;
inline void OneClickOpenTreasuryChestAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool OneClickOpenTreasuryChestAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool OneClickOpenTreasuryChestAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.OneClickOpenTreasuryChestAck.ok)
  return _internal_ok();
}
inline void OneClickOpenTreasuryChestAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void OneClickOpenTreasuryChestAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.OneClickOpenTreasuryChestAck.ok)
}

// repeated int32 today_open_times = 2;
inline int OneClickOpenTreasuryChestAck::_internal_today_open_times_size() const {
  return _impl_.today_open_times_.size();
}
inline int OneClickOpenTreasuryChestAck::today_open_times_size() const {
  return _internal_today_open_times_size();
}
inline void OneClickOpenTreasuryChestAck::clear_today_open_times() {
  _impl_.today_open_times_.Clear();
}
inline int32_t OneClickOpenTreasuryChestAck::_internal_today_open_times(int index) const {
  return _impl_.today_open_times_.Get(index);
}
inline int32_t OneClickOpenTreasuryChestAck::today_open_times(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.OneClickOpenTreasuryChestAck.today_open_times)
  return _internal_today_open_times(index);
}
inline void OneClickOpenTreasuryChestAck::set_today_open_times(int index, int32_t value) {
  _impl_.today_open_times_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.OneClickOpenTreasuryChestAck.today_open_times)
}
inline void OneClickOpenTreasuryChestAck::_internal_add_today_open_times(int32_t value) {
  _impl_.today_open_times_.Add(value);
}
inline void OneClickOpenTreasuryChestAck::add_today_open_times(int32_t value) {
  _internal_add_today_open_times(value);
  // @@protoc_insertion_point(field_add:idlepb.OneClickOpenTreasuryChestAck.today_open_times)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
OneClickOpenTreasuryChestAck::_internal_today_open_times() const {
  return _impl_.today_open_times_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
OneClickOpenTreasuryChestAck::today_open_times() const {
  // @@protoc_insertion_point(field_list:idlepb.OneClickOpenTreasuryChestAck.today_open_times)
  return _internal_today_open_times();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
OneClickOpenTreasuryChestAck::_internal_mutable_today_open_times() {
  return &_impl_.today_open_times_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
OneClickOpenTreasuryChestAck::mutable_today_open_times() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.OneClickOpenTreasuryChestAck.today_open_times)
  return _internal_mutable_today_open_times();
}

// repeated int32 guarantee_count = 3;
inline int OneClickOpenTreasuryChestAck::_internal_guarantee_count_size() const {
  return _impl_.guarantee_count_.size();
}
inline int OneClickOpenTreasuryChestAck::guarantee_count_size() const {
  return _internal_guarantee_count_size();
}
inline void OneClickOpenTreasuryChestAck::clear_guarantee_count() {
  _impl_.guarantee_count_.Clear();
}
inline int32_t OneClickOpenTreasuryChestAck::_internal_guarantee_count(int index) const {
  return _impl_.guarantee_count_.Get(index);
}
inline int32_t OneClickOpenTreasuryChestAck::guarantee_count(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.OneClickOpenTreasuryChestAck.guarantee_count)
  return _internal_guarantee_count(index);
}
inline void OneClickOpenTreasuryChestAck::set_guarantee_count(int index, int32_t value) {
  _impl_.guarantee_count_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.OneClickOpenTreasuryChestAck.guarantee_count)
}
inline void OneClickOpenTreasuryChestAck::_internal_add_guarantee_count(int32_t value) {
  _impl_.guarantee_count_.Add(value);
}
inline void OneClickOpenTreasuryChestAck::add_guarantee_count(int32_t value) {
  _internal_add_guarantee_count(value);
  // @@protoc_insertion_point(field_add:idlepb.OneClickOpenTreasuryChestAck.guarantee_count)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
OneClickOpenTreasuryChestAck::_internal_guarantee_count() const {
  return _impl_.guarantee_count_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
OneClickOpenTreasuryChestAck::guarantee_count() const {
  // @@protoc_insertion_point(field_list:idlepb.OneClickOpenTreasuryChestAck.guarantee_count)
  return _internal_guarantee_count();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
OneClickOpenTreasuryChestAck::_internal_mutable_guarantee_count() {
  return &_impl_.guarantee_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
OneClickOpenTreasuryChestAck::mutable_guarantee_count() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.OneClickOpenTreasuryChestAck.guarantee_count)
  return _internal_mutable_guarantee_count();
}

// -------------------------------------------------------------------

// OpenTreasuryGachaReq

// int32 gacha_type = 1;
inline void OpenTreasuryGachaReq::clear_gacha_type() {
  _impl_.gacha_type_ = 0;
}
inline int32_t OpenTreasuryGachaReq::_internal_gacha_type() const {
  return _impl_.gacha_type_;
}
inline int32_t OpenTreasuryGachaReq::gacha_type() const {
  // @@protoc_insertion_point(field_get:idlepb.OpenTreasuryGachaReq.gacha_type)
  return _internal_gacha_type();
}
inline void OpenTreasuryGachaReq::_internal_set_gacha_type(int32_t value) {
  
  _impl_.gacha_type_ = value;
}
inline void OpenTreasuryGachaReq::set_gacha_type(int32_t value) {
  _internal_set_gacha_type(value);
  // @@protoc_insertion_point(field_set:idlepb.OpenTreasuryGachaReq.gacha_type)
}

// int32 num = 2;
inline void OpenTreasuryGachaReq::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t OpenTreasuryGachaReq::_internal_num() const {
  return _impl_.num_;
}
inline int32_t OpenTreasuryGachaReq::num() const {
  // @@protoc_insertion_point(field_get:idlepb.OpenTreasuryGachaReq.num)
  return _internal_num();
}
inline void OpenTreasuryGachaReq::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void OpenTreasuryGachaReq::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.OpenTreasuryGachaReq.num)
}

// -------------------------------------------------------------------

// OpenTreasuryGachaAck

// bool ok = 1;
inline void OpenTreasuryGachaAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool OpenTreasuryGachaAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool OpenTreasuryGachaAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.OpenTreasuryGachaAck.ok)
  return _internal_ok();
}
inline void OpenTreasuryGachaAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void OpenTreasuryGachaAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.OpenTreasuryGachaAck.ok)
}

// bool free = 2;
inline void OpenTreasuryGachaAck::clear_free() {
  _impl_.free_ = false;
}
inline bool OpenTreasuryGachaAck::_internal_free() const {
  return _impl_.free_;
}
inline bool OpenTreasuryGachaAck::free() const {
  // @@protoc_insertion_point(field_get:idlepb.OpenTreasuryGachaAck.free)
  return _internal_free();
}
inline void OpenTreasuryGachaAck::_internal_set_free(bool value) {
  
  _impl_.free_ = value;
}
inline void OpenTreasuryGachaAck::set_free(bool value) {
  _internal_set_free(value);
  // @@protoc_insertion_point(field_set:idlepb.OpenTreasuryGachaAck.free)
}

// -------------------------------------------------------------------

// RefreshTreasuryShopReq

// -------------------------------------------------------------------

// RefreshTreasuryShopAck

// bool ok = 1;
inline void RefreshTreasuryShopAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool RefreshTreasuryShopAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool RefreshTreasuryShopAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshTreasuryShopAck.ok)
  return _internal_ok();
}
inline void RefreshTreasuryShopAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void RefreshTreasuryShopAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.RefreshTreasuryShopAck.ok)
}

// repeated .idlepb.TreasuryShopItem items = 2;
inline int RefreshTreasuryShopAck::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int RefreshTreasuryShopAck::items_size() const {
  return _internal_items_size();
}
inline ::idlepb::TreasuryShopItem* RefreshTreasuryShopAck::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.RefreshTreasuryShopAck.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TreasuryShopItem >*
RefreshTreasuryShopAck::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.RefreshTreasuryShopAck.items)
  return &_impl_.items_;
}
inline const ::idlepb::TreasuryShopItem& RefreshTreasuryShopAck::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::TreasuryShopItem& RefreshTreasuryShopAck::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.RefreshTreasuryShopAck.items)
  return _internal_items(index);
}
inline ::idlepb::TreasuryShopItem* RefreshTreasuryShopAck::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::TreasuryShopItem* RefreshTreasuryShopAck::add_items() {
  ::idlepb::TreasuryShopItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.RefreshTreasuryShopAck.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::TreasuryShopItem >&
RefreshTreasuryShopAck::items() const {
  // @@protoc_insertion_point(field_list:idlepb.RefreshTreasuryShopAck.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// TreasuryShopBuyReq

// int32 index = 1;
inline void TreasuryShopBuyReq::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t TreasuryShopBuyReq::_internal_index() const {
  return _impl_.index_;
}
inline int32_t TreasuryShopBuyReq::index() const {
  // @@protoc_insertion_point(field_get:idlepb.TreasuryShopBuyReq.index)
  return _internal_index();
}
inline void TreasuryShopBuyReq::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void TreasuryShopBuyReq::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:idlepb.TreasuryShopBuyReq.index)
}

// -------------------------------------------------------------------

// TreasuryShopBuyAck

// bool ok = 1;
inline void TreasuryShopBuyAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool TreasuryShopBuyAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool TreasuryShopBuyAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.TreasuryShopBuyAck.ok)
  return _internal_ok();
}
inline void TreasuryShopBuyAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void TreasuryShopBuyAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.TreasuryShopBuyAck.ok)
}

// -------------------------------------------------------------------

// GetLifeCounterDataReq

// -------------------------------------------------------------------

// GetLifeCounterDataAck

// .idlepb.RoleLifeCounterData data = 1;
inline bool GetLifeCounterDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetLifeCounterDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleLifeCounterData& GetLifeCounterDataAck::_internal_data() const {
  const ::idlepb::RoleLifeCounterData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleLifeCounterData&>(
      ::idlepb::_RoleLifeCounterData_default_instance_);
}
inline const ::idlepb::RoleLifeCounterData& GetLifeCounterDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetLifeCounterDataAck.data)
  return _internal_data();
}
inline void GetLifeCounterDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleLifeCounterData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetLifeCounterDataAck.data)
}
inline ::idlepb::RoleLifeCounterData* GetLifeCounterDataAck::release_data() {
  
  ::idlepb::RoleLifeCounterData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleLifeCounterData* GetLifeCounterDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetLifeCounterDataAck.data)
  
  ::idlepb::RoleLifeCounterData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleLifeCounterData* GetLifeCounterDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleLifeCounterData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleLifeCounterData* GetLifeCounterDataAck::mutable_data() {
  ::idlepb::RoleLifeCounterData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetLifeCounterDataAck.data)
  return _msg;
}
inline void GetLifeCounterDataAck::set_allocated_data(::idlepb::RoleLifeCounterData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetLifeCounterDataAck.data)
}

// -------------------------------------------------------------------

// UpdateLifeCounter

// int32 function_type = 1;
inline void UpdateLifeCounter::clear_function_type() {
  _impl_.function_type_ = 0;
}
inline int32_t UpdateLifeCounter::_internal_function_type() const {
  return _impl_.function_type_;
}
inline int32_t UpdateLifeCounter::function_type() const {
  // @@protoc_insertion_point(field_get:idlepb.UpdateLifeCounter.function_type)
  return _internal_function_type();
}
inline void UpdateLifeCounter::_internal_set_function_type(int32_t value) {
  
  _impl_.function_type_ = value;
}
inline void UpdateLifeCounter::set_function_type(int32_t value) {
  _internal_set_function_type(value);
  // @@protoc_insertion_point(field_set:idlepb.UpdateLifeCounter.function_type)
}

// int32 target_id = 2;
inline void UpdateLifeCounter::clear_target_id() {
  _impl_.target_id_ = 0;
}
inline int32_t UpdateLifeCounter::_internal_target_id() const {
  return _impl_.target_id_;
}
inline int32_t UpdateLifeCounter::target_id() const {
  // @@protoc_insertion_point(field_get:idlepb.UpdateLifeCounter.target_id)
  return _internal_target_id();
}
inline void UpdateLifeCounter::_internal_set_target_id(int32_t value) {
  
  _impl_.target_id_ = value;
}
inline void UpdateLifeCounter::set_target_id(int32_t value) {
  _internal_set_target_id(value);
  // @@protoc_insertion_point(field_set:idlepb.UpdateLifeCounter.target_id)
}

// int64 new_num = 3;
inline void UpdateLifeCounter::clear_new_num() {
  _impl_.new_num_ = int64_t{0};
}
inline int64_t UpdateLifeCounter::_internal_new_num() const {
  return _impl_.new_num_;
}
inline int64_t UpdateLifeCounter::new_num() const {
  // @@protoc_insertion_point(field_get:idlepb.UpdateLifeCounter.new_num)
  return _internal_new_num();
}
inline void UpdateLifeCounter::_internal_set_new_num(int64_t value) {
  
  _impl_.new_num_ = value;
}
inline void UpdateLifeCounter::set_new_num(int64_t value) {
  _internal_set_new_num(value);
  // @@protoc_insertion_point(field_set:idlepb.UpdateLifeCounter.new_num)
}

// -------------------------------------------------------------------

// DoQuestFightReq

// int32 quest_id = 1;
inline void DoQuestFightReq::clear_quest_id() {
  _impl_.quest_id_ = 0;
}
inline int32_t DoQuestFightReq::_internal_quest_id() const {
  return _impl_.quest_id_;
}
inline int32_t DoQuestFightReq::quest_id() const {
  // @@protoc_insertion_point(field_get:idlepb.DoQuestFightReq.quest_id)
  return _internal_quest_id();
}
inline void DoQuestFightReq::_internal_set_quest_id(int32_t value) {
  
  _impl_.quest_id_ = value;
}
inline void DoQuestFightReq::set_quest_id(int32_t value) {
  _internal_set_quest_id(value);
  // @@protoc_insertion_point(field_set:idlepb.DoQuestFightReq.quest_id)
}

// -------------------------------------------------------------------

// DoQuestFightAck

// bool ok = 1;
inline void DoQuestFightAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool DoQuestFightAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool DoQuestFightAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.DoQuestFightAck.ok)
  return _internal_ok();
}
inline void DoQuestFightAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void DoQuestFightAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.DoQuestFightAck.ok)
}

// -------------------------------------------------------------------

// QuestFightQuickEndReq

// bool is_exit = 1;
inline void QuestFightQuickEndReq::clear_is_exit() {
  _impl_.is_exit_ = false;
}
inline bool QuestFightQuickEndReq::_internal_is_exit() const {
  return _impl_.is_exit_;
}
inline bool QuestFightQuickEndReq::is_exit() const {
  // @@protoc_insertion_point(field_get:idlepb.QuestFightQuickEndReq.is_exit)
  return _internal_is_exit();
}
inline void QuestFightQuickEndReq::_internal_set_is_exit(bool value) {
  
  _impl_.is_exit_ = value;
}
inline void QuestFightQuickEndReq::set_is_exit(bool value) {
  _internal_set_is_exit(value);
  // @@protoc_insertion_point(field_set:idlepb.QuestFightQuickEndReq.is_exit)
}

// -------------------------------------------------------------------

// QuestFightQuickEndAck

// -------------------------------------------------------------------

// NotifyQuestFightChallengeOver

// int32 quest_id = 1;
inline void NotifyQuestFightChallengeOver::clear_quest_id() {
  _impl_.quest_id_ = 0;
}
inline int32_t NotifyQuestFightChallengeOver::_internal_quest_id() const {
  return _impl_.quest_id_;
}
inline int32_t NotifyQuestFightChallengeOver::quest_id() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyQuestFightChallengeOver.quest_id)
  return _internal_quest_id();
}
inline void NotifyQuestFightChallengeOver::_internal_set_quest_id(int32_t value) {
  
  _impl_.quest_id_ = value;
}
inline void NotifyQuestFightChallengeOver::set_quest_id(int32_t value) {
  _internal_set_quest_id(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyQuestFightChallengeOver.quest_id)
}

// bool win = 2;
inline void NotifyQuestFightChallengeOver::clear_win() {
  _impl_.win_ = false;
}
inline bool NotifyQuestFightChallengeOver::_internal_win() const {
  return _impl_.win_;
}
inline bool NotifyQuestFightChallengeOver::win() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyQuestFightChallengeOver.win)
  return _internal_win();
}
inline void NotifyQuestFightChallengeOver::_internal_set_win(bool value) {
  
  _impl_.win_ = value;
}
inline void NotifyQuestFightChallengeOver::set_win(bool value) {
  _internal_set_win(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyQuestFightChallengeOver.win)
}

// -------------------------------------------------------------------

// GetAppearanceDataReq

// -------------------------------------------------------------------

// GetAppearanceDataAck

// .idlepb.RoleAppearanceData data = 1;
inline bool GetAppearanceDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetAppearanceDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleAppearanceData& GetAppearanceDataAck::_internal_data() const {
  const ::idlepb::RoleAppearanceData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleAppearanceData&>(
      ::idlepb::_RoleAppearanceData_default_instance_);
}
inline const ::idlepb::RoleAppearanceData& GetAppearanceDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetAppearanceDataAck.data)
  return _internal_data();
}
inline void GetAppearanceDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleAppearanceData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetAppearanceDataAck.data)
}
inline ::idlepb::RoleAppearanceData* GetAppearanceDataAck::release_data() {
  
  ::idlepb::RoleAppearanceData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleAppearanceData* GetAppearanceDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetAppearanceDataAck.data)
  
  ::idlepb::RoleAppearanceData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleAppearanceData* GetAppearanceDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleAppearanceData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleAppearanceData* GetAppearanceDataAck::mutable_data() {
  ::idlepb::RoleAppearanceData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetAppearanceDataAck.data)
  return _msg;
}
inline void GetAppearanceDataAck::set_allocated_data(::idlepb::RoleAppearanceData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetAppearanceDataAck.data)
}

// -------------------------------------------------------------------

// AppearanceAddReq

// int32 item_id = 1;
inline void AppearanceAddReq::clear_item_id() {
  _impl_.item_id_ = 0;
}
inline int32_t AppearanceAddReq::_internal_item_id() const {
  return _impl_.item_id_;
}
inline int32_t AppearanceAddReq::item_id() const {
  // @@protoc_insertion_point(field_get:idlepb.AppearanceAddReq.item_id)
  return _internal_item_id();
}
inline void AppearanceAddReq::_internal_set_item_id(int32_t value) {
  
  _impl_.item_id_ = value;
}
inline void AppearanceAddReq::set_item_id(int32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:idlepb.AppearanceAddReq.item_id)
}

// -------------------------------------------------------------------

// AppearanceAddAck

// bool ok = 1;
inline void AppearanceAddAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool AppearanceAddAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool AppearanceAddAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.AppearanceAddAck.ok)
  return _internal_ok();
}
inline void AppearanceAddAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void AppearanceAddAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.AppearanceAddAck.ok)
}

// -------------------------------------------------------------------

// AppearanceActiveReq

// int32 group_id = 1;
inline void AppearanceActiveReq::clear_group_id() {
  _impl_.group_id_ = 0;
}
inline int32_t AppearanceActiveReq::_internal_group_id() const {
  return _impl_.group_id_;
}
inline int32_t AppearanceActiveReq::group_id() const {
  // @@protoc_insertion_point(field_get:idlepb.AppearanceActiveReq.group_id)
  return _internal_group_id();
}
inline void AppearanceActiveReq::_internal_set_group_id(int32_t value) {
  
  _impl_.group_id_ = value;
}
inline void AppearanceActiveReq::set_group_id(int32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:idlepb.AppearanceActiveReq.group_id)
}

// -------------------------------------------------------------------

// AppearanceActiveAck

// bool ok = 1;
inline void AppearanceActiveAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool AppearanceActiveAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool AppearanceActiveAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.AppearanceActiveAck.ok)
  return _internal_ok();
}
inline void AppearanceActiveAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void AppearanceActiveAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.AppearanceActiveAck.ok)
}

// -------------------------------------------------------------------

// AppearanceWearReq

// int32 group_id = 1;
inline void AppearanceWearReq::clear_group_id() {
  _impl_.group_id_ = 0;
}
inline int32_t AppearanceWearReq::_internal_group_id() const {
  return _impl_.group_id_;
}
inline int32_t AppearanceWearReq::group_id() const {
  // @@protoc_insertion_point(field_get:idlepb.AppearanceWearReq.group_id)
  return _internal_group_id();
}
inline void AppearanceWearReq::_internal_set_group_id(int32_t value) {
  
  _impl_.group_id_ = value;
}
inline void AppearanceWearReq::set_group_id(int32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:idlepb.AppearanceWearReq.group_id)
}

// -------------------------------------------------------------------

// AppearanceWearAck

// bool ok = 1;
inline void AppearanceWearAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool AppearanceWearAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool AppearanceWearAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.AppearanceWearAck.ok)
  return _internal_ok();
}
inline void AppearanceWearAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void AppearanceWearAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.AppearanceWearAck.ok)
}

// -------------------------------------------------------------------

// AppearanceChangeSkTypeReq

// int32 sk_type = 1;
inline void AppearanceChangeSkTypeReq::clear_sk_type() {
  _impl_.sk_type_ = 0;
}
inline int32_t AppearanceChangeSkTypeReq::_internal_sk_type() const {
  return _impl_.sk_type_;
}
inline int32_t AppearanceChangeSkTypeReq::sk_type() const {
  // @@protoc_insertion_point(field_get:idlepb.AppearanceChangeSkTypeReq.sk_type)
  return _internal_sk_type();
}
inline void AppearanceChangeSkTypeReq::_internal_set_sk_type(int32_t value) {
  
  _impl_.sk_type_ = value;
}
inline void AppearanceChangeSkTypeReq::set_sk_type(int32_t value) {
  _internal_set_sk_type(value);
  // @@protoc_insertion_point(field_set:idlepb.AppearanceChangeSkTypeReq.sk_type)
}

// -------------------------------------------------------------------

// AppearanceChangeSkTypeAck

// bool ok = 1;
inline void AppearanceChangeSkTypeAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool AppearanceChangeSkTypeAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool AppearanceChangeSkTypeAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.AppearanceChangeSkTypeAck.ok)
  return _internal_ok();
}
inline void AppearanceChangeSkTypeAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void AppearanceChangeSkTypeAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.AppearanceChangeSkTypeAck.ok)
}

// -------------------------------------------------------------------

// AppearanceBuyReq

// int32 shop_index = 1;
inline void AppearanceBuyReq::clear_shop_index() {
  _impl_.shop_index_ = 0;
}
inline int32_t AppearanceBuyReq::_internal_shop_index() const {
  return _impl_.shop_index_;
}
inline int32_t AppearanceBuyReq::shop_index() const {
  // @@protoc_insertion_point(field_get:idlepb.AppearanceBuyReq.shop_index)
  return _internal_shop_index();
}
inline void AppearanceBuyReq::_internal_set_shop_index(int32_t value) {
  
  _impl_.shop_index_ = value;
}
inline void AppearanceBuyReq::set_shop_index(int32_t value) {
  _internal_set_shop_index(value);
  // @@protoc_insertion_point(field_set:idlepb.AppearanceBuyReq.shop_index)
}

// int32 item_index = 2;
inline void AppearanceBuyReq::clear_item_index() {
  _impl_.item_index_ = 0;
}
inline int32_t AppearanceBuyReq::_internal_item_index() const {
  return _impl_.item_index_;
}
inline int32_t AppearanceBuyReq::item_index() const {
  // @@protoc_insertion_point(field_get:idlepb.AppearanceBuyReq.item_index)
  return _internal_item_index();
}
inline void AppearanceBuyReq::_internal_set_item_index(int32_t value) {
  
  _impl_.item_index_ = value;
}
inline void AppearanceBuyReq::set_item_index(int32_t value) {
  _internal_set_item_index(value);
  // @@protoc_insertion_point(field_set:idlepb.AppearanceBuyReq.item_index)
}

// -------------------------------------------------------------------

// AppearanceBuyAck

// bool ok = 1;
inline void AppearanceBuyAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool AppearanceBuyAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool AppearanceBuyAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.AppearanceBuyAck.ok)
  return _internal_ok();
}
inline void AppearanceBuyAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void AppearanceBuyAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.AppearanceBuyAck.ok)
}

// -------------------------------------------------------------------

// GetArenaCheckListDataReq

// -------------------------------------------------------------------

// GetArenaCheckListDataAck

// .idlepb.RoleArenaCheckListData data = 1;
inline bool GetArenaCheckListDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetArenaCheckListDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleArenaCheckListData& GetArenaCheckListDataAck::_internal_data() const {
  const ::idlepb::RoleArenaCheckListData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleArenaCheckListData&>(
      ::idlepb::_RoleArenaCheckListData_default_instance_);
}
inline const ::idlepb::RoleArenaCheckListData& GetArenaCheckListDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetArenaCheckListDataAck.data)
  return _internal_data();
}
inline void GetArenaCheckListDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleArenaCheckListData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetArenaCheckListDataAck.data)
}
inline ::idlepb::RoleArenaCheckListData* GetArenaCheckListDataAck::release_data() {
  
  ::idlepb::RoleArenaCheckListData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleArenaCheckListData* GetArenaCheckListDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetArenaCheckListDataAck.data)
  
  ::idlepb::RoleArenaCheckListData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleArenaCheckListData* GetArenaCheckListDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleArenaCheckListData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleArenaCheckListData* GetArenaCheckListDataAck::mutable_data() {
  ::idlepb::RoleArenaCheckListData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetArenaCheckListDataAck.data)
  return _msg;
}
inline void GetArenaCheckListDataAck::set_allocated_data(::idlepb::RoleArenaCheckListData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetArenaCheckListDataAck.data)
}

// -------------------------------------------------------------------

// ArenaCheckListSubmitReq

// int32 check_list_id = 1;
inline void ArenaCheckListSubmitReq::clear_check_list_id() {
  _impl_.check_list_id_ = 0;
}
inline int32_t ArenaCheckListSubmitReq::_internal_check_list_id() const {
  return _impl_.check_list_id_;
}
inline int32_t ArenaCheckListSubmitReq::check_list_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ArenaCheckListSubmitReq.check_list_id)
  return _internal_check_list_id();
}
inline void ArenaCheckListSubmitReq::_internal_set_check_list_id(int32_t value) {
  
  _impl_.check_list_id_ = value;
}
inline void ArenaCheckListSubmitReq::set_check_list_id(int32_t value) {
  _internal_set_check_list_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ArenaCheckListSubmitReq.check_list_id)
}

// -------------------------------------------------------------------

// ArenaCheckListSubmitAck

// bool ok = 1;
inline void ArenaCheckListSubmitAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ArenaCheckListSubmitAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ArenaCheckListSubmitAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ArenaCheckListSubmitAck.ok)
  return _internal_ok();
}
inline void ArenaCheckListSubmitAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ArenaCheckListSubmitAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ArenaCheckListSubmitAck.ok)
}

// .idlepb.ArenaCheckListData data = 2;
inline bool ArenaCheckListSubmitAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool ArenaCheckListSubmitAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::ArenaCheckListData& ArenaCheckListSubmitAck::_internal_data() const {
  const ::idlepb::ArenaCheckListData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::ArenaCheckListData&>(
      ::idlepb::_ArenaCheckListData_default_instance_);
}
inline const ::idlepb::ArenaCheckListData& ArenaCheckListSubmitAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.ArenaCheckListSubmitAck.data)
  return _internal_data();
}
inline void ArenaCheckListSubmitAck::unsafe_arena_set_allocated_data(
    ::idlepb::ArenaCheckListData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.ArenaCheckListSubmitAck.data)
}
inline ::idlepb::ArenaCheckListData* ArenaCheckListSubmitAck::release_data() {
  
  ::idlepb::ArenaCheckListData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::ArenaCheckListData* ArenaCheckListSubmitAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.ArenaCheckListSubmitAck.data)
  
  ::idlepb::ArenaCheckListData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::ArenaCheckListData* ArenaCheckListSubmitAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::ArenaCheckListData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::ArenaCheckListData* ArenaCheckListSubmitAck::mutable_data() {
  ::idlepb::ArenaCheckListData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.ArenaCheckListSubmitAck.data)
  return _msg;
}
inline void ArenaCheckListSubmitAck::set_allocated_data(::idlepb::ArenaCheckListData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.ArenaCheckListSubmitAck.data)
}

// -------------------------------------------------------------------

// ArenaCheckListRewardSubmitReq

// int32 reward_id = 1;
inline void ArenaCheckListRewardSubmitReq::clear_reward_id() {
  _impl_.reward_id_ = 0;
}
inline int32_t ArenaCheckListRewardSubmitReq::_internal_reward_id() const {
  return _impl_.reward_id_;
}
inline int32_t ArenaCheckListRewardSubmitReq::reward_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ArenaCheckListRewardSubmitReq.reward_id)
  return _internal_reward_id();
}
inline void ArenaCheckListRewardSubmitReq::_internal_set_reward_id(int32_t value) {
  
  _impl_.reward_id_ = value;
}
inline void ArenaCheckListRewardSubmitReq::set_reward_id(int32_t value) {
  _internal_set_reward_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ArenaCheckListRewardSubmitReq.reward_id)
}

// -------------------------------------------------------------------

// ArenaCheckListRewardSubmitAck

// bool ok = 1;
inline void ArenaCheckListRewardSubmitAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ArenaCheckListRewardSubmitAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ArenaCheckListRewardSubmitAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ArenaCheckListRewardSubmitAck.ok)
  return _internal_ok();
}
inline void ArenaCheckListRewardSubmitAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ArenaCheckListRewardSubmitAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ArenaCheckListRewardSubmitAck.ok)
}

// .idlepb.ArenaCheckListRewardData data = 2;
inline bool ArenaCheckListRewardSubmitAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool ArenaCheckListRewardSubmitAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::ArenaCheckListRewardData& ArenaCheckListRewardSubmitAck::_internal_data() const {
  const ::idlepb::ArenaCheckListRewardData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::ArenaCheckListRewardData&>(
      ::idlepb::_ArenaCheckListRewardData_default_instance_);
}
inline const ::idlepb::ArenaCheckListRewardData& ArenaCheckListRewardSubmitAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.ArenaCheckListRewardSubmitAck.data)
  return _internal_data();
}
inline void ArenaCheckListRewardSubmitAck::unsafe_arena_set_allocated_data(
    ::idlepb::ArenaCheckListRewardData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.ArenaCheckListRewardSubmitAck.data)
}
inline ::idlepb::ArenaCheckListRewardData* ArenaCheckListRewardSubmitAck::release_data() {
  
  ::idlepb::ArenaCheckListRewardData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::ArenaCheckListRewardData* ArenaCheckListRewardSubmitAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.ArenaCheckListRewardSubmitAck.data)
  
  ::idlepb::ArenaCheckListRewardData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::ArenaCheckListRewardData* ArenaCheckListRewardSubmitAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::ArenaCheckListRewardData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::ArenaCheckListRewardData* ArenaCheckListRewardSubmitAck::mutable_data() {
  ::idlepb::ArenaCheckListRewardData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.ArenaCheckListRewardSubmitAck.data)
  return _msg;
}
inline void ArenaCheckListRewardSubmitAck::set_allocated_data(::idlepb::ArenaCheckListRewardData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.ArenaCheckListRewardSubmitAck.data)
}

// -------------------------------------------------------------------

// DungeonKillAllChallengeReq

// int32 dungeon_uid_id = 1;
inline void DungeonKillAllChallengeReq::clear_dungeon_uid_id() {
  _impl_.dungeon_uid_id_ = 0;
}
inline int32_t DungeonKillAllChallengeReq::_internal_dungeon_uid_id() const {
  return _impl_.dungeon_uid_id_;
}
inline int32_t DungeonKillAllChallengeReq::dungeon_uid_id() const {
  // @@protoc_insertion_point(field_get:idlepb.DungeonKillAllChallengeReq.dungeon_uid_id)
  return _internal_dungeon_uid_id();
}
inline void DungeonKillAllChallengeReq::_internal_set_dungeon_uid_id(int32_t value) {
  
  _impl_.dungeon_uid_id_ = value;
}
inline void DungeonKillAllChallengeReq::set_dungeon_uid_id(int32_t value) {
  _internal_set_dungeon_uid_id(value);
  // @@protoc_insertion_point(field_set:idlepb.DungeonKillAllChallengeReq.dungeon_uid_id)
}

// -------------------------------------------------------------------

// DungeonKillAllChallengeAck

// bool ok = 1;
inline void DungeonKillAllChallengeAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool DungeonKillAllChallengeAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool DungeonKillAllChallengeAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.DungeonKillAllChallengeAck.ok)
  return _internal_ok();
}
inline void DungeonKillAllChallengeAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void DungeonKillAllChallengeAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.DungeonKillAllChallengeAck.ok)
}

// -------------------------------------------------------------------

// DungeonKillAllQuickEndReq

// bool is_exit = 1;
inline void DungeonKillAllQuickEndReq::clear_is_exit() {
  _impl_.is_exit_ = false;
}
inline bool DungeonKillAllQuickEndReq::_internal_is_exit() const {
  return _impl_.is_exit_;
}
inline bool DungeonKillAllQuickEndReq::is_exit() const {
  // @@protoc_insertion_point(field_get:idlepb.DungeonKillAllQuickEndReq.is_exit)
  return _internal_is_exit();
}
inline void DungeonKillAllQuickEndReq::_internal_set_is_exit(bool value) {
  
  _impl_.is_exit_ = value;
}
inline void DungeonKillAllQuickEndReq::set_is_exit(bool value) {
  _internal_set_is_exit(value);
  // @@protoc_insertion_point(field_set:idlepb.DungeonKillAllQuickEndReq.is_exit)
}

// -------------------------------------------------------------------

// DungeonKillAllQuickEndAck

// bool ok = 1;
inline void DungeonKillAllQuickEndAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool DungeonKillAllQuickEndAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool DungeonKillAllQuickEndAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.DungeonKillAllQuickEndAck.ok)
  return _internal_ok();
}
inline void DungeonKillAllQuickEndAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void DungeonKillAllQuickEndAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.DungeonKillAllQuickEndAck.ok)
}

// -------------------------------------------------------------------

// NotifyDungeonKillAllChallengeOver

// int32 uid = 1;
inline void NotifyDungeonKillAllChallengeOver::clear_uid() {
  _impl_.uid_ = 0;
}
inline int32_t NotifyDungeonKillAllChallengeOver::_internal_uid() const {
  return _impl_.uid_;
}
inline int32_t NotifyDungeonKillAllChallengeOver::uid() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyDungeonKillAllChallengeOver.uid)
  return _internal_uid();
}
inline void NotifyDungeonKillAllChallengeOver::_internal_set_uid(int32_t value) {
  
  _impl_.uid_ = value;
}
inline void NotifyDungeonKillAllChallengeOver::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyDungeonKillAllChallengeOver.uid)
}

// bool win = 2;
inline void NotifyDungeonKillAllChallengeOver::clear_win() {
  _impl_.win_ = false;
}
inline bool NotifyDungeonKillAllChallengeOver::_internal_win() const {
  return _impl_.win_;
}
inline bool NotifyDungeonKillAllChallengeOver::win() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyDungeonKillAllChallengeOver.win)
  return _internal_win();
}
inline void NotifyDungeonKillAllChallengeOver::_internal_set_win(bool value) {
  
  _impl_.win_ = value;
}
inline void NotifyDungeonKillAllChallengeOver::set_win(bool value) {
  _internal_set_win(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyDungeonKillAllChallengeOver.win)
}

// -------------------------------------------------------------------

// NotifyDungeonKillAllChallengeCurWaveNum

// int32 uid = 1;
inline void NotifyDungeonKillAllChallengeCurWaveNum::clear_uid() {
  _impl_.uid_ = 0;
}
inline int32_t NotifyDungeonKillAllChallengeCurWaveNum::_internal_uid() const {
  return _impl_.uid_;
}
inline int32_t NotifyDungeonKillAllChallengeCurWaveNum::uid() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyDungeonKillAllChallengeCurWaveNum.uid)
  return _internal_uid();
}
inline void NotifyDungeonKillAllChallengeCurWaveNum::_internal_set_uid(int32_t value) {
  
  _impl_.uid_ = value;
}
inline void NotifyDungeonKillAllChallengeCurWaveNum::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyDungeonKillAllChallengeCurWaveNum.uid)
}

// int32 curnum = 2;
inline void NotifyDungeonKillAllChallengeCurWaveNum::clear_curnum() {
  _impl_.curnum_ = 0;
}
inline int32_t NotifyDungeonKillAllChallengeCurWaveNum::_internal_curnum() const {
  return _impl_.curnum_;
}
inline int32_t NotifyDungeonKillAllChallengeCurWaveNum::curnum() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyDungeonKillAllChallengeCurWaveNum.curnum)
  return _internal_curnum();
}
inline void NotifyDungeonKillAllChallengeCurWaveNum::_internal_set_curnum(int32_t value) {
  
  _impl_.curnum_ = value;
}
inline void NotifyDungeonKillAllChallengeCurWaveNum::set_curnum(int32_t value) {
  _internal_set_curnum(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyDungeonKillAllChallengeCurWaveNum.curnum)
}

// int32 maxnum = 3;
inline void NotifyDungeonKillAllChallengeCurWaveNum::clear_maxnum() {
  _impl_.maxnum_ = 0;
}
inline int32_t NotifyDungeonKillAllChallengeCurWaveNum::_internal_maxnum() const {
  return _impl_.maxnum_;
}
inline int32_t NotifyDungeonKillAllChallengeCurWaveNum::maxnum() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyDungeonKillAllChallengeCurWaveNum.maxnum)
  return _internal_maxnum();
}
inline void NotifyDungeonKillAllChallengeCurWaveNum::_internal_set_maxnum(int32_t value) {
  
  _impl_.maxnum_ = value;
}
inline void NotifyDungeonKillAllChallengeCurWaveNum::set_maxnum(int32_t value) {
  _internal_set_maxnum(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyDungeonKillAllChallengeCurWaveNum.maxnum)
}

// -------------------------------------------------------------------

// DungeonKillAllDataReq

// int32 ask_uid = 1;
inline void DungeonKillAllDataReq::clear_ask_uid() {
  _impl_.ask_uid_ = 0;
}
inline int32_t DungeonKillAllDataReq::_internal_ask_uid() const {
  return _impl_.ask_uid_;
}
inline int32_t DungeonKillAllDataReq::ask_uid() const {
  // @@protoc_insertion_point(field_get:idlepb.DungeonKillAllDataReq.ask_uid)
  return _internal_ask_uid();
}
inline void DungeonKillAllDataReq::_internal_set_ask_uid(int32_t value) {
  
  _impl_.ask_uid_ = value;
}
inline void DungeonKillAllDataReq::set_ask_uid(int32_t value) {
  _internal_set_ask_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.DungeonKillAllDataReq.ask_uid)
}

// -------------------------------------------------------------------

// DungeonKillAllDataAck

// bool ok = 1;
inline void DungeonKillAllDataAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool DungeonKillAllDataAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool DungeonKillAllDataAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.DungeonKillAllDataAck.ok)
  return _internal_ok();
}
inline void DungeonKillAllDataAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void DungeonKillAllDataAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.DungeonKillAllDataAck.ok)
}

// -------------------------------------------------------------------

// DungeonSurviveChallengeReq

// int32 dungeon_uid = 1;
inline void DungeonSurviveChallengeReq::clear_dungeon_uid() {
  _impl_.dungeon_uid_ = 0;
}
inline int32_t DungeonSurviveChallengeReq::_internal_dungeon_uid() const {
  return _impl_.dungeon_uid_;
}
inline int32_t DungeonSurviveChallengeReq::dungeon_uid() const {
  // @@protoc_insertion_point(field_get:idlepb.DungeonSurviveChallengeReq.dungeon_uid)
  return _internal_dungeon_uid();
}
inline void DungeonSurviveChallengeReq::_internal_set_dungeon_uid(int32_t value) {
  
  _impl_.dungeon_uid_ = value;
}
inline void DungeonSurviveChallengeReq::set_dungeon_uid(int32_t value) {
  _internal_set_dungeon_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.DungeonSurviveChallengeReq.dungeon_uid)
}

// -------------------------------------------------------------------

// DungeonSurviveChallengeAck

// bool ok = 1;
inline void DungeonSurviveChallengeAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool DungeonSurviveChallengeAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool DungeonSurviveChallengeAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.DungeonSurviveChallengeAck.ok)
  return _internal_ok();
}
inline void DungeonSurviveChallengeAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void DungeonSurviveChallengeAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.DungeonSurviveChallengeAck.ok)
}

// -------------------------------------------------------------------

// DungeonSurviveQuickEndReq

// bool is_exit = 1;
inline void DungeonSurviveQuickEndReq::clear_is_exit() {
  _impl_.is_exit_ = false;
}
inline bool DungeonSurviveQuickEndReq::_internal_is_exit() const {
  return _impl_.is_exit_;
}
inline bool DungeonSurviveQuickEndReq::is_exit() const {
  // @@protoc_insertion_point(field_get:idlepb.DungeonSurviveQuickEndReq.is_exit)
  return _internal_is_exit();
}
inline void DungeonSurviveQuickEndReq::_internal_set_is_exit(bool value) {
  
  _impl_.is_exit_ = value;
}
inline void DungeonSurviveQuickEndReq::set_is_exit(bool value) {
  _internal_set_is_exit(value);
  // @@protoc_insertion_point(field_set:idlepb.DungeonSurviveQuickEndReq.is_exit)
}

// -------------------------------------------------------------------

// DungeonSurviveQuickEndAck

// bool ok = 1;
inline void DungeonSurviveQuickEndAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool DungeonSurviveQuickEndAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool DungeonSurviveQuickEndAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.DungeonSurviveQuickEndAck.ok)
  return _internal_ok();
}
inline void DungeonSurviveQuickEndAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void DungeonSurviveQuickEndAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.DungeonSurviveQuickEndAck.ok)
}

// -------------------------------------------------------------------

// NotifyDungeonSurviveChallengeOver

// int32 uid = 1;
inline void NotifyDungeonSurviveChallengeOver::clear_uid() {
  _impl_.uid_ = 0;
}
inline int32_t NotifyDungeonSurviveChallengeOver::_internal_uid() const {
  return _impl_.uid_;
}
inline int32_t NotifyDungeonSurviveChallengeOver::uid() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyDungeonSurviveChallengeOver.uid)
  return _internal_uid();
}
inline void NotifyDungeonSurviveChallengeOver::_internal_set_uid(int32_t value) {
  
  _impl_.uid_ = value;
}
inline void NotifyDungeonSurviveChallengeOver::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyDungeonSurviveChallengeOver.uid)
}

// bool win = 2;
inline void NotifyDungeonSurviveChallengeOver::clear_win() {
  _impl_.win_ = false;
}
inline bool NotifyDungeonSurviveChallengeOver::_internal_win() const {
  return _impl_.win_;
}
inline bool NotifyDungeonSurviveChallengeOver::win() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyDungeonSurviveChallengeOver.win)
  return _internal_win();
}
inline void NotifyDungeonSurviveChallengeOver::_internal_set_win(bool value) {
  
  _impl_.win_ = value;
}
inline void NotifyDungeonSurviveChallengeOver::set_win(bool value) {
  _internal_set_win(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyDungeonSurviveChallengeOver.win)
}

// -------------------------------------------------------------------

// NotifyDungeonSurviveChallengeCurWaveNum

// int32 uid = 1;
inline void NotifyDungeonSurviveChallengeCurWaveNum::clear_uid() {
  _impl_.uid_ = 0;
}
inline int32_t NotifyDungeonSurviveChallengeCurWaveNum::_internal_uid() const {
  return _impl_.uid_;
}
inline int32_t NotifyDungeonSurviveChallengeCurWaveNum::uid() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyDungeonSurviveChallengeCurWaveNum.uid)
  return _internal_uid();
}
inline void NotifyDungeonSurviveChallengeCurWaveNum::_internal_set_uid(int32_t value) {
  
  _impl_.uid_ = value;
}
inline void NotifyDungeonSurviveChallengeCurWaveNum::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyDungeonSurviveChallengeCurWaveNum.uid)
}

// int32 curnum = 2;
inline void NotifyDungeonSurviveChallengeCurWaveNum::clear_curnum() {
  _impl_.curnum_ = 0;
}
inline int32_t NotifyDungeonSurviveChallengeCurWaveNum::_internal_curnum() const {
  return _impl_.curnum_;
}
inline int32_t NotifyDungeonSurviveChallengeCurWaveNum::curnum() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyDungeonSurviveChallengeCurWaveNum.curnum)
  return _internal_curnum();
}
inline void NotifyDungeonSurviveChallengeCurWaveNum::_internal_set_curnum(int32_t value) {
  
  _impl_.curnum_ = value;
}
inline void NotifyDungeonSurviveChallengeCurWaveNum::set_curnum(int32_t value) {
  _internal_set_curnum(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyDungeonSurviveChallengeCurWaveNum.curnum)
}

// int32 maxnum = 3;
inline void NotifyDungeonSurviveChallengeCurWaveNum::clear_maxnum() {
  _impl_.maxnum_ = 0;
}
inline int32_t NotifyDungeonSurviveChallengeCurWaveNum::_internal_maxnum() const {
  return _impl_.maxnum_;
}
inline int32_t NotifyDungeonSurviveChallengeCurWaveNum::maxnum() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyDungeonSurviveChallengeCurWaveNum.maxnum)
  return _internal_maxnum();
}
inline void NotifyDungeonSurviveChallengeCurWaveNum::_internal_set_maxnum(int32_t value) {
  
  _impl_.maxnum_ = value;
}
inline void NotifyDungeonSurviveChallengeCurWaveNum::set_maxnum(int32_t value) {
  _internal_set_maxnum(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyDungeonSurviveChallengeCurWaveNum.maxnum)
}

// -------------------------------------------------------------------

// DungeonSurviveDataReq

// int32 ask_uid = 1;
inline void DungeonSurviveDataReq::clear_ask_uid() {
  _impl_.ask_uid_ = 0;
}
inline int32_t DungeonSurviveDataReq::_internal_ask_uid() const {
  return _impl_.ask_uid_;
}
inline int32_t DungeonSurviveDataReq::ask_uid() const {
  // @@protoc_insertion_point(field_get:idlepb.DungeonSurviveDataReq.ask_uid)
  return _internal_ask_uid();
}
inline void DungeonSurviveDataReq::_internal_set_ask_uid(int32_t value) {
  
  _impl_.ask_uid_ = value;
}
inline void DungeonSurviveDataReq::set_ask_uid(int32_t value) {
  _internal_set_ask_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.DungeonSurviveDataReq.ask_uid)
}

// -------------------------------------------------------------------

// DungeonSurviveDataAck

// bool ok = 1;
inline void DungeonSurviveDataAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool DungeonSurviveDataAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool DungeonSurviveDataAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.DungeonSurviveDataAck.ok)
  return _internal_ok();
}
inline void DungeonSurviveDataAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void DungeonSurviveDataAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.DungeonSurviveDataAck.ok)
}

// -------------------------------------------------------------------

// RequestEnterSeptDemonWorldReq

// int64 sept_id = 1;
inline void RequestEnterSeptDemonWorldReq::clear_sept_id() {
  _impl_.sept_id_ = int64_t{0};
}
inline int64_t RequestEnterSeptDemonWorldReq::_internal_sept_id() const {
  return _impl_.sept_id_;
}
inline int64_t RequestEnterSeptDemonWorldReq::sept_id() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestEnterSeptDemonWorldReq.sept_id)
  return _internal_sept_id();
}
inline void RequestEnterSeptDemonWorldReq::_internal_set_sept_id(int64_t value) {
  
  _impl_.sept_id_ = value;
}
inline void RequestEnterSeptDemonWorldReq::set_sept_id(int64_t value) {
  _internal_set_sept_id(value);
  // @@protoc_insertion_point(field_set:idlepb.RequestEnterSeptDemonWorldReq.sept_id)
}

// -------------------------------------------------------------------

// RequestEnterSeptDemonWorldAck

// bool ok = 1;
inline void RequestEnterSeptDemonWorldAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool RequestEnterSeptDemonWorldAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool RequestEnterSeptDemonWorldAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestEnterSeptDemonWorldAck.ok)
  return _internal_ok();
}
inline void RequestEnterSeptDemonWorldAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void RequestEnterSeptDemonWorldAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.RequestEnterSeptDemonWorldAck.ok)
}

// -------------------------------------------------------------------

// RequestLeaveSeptDemonWorldReq

// int64 sept_id = 1;
inline void RequestLeaveSeptDemonWorldReq::clear_sept_id() {
  _impl_.sept_id_ = int64_t{0};
}
inline int64_t RequestLeaveSeptDemonWorldReq::_internal_sept_id() const {
  return _impl_.sept_id_;
}
inline int64_t RequestLeaveSeptDemonWorldReq::sept_id() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestLeaveSeptDemonWorldReq.sept_id)
  return _internal_sept_id();
}
inline void RequestLeaveSeptDemonWorldReq::_internal_set_sept_id(int64_t value) {
  
  _impl_.sept_id_ = value;
}
inline void RequestLeaveSeptDemonWorldReq::set_sept_id(int64_t value) {
  _internal_set_sept_id(value);
  // @@protoc_insertion_point(field_set:idlepb.RequestLeaveSeptDemonWorldReq.sept_id)
}

// -------------------------------------------------------------------

// RequestLeaveSeptDemonWorldAck

// bool ok = 1;
inline void RequestLeaveSeptDemonWorldAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool RequestLeaveSeptDemonWorldAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool RequestLeaveSeptDemonWorldAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestLeaveSeptDemonWorldAck.ok)
  return _internal_ok();
}
inline void RequestLeaveSeptDemonWorldAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void RequestLeaveSeptDemonWorldAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.RequestLeaveSeptDemonWorldAck.ok)
}

// -------------------------------------------------------------------

// RequestSeptDemonWorldDataReq

// int64 sept_id = 1;
inline void RequestSeptDemonWorldDataReq::clear_sept_id() {
  _impl_.sept_id_ = int64_t{0};
}
inline int64_t RequestSeptDemonWorldDataReq::_internal_sept_id() const {
  return _impl_.sept_id_;
}
inline int64_t RequestSeptDemonWorldDataReq::sept_id() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestSeptDemonWorldDataReq.sept_id)
  return _internal_sept_id();
}
inline void RequestSeptDemonWorldDataReq::_internal_set_sept_id(int64_t value) {
  
  _impl_.sept_id_ = value;
}
inline void RequestSeptDemonWorldDataReq::set_sept_id(int64_t value) {
  _internal_set_sept_id(value);
  // @@protoc_insertion_point(field_set:idlepb.RequestSeptDemonWorldDataReq.sept_id)
}

// -------------------------------------------------------------------

// RequestSeptDemonWorldDataAck

// .idlepb.SeptDemonWorldData data = 1;
inline bool RequestSeptDemonWorldDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool RequestSeptDemonWorldDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::SeptDemonWorldData& RequestSeptDemonWorldDataAck::_internal_data() const {
  const ::idlepb::SeptDemonWorldData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::SeptDemonWorldData&>(
      ::idlepb::_SeptDemonWorldData_default_instance_);
}
inline const ::idlepb::SeptDemonWorldData& RequestSeptDemonWorldDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestSeptDemonWorldDataAck.data)
  return _internal_data();
}
inline void RequestSeptDemonWorldDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::SeptDemonWorldData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.RequestSeptDemonWorldDataAck.data)
}
inline ::idlepb::SeptDemonWorldData* RequestSeptDemonWorldDataAck::release_data() {
  
  ::idlepb::SeptDemonWorldData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::SeptDemonWorldData* RequestSeptDemonWorldDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.RequestSeptDemonWorldDataAck.data)
  
  ::idlepb::SeptDemonWorldData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::SeptDemonWorldData* RequestSeptDemonWorldDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::SeptDemonWorldData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::SeptDemonWorldData* RequestSeptDemonWorldDataAck::mutable_data() {
  ::idlepb::SeptDemonWorldData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.RequestSeptDemonWorldDataAck.data)
  return _msg;
}
inline void RequestSeptDemonWorldDataAck::set_allocated_data(::idlepb::SeptDemonWorldData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.RequestSeptDemonWorldDataAck.data)
}

// -------------------------------------------------------------------

// RequestInSeptDemonWorldEndTimeReq

// -------------------------------------------------------------------

// RequestInSeptDemonWorldEndTimeAck

// int64 end_time = 1;
inline void RequestInSeptDemonWorldEndTimeAck::clear_end_time() {
  _impl_.end_time_ = int64_t{0};
}
inline int64_t RequestInSeptDemonWorldEndTimeAck::_internal_end_time() const {
  return _impl_.end_time_;
}
inline int64_t RequestInSeptDemonWorldEndTimeAck::end_time() const {
  // @@protoc_insertion_point(field_get:idlepb.RequestInSeptDemonWorldEndTimeAck.end_time)
  return _internal_end_time();
}
inline void RequestInSeptDemonWorldEndTimeAck::_internal_set_end_time(int64_t value) {
  
  _impl_.end_time_ = value;
}
inline void RequestInSeptDemonWorldEndTimeAck::set_end_time(int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:idlepb.RequestInSeptDemonWorldEndTimeAck.end_time)
}

// -------------------------------------------------------------------

// GetFarmlandDataReq

// -------------------------------------------------------------------

// GetFarmlandDataAck

// .idlepb.RoleFarmlandData data = 1;
inline bool GetFarmlandDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetFarmlandDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleFarmlandData& GetFarmlandDataAck::_internal_data() const {
  const ::idlepb::RoleFarmlandData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleFarmlandData&>(
      ::idlepb::_RoleFarmlandData_default_instance_);
}
inline const ::idlepb::RoleFarmlandData& GetFarmlandDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetFarmlandDataAck.data)
  return _internal_data();
}
inline void GetFarmlandDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleFarmlandData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetFarmlandDataAck.data)
}
inline ::idlepb::RoleFarmlandData* GetFarmlandDataAck::release_data() {
  
  ::idlepb::RoleFarmlandData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleFarmlandData* GetFarmlandDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetFarmlandDataAck.data)
  
  ::idlepb::RoleFarmlandData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleFarmlandData* GetFarmlandDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleFarmlandData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleFarmlandData* GetFarmlandDataAck::mutable_data() {
  ::idlepb::RoleFarmlandData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetFarmlandDataAck.data)
  return _msg;
}
inline void GetFarmlandDataAck::set_allocated_data(::idlepb::RoleFarmlandData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetFarmlandDataAck.data)
}

// -------------------------------------------------------------------

// FarmlandUnlockBlockReq

// int32 x = 1;
inline void FarmlandUnlockBlockReq::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t FarmlandUnlockBlockReq::_internal_x() const {
  return _impl_.x_;
}
inline int32_t FarmlandUnlockBlockReq::x() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandUnlockBlockReq.x)
  return _internal_x();
}
inline void FarmlandUnlockBlockReq::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void FarmlandUnlockBlockReq::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandUnlockBlockReq.x)
}

// int32 y = 2;
inline void FarmlandUnlockBlockReq::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t FarmlandUnlockBlockReq::_internal_y() const {
  return _impl_.y_;
}
inline int32_t FarmlandUnlockBlockReq::y() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandUnlockBlockReq.y)
  return _internal_y();
}
inline void FarmlandUnlockBlockReq::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void FarmlandUnlockBlockReq::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandUnlockBlockReq.y)
}

// -------------------------------------------------------------------

// FarmlandUnlockBlockAck

// bool ok = 1;
inline void FarmlandUnlockBlockAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool FarmlandUnlockBlockAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool FarmlandUnlockBlockAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandUnlockBlockAck.ok)
  return _internal_ok();
}
inline void FarmlandUnlockBlockAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void FarmlandUnlockBlockAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandUnlockBlockAck.ok)
}

// -------------------------------------------------------------------

// FarmlandPlantSeedReq

// int32 item_id = 1;
inline void FarmlandPlantSeedReq::clear_item_id() {
  _impl_.item_id_ = 0;
}
inline int32_t FarmlandPlantSeedReq::_internal_item_id() const {
  return _impl_.item_id_;
}
inline int32_t FarmlandPlantSeedReq::item_id() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandPlantSeedReq.item_id)
  return _internal_item_id();
}
inline void FarmlandPlantSeedReq::_internal_set_item_id(int32_t value) {
  
  _impl_.item_id_ = value;
}
inline void FarmlandPlantSeedReq::set_item_id(int32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandPlantSeedReq.item_id)
}

// int32 x = 2;
inline void FarmlandPlantSeedReq::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t FarmlandPlantSeedReq::_internal_x() const {
  return _impl_.x_;
}
inline int32_t FarmlandPlantSeedReq::x() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandPlantSeedReq.x)
  return _internal_x();
}
inline void FarmlandPlantSeedReq::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void FarmlandPlantSeedReq::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandPlantSeedReq.x)
}

// int32 y = 3;
inline void FarmlandPlantSeedReq::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t FarmlandPlantSeedReq::_internal_y() const {
  return _impl_.y_;
}
inline int32_t FarmlandPlantSeedReq::y() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandPlantSeedReq.y)
  return _internal_y();
}
inline void FarmlandPlantSeedReq::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void FarmlandPlantSeedReq::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandPlantSeedReq.y)
}

// int32 rotation = 4;
inline void FarmlandPlantSeedReq::clear_rotation() {
  _impl_.rotation_ = 0;
}
inline int32_t FarmlandPlantSeedReq::_internal_rotation() const {
  return _impl_.rotation_;
}
inline int32_t FarmlandPlantSeedReq::rotation() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandPlantSeedReq.rotation)
  return _internal_rotation();
}
inline void FarmlandPlantSeedReq::_internal_set_rotation(int32_t value) {
  
  _impl_.rotation_ = value;
}
inline void FarmlandPlantSeedReq::set_rotation(int32_t value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandPlantSeedReq.rotation)
}

// bool is_delete = 5;
inline void FarmlandPlantSeedReq::clear_is_delete() {
  _impl_.is_delete_ = false;
}
inline bool FarmlandPlantSeedReq::_internal_is_delete() const {
  return _impl_.is_delete_;
}
inline bool FarmlandPlantSeedReq::is_delete() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandPlantSeedReq.is_delete)
  return _internal_is_delete();
}
inline void FarmlandPlantSeedReq::_internal_set_is_delete(bool value) {
  
  _impl_.is_delete_ = value;
}
inline void FarmlandPlantSeedReq::set_is_delete(bool value) {
  _internal_set_is_delete(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandPlantSeedReq.is_delete)
}

// -------------------------------------------------------------------

// FarmlandPlantSeedAck

// .idlepb.FarmlandPlantData plant_data = 2;
inline bool FarmlandPlantSeedAck::_internal_has_plant_data() const {
  return this != internal_default_instance() && _impl_.plant_data_ != nullptr;
}
inline bool FarmlandPlantSeedAck::has_plant_data() const {
  return _internal_has_plant_data();
}
inline const ::idlepb::FarmlandPlantData& FarmlandPlantSeedAck::_internal_plant_data() const {
  const ::idlepb::FarmlandPlantData* p = _impl_.plant_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::FarmlandPlantData&>(
      ::idlepb::_FarmlandPlantData_default_instance_);
}
inline const ::idlepb::FarmlandPlantData& FarmlandPlantSeedAck::plant_data() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandPlantSeedAck.plant_data)
  return _internal_plant_data();
}
inline void FarmlandPlantSeedAck::unsafe_arena_set_allocated_plant_data(
    ::idlepb::FarmlandPlantData* plant_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.plant_data_);
  }
  _impl_.plant_data_ = plant_data;
  if (plant_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.FarmlandPlantSeedAck.plant_data)
}
inline ::idlepb::FarmlandPlantData* FarmlandPlantSeedAck::release_plant_data() {
  
  ::idlepb::FarmlandPlantData* temp = _impl_.plant_data_;
  _impl_.plant_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::FarmlandPlantData* FarmlandPlantSeedAck::unsafe_arena_release_plant_data() {
  // @@protoc_insertion_point(field_release:idlepb.FarmlandPlantSeedAck.plant_data)
  
  ::idlepb::FarmlandPlantData* temp = _impl_.plant_data_;
  _impl_.plant_data_ = nullptr;
  return temp;
}
inline ::idlepb::FarmlandPlantData* FarmlandPlantSeedAck::_internal_mutable_plant_data() {
  
  if (_impl_.plant_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::FarmlandPlantData>(GetArenaForAllocation());
    _impl_.plant_data_ = p;
  }
  return _impl_.plant_data_;
}
inline ::idlepb::FarmlandPlantData* FarmlandPlantSeedAck::mutable_plant_data() {
  ::idlepb::FarmlandPlantData* _msg = _internal_mutable_plant_data();
  // @@protoc_insertion_point(field_mutable:idlepb.FarmlandPlantSeedAck.plant_data)
  return _msg;
}
inline void FarmlandPlantSeedAck::set_allocated_plant_data(::idlepb::FarmlandPlantData* plant_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.plant_data_);
  }
  if (plant_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plant_data));
    if (message_arena != submessage_arena) {
      plant_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plant_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.plant_data_ = plant_data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.FarmlandPlantSeedAck.plant_data)
}

// -------------------------------------------------------------------

// FarmlandWateringReq

// int32 num = 1;
inline void FarmlandWateringReq::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t FarmlandWateringReq::_internal_num() const {
  return _impl_.num_;
}
inline int32_t FarmlandWateringReq::num() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandWateringReq.num)
  return _internal_num();
}
inline void FarmlandWateringReq::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void FarmlandWateringReq::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandWateringReq.num)
}

// -------------------------------------------------------------------

// FarmlandWateringAck

// int32 totaol_speed_up = 1;
inline void FarmlandWateringAck::clear_totaol_speed_up() {
  _impl_.totaol_speed_up_ = 0;
}
inline int32_t FarmlandWateringAck::_internal_totaol_speed_up() const {
  return _impl_.totaol_speed_up_;
}
inline int32_t FarmlandWateringAck::totaol_speed_up() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandWateringAck.totaol_speed_up)
  return _internal_totaol_speed_up();
}
inline void FarmlandWateringAck::_internal_set_totaol_speed_up(int32_t value) {
  
  _impl_.totaol_speed_up_ = value;
}
inline void FarmlandWateringAck::set_totaol_speed_up(int32_t value) {
  _internal_set_totaol_speed_up(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandWateringAck.totaol_speed_up)
}

// -------------------------------------------------------------------

// FarmlandRipeningReq

// int32 plant_uid = 1;
inline void FarmlandRipeningReq::clear_plant_uid() {
  _impl_.plant_uid_ = 0;
}
inline int32_t FarmlandRipeningReq::_internal_plant_uid() const {
  return _impl_.plant_uid_;
}
inline int32_t FarmlandRipeningReq::plant_uid() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandRipeningReq.plant_uid)
  return _internal_plant_uid();
}
inline void FarmlandRipeningReq::_internal_set_plant_uid(int32_t value) {
  
  _impl_.plant_uid_ = value;
}
inline void FarmlandRipeningReq::set_plant_uid(int32_t value) {
  _internal_set_plant_uid(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandRipeningReq.plant_uid)
}

// int32 item_id = 2;
inline void FarmlandRipeningReq::clear_item_id() {
  _impl_.item_id_ = 0;
}
inline int32_t FarmlandRipeningReq::_internal_item_id() const {
  return _impl_.item_id_;
}
inline int32_t FarmlandRipeningReq::item_id() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandRipeningReq.item_id)
  return _internal_item_id();
}
inline void FarmlandRipeningReq::_internal_set_item_id(int32_t value) {
  
  _impl_.item_id_ = value;
}
inline void FarmlandRipeningReq::set_item_id(int32_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandRipeningReq.item_id)
}

// int32 num = 3;
inline void FarmlandRipeningReq::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t FarmlandRipeningReq::_internal_num() const {
  return _impl_.num_;
}
inline int32_t FarmlandRipeningReq::num() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandRipeningReq.num)
  return _internal_num();
}
inline void FarmlandRipeningReq::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void FarmlandRipeningReq::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandRipeningReq.num)
}

// int32 one_click = 4;
inline void FarmlandRipeningReq::clear_one_click() {
  _impl_.one_click_ = 0;
}
inline int32_t FarmlandRipeningReq::_internal_one_click() const {
  return _impl_.one_click_;
}
inline int32_t FarmlandRipeningReq::one_click() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandRipeningReq.one_click)
  return _internal_one_click();
}
inline void FarmlandRipeningReq::_internal_set_one_click(int32_t value) {
  
  _impl_.one_click_ = value;
}
inline void FarmlandRipeningReq::set_one_click(int32_t value) {
  _internal_set_one_click(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandRipeningReq.one_click)
}

// repeated .idlepb.FarmlandManagementInfo one_click_plants = 5;
inline int FarmlandRipeningReq::_internal_one_click_plants_size() const {
  return _impl_.one_click_plants_.size();
}
inline int FarmlandRipeningReq::one_click_plants_size() const {
  return _internal_one_click_plants_size();
}
inline ::idlepb::FarmlandManagementInfo* FarmlandRipeningReq::mutable_one_click_plants(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.FarmlandRipeningReq.one_click_plants)
  return _impl_.one_click_plants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandManagementInfo >*
FarmlandRipeningReq::mutable_one_click_plants() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.FarmlandRipeningReq.one_click_plants)
  return &_impl_.one_click_plants_;
}
inline const ::idlepb::FarmlandManagementInfo& FarmlandRipeningReq::_internal_one_click_plants(int index) const {
  return _impl_.one_click_plants_.Get(index);
}
inline const ::idlepb::FarmlandManagementInfo& FarmlandRipeningReq::one_click_plants(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandRipeningReq.one_click_plants)
  return _internal_one_click_plants(index);
}
inline ::idlepb::FarmlandManagementInfo* FarmlandRipeningReq::_internal_add_one_click_plants() {
  return _impl_.one_click_plants_.Add();
}
inline ::idlepb::FarmlandManagementInfo* FarmlandRipeningReq::add_one_click_plants() {
  ::idlepb::FarmlandManagementInfo* _add = _internal_add_one_click_plants();
  // @@protoc_insertion_point(field_add:idlepb.FarmlandRipeningReq.one_click_plants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandManagementInfo >&
FarmlandRipeningReq::one_click_plants() const {
  // @@protoc_insertion_point(field_list:idlepb.FarmlandRipeningReq.one_click_plants)
  return _impl_.one_click_plants_;
}

// -------------------------------------------------------------------

// FarmlandRipeningAck

// bool ok = 1;
inline void FarmlandRipeningAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool FarmlandRipeningAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool FarmlandRipeningAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandRipeningAck.ok)
  return _internal_ok();
}
inline void FarmlandRipeningAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void FarmlandRipeningAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandRipeningAck.ok)
}

// repeated .idlepb.FarmlandPlantData result = 2;
inline int FarmlandRipeningAck::_internal_result_size() const {
  return _impl_.result_.size();
}
inline int FarmlandRipeningAck::result_size() const {
  return _internal_result_size();
}
inline ::idlepb::FarmlandPlantData* FarmlandRipeningAck::mutable_result(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.FarmlandRipeningAck.result)
  return _impl_.result_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData >*
FarmlandRipeningAck::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.FarmlandRipeningAck.result)
  return &_impl_.result_;
}
inline const ::idlepb::FarmlandPlantData& FarmlandRipeningAck::_internal_result(int index) const {
  return _impl_.result_.Get(index);
}
inline const ::idlepb::FarmlandPlantData& FarmlandRipeningAck::result(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandRipeningAck.result)
  return _internal_result(index);
}
inline ::idlepb::FarmlandPlantData* FarmlandRipeningAck::_internal_add_result() {
  return _impl_.result_.Add();
}
inline ::idlepb::FarmlandPlantData* FarmlandRipeningAck::add_result() {
  ::idlepb::FarmlandPlantData* _add = _internal_add_result();
  // @@protoc_insertion_point(field_add:idlepb.FarmlandRipeningAck.result)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData >&
FarmlandRipeningAck::result() const {
  // @@protoc_insertion_point(field_list:idlepb.FarmlandRipeningAck.result)
  return _impl_.result_;
}

// repeated .idlepb.SimpleItemData used_ripe_items = 3;
inline int FarmlandRipeningAck::_internal_used_ripe_items_size() const {
  return _impl_.used_ripe_items_.size();
}
inline int FarmlandRipeningAck::used_ripe_items_size() const {
  return _internal_used_ripe_items_size();
}
inline ::idlepb::SimpleItemData* FarmlandRipeningAck::mutable_used_ripe_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.FarmlandRipeningAck.used_ripe_items)
  return _impl_.used_ripe_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
FarmlandRipeningAck::mutable_used_ripe_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.FarmlandRipeningAck.used_ripe_items)
  return &_impl_.used_ripe_items_;
}
inline const ::idlepb::SimpleItemData& FarmlandRipeningAck::_internal_used_ripe_items(int index) const {
  return _impl_.used_ripe_items_.Get(index);
}
inline const ::idlepb::SimpleItemData& FarmlandRipeningAck::used_ripe_items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandRipeningAck.used_ripe_items)
  return _internal_used_ripe_items(index);
}
inline ::idlepb::SimpleItemData* FarmlandRipeningAck::_internal_add_used_ripe_items() {
  return _impl_.used_ripe_items_.Add();
}
inline ::idlepb::SimpleItemData* FarmlandRipeningAck::add_used_ripe_items() {
  ::idlepb::SimpleItemData* _add = _internal_add_used_ripe_items();
  // @@protoc_insertion_point(field_add:idlepb.FarmlandRipeningAck.used_ripe_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
FarmlandRipeningAck::used_ripe_items() const {
  // @@protoc_insertion_point(field_list:idlepb.FarmlandRipeningAck.used_ripe_items)
  return _impl_.used_ripe_items_;
}

// -------------------------------------------------------------------

// FarmlandHarvestReq

// repeated int32 plant_ids = 1;
inline int FarmlandHarvestReq::_internal_plant_ids_size() const {
  return _impl_.plant_ids_.size();
}
inline int FarmlandHarvestReq::plant_ids_size() const {
  return _internal_plant_ids_size();
}
inline void FarmlandHarvestReq::clear_plant_ids() {
  _impl_.plant_ids_.Clear();
}
inline int32_t FarmlandHarvestReq::_internal_plant_ids(int index) const {
  return _impl_.plant_ids_.Get(index);
}
inline int32_t FarmlandHarvestReq::plant_ids(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandHarvestReq.plant_ids)
  return _internal_plant_ids(index);
}
inline void FarmlandHarvestReq::set_plant_ids(int index, int32_t value) {
  _impl_.plant_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandHarvestReq.plant_ids)
}
inline void FarmlandHarvestReq::_internal_add_plant_ids(int32_t value) {
  _impl_.plant_ids_.Add(value);
}
inline void FarmlandHarvestReq::add_plant_ids(int32_t value) {
  _internal_add_plant_ids(value);
  // @@protoc_insertion_point(field_add:idlepb.FarmlandHarvestReq.plant_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
FarmlandHarvestReq::_internal_plant_ids() const {
  return _impl_.plant_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
FarmlandHarvestReq::plant_ids() const {
  // @@protoc_insertion_point(field_list:idlepb.FarmlandHarvestReq.plant_ids)
  return _internal_plant_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
FarmlandHarvestReq::_internal_mutable_plant_ids() {
  return &_impl_.plant_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
FarmlandHarvestReq::mutable_plant_ids() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.FarmlandHarvestReq.plant_ids)
  return _internal_mutable_plant_ids();
}

// bool auto_harvest_same_class = 2;
inline void FarmlandHarvestReq::clear_auto_harvest_same_class() {
  _impl_.auto_harvest_same_class_ = false;
}
inline bool FarmlandHarvestReq::_internal_auto_harvest_same_class() const {
  return _impl_.auto_harvest_same_class_;
}
inline bool FarmlandHarvestReq::auto_harvest_same_class() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandHarvestReq.auto_harvest_same_class)
  return _internal_auto_harvest_same_class();
}
inline void FarmlandHarvestReq::_internal_set_auto_harvest_same_class(bool value) {
  
  _impl_.auto_harvest_same_class_ = value;
}
inline void FarmlandHarvestReq::set_auto_harvest_same_class(bool value) {
  _internal_set_auto_harvest_same_class(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandHarvestReq.auto_harvest_same_class)
}

// -------------------------------------------------------------------

// FarmlandHarvestAck

// bool ok = 1;
inline void FarmlandHarvestAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool FarmlandHarvestAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool FarmlandHarvestAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandHarvestAck.ok)
  return _internal_ok();
}
inline void FarmlandHarvestAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void FarmlandHarvestAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandHarvestAck.ok)
}

// repeated .idlepb.SimpleItemData items = 2;
inline int FarmlandHarvestAck::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int FarmlandHarvestAck::items_size() const {
  return _internal_items_size();
}
inline ::idlepb::SimpleItemData* FarmlandHarvestAck::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.FarmlandHarvestAck.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
FarmlandHarvestAck::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.FarmlandHarvestAck.items)
  return &_impl_.items_;
}
inline const ::idlepb::SimpleItemData& FarmlandHarvestAck::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::SimpleItemData& FarmlandHarvestAck::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandHarvestAck.items)
  return _internal_items(index);
}
inline ::idlepb::SimpleItemData* FarmlandHarvestAck::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::SimpleItemData* FarmlandHarvestAck::add_items() {
  ::idlepb::SimpleItemData* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.FarmlandHarvestAck.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
FarmlandHarvestAck::items() const {
  // @@protoc_insertion_point(field_list:idlepb.FarmlandHarvestAck.items)
  return _impl_.items_;
}

// repeated int32 op_success_plant_id = 3;
inline int FarmlandHarvestAck::_internal_op_success_plant_id_size() const {
  return _impl_.op_success_plant_id_.size();
}
inline int FarmlandHarvestAck::op_success_plant_id_size() const {
  return _internal_op_success_plant_id_size();
}
inline void FarmlandHarvestAck::clear_op_success_plant_id() {
  _impl_.op_success_plant_id_.Clear();
}
inline int32_t FarmlandHarvestAck::_internal_op_success_plant_id(int index) const {
  return _impl_.op_success_plant_id_.Get(index);
}
inline int32_t FarmlandHarvestAck::op_success_plant_id(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandHarvestAck.op_success_plant_id)
  return _internal_op_success_plant_id(index);
}
inline void FarmlandHarvestAck::set_op_success_plant_id(int index, int32_t value) {
  _impl_.op_success_plant_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandHarvestAck.op_success_plant_id)
}
inline void FarmlandHarvestAck::_internal_add_op_success_plant_id(int32_t value) {
  _impl_.op_success_plant_id_.Add(value);
}
inline void FarmlandHarvestAck::add_op_success_plant_id(int32_t value) {
  _internal_add_op_success_plant_id(value);
  // @@protoc_insertion_point(field_add:idlepb.FarmlandHarvestAck.op_success_plant_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
FarmlandHarvestAck::_internal_op_success_plant_id() const {
  return _impl_.op_success_plant_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
FarmlandHarvestAck::op_success_plant_id() const {
  // @@protoc_insertion_point(field_list:idlepb.FarmlandHarvestAck.op_success_plant_id)
  return _internal_op_success_plant_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
FarmlandHarvestAck::_internal_mutable_op_success_plant_id() {
  return &_impl_.op_success_plant_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
FarmlandHarvestAck::mutable_op_success_plant_id() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.FarmlandHarvestAck.op_success_plant_id)
  return _internal_mutable_op_success_plant_id();
}

// repeated .idlepb.FarmlandPlantData continue_seeds = 4;
inline int FarmlandHarvestAck::_internal_continue_seeds_size() const {
  return _impl_.continue_seeds_.size();
}
inline int FarmlandHarvestAck::continue_seeds_size() const {
  return _internal_continue_seeds_size();
}
inline ::idlepb::FarmlandPlantData* FarmlandHarvestAck::mutable_continue_seeds(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.FarmlandHarvestAck.continue_seeds)
  return _impl_.continue_seeds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData >*
FarmlandHarvestAck::mutable_continue_seeds() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.FarmlandHarvestAck.continue_seeds)
  return &_impl_.continue_seeds_;
}
inline const ::idlepb::FarmlandPlantData& FarmlandHarvestAck::_internal_continue_seeds(int index) const {
  return _impl_.continue_seeds_.Get(index);
}
inline const ::idlepb::FarmlandPlantData& FarmlandHarvestAck::continue_seeds(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandHarvestAck.continue_seeds)
  return _internal_continue_seeds(index);
}
inline ::idlepb::FarmlandPlantData* FarmlandHarvestAck::_internal_add_continue_seeds() {
  return _impl_.continue_seeds_.Add();
}
inline ::idlepb::FarmlandPlantData* FarmlandHarvestAck::add_continue_seeds() {
  ::idlepb::FarmlandPlantData* _add = _internal_add_continue_seeds();
  // @@protoc_insertion_point(field_add:idlepb.FarmlandHarvestAck.continue_seeds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData >&
FarmlandHarvestAck::continue_seeds() const {
  // @@protoc_insertion_point(field_list:idlepb.FarmlandHarvestAck.continue_seeds)
  return _impl_.continue_seeds_;
}

// -------------------------------------------------------------------

// FarmerRankUpReq

// -------------------------------------------------------------------

// FarmerRankUpAck

// bool ok = 1;
inline void FarmerRankUpAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool FarmerRankUpAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool FarmerRankUpAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmerRankUpAck.ok)
  return _internal_ok();
}
inline void FarmerRankUpAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void FarmerRankUpAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmerRankUpAck.ok)
}

// -------------------------------------------------------------------

// FarmlandSetManagementReq

// repeated .idlepb.FarmlandManagementInfo plans = 1;
inline int FarmlandSetManagementReq::_internal_plans_size() const {
  return _impl_.plans_.size();
}
inline int FarmlandSetManagementReq::plans_size() const {
  return _internal_plans_size();
}
inline ::idlepb::FarmlandManagementInfo* FarmlandSetManagementReq::mutable_plans(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.FarmlandSetManagementReq.plans)
  return _impl_.plans_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandManagementInfo >*
FarmlandSetManagementReq::mutable_plans() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.FarmlandSetManagementReq.plans)
  return &_impl_.plans_;
}
inline const ::idlepb::FarmlandManagementInfo& FarmlandSetManagementReq::_internal_plans(int index) const {
  return _impl_.plans_.Get(index);
}
inline const ::idlepb::FarmlandManagementInfo& FarmlandSetManagementReq::plans(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandSetManagementReq.plans)
  return _internal_plans(index);
}
inline ::idlepb::FarmlandManagementInfo* FarmlandSetManagementReq::_internal_add_plans() {
  return _impl_.plans_.Add();
}
inline ::idlepb::FarmlandManagementInfo* FarmlandSetManagementReq::add_plans() {
  ::idlepb::FarmlandManagementInfo* _add = _internal_add_plans();
  // @@protoc_insertion_point(field_add:idlepb.FarmlandSetManagementReq.plans)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandManagementInfo >&
FarmlandSetManagementReq::plans() const {
  // @@protoc_insertion_point(field_list:idlepb.FarmlandSetManagementReq.plans)
  return _impl_.plans_;
}

// -------------------------------------------------------------------

// FarmlandSetManagementAck

// bool ok = 1;
inline void FarmlandSetManagementAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool FarmlandSetManagementAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool FarmlandSetManagementAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.FarmlandSetManagementAck.ok)
  return _internal_ok();
}
inline void FarmlandSetManagementAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void FarmlandSetManagementAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.FarmlandSetManagementAck.ok)
}

// -------------------------------------------------------------------

// UpdateFarmlandStateReq

// -------------------------------------------------------------------

// UpdateFarmlandStateAck

// int32 farmer_friendship_exp = 1;
inline void UpdateFarmlandStateAck::clear_farmer_friendship_exp() {
  _impl_.farmer_friendship_exp_ = 0;
}
inline int32_t UpdateFarmlandStateAck::_internal_farmer_friendship_exp() const {
  return _impl_.farmer_friendship_exp_;
}
inline int32_t UpdateFarmlandStateAck::farmer_friendship_exp() const {
  // @@protoc_insertion_point(field_get:idlepb.UpdateFarmlandStateAck.farmer_friendship_exp)
  return _internal_farmer_friendship_exp();
}
inline void UpdateFarmlandStateAck::_internal_set_farmer_friendship_exp(int32_t value) {
  
  _impl_.farmer_friendship_exp_ = value;
}
inline void UpdateFarmlandStateAck::set_farmer_friendship_exp(int32_t value) {
  _internal_set_farmer_friendship_exp(value);
  // @@protoc_insertion_point(field_set:idlepb.UpdateFarmlandStateAck.farmer_friendship_exp)
}

// repeated int32 auto_harvest_plants = 2;
inline int UpdateFarmlandStateAck::_internal_auto_harvest_plants_size() const {
  return _impl_.auto_harvest_plants_.size();
}
inline int UpdateFarmlandStateAck::auto_harvest_plants_size() const {
  return _internal_auto_harvest_plants_size();
}
inline void UpdateFarmlandStateAck::clear_auto_harvest_plants() {
  _impl_.auto_harvest_plants_.Clear();
}
inline int32_t UpdateFarmlandStateAck::_internal_auto_harvest_plants(int index) const {
  return _impl_.auto_harvest_plants_.Get(index);
}
inline int32_t UpdateFarmlandStateAck::auto_harvest_plants(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.UpdateFarmlandStateAck.auto_harvest_plants)
  return _internal_auto_harvest_plants(index);
}
inline void UpdateFarmlandStateAck::set_auto_harvest_plants(int index, int32_t value) {
  _impl_.auto_harvest_plants_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.UpdateFarmlandStateAck.auto_harvest_plants)
}
inline void UpdateFarmlandStateAck::_internal_add_auto_harvest_plants(int32_t value) {
  _impl_.auto_harvest_plants_.Add(value);
}
inline void UpdateFarmlandStateAck::add_auto_harvest_plants(int32_t value) {
  _internal_add_auto_harvest_plants(value);
  // @@protoc_insertion_point(field_add:idlepb.UpdateFarmlandStateAck.auto_harvest_plants)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
UpdateFarmlandStateAck::_internal_auto_harvest_plants() const {
  return _impl_.auto_harvest_plants_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
UpdateFarmlandStateAck::auto_harvest_plants() const {
  // @@protoc_insertion_point(field_list:idlepb.UpdateFarmlandStateAck.auto_harvest_plants)
  return _internal_auto_harvest_plants();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
UpdateFarmlandStateAck::_internal_mutable_auto_harvest_plants() {
  return &_impl_.auto_harvest_plants_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
UpdateFarmlandStateAck::mutable_auto_harvest_plants() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.UpdateFarmlandStateAck.auto_harvest_plants)
  return _internal_mutable_auto_harvest_plants();
}

// repeated .idlepb.FarmlandPlantData continue_seeds = 3;
inline int UpdateFarmlandStateAck::_internal_continue_seeds_size() const {
  return _impl_.continue_seeds_.size();
}
inline int UpdateFarmlandStateAck::continue_seeds_size() const {
  return _internal_continue_seeds_size();
}
inline ::idlepb::FarmlandPlantData* UpdateFarmlandStateAck::mutable_continue_seeds(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.UpdateFarmlandStateAck.continue_seeds)
  return _impl_.continue_seeds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData >*
UpdateFarmlandStateAck::mutable_continue_seeds() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.UpdateFarmlandStateAck.continue_seeds)
  return &_impl_.continue_seeds_;
}
inline const ::idlepb::FarmlandPlantData& UpdateFarmlandStateAck::_internal_continue_seeds(int index) const {
  return _impl_.continue_seeds_.Get(index);
}
inline const ::idlepb::FarmlandPlantData& UpdateFarmlandStateAck::continue_seeds(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.UpdateFarmlandStateAck.continue_seeds)
  return _internal_continue_seeds(index);
}
inline ::idlepb::FarmlandPlantData* UpdateFarmlandStateAck::_internal_add_continue_seeds() {
  return _impl_.continue_seeds_.Add();
}
inline ::idlepb::FarmlandPlantData* UpdateFarmlandStateAck::add_continue_seeds() {
  ::idlepb::FarmlandPlantData* _add = _internal_add_continue_seeds();
  // @@protoc_insertion_point(field_add:idlepb.UpdateFarmlandStateAck.continue_seeds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::FarmlandPlantData >&
UpdateFarmlandStateAck::continue_seeds() const {
  // @@protoc_insertion_point(field_list:idlepb.UpdateFarmlandStateAck.continue_seeds)
  return _impl_.continue_seeds_;
}

// repeated .idlepb.SimpleItemData harvest_items = 4;
inline int UpdateFarmlandStateAck::_internal_harvest_items_size() const {
  return _impl_.harvest_items_.size();
}
inline int UpdateFarmlandStateAck::harvest_items_size() const {
  return _internal_harvest_items_size();
}
inline ::idlepb::SimpleItemData* UpdateFarmlandStateAck::mutable_harvest_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.UpdateFarmlandStateAck.harvest_items)
  return _impl_.harvest_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
UpdateFarmlandStateAck::mutable_harvest_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.UpdateFarmlandStateAck.harvest_items)
  return &_impl_.harvest_items_;
}
inline const ::idlepb::SimpleItemData& UpdateFarmlandStateAck::_internal_harvest_items(int index) const {
  return _impl_.harvest_items_.Get(index);
}
inline const ::idlepb::SimpleItemData& UpdateFarmlandStateAck::harvest_items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.UpdateFarmlandStateAck.harvest_items)
  return _internal_harvest_items(index);
}
inline ::idlepb::SimpleItemData* UpdateFarmlandStateAck::_internal_add_harvest_items() {
  return _impl_.harvest_items_.Add();
}
inline ::idlepb::SimpleItemData* UpdateFarmlandStateAck::add_harvest_items() {
  ::idlepb::SimpleItemData* _add = _internal_add_harvest_items();
  // @@protoc_insertion_point(field_add:idlepb.UpdateFarmlandStateAck.harvest_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
UpdateFarmlandStateAck::harvest_items() const {
  // @@protoc_insertion_point(field_list:idlepb.UpdateFarmlandStateAck.harvest_items)
  return _impl_.harvest_items_;
}

// -------------------------------------------------------------------

// GetRoleInfoReq

// uint64 role_id = 1;
inline void GetRoleInfoReq::clear_role_id() {
  _impl_.role_id_ = uint64_t{0u};
}
inline uint64_t GetRoleInfoReq::_internal_role_id() const {
  return _impl_.role_id_;
}
inline uint64_t GetRoleInfoReq::role_id() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleInfoReq.role_id)
  return _internal_role_id();
}
inline void GetRoleInfoReq::_internal_set_role_id(uint64_t value) {
  
  _impl_.role_id_ = value;
}
inline void GetRoleInfoReq::set_role_id(uint64_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleInfoReq.role_id)
}

// -------------------------------------------------------------------

// GetRoleInfoAck

// .idlepb.RoleInfo role_info = 1;
inline bool GetRoleInfoAck::_internal_has_role_info() const {
  return this != internal_default_instance() && _impl_.role_info_ != nullptr;
}
inline bool GetRoleInfoAck::has_role_info() const {
  return _internal_has_role_info();
}
inline const ::idlepb::RoleInfo& GetRoleInfoAck::_internal_role_info() const {
  const ::idlepb::RoleInfo* p = _impl_.role_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleInfo&>(
      ::idlepb::_RoleInfo_default_instance_);
}
inline const ::idlepb::RoleInfo& GetRoleInfoAck::role_info() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleInfoAck.role_info)
  return _internal_role_info();
}
inline void GetRoleInfoAck::unsafe_arena_set_allocated_role_info(
    ::idlepb::RoleInfo* role_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.role_info_);
  }
  _impl_.role_info_ = role_info;
  if (role_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleInfoAck.role_info)
}
inline ::idlepb::RoleInfo* GetRoleInfoAck::release_role_info() {
  
  ::idlepb::RoleInfo* temp = _impl_.role_info_;
  _impl_.role_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleInfo* GetRoleInfoAck::unsafe_arena_release_role_info() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleInfoAck.role_info)
  
  ::idlepb::RoleInfo* temp = _impl_.role_info_;
  _impl_.role_info_ = nullptr;
  return temp;
}
inline ::idlepb::RoleInfo* GetRoleInfoAck::_internal_mutable_role_info() {
  
  if (_impl_.role_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleInfo>(GetArenaForAllocation());
    _impl_.role_info_ = p;
  }
  return _impl_.role_info_;
}
inline ::idlepb::RoleInfo* GetRoleInfoAck::mutable_role_info() {
  ::idlepb::RoleInfo* _msg = _internal_mutable_role_info();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleInfoAck.role_info)
  return _msg;
}
inline void GetRoleInfoAck::set_allocated_role_info(::idlepb::RoleInfo* role_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.role_info_);
  }
  if (role_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_info));
    if (message_arena != submessage_arena) {
      role_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.role_info_ = role_info;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleInfoAck.role_info)
}

// bool ok = 2;
inline void GetRoleInfoAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool GetRoleInfoAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool GetRoleInfoAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleInfoAck.ok)
  return _internal_ok();
}
inline void GetRoleInfoAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void GetRoleInfoAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleInfoAck.ok)
}

// -------------------------------------------------------------------

// GetRoleFriendDataReq

// -------------------------------------------------------------------

// GetRoleFriendDataAck

// .idlepb.RoleFriendData data = 1;
inline bool GetRoleFriendDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetRoleFriendDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleFriendData& GetRoleFriendDataAck::_internal_data() const {
  const ::idlepb::RoleFriendData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleFriendData&>(
      ::idlepb::_RoleFriendData_default_instance_);
}
inline const ::idlepb::RoleFriendData& GetRoleFriendDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleFriendDataAck.data)
  return _internal_data();
}
inline void GetRoleFriendDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleFriendData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleFriendDataAck.data)
}
inline ::idlepb::RoleFriendData* GetRoleFriendDataAck::release_data() {
  
  ::idlepb::RoleFriendData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleFriendData* GetRoleFriendDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleFriendDataAck.data)
  
  ::idlepb::RoleFriendData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleFriendData* GetRoleFriendDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleFriendData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleFriendData* GetRoleFriendDataAck::mutable_data() {
  ::idlepb::RoleFriendData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleFriendDataAck.data)
  return _msg;
}
inline void GetRoleFriendDataAck::set_allocated_data(::idlepb::RoleFriendData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleFriendDataAck.data)
}

// repeated .idlepb.SimpleRoleInfo role_infos = 11;
inline int GetRoleFriendDataAck::_internal_role_infos_size() const {
  return _impl_.role_infos_.size();
}
inline int GetRoleFriendDataAck::role_infos_size() const {
  return _internal_role_infos_size();
}
inline ::idlepb::SimpleRoleInfo* GetRoleFriendDataAck::mutable_role_infos(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleFriendDataAck.role_infos)
  return _impl_.role_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo >*
GetRoleFriendDataAck::mutable_role_infos() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetRoleFriendDataAck.role_infos)
  return &_impl_.role_infos_;
}
inline const ::idlepb::SimpleRoleInfo& GetRoleFriendDataAck::_internal_role_infos(int index) const {
  return _impl_.role_infos_.Get(index);
}
inline const ::idlepb::SimpleRoleInfo& GetRoleFriendDataAck::role_infos(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleFriendDataAck.role_infos)
  return _internal_role_infos(index);
}
inline ::idlepb::SimpleRoleInfo* GetRoleFriendDataAck::_internal_add_role_infos() {
  return _impl_.role_infos_.Add();
}
inline ::idlepb::SimpleRoleInfo* GetRoleFriendDataAck::add_role_infos() {
  ::idlepb::SimpleRoleInfo* _add = _internal_add_role_infos();
  // @@protoc_insertion_point(field_add:idlepb.GetRoleFriendDataAck.role_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo >&
GetRoleFriendDataAck::role_infos() const {
  // @@protoc_insertion_point(field_list:idlepb.GetRoleFriendDataAck.role_infos)
  return _impl_.role_infos_;
}

// -------------------------------------------------------------------

// FriendOpReq

// int64 role_id = 1;
inline void FriendOpReq::clear_role_id() {
  _impl_.role_id_ = int64_t{0};
}
inline int64_t FriendOpReq::_internal_role_id() const {
  return _impl_.role_id_;
}
inline int64_t FriendOpReq::role_id() const {
  // @@protoc_insertion_point(field_get:idlepb.FriendOpReq.role_id)
  return _internal_role_id();
}
inline void FriendOpReq::_internal_set_role_id(int64_t value) {
  
  _impl_.role_id_ = value;
}
inline void FriendOpReq::set_role_id(int64_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:idlepb.FriendOpReq.role_id)
}

// .idlepb.FriendRelationshipType op_type = 2;
inline void FriendOpReq::clear_op_type() {
  _impl_.op_type_ = 0;
}
inline ::idlepb::FriendRelationshipType FriendOpReq::_internal_op_type() const {
  return static_cast< ::idlepb::FriendRelationshipType >(_impl_.op_type_);
}
inline ::idlepb::FriendRelationshipType FriendOpReq::op_type() const {
  // @@protoc_insertion_point(field_get:idlepb.FriendOpReq.op_type)
  return _internal_op_type();
}
inline void FriendOpReq::_internal_set_op_type(::idlepb::FriendRelationshipType value) {
  
  _impl_.op_type_ = value;
}
inline void FriendOpReq::set_op_type(::idlepb::FriendRelationshipType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:idlepb.FriendOpReq.op_type)
}

// bool reverse_op = 3;
inline void FriendOpReq::clear_reverse_op() {
  _impl_.reverse_op_ = false;
}
inline bool FriendOpReq::_internal_reverse_op() const {
  return _impl_.reverse_op_;
}
inline bool FriendOpReq::reverse_op() const {
  // @@protoc_insertion_point(field_get:idlepb.FriendOpReq.reverse_op)
  return _internal_reverse_op();
}
inline void FriendOpReq::_internal_set_reverse_op(bool value) {
  
  _impl_.reverse_op_ = value;
}
inline void FriendOpReq::set_reverse_op(bool value) {
  _internal_set_reverse_op(value);
  // @@protoc_insertion_point(field_set:idlepb.FriendOpReq.reverse_op)
}

// -------------------------------------------------------------------

// FriendOpAck

// bool ok = 1;
inline void FriendOpAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool FriendOpAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool FriendOpAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.FriendOpAck.ok)
  return _internal_ok();
}
inline void FriendOpAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void FriendOpAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.FriendOpAck.ok)
}

// .idlepb.FriendRelationshipType relationship_ab = 2;
inline void FriendOpAck::clear_relationship_ab() {
  _impl_.relationship_ab_ = 0;
}
inline ::idlepb::FriendRelationshipType FriendOpAck::_internal_relationship_ab() const {
  return static_cast< ::idlepb::FriendRelationshipType >(_impl_.relationship_ab_);
}
inline ::idlepb::FriendRelationshipType FriendOpAck::relationship_ab() const {
  // @@protoc_insertion_point(field_get:idlepb.FriendOpAck.relationship_ab)
  return _internal_relationship_ab();
}
inline void FriendOpAck::_internal_set_relationship_ab(::idlepb::FriendRelationshipType value) {
  
  _impl_.relationship_ab_ = value;
}
inline void FriendOpAck::set_relationship_ab(::idlepb::FriendRelationshipType value) {
  _internal_set_relationship_ab(value);
  // @@protoc_insertion_point(field_set:idlepb.FriendOpAck.relationship_ab)
}

// .idlepb.FriendRelationshipType relationship_ba = 3;
inline void FriendOpAck::clear_relationship_ba() {
  _impl_.relationship_ba_ = 0;
}
inline ::idlepb::FriendRelationshipType FriendOpAck::_internal_relationship_ba() const {
  return static_cast< ::idlepb::FriendRelationshipType >(_impl_.relationship_ba_);
}
inline ::idlepb::FriendRelationshipType FriendOpAck::relationship_ba() const {
  // @@protoc_insertion_point(field_get:idlepb.FriendOpAck.relationship_ba)
  return _internal_relationship_ba();
}
inline void FriendOpAck::_internal_set_relationship_ba(::idlepb::FriendRelationshipType value) {
  
  _impl_.relationship_ba_ = value;
}
inline void FriendOpAck::set_relationship_ba(::idlepb::FriendRelationshipType value) {
  _internal_set_relationship_ba(value);
  // @@protoc_insertion_point(field_set:idlepb.FriendOpAck.relationship_ba)
}

// -------------------------------------------------------------------

// ReplyFriendRequestReq

// int64 role_id = 1;
inline void ReplyFriendRequestReq::clear_role_id() {
  _impl_.role_id_ = int64_t{0};
}
inline int64_t ReplyFriendRequestReq::_internal_role_id() const {
  return _impl_.role_id_;
}
inline int64_t ReplyFriendRequestReq::role_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ReplyFriendRequestReq.role_id)
  return _internal_role_id();
}
inline void ReplyFriendRequestReq::_internal_set_role_id(int64_t value) {
  
  _impl_.role_id_ = value;
}
inline void ReplyFriendRequestReq::set_role_id(int64_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ReplyFriendRequestReq.role_id)
}

// bool agree = 2;
inline void ReplyFriendRequestReq::clear_agree() {
  _impl_.agree_ = false;
}
inline bool ReplyFriendRequestReq::_internal_agree() const {
  return _impl_.agree_;
}
inline bool ReplyFriendRequestReq::agree() const {
  // @@protoc_insertion_point(field_get:idlepb.ReplyFriendRequestReq.agree)
  return _internal_agree();
}
inline void ReplyFriendRequestReq::_internal_set_agree(bool value) {
  
  _impl_.agree_ = value;
}
inline void ReplyFriendRequestReq::set_agree(bool value) {
  _internal_set_agree(value);
  // @@protoc_insertion_point(field_set:idlepb.ReplyFriendRequestReq.agree)
}

// bool one_click = 3;
inline void ReplyFriendRequestReq::clear_one_click() {
  _impl_.one_click_ = false;
}
inline bool ReplyFriendRequestReq::_internal_one_click() const {
  return _impl_.one_click_;
}
inline bool ReplyFriendRequestReq::one_click() const {
  // @@protoc_insertion_point(field_get:idlepb.ReplyFriendRequestReq.one_click)
  return _internal_one_click();
}
inline void ReplyFriendRequestReq::_internal_set_one_click(bool value) {
  
  _impl_.one_click_ = value;
}
inline void ReplyFriendRequestReq::set_one_click(bool value) {
  _internal_set_one_click(value);
  // @@protoc_insertion_point(field_set:idlepb.ReplyFriendRequestReq.one_click)
}

// -------------------------------------------------------------------

// ReplyFriendRequestAck

// bool ok = 1;
inline void ReplyFriendRequestAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ReplyFriendRequestAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ReplyFriendRequestAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ReplyFriendRequestAck.ok)
  return _internal_ok();
}
inline void ReplyFriendRequestAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ReplyFriendRequestAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ReplyFriendRequestAck.ok)
}

// repeated int32 relationship_ba = 2;
inline int ReplyFriendRequestAck::_internal_relationship_ba_size() const {
  return _impl_.relationship_ba_.size();
}
inline int ReplyFriendRequestAck::relationship_ba_size() const {
  return _internal_relationship_ba_size();
}
inline void ReplyFriendRequestAck::clear_relationship_ba() {
  _impl_.relationship_ba_.Clear();
}
inline int32_t ReplyFriendRequestAck::_internal_relationship_ba(int index) const {
  return _impl_.relationship_ba_.Get(index);
}
inline int32_t ReplyFriendRequestAck::relationship_ba(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.ReplyFriendRequestAck.relationship_ba)
  return _internal_relationship_ba(index);
}
inline void ReplyFriendRequestAck::set_relationship_ba(int index, int32_t value) {
  _impl_.relationship_ba_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.ReplyFriendRequestAck.relationship_ba)
}
inline void ReplyFriendRequestAck::_internal_add_relationship_ba(int32_t value) {
  _impl_.relationship_ba_.Add(value);
}
inline void ReplyFriendRequestAck::add_relationship_ba(int32_t value) {
  _internal_add_relationship_ba(value);
  // @@protoc_insertion_point(field_add:idlepb.ReplyFriendRequestAck.relationship_ba)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ReplyFriendRequestAck::_internal_relationship_ba() const {
  return _impl_.relationship_ba_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ReplyFriendRequestAck::relationship_ba() const {
  // @@protoc_insertion_point(field_list:idlepb.ReplyFriendRequestAck.relationship_ba)
  return _internal_relationship_ba();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ReplyFriendRequestAck::_internal_mutable_relationship_ba() {
  return &_impl_.relationship_ba_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ReplyFriendRequestAck::mutable_relationship_ba() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.ReplyFriendRequestAck.relationship_ba)
  return _internal_mutable_relationship_ba();
}

// repeated int64 failed_ids = 3;
inline int ReplyFriendRequestAck::_internal_failed_ids_size() const {
  return _impl_.failed_ids_.size();
}
inline int ReplyFriendRequestAck::failed_ids_size() const {
  return _internal_failed_ids_size();
}
inline void ReplyFriendRequestAck::clear_failed_ids() {
  _impl_.failed_ids_.Clear();
}
inline int64_t ReplyFriendRequestAck::_internal_failed_ids(int index) const {
  return _impl_.failed_ids_.Get(index);
}
inline int64_t ReplyFriendRequestAck::failed_ids(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.ReplyFriendRequestAck.failed_ids)
  return _internal_failed_ids(index);
}
inline void ReplyFriendRequestAck::set_failed_ids(int index, int64_t value) {
  _impl_.failed_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.ReplyFriendRequestAck.failed_ids)
}
inline void ReplyFriendRequestAck::_internal_add_failed_ids(int64_t value) {
  _impl_.failed_ids_.Add(value);
}
inline void ReplyFriendRequestAck::add_failed_ids(int64_t value) {
  _internal_add_failed_ids(value);
  // @@protoc_insertion_point(field_add:idlepb.ReplyFriendRequestAck.failed_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ReplyFriendRequestAck::_internal_failed_ids() const {
  return _impl_.failed_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ReplyFriendRequestAck::failed_ids() const {
  // @@protoc_insertion_point(field_list:idlepb.ReplyFriendRequestAck.failed_ids)
  return _internal_failed_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ReplyFriendRequestAck::_internal_mutable_failed_ids() {
  return &_impl_.failed_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ReplyFriendRequestAck::mutable_failed_ids() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.ReplyFriendRequestAck.failed_ids)
  return _internal_mutable_failed_ids();
}

// -------------------------------------------------------------------

// FriendSearchRoleInfoReq

// string role_name = 1;
inline void FriendSearchRoleInfoReq::clear_role_name() {
  _impl_.role_name_.ClearToEmpty();
}
inline const std::string& FriendSearchRoleInfoReq::role_name() const {
  // @@protoc_insertion_point(field_get:idlepb.FriendSearchRoleInfoReq.role_name)
  return _internal_role_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendSearchRoleInfoReq::set_role_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.role_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:idlepb.FriendSearchRoleInfoReq.role_name)
}
inline std::string* FriendSearchRoleInfoReq::mutable_role_name() {
  std::string* _s = _internal_mutable_role_name();
  // @@protoc_insertion_point(field_mutable:idlepb.FriendSearchRoleInfoReq.role_name)
  return _s;
}
inline const std::string& FriendSearchRoleInfoReq::_internal_role_name() const {
  return _impl_.role_name_.Get();
}
inline void FriendSearchRoleInfoReq::_internal_set_role_name(const std::string& value) {
  
  _impl_.role_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendSearchRoleInfoReq::_internal_mutable_role_name() {
  
  return _impl_.role_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendSearchRoleInfoReq::release_role_name() {
  // @@protoc_insertion_point(field_release:idlepb.FriendSearchRoleInfoReq.role_name)
  return _impl_.role_name_.Release();
}
inline void FriendSearchRoleInfoReq::set_allocated_role_name(std::string* role_name) {
  if (role_name != nullptr) {
    
  } else {
    
  }
  _impl_.role_name_.SetAllocated(role_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.role_name_.IsDefault()) {
    _impl_.role_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:idlepb.FriendSearchRoleInfoReq.role_name)
}

// -------------------------------------------------------------------

// FriendSearchRoleInfoAck

// repeated .idlepb.SimpleRoleInfo role_infos = 2;
inline int FriendSearchRoleInfoAck::_internal_role_infos_size() const {
  return _impl_.role_infos_.size();
}
inline int FriendSearchRoleInfoAck::role_infos_size() const {
  return _internal_role_infos_size();
}
inline ::idlepb::SimpleRoleInfo* FriendSearchRoleInfoAck::mutable_role_infos(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.FriendSearchRoleInfoAck.role_infos)
  return _impl_.role_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo >*
FriendSearchRoleInfoAck::mutable_role_infos() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.FriendSearchRoleInfoAck.role_infos)
  return &_impl_.role_infos_;
}
inline const ::idlepb::SimpleRoleInfo& FriendSearchRoleInfoAck::_internal_role_infos(int index) const {
  return _impl_.role_infos_.Get(index);
}
inline const ::idlepb::SimpleRoleInfo& FriendSearchRoleInfoAck::role_infos(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.FriendSearchRoleInfoAck.role_infos)
  return _internal_role_infos(index);
}
inline ::idlepb::SimpleRoleInfo* FriendSearchRoleInfoAck::_internal_add_role_infos() {
  return _impl_.role_infos_.Add();
}
inline ::idlepb::SimpleRoleInfo* FriendSearchRoleInfoAck::add_role_infos() {
  ::idlepb::SimpleRoleInfo* _add = _internal_add_role_infos();
  // @@protoc_insertion_point(field_add:idlepb.FriendSearchRoleInfoAck.role_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleRoleInfo >&
FriendSearchRoleInfoAck::role_infos() const {
  // @@protoc_insertion_point(field_list:idlepb.FriendSearchRoleInfoAck.role_infos)
  return _impl_.role_infos_;
}

// -------------------------------------------------------------------

// NotifyFriendMessage

// .idlepb.SimpleRoleInfo role_info = 1;
inline bool NotifyFriendMessage::_internal_has_role_info() const {
  return this != internal_default_instance() && _impl_.role_info_ != nullptr;
}
inline bool NotifyFriendMessage::has_role_info() const {
  return _internal_has_role_info();
}
inline const ::idlepb::SimpleRoleInfo& NotifyFriendMessage::_internal_role_info() const {
  const ::idlepb::SimpleRoleInfo* p = _impl_.role_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::SimpleRoleInfo&>(
      ::idlepb::_SimpleRoleInfo_default_instance_);
}
inline const ::idlepb::SimpleRoleInfo& NotifyFriendMessage::role_info() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyFriendMessage.role_info)
  return _internal_role_info();
}
inline void NotifyFriendMessage::unsafe_arena_set_allocated_role_info(
    ::idlepb::SimpleRoleInfo* role_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.role_info_);
  }
  _impl_.role_info_ = role_info;
  if (role_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.NotifyFriendMessage.role_info)
}
inline ::idlepb::SimpleRoleInfo* NotifyFriendMessage::release_role_info() {
  
  ::idlepb::SimpleRoleInfo* temp = _impl_.role_info_;
  _impl_.role_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::SimpleRoleInfo* NotifyFriendMessage::unsafe_arena_release_role_info() {
  // @@protoc_insertion_point(field_release:idlepb.NotifyFriendMessage.role_info)
  
  ::idlepb::SimpleRoleInfo* temp = _impl_.role_info_;
  _impl_.role_info_ = nullptr;
  return temp;
}
inline ::idlepb::SimpleRoleInfo* NotifyFriendMessage::_internal_mutable_role_info() {
  
  if (_impl_.role_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::SimpleRoleInfo>(GetArenaForAllocation());
    _impl_.role_info_ = p;
  }
  return _impl_.role_info_;
}
inline ::idlepb::SimpleRoleInfo* NotifyFriendMessage::mutable_role_info() {
  ::idlepb::SimpleRoleInfo* _msg = _internal_mutable_role_info();
  // @@protoc_insertion_point(field_mutable:idlepb.NotifyFriendMessage.role_info)
  return _msg;
}
inline void NotifyFriendMessage::set_allocated_role_info(::idlepb::SimpleRoleInfo* role_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.role_info_);
  }
  if (role_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_info));
    if (message_arena != submessage_arena) {
      role_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.role_info_ = role_info;
  // @@protoc_insertion_point(field_set_allocated:idlepb.NotifyFriendMessage.role_info)
}

// bool is_update_state = 2;
inline void NotifyFriendMessage::clear_is_update_state() {
  _impl_.is_update_state_ = false;
}
inline bool NotifyFriendMessage::_internal_is_update_state() const {
  return _impl_.is_update_state_;
}
inline bool NotifyFriendMessage::is_update_state() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyFriendMessage.is_update_state)
  return _internal_is_update_state();
}
inline void NotifyFriendMessage::_internal_set_is_update_state(bool value) {
  
  _impl_.is_update_state_ = value;
}
inline void NotifyFriendMessage::set_is_update_state(bool value) {
  _internal_set_is_update_state(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyFriendMessage.is_update_state)
}

// bool b_refused = 3;
inline void NotifyFriendMessage::clear_b_refused() {
  _impl_.b_refused_ = false;
}
inline bool NotifyFriendMessage::_internal_b_refused() const {
  return _impl_.b_refused_;
}
inline bool NotifyFriendMessage::b_refused() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyFriendMessage.b_refused)
  return _internal_b_refused();
}
inline void NotifyFriendMessage::_internal_set_b_refused(bool value) {
  
  _impl_.b_refused_ = value;
}
inline void NotifyFriendMessage::set_b_refused(bool value) {
  _internal_set_b_refused(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyFriendMessage.b_refused)
}

// .idlepb.FriendListItem friend_event = 4;
inline bool NotifyFriendMessage::_internal_has_friend_event() const {
  return this != internal_default_instance() && _impl_.friend_event_ != nullptr;
}
inline bool NotifyFriendMessage::has_friend_event() const {
  return _internal_has_friend_event();
}
inline const ::idlepb::FriendListItem& NotifyFriendMessage::_internal_friend_event() const {
  const ::idlepb::FriendListItem* p = _impl_.friend_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::FriendListItem&>(
      ::idlepb::_FriendListItem_default_instance_);
}
inline const ::idlepb::FriendListItem& NotifyFriendMessage::friend_event() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyFriendMessage.friend_event)
  return _internal_friend_event();
}
inline void NotifyFriendMessage::unsafe_arena_set_allocated_friend_event(
    ::idlepb::FriendListItem* friend_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.friend_event_);
  }
  _impl_.friend_event_ = friend_event;
  if (friend_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.NotifyFriendMessage.friend_event)
}
inline ::idlepb::FriendListItem* NotifyFriendMessage::release_friend_event() {
  
  ::idlepb::FriendListItem* temp = _impl_.friend_event_;
  _impl_.friend_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::FriendListItem* NotifyFriendMessage::unsafe_arena_release_friend_event() {
  // @@protoc_insertion_point(field_release:idlepb.NotifyFriendMessage.friend_event)
  
  ::idlepb::FriendListItem* temp = _impl_.friend_event_;
  _impl_.friend_event_ = nullptr;
  return temp;
}
inline ::idlepb::FriendListItem* NotifyFriendMessage::_internal_mutable_friend_event() {
  
  if (_impl_.friend_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::FriendListItem>(GetArenaForAllocation());
    _impl_.friend_event_ = p;
  }
  return _impl_.friend_event_;
}
inline ::idlepb::FriendListItem* NotifyFriendMessage::mutable_friend_event() {
  ::idlepb::FriendListItem* _msg = _internal_mutable_friend_event();
  // @@protoc_insertion_point(field_mutable:idlepb.NotifyFriendMessage.friend_event)
  return _msg;
}
inline void NotifyFriendMessage::set_allocated_friend_event(::idlepb::FriendListItem* friend_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.friend_event_);
  }
  if (friend_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(friend_event));
    if (message_arena != submessage_arena) {
      friend_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friend_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.friend_event_ = friend_event;
  // @@protoc_insertion_point(field_set_allocated:idlepb.NotifyFriendMessage.friend_event)
}

// bool online = 5;
inline void NotifyFriendMessage::clear_online() {
  _impl_.online_ = false;
}
inline bool NotifyFriendMessage::_internal_online() const {
  return _impl_.online_;
}
inline bool NotifyFriendMessage::online() const {
  // @@protoc_insertion_point(field_get:idlepb.NotifyFriendMessage.online)
  return _internal_online();
}
inline void NotifyFriendMessage::_internal_set_online(bool value) {
  
  _impl_.online_ = value;
}
inline void NotifyFriendMessage::set_online(bool value) {
  _internal_set_online(value);
  // @@protoc_insertion_point(field_set:idlepb.NotifyFriendMessage.online)
}

// -------------------------------------------------------------------

// GetRoleAvatarDataReq

// bool draw_this_time = 1;
inline void GetRoleAvatarDataReq::clear_draw_this_time() {
  _impl_.draw_this_time_ = false;
}
inline bool GetRoleAvatarDataReq::_internal_draw_this_time() const {
  return _impl_.draw_this_time_;
}
inline bool GetRoleAvatarDataReq::draw_this_time() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleAvatarDataReq.draw_this_time)
  return _internal_draw_this_time();
}
inline void GetRoleAvatarDataReq::_internal_set_draw_this_time(bool value) {
  
  _impl_.draw_this_time_ = value;
}
inline void GetRoleAvatarDataReq::set_draw_this_time(bool value) {
  _internal_set_draw_this_time(value);
  // @@protoc_insertion_point(field_set:idlepb.GetRoleAvatarDataReq.draw_this_time)
}

// -------------------------------------------------------------------

// GetRoleAvatarDataAck

// .idlepb.RoleAvatarData data = 1;
inline bool GetRoleAvatarDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetRoleAvatarDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleAvatarData& GetRoleAvatarDataAck::_internal_data() const {
  const ::idlepb::RoleAvatarData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleAvatarData&>(
      ::idlepb::_RoleAvatarData_default_instance_);
}
inline const ::idlepb::RoleAvatarData& GetRoleAvatarDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleAvatarDataAck.data)
  return _internal_data();
}
inline void GetRoleAvatarDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleAvatarData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleAvatarDataAck.data)
}
inline ::idlepb::RoleAvatarData* GetRoleAvatarDataAck::release_data() {
  
  ::idlepb::RoleAvatarData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleAvatarData* GetRoleAvatarDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleAvatarDataAck.data)
  
  ::idlepb::RoleAvatarData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleAvatarData* GetRoleAvatarDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleAvatarData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleAvatarData* GetRoleAvatarDataAck::mutable_data() {
  ::idlepb::RoleAvatarData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleAvatarDataAck.data)
  return _msg;
}
inline void GetRoleAvatarDataAck::set_allocated_data(::idlepb::RoleAvatarData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleAvatarDataAck.data)
}

// -------------------------------------------------------------------

// DispatchAvatarReq

// int32 world_index = 1;
inline void DispatchAvatarReq::clear_world_index() {
  _impl_.world_index_ = 0;
}
inline int32_t DispatchAvatarReq::_internal_world_index() const {
  return _impl_.world_index_;
}
inline int32_t DispatchAvatarReq::world_index() const {
  // @@protoc_insertion_point(field_get:idlepb.DispatchAvatarReq.world_index)
  return _internal_world_index();
}
inline void DispatchAvatarReq::_internal_set_world_index(int32_t value) {
  
  _impl_.world_index_ = value;
}
inline void DispatchAvatarReq::set_world_index(int32_t value) {
  _internal_set_world_index(value);
  // @@protoc_insertion_point(field_set:idlepb.DispatchAvatarReq.world_index)
}

// -------------------------------------------------------------------

// DispatchAvatarAck

// .idlepb.RoleAvatarData data = 1;
inline bool DispatchAvatarAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool DispatchAvatarAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleAvatarData& DispatchAvatarAck::_internal_data() const {
  const ::idlepb::RoleAvatarData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleAvatarData&>(
      ::idlepb::_RoleAvatarData_default_instance_);
}
inline const ::idlepb::RoleAvatarData& DispatchAvatarAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.DispatchAvatarAck.data)
  return _internal_data();
}
inline void DispatchAvatarAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleAvatarData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.DispatchAvatarAck.data)
}
inline ::idlepb::RoleAvatarData* DispatchAvatarAck::release_data() {
  
  ::idlepb::RoleAvatarData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleAvatarData* DispatchAvatarAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.DispatchAvatarAck.data)
  
  ::idlepb::RoleAvatarData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleAvatarData* DispatchAvatarAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleAvatarData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleAvatarData* DispatchAvatarAck::mutable_data() {
  ::idlepb::RoleAvatarData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.DispatchAvatarAck.data)
  return _msg;
}
inline void DispatchAvatarAck::set_allocated_data(::idlepb::RoleAvatarData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.DispatchAvatarAck.data)
}

// -------------------------------------------------------------------

// AvatarRankUpReq

// -------------------------------------------------------------------

// AvatarRankUpAck

// .idlepb.RoleAvatarData data = 1;
inline bool AvatarRankUpAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool AvatarRankUpAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleAvatarData& AvatarRankUpAck::_internal_data() const {
  const ::idlepb::RoleAvatarData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleAvatarData&>(
      ::idlepb::_RoleAvatarData_default_instance_);
}
inline const ::idlepb::RoleAvatarData& AvatarRankUpAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.AvatarRankUpAck.data)
  return _internal_data();
}
inline void AvatarRankUpAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleAvatarData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.AvatarRankUpAck.data)
}
inline ::idlepb::RoleAvatarData* AvatarRankUpAck::release_data() {
  
  ::idlepb::RoleAvatarData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleAvatarData* AvatarRankUpAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.AvatarRankUpAck.data)
  
  ::idlepb::RoleAvatarData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleAvatarData* AvatarRankUpAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleAvatarData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleAvatarData* AvatarRankUpAck::mutable_data() {
  ::idlepb::RoleAvatarData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.AvatarRankUpAck.data)
  return _msg;
}
inline void AvatarRankUpAck::set_allocated_data(::idlepb::RoleAvatarData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.AvatarRankUpAck.data)
}

// -------------------------------------------------------------------

// ReceiveAvatarTempPackageReq

// -------------------------------------------------------------------

// ReceiveAvatarTempPackageAck

// .idlepb.RoleAvatarData data = 1;
inline bool ReceiveAvatarTempPackageAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool ReceiveAvatarTempPackageAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleAvatarData& ReceiveAvatarTempPackageAck::_internal_data() const {
  const ::idlepb::RoleAvatarData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleAvatarData&>(
      ::idlepb::_RoleAvatarData_default_instance_);
}
inline const ::idlepb::RoleAvatarData& ReceiveAvatarTempPackageAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.ReceiveAvatarTempPackageAck.data)
  return _internal_data();
}
inline void ReceiveAvatarTempPackageAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleAvatarData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.ReceiveAvatarTempPackageAck.data)
}
inline ::idlepb::RoleAvatarData* ReceiveAvatarTempPackageAck::release_data() {
  
  ::idlepb::RoleAvatarData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleAvatarData* ReceiveAvatarTempPackageAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.ReceiveAvatarTempPackageAck.data)
  
  ::idlepb::RoleAvatarData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleAvatarData* ReceiveAvatarTempPackageAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleAvatarData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleAvatarData* ReceiveAvatarTempPackageAck::mutable_data() {
  ::idlepb::RoleAvatarData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.ReceiveAvatarTempPackageAck.data)
  return _msg;
}
inline void ReceiveAvatarTempPackageAck::set_allocated_data(::idlepb::RoleAvatarData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.ReceiveAvatarTempPackageAck.data)
}

// -------------------------------------------------------------------

// GetRoleBiographyDataReq

// -------------------------------------------------------------------

// GetRoleBiographyDataAck

// .idlepb.RoleBiographyData data = 1;
inline bool GetRoleBiographyDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetRoleBiographyDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleBiographyData& GetRoleBiographyDataAck::_internal_data() const {
  const ::idlepb::RoleBiographyData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleBiographyData&>(
      ::idlepb::_RoleBiographyData_default_instance_);
}
inline const ::idlepb::RoleBiographyData& GetRoleBiographyDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleBiographyDataAck.data)
  return _internal_data();
}
inline void GetRoleBiographyDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleBiographyData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleBiographyDataAck.data)
}
inline ::idlepb::RoleBiographyData* GetRoleBiographyDataAck::release_data() {
  
  ::idlepb::RoleBiographyData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleBiographyData* GetRoleBiographyDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleBiographyDataAck.data)
  
  ::idlepb::RoleBiographyData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleBiographyData* GetRoleBiographyDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleBiographyData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleBiographyData* GetRoleBiographyDataAck::mutable_data() {
  ::idlepb::RoleBiographyData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleBiographyDataAck.data)
  return _msg;
}
inline void GetRoleBiographyDataAck::set_allocated_data(::idlepb::RoleBiographyData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleBiographyDataAck.data)
}

// -------------------------------------------------------------------

// ReceiveBiographyItemReq

// repeated int32 cfg_ids = 1;
inline int ReceiveBiographyItemReq::_internal_cfg_ids_size() const {
  return _impl_.cfg_ids_.size();
}
inline int ReceiveBiographyItemReq::cfg_ids_size() const {
  return _internal_cfg_ids_size();
}
inline void ReceiveBiographyItemReq::clear_cfg_ids() {
  _impl_.cfg_ids_.Clear();
}
inline int32_t ReceiveBiographyItemReq::_internal_cfg_ids(int index) const {
  return _impl_.cfg_ids_.Get(index);
}
inline int32_t ReceiveBiographyItemReq::cfg_ids(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.ReceiveBiographyItemReq.cfg_ids)
  return _internal_cfg_ids(index);
}
inline void ReceiveBiographyItemReq::set_cfg_ids(int index, int32_t value) {
  _impl_.cfg_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:idlepb.ReceiveBiographyItemReq.cfg_ids)
}
inline void ReceiveBiographyItemReq::_internal_add_cfg_ids(int32_t value) {
  _impl_.cfg_ids_.Add(value);
}
inline void ReceiveBiographyItemReq::add_cfg_ids(int32_t value) {
  _internal_add_cfg_ids(value);
  // @@protoc_insertion_point(field_add:idlepb.ReceiveBiographyItemReq.cfg_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ReceiveBiographyItemReq::_internal_cfg_ids() const {
  return _impl_.cfg_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ReceiveBiographyItemReq::cfg_ids() const {
  // @@protoc_insertion_point(field_list:idlepb.ReceiveBiographyItemReq.cfg_ids)
  return _internal_cfg_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ReceiveBiographyItemReq::_internal_mutable_cfg_ids() {
  return &_impl_.cfg_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ReceiveBiographyItemReq::mutable_cfg_ids() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.ReceiveBiographyItemReq.cfg_ids)
  return _internal_mutable_cfg_ids();
}

// -------------------------------------------------------------------

// ReceiveBiographyItemAck

// bool ok = 1;
inline void ReceiveBiographyItemAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool ReceiveBiographyItemAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool ReceiveBiographyItemAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.ReceiveBiographyItemAck.ok)
  return _internal_ok();
}
inline void ReceiveBiographyItemAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void ReceiveBiographyItemAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.ReceiveBiographyItemAck.ok)
}

// -------------------------------------------------------------------

// NotifyBiographyMessage

// -------------------------------------------------------------------

// GetBiographyEventDataReq

// -------------------------------------------------------------------

// GetBiographyEventDataAck

// repeated .idlepb.BiographyEventLeaderboardList biography_lists = 1;
inline int GetBiographyEventDataAck::_internal_biography_lists_size() const {
  return _impl_.biography_lists_.size();
}
inline int GetBiographyEventDataAck::biography_lists_size() const {
  return _internal_biography_lists_size();
}
inline ::idlepb::BiographyEventLeaderboardList* GetBiographyEventDataAck::mutable_biography_lists(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.GetBiographyEventDataAck.biography_lists)
  return _impl_.biography_lists_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::BiographyEventLeaderboardList >*
GetBiographyEventDataAck::mutable_biography_lists() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.GetBiographyEventDataAck.biography_lists)
  return &_impl_.biography_lists_;
}
inline const ::idlepb::BiographyEventLeaderboardList& GetBiographyEventDataAck::_internal_biography_lists(int index) const {
  return _impl_.biography_lists_.Get(index);
}
inline const ::idlepb::BiographyEventLeaderboardList& GetBiographyEventDataAck::biography_lists(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.GetBiographyEventDataAck.biography_lists)
  return _internal_biography_lists(index);
}
inline ::idlepb::BiographyEventLeaderboardList* GetBiographyEventDataAck::_internal_add_biography_lists() {
  return _impl_.biography_lists_.Add();
}
inline ::idlepb::BiographyEventLeaderboardList* GetBiographyEventDataAck::add_biography_lists() {
  ::idlepb::BiographyEventLeaderboardList* _add = _internal_add_biography_lists();
  // @@protoc_insertion_point(field_add:idlepb.GetBiographyEventDataAck.biography_lists)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::BiographyEventLeaderboardList >&
GetBiographyEventDataAck::biography_lists() const {
  // @@protoc_insertion_point(field_list:idlepb.GetBiographyEventDataAck.biography_lists)
  return _impl_.biography_lists_;
}

// .idlepb.ServerCounterData server_counter_data = 2;
inline bool GetBiographyEventDataAck::_internal_has_server_counter_data() const {
  return this != internal_default_instance() && _impl_.server_counter_data_ != nullptr;
}
inline bool GetBiographyEventDataAck::has_server_counter_data() const {
  return _internal_has_server_counter_data();
}
inline const ::idlepb::ServerCounterData& GetBiographyEventDataAck::_internal_server_counter_data() const {
  const ::idlepb::ServerCounterData* p = _impl_.server_counter_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::ServerCounterData&>(
      ::idlepb::_ServerCounterData_default_instance_);
}
inline const ::idlepb::ServerCounterData& GetBiographyEventDataAck::server_counter_data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetBiographyEventDataAck.server_counter_data)
  return _internal_server_counter_data();
}
inline void GetBiographyEventDataAck::unsafe_arena_set_allocated_server_counter_data(
    ::idlepb::ServerCounterData* server_counter_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_counter_data_);
  }
  _impl_.server_counter_data_ = server_counter_data;
  if (server_counter_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetBiographyEventDataAck.server_counter_data)
}
inline ::idlepb::ServerCounterData* GetBiographyEventDataAck::release_server_counter_data() {
  
  ::idlepb::ServerCounterData* temp = _impl_.server_counter_data_;
  _impl_.server_counter_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::ServerCounterData* GetBiographyEventDataAck::unsafe_arena_release_server_counter_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetBiographyEventDataAck.server_counter_data)
  
  ::idlepb::ServerCounterData* temp = _impl_.server_counter_data_;
  _impl_.server_counter_data_ = nullptr;
  return temp;
}
inline ::idlepb::ServerCounterData* GetBiographyEventDataAck::_internal_mutable_server_counter_data() {
  
  if (_impl_.server_counter_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::ServerCounterData>(GetArenaForAllocation());
    _impl_.server_counter_data_ = p;
  }
  return _impl_.server_counter_data_;
}
inline ::idlepb::ServerCounterData* GetBiographyEventDataAck::mutable_server_counter_data() {
  ::idlepb::ServerCounterData* _msg = _internal_mutable_server_counter_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetBiographyEventDataAck.server_counter_data)
  return _msg;
}
inline void GetBiographyEventDataAck::set_allocated_server_counter_data(::idlepb::ServerCounterData* server_counter_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_counter_data_);
  }
  if (server_counter_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_counter_data));
    if (message_arena != submessage_arena) {
      server_counter_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_counter_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_counter_data_ = server_counter_data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetBiographyEventDataAck.server_counter_data)
}

// -------------------------------------------------------------------

// ReceiveBiographyEventItemReq

// int32 cfg_id = 1;
inline void ReceiveBiographyEventItemReq::clear_cfg_id() {
  _impl_.cfg_id_ = 0;
}
inline int32_t ReceiveBiographyEventItemReq::_internal_cfg_id() const {
  return _impl_.cfg_id_;
}
inline int32_t ReceiveBiographyEventItemReq::cfg_id() const {
  // @@protoc_insertion_point(field_get:idlepb.ReceiveBiographyEventItemReq.cfg_id)
  return _internal_cfg_id();
}
inline void ReceiveBiographyEventItemReq::_internal_set_cfg_id(int32_t value) {
  
  _impl_.cfg_id_ = value;
}
inline void ReceiveBiographyEventItemReq::set_cfg_id(int32_t value) {
  _internal_set_cfg_id(value);
  // @@protoc_insertion_point(field_set:idlepb.ReceiveBiographyEventItemReq.cfg_id)
}

// -------------------------------------------------------------------

// ReceiveBiographyEventItemAck

// repeated .idlepb.SimpleItemData items = 1;
inline int ReceiveBiographyEventItemAck::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int ReceiveBiographyEventItemAck::items_size() const {
  return _internal_items_size();
}
inline ::idlepb::SimpleItemData* ReceiveBiographyEventItemAck::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:idlepb.ReceiveBiographyEventItemAck.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >*
ReceiveBiographyEventItemAck::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:idlepb.ReceiveBiographyEventItemAck.items)
  return &_impl_.items_;
}
inline const ::idlepb::SimpleItemData& ReceiveBiographyEventItemAck::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::idlepb::SimpleItemData& ReceiveBiographyEventItemAck::items(int index) const {
  // @@protoc_insertion_point(field_get:idlepb.ReceiveBiographyEventItemAck.items)
  return _internal_items(index);
}
inline ::idlepb::SimpleItemData* ReceiveBiographyEventItemAck::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::idlepb::SimpleItemData* ReceiveBiographyEventItemAck::add_items() {
  ::idlepb::SimpleItemData* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:idlepb.ReceiveBiographyEventItemAck.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::idlepb::SimpleItemData >&
ReceiveBiographyEventItemAck::items() const {
  // @@protoc_insertion_point(field_list:idlepb.ReceiveBiographyEventItemAck.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// AddBiographyRoleLogReq

// .idlepb.BiographyRoleLog log = 1;
inline bool AddBiographyRoleLogReq::_internal_has_log() const {
  return this != internal_default_instance() && _impl_.log_ != nullptr;
}
inline bool AddBiographyRoleLogReq::has_log() const {
  return _internal_has_log();
}
inline const ::idlepb::BiographyRoleLog& AddBiographyRoleLogReq::_internal_log() const {
  const ::idlepb::BiographyRoleLog* p = _impl_.log_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::BiographyRoleLog&>(
      ::idlepb::_BiographyRoleLog_default_instance_);
}
inline const ::idlepb::BiographyRoleLog& AddBiographyRoleLogReq::log() const {
  // @@protoc_insertion_point(field_get:idlepb.AddBiographyRoleLogReq.log)
  return _internal_log();
}
inline void AddBiographyRoleLogReq::unsafe_arena_set_allocated_log(
    ::idlepb::BiographyRoleLog* log) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.log_);
  }
  _impl_.log_ = log;
  if (log) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.AddBiographyRoleLogReq.log)
}
inline ::idlepb::BiographyRoleLog* AddBiographyRoleLogReq::release_log() {
  
  ::idlepb::BiographyRoleLog* temp = _impl_.log_;
  _impl_.log_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::BiographyRoleLog* AddBiographyRoleLogReq::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_release:idlepb.AddBiographyRoleLogReq.log)
  
  ::idlepb::BiographyRoleLog* temp = _impl_.log_;
  _impl_.log_ = nullptr;
  return temp;
}
inline ::idlepb::BiographyRoleLog* AddBiographyRoleLogReq::_internal_mutable_log() {
  
  if (_impl_.log_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::BiographyRoleLog>(GetArenaForAllocation());
    _impl_.log_ = p;
  }
  return _impl_.log_;
}
inline ::idlepb::BiographyRoleLog* AddBiographyRoleLogReq::mutable_log() {
  ::idlepb::BiographyRoleLog* _msg = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:idlepb.AddBiographyRoleLogReq.log)
  return _msg;
}
inline void AddBiographyRoleLogReq::set_allocated_log(::idlepb::BiographyRoleLog* log) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.log_);
  }
  if (log) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log));
    if (message_arena != submessage_arena) {
      log = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.log_ = log;
  // @@protoc_insertion_point(field_set_allocated:idlepb.AddBiographyRoleLogReq.log)
}

// -------------------------------------------------------------------

// AddBiographyRoleLogAck

// .idlepb.BiographyRoleLog log = 1;
inline bool AddBiographyRoleLogAck::_internal_has_log() const {
  return this != internal_default_instance() && _impl_.log_ != nullptr;
}
inline bool AddBiographyRoleLogAck::has_log() const {
  return _internal_has_log();
}
inline const ::idlepb::BiographyRoleLog& AddBiographyRoleLogAck::_internal_log() const {
  const ::idlepb::BiographyRoleLog* p = _impl_.log_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::BiographyRoleLog&>(
      ::idlepb::_BiographyRoleLog_default_instance_);
}
inline const ::idlepb::BiographyRoleLog& AddBiographyRoleLogAck::log() const {
  // @@protoc_insertion_point(field_get:idlepb.AddBiographyRoleLogAck.log)
  return _internal_log();
}
inline void AddBiographyRoleLogAck::unsafe_arena_set_allocated_log(
    ::idlepb::BiographyRoleLog* log) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.log_);
  }
  _impl_.log_ = log;
  if (log) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.AddBiographyRoleLogAck.log)
}
inline ::idlepb::BiographyRoleLog* AddBiographyRoleLogAck::release_log() {
  
  ::idlepb::BiographyRoleLog* temp = _impl_.log_;
  _impl_.log_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::BiographyRoleLog* AddBiographyRoleLogAck::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_release:idlepb.AddBiographyRoleLogAck.log)
  
  ::idlepb::BiographyRoleLog* temp = _impl_.log_;
  _impl_.log_ = nullptr;
  return temp;
}
inline ::idlepb::BiographyRoleLog* AddBiographyRoleLogAck::_internal_mutable_log() {
  
  if (_impl_.log_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::BiographyRoleLog>(GetArenaForAllocation());
    _impl_.log_ = p;
  }
  return _impl_.log_;
}
inline ::idlepb::BiographyRoleLog* AddBiographyRoleLogAck::mutable_log() {
  ::idlepb::BiographyRoleLog* _msg = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:idlepb.AddBiographyRoleLogAck.log)
  return _msg;
}
inline void AddBiographyRoleLogAck::set_allocated_log(::idlepb::BiographyRoleLog* log) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.log_);
  }
  if (log) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log));
    if (message_arena != submessage_arena) {
      log = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.log_ = log;
  // @@protoc_insertion_point(field_set_allocated:idlepb.AddBiographyRoleLogAck.log)
}

// -------------------------------------------------------------------

// GetRoleVipShopDataReq

// -------------------------------------------------------------------

// GetRoleVipShopDataAck

// .idlepb.RoleVipShopData data = 1;
inline bool GetRoleVipShopDataAck::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool GetRoleVipShopDataAck::has_data() const {
  return _internal_has_data();
}
inline const ::idlepb::RoleVipShopData& GetRoleVipShopDataAck::_internal_data() const {
  const ::idlepb::RoleVipShopData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::idlepb::RoleVipShopData&>(
      ::idlepb::_RoleVipShopData_default_instance_);
}
inline const ::idlepb::RoleVipShopData& GetRoleVipShopDataAck::data() const {
  // @@protoc_insertion_point(field_get:idlepb.GetRoleVipShopDataAck.data)
  return _internal_data();
}
inline void GetRoleVipShopDataAck::unsafe_arena_set_allocated_data(
    ::idlepb::RoleVipShopData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:idlepb.GetRoleVipShopDataAck.data)
}
inline ::idlepb::RoleVipShopData* GetRoleVipShopDataAck::release_data() {
  
  ::idlepb::RoleVipShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::idlepb::RoleVipShopData* GetRoleVipShopDataAck::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:idlepb.GetRoleVipShopDataAck.data)
  
  ::idlepb::RoleVipShopData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::idlepb::RoleVipShopData* GetRoleVipShopDataAck::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::idlepb::RoleVipShopData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::idlepb::RoleVipShopData* GetRoleVipShopDataAck::mutable_data() {
  ::idlepb::RoleVipShopData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:idlepb.GetRoleVipShopDataAck.data)
  return _msg;
}
inline void GetRoleVipShopDataAck::set_allocated_data(::idlepb::RoleVipShopData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:idlepb.GetRoleVipShopDataAck.data)
}

// -------------------------------------------------------------------

// VipShopBuyReq

// int32 index = 1;
inline void VipShopBuyReq::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t VipShopBuyReq::_internal_index() const {
  return _impl_.index_;
}
inline int32_t VipShopBuyReq::index() const {
  // @@protoc_insertion_point(field_get:idlepb.VipShopBuyReq.index)
  return _internal_index();
}
inline void VipShopBuyReq::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void VipShopBuyReq::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:idlepb.VipShopBuyReq.index)
}

// int32 num = 2;
inline void VipShopBuyReq::clear_num() {
  _impl_.num_ = 0;
}
inline int32_t VipShopBuyReq::_internal_num() const {
  return _impl_.num_;
}
inline int32_t VipShopBuyReq::num() const {
  // @@protoc_insertion_point(field_get:idlepb.VipShopBuyReq.num)
  return _internal_num();
}
inline void VipShopBuyReq::_internal_set_num(int32_t value) {
  
  _impl_.num_ = value;
}
inline void VipShopBuyReq::set_num(int32_t value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:idlepb.VipShopBuyReq.num)
}

// -------------------------------------------------------------------

// VipShopBuyAck

// bool ok = 1;
inline void VipShopBuyAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool VipShopBuyAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool VipShopBuyAck::ok() const {
  // @@protoc_insertion_point(field_get:idlepb.VipShopBuyAck.ok)
  return _internal_ok();
}
inline void VipShopBuyAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void VipShopBuyAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:idlepb.VipShopBuyAck.ok)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace idlepb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::idlepb::UseItemResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::UseItemResult>() {
  return ::idlepb::UseItemResult_descriptor();
}
template <> struct is_proto_enum< ::idlepb::RoleCollectionOpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::RoleCollectionOpType>() {
  return ::idlepb::RoleCollectionOpType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::SetFightModeAckErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::SetFightModeAckErrorCode>() {
  return ::idlepb::SetFightModeAckErrorCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_game_2eproto
