// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: defines.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_defines_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_defines_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_defines_2eproto MPROTOCOL_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct MPROTOCOL_API TableStruct_defines_2eproto {
  static const uint32_t offsets[];
};
MPROTOCOL_API extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_defines_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace idlepb {

enum ItemQuality : int {
  EQ_None = 0,
  EQ_White = 1,
  EQ_Green = 2,
  EQ_Blue = 3,
  EQ_Purple = 4,
  EQ_Orange = 5,
  EQ_Red = 6,
  ItemQuality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemQuality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool ItemQuality_IsValid(int value);
constexpr ItemQuality ItemQuality_MIN = EQ_None;
constexpr ItemQuality ItemQuality_MAX = EQ_Red;
constexpr int ItemQuality_ARRAYSIZE = ItemQuality_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemQuality_descriptor();
template<typename T>
inline const std::string& ItemQuality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemQuality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemQuality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemQuality_descriptor(), enum_t_value);
}
inline bool ItemQuality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemQuality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemQuality>(
    ItemQuality_descriptor(), name, value);
}
enum ItemShowType : int {
  ItemShowType_None = 0,
  ItemShowType_Equipment = 1,
  ItemShowType_Pill = 2,
  ItemShowType_Material = 3,
  ItemShowType_Special = 4,
  ItemShowType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemShowType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool ItemShowType_IsValid(int value);
constexpr ItemShowType ItemShowType_MIN = ItemShowType_None;
constexpr ItemShowType ItemShowType_MAX = ItemShowType_Special;
constexpr int ItemShowType_ARRAYSIZE = ItemShowType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemShowType_descriptor();
template<typename T>
inline const std::string& ItemShowType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemShowType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemShowType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemShowType_descriptor(), enum_t_value);
}
inline bool ItemShowType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemShowType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemShowType>(
    ItemShowType_descriptor(), name, value);
}
enum ItemType : int {
  ItemType_None = 0,
  ItemType_ExpPill = 1,
  ItemType_Weapon = 2,
  ItemType_CLOTHING = 3,
  ItemType_JEWELRY = 4,
  ItemType_SkillEquipment = 5,
  ItemType_RecoverPill = 6,
  ItemType_SkillBook = 7,
  ItemType_SecretPill = 8,
  ItemType_AttrPill = 9,
  ItemType_BreakthroughPill = 10,
  ItemType_PillMaterial = 11,
  ItemType_WeaponMaterial = 12,
  ItemType_PillRecipe = 13,
  ItemType_EquipRecipe = 14,
  ItemType_ForgeMaterial = 15,
  ItemType_GiftPackage = 16,
  ItemType_SpaceMaterial = 17,
  ItemType_Seed = 18,
  ItemType_ShanHeTu = 20,
  ItemType_QiWen = 21,
  ItemType_QiLing = 22,
  ItemType_GuBao = 23,
  ItemType_GuBaoPiece = 24,
  ItemType_QiLingSkill = 25,
  ItemType_ZhuLingMeterial = 28,
  ItemType_FarmRipe = 36,
  ItemType_Token = 100,
  ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool ItemType_IsValid(int value);
constexpr ItemType ItemType_MIN = ItemType_None;
constexpr ItemType ItemType_MAX = ItemType_Token;
constexpr int ItemType_ARRAYSIZE = ItemType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemType_descriptor();
template<typename T>
inline const std::string& ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemType_descriptor(), enum_t_value);
}
inline bool ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemType>(
    ItemType_descriptor(), name, value);
}
enum EquipmentMainType : int {
  EquipmentMainType_None = 0,
  EquipmentMainType_Weapon = 1,
  EquipmentMainType_CLOTHING = 2,
  EquipmentMainType_JEWELRY = 3,
  EquipmentMainType_AttSkillEquipment = 4,
  EquipmentMainType_DefSkillEquipment = 5,
  EquipmentMainType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EquipmentMainType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool EquipmentMainType_IsValid(int value);
constexpr EquipmentMainType EquipmentMainType_MIN = EquipmentMainType_None;
constexpr EquipmentMainType EquipmentMainType_MAX = EquipmentMainType_DefSkillEquipment;
constexpr int EquipmentMainType_ARRAYSIZE = EquipmentMainType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EquipmentMainType_descriptor();
template<typename T>
inline const std::string& EquipmentMainType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EquipmentMainType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EquipmentMainType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EquipmentMainType_descriptor(), enum_t_value);
}
inline bool EquipmentMainType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EquipmentMainType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EquipmentMainType>(
    EquipmentMainType_descriptor(), name, value);
}
enum PerkValueAddType : int {
  PerkValueAddType_None = 0,
  PerkValueAddType_Add = 1,
  PerkValueAddType_Sub = 2,
  PerkValueAddType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PerkValueAddType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool PerkValueAddType_IsValid(int value);
constexpr PerkValueAddType PerkValueAddType_MIN = PerkValueAddType_None;
constexpr PerkValueAddType PerkValueAddType_MAX = PerkValueAddType_Sub;
constexpr int PerkValueAddType_ARRAYSIZE = PerkValueAddType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerkValueAddType_descriptor();
template<typename T>
inline const std::string& PerkValueAddType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PerkValueAddType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PerkValueAddType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PerkValueAddType_descriptor(), enum_t_value);
}
inline bool PerkValueAddType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PerkValueAddType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerkValueAddType>(
    PerkValueAddType_descriptor(), name, value);
}
enum PerkValueEffectType : int {
  PerkValueEffectType_None = 0,
  PerkValueEffectType_EquipmentBasicAttribute = 1,
  PerkValueEffectType_Attack = 2,
  PerkValueEffectType_HpMp = 3,
  PerkValueEffectType_Defence = 4,
  PerkValueEffectType_CritAndCritDef = 5,
  PerkValueEffectType_CritCoeff = 6,
  PerkValueEffectType_StrengthIntellect = 7,
  PerkValueEffectType_RecoverPercent = 8,
  PerkValueEffectType_Agility = 9,
  PerkValueEffectType_DodgeHit = 10,
  PerkValueEffectType_MoveSpeed = 11,
  PerkValueEffectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PerkValueEffectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool PerkValueEffectType_IsValid(int value);
constexpr PerkValueEffectType PerkValueEffectType_MIN = PerkValueEffectType_None;
constexpr PerkValueEffectType PerkValueEffectType_MAX = PerkValueEffectType_MoveSpeed;
constexpr int PerkValueEffectType_ARRAYSIZE = PerkValueEffectType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerkValueEffectType_descriptor();
template<typename T>
inline const std::string& PerkValueEffectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PerkValueEffectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PerkValueEffectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PerkValueEffectType_descriptor(), enum_t_value);
}
inline bool PerkValueEffectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PerkValueEffectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerkValueEffectType>(
    PerkValueEffectType_descriptor(), name, value);
}
enum PerkIdConsts : int {
  PerkIdConsts_None = 0,
  PerkIdConsts_EquipmentBasicAttribute = 1,
  PerkIdConsts_MagAttack = 2,
  PerkIdConsts_PhyAttack = 3,
  PerkIdConsts_Hp = 4,
  PerkIdConsts_Mp = 5,
  PerkIdConsts_PhyDefence = 6,
  PerkIdConsts_MagDefence = 7,
  PerkIdConsts_Crit = 8,
  PerkIdConsts_CritCoeff = 9,
  PerkIdConsts_Strength = 11,
  PerkIdConsts_Intellect = 12,
  PerkIdConsts_MpRecoverPercent = 13,
  PerkIdConsts_HpRecoverPercent = 14,
  PerkIdConsts_Agility = 15,
  PerkIdConsts_MagDodge = 16,
  PerkIdConsts_PhyDodge = 17,
  PerkIdConsts_CritDef = 18,
  PerkIdConsts_PhyHit = 19,
  PerkIdConsts_MagHit = 20,
  PerkIdConsts_MoveSpeed = 25,
  PerkIdConsts_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PerkIdConsts_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool PerkIdConsts_IsValid(int value);
constexpr PerkIdConsts PerkIdConsts_MIN = PerkIdConsts_None;
constexpr PerkIdConsts PerkIdConsts_MAX = PerkIdConsts_MoveSpeed;
constexpr int PerkIdConsts_ARRAYSIZE = PerkIdConsts_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerkIdConsts_descriptor();
template<typename T>
inline const std::string& PerkIdConsts_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PerkIdConsts>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PerkIdConsts_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PerkIdConsts_descriptor(), enum_t_value);
}
inline bool PerkIdConsts_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PerkIdConsts* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerkIdConsts>(
    PerkIdConsts_descriptor(), name, value);
}
enum EquipmentSlotState : int {
  EquipmentSlotState_Locked = 0,
  EquipmentSlotState_ToUnlock = 1,
  EquipmentSlotState_UnlockNoEquip = 2,
  EquipmentSlotState_UnlockEquipInBag = 3,
  EquipmentSlotState_Slotted = 4,
  EquipmentSlotState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EquipmentSlotState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool EquipmentSlotState_IsValid(int value);
constexpr EquipmentSlotState EquipmentSlotState_MIN = EquipmentSlotState_Locked;
constexpr EquipmentSlotState EquipmentSlotState_MAX = EquipmentSlotState_Slotted;
constexpr int EquipmentSlotState_ARRAYSIZE = EquipmentSlotState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EquipmentSlotState_descriptor();
template<typename T>
inline const std::string& EquipmentSlotState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EquipmentSlotState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EquipmentSlotState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EquipmentSlotState_descriptor(), enum_t_value);
}
inline bool EquipmentSlotState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EquipmentSlotState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EquipmentSlotState>(
    EquipmentSlotState_descriptor(), name, value);
}
enum EquipmentSlotWearType : int {
  ESWT_Equipment = 0,
  ESWT_Collection = 1,
  EquipmentSlotWearType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EquipmentSlotWearType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool EquipmentSlotWearType_IsValid(int value);
constexpr EquipmentSlotWearType EquipmentSlotWearType_MIN = ESWT_Equipment;
constexpr EquipmentSlotWearType EquipmentSlotWearType_MAX = ESWT_Collection;
constexpr int EquipmentSlotWearType_ARRAYSIZE = EquipmentSlotWearType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EquipmentSlotWearType_descriptor();
template<typename T>
inline const std::string& EquipmentSlotWearType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EquipmentSlotWearType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EquipmentSlotWearType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EquipmentSlotWearType_descriptor(), enum_t_value);
}
inline bool EquipmentSlotWearType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EquipmentSlotWearType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EquipmentSlotWearType>(
    EquipmentSlotWearType_descriptor(), name, value);
}
enum AlchemyChanceType : int {
  AlchemyChanceType_Normal = 0,
  AlchemyChanceType_Small = 1,
  AlchemyChanceType_Big = 2,
  AlchemyChanceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AlchemyChanceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool AlchemyChanceType_IsValid(int value);
constexpr AlchemyChanceType AlchemyChanceType_MIN = AlchemyChanceType_Normal;
constexpr AlchemyChanceType AlchemyChanceType_MAX = AlchemyChanceType_Big;
constexpr int AlchemyChanceType_ARRAYSIZE = AlchemyChanceType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AlchemyChanceType_descriptor();
template<typename T>
inline const std::string& AlchemyChanceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AlchemyChanceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AlchemyChanceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AlchemyChanceType_descriptor(), enum_t_value);
}
inline bool AlchemyChanceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AlchemyChanceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AlchemyChanceType>(
    AlchemyChanceType_descriptor(), name, value);
}
enum PillType : int {
  PillType_None = 0,
  PillType_Hp = 1,
  PillType_Mp = 2,
  PillType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PillType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool PillType_IsValid(int value);
constexpr PillType PillType_MIN = PillType_None;
constexpr PillType PillType_MAX = PillType_Mp;
constexpr int PillType_ARRAYSIZE = PillType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PillType_descriptor();
template<typename T>
inline const std::string& PillType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PillType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PillType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PillType_descriptor(), enum_t_value);
}
inline bool PillType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PillType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PillType>(
    PillType_descriptor(), name, value);
}
enum CultivationDirection : int {
  CD_None = 0,
  CD_Physic = 1,
  CD_Magic = 2,
  CultivationDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CultivationDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool CultivationDirection_IsValid(int value);
constexpr CultivationDirection CultivationDirection_MIN = CD_None;
constexpr CultivationDirection CultivationDirection_MAX = CD_Magic;
constexpr int CultivationDirection_ARRAYSIZE = CultivationDirection_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CultivationDirection_descriptor();
template<typename T>
inline const std::string& CultivationDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CultivationDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CultivationDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CultivationDirection_descriptor(), enum_t_value);
}
inline bool CultivationDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CultivationDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CultivationDirection>(
    CultivationDirection_descriptor(), name, value);
}
enum BreakthroughType : int {
  BT_None = 0,
  BT_Layer = 1,
  BT_Stage = 2,
  BT_Degree = 3,
  BreakthroughType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BreakthroughType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool BreakthroughType_IsValid(int value);
constexpr BreakthroughType BreakthroughType_MIN = BT_None;
constexpr BreakthroughType BreakthroughType_MAX = BT_Degree;
constexpr int BreakthroughType_ARRAYSIZE = BreakthroughType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BreakthroughType_descriptor();
template<typename T>
inline const std::string& BreakthroughType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BreakthroughType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BreakthroughType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BreakthroughType_descriptor(), enum_t_value);
}
inline bool BreakthroughType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BreakthroughType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BreakthroughType>(
    BreakthroughType_descriptor(), name, value);
}
enum WorldType : int {
  WT_None = 0,
  WT_ClientOnly = 1,
  WT_Arena = 2,
  WT_Door = 3,
  WT_MonsterTower = 4,
  WT_SoloArena = 5,
  WT_SeptArena = 6,
  WT_QuestFight = 7,
  WT_DungeonKillAll = 8,
  WT_DungeonSurvive = 9,
  WT_SeptDemon = 10,
  WorldType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WorldType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool WorldType_IsValid(int value);
constexpr WorldType WorldType_MIN = WT_None;
constexpr WorldType WorldType_MAX = WT_SeptDemon;
constexpr int WorldType_ARRAYSIZE = WorldType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorldType_descriptor();
template<typename T>
inline const std::string& WorldType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorldType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorldType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorldType_descriptor(), enum_t_value);
}
inline bool WorldType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorldType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorldType>(
    WorldType_descriptor(), name, value);
}
enum EntityType : int {
  ET_Unknown = 0,
  ET_Player = 1,
  ET_Npc = 2,
  EntityType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EntityType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool EntityType_IsValid(int value);
constexpr EntityType EntityType_MIN = ET_Unknown;
constexpr EntityType EntityType_MAX = ET_Npc;
constexpr int EntityType_ARRAYSIZE = EntityType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntityType_descriptor();
template<typename T>
inline const std::string& EntityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EntityType_descriptor(), enum_t_value);
}
inline bool EntityType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EntityType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EntityType>(
    EntityType_descriptor(), name, value);
}
enum EntityState : int {
  ES_None = 0,
  ES_Init = 1,
  ES_Normal = 2,
  ES_Death = 3,
  ES_Recycle = 4,
  EntityState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EntityState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool EntityState_IsValid(int value);
constexpr EntityState EntityState_MIN = ES_None;
constexpr EntityState EntityState_MAX = ES_Recycle;
constexpr int EntityState_ARRAYSIZE = EntityState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntityState_descriptor();
template<typename T>
inline const std::string& EntityState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntityState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntityState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EntityState_descriptor(), enum_t_value);
}
inline bool EntityState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EntityState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EntityState>(
    EntityState_descriptor(), name, value);
}
enum NpcType : int {
  NpcType_None = 0,
  NpcType_Function = 1,
  NpcType_Monster = 2,
  NpcType_SeptStone = 3,
  NpcType_SeptLand = 4,
  NpcType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NpcType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool NpcType_IsValid(int value);
constexpr NpcType NpcType_MIN = NpcType_None;
constexpr NpcType NpcType_MAX = NpcType_SeptLand;
constexpr int NpcType_ARRAYSIZE = NpcType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NpcType_descriptor();
template<typename T>
inline const std::string& NpcType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NpcType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NpcType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NpcType_descriptor(), enum_t_value);
}
inline bool NpcType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NpcType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NpcType>(
    NpcType_descriptor(), name, value);
}
enum MonsterType : int {
  MonsterType_None = 0,
  MonsterType_Normal = 1,
  MonsterType_Elite = 2,
  MonsterType_Chief = 3,
  MonsterType_SuperBoss = 4,
  MonsterType_SeptDemon = 5,
  MonsterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MonsterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool MonsterType_IsValid(int value);
constexpr MonsterType MonsterType_MIN = MonsterType_None;
constexpr MonsterType MonsterType_MAX = MonsterType_SeptDemon;
constexpr int MonsterType_ARRAYSIZE = MonsterType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MonsterType_descriptor();
template<typename T>
inline const std::string& MonsterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MonsterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MonsterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MonsterType_descriptor(), enum_t_value);
}
inline bool MonsterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MonsterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MonsterType>(
    MonsterType_descriptor(), name, value);
}
enum CurrencyType : int {
  CurrencyType_None = 0,
  CurrencyType_Money = 1,
  CurrencyType_Soul = 2,
  CurrencyType_Gold = 3,
  CurrencyType_Item = 4,
  CurrencyType_AbilityActivePoint = 5,
  CurrencyType_AbilityUpgradePoint = 6,
  CurrencyType_KungfuPoint = 7,
  CurrencyType_TreasureToken = 8,
  CurrencyType_ChaosStone = 9,
  CurrencyType_StudyPoint = 10,
  CurrencyType_NingWenGem = 11,
  CurrencyType_HeroCard = 12,
  CurrencyType_SeptDonation = 13,
  CurrencyType_SeptStone = 14,
  CurrencyType_SeptQuestExp = 15,
  CurrencyType_SeptQuestToken = 16,
  CurrencyType_GongFaToken = 17,
  CurrencyType_GachaTokenL1 = 18,
  CurrencyType_GachaTokenL2 = 19,
  CurrencyType_GachaTokenL3 = 20,
  CurrencyType_GachaTokenL4 = 21,
  CurrencyType_GachaTokenL5 = 22,
  CurrencyType_TreasuryChest01 = 23,
  CurrencyType_TreasuryChest02 = 24,
  CurrencyType_TreasuryChest03 = 25,
  CurrencyType_TreasuryChest04 = 26,
  CurrencyType_TreasuryChest05 = 27,
  CurrencyType_TreasuryChest06 = 28,
  CurrencyType_TreasuryChest07 = 29,
  CurrencyType_TreasuryChest08 = 30,
  CurrencyType_AppearanceMoney = 31,
  CurrencyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CurrencyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool CurrencyType_IsValid(int value);
constexpr CurrencyType CurrencyType_MIN = CurrencyType_None;
constexpr CurrencyType CurrencyType_MAX = CurrencyType_AppearanceMoney;
constexpr int CurrencyType_ARRAYSIZE = CurrencyType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CurrencyType_descriptor();
template<typename T>
inline const std::string& CurrencyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CurrencyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CurrencyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CurrencyType_descriptor(), enum_t_value);
}
inline bool CurrencyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CurrencyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CurrencyType>(
    CurrencyType_descriptor(), name, value);
}
enum SoloType : int {
  SoloType_None = 0,
  SoloType_FriendlyPk = 1,
  SoloType_SwordPk = 2,
  SoloType_SwordPkRevenge = 3,
  SoloType_RobberySeptStone = 4,
  SoloType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SoloType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool SoloType_IsValid(int value);
constexpr SoloType SoloType_MIN = SoloType_None;
constexpr SoloType SoloType_MAX = SoloType_RobberySeptStone;
constexpr int SoloType_ARRAYSIZE = SoloType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SoloType_descriptor();
template<typename T>
inline const std::string& SoloType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SoloType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SoloType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SoloType_descriptor(), enum_t_value);
}
inline bool SoloType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SoloType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SoloType>(
    SoloType_descriptor(), name, value);
}
enum QuestRequirementType : int {
  QT_Kill = 0,
  QT_Get = 1,
  QT_Submit = 2,
  QT_Rank = 3,
  QT_Event = 4,
  QT_Alchemy = 5,
  QT_AlchemyRank = 6,
  QT_SkillRank = 7,
  QT_Forge = 8,
  QT_ForgeRank = 9,
  QT_ArenaDoor = 10,
  QT_MonsterTower = 11,
  QT_QiCollector = 12,
  QT_GongFa = 13,
  QT_QuestFight = 14,
  QT_SkillDegree = 15,
  QT_GongFaDegree = 16,
  QT_CollectorQuality = 17,
  QT_JoinSept = 18,
  QT_FarmlandSeed = 19,
  QuestRequirementType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QuestRequirementType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool QuestRequirementType_IsValid(int value);
constexpr QuestRequirementType QuestRequirementType_MIN = QT_Kill;
constexpr QuestRequirementType QuestRequirementType_MAX = QT_FarmlandSeed;
constexpr int QuestRequirementType_ARRAYSIZE = QuestRequirementType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestRequirementType_descriptor();
template<typename T>
inline const std::string& QuestRequirementType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestRequirementType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestRequirementType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestRequirementType_descriptor(), enum_t_value);
}
inline bool QuestRequirementType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestRequirementType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestRequirementType>(
    QuestRequirementType_descriptor(), name, value);
}
enum QuestOpType : int {
  QOp_Accept = 0,
  QOp_Finish = 1,
  QOp_GiveUp = 2,
  QuestOpType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QuestOpType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool QuestOpType_IsValid(int value);
constexpr QuestOpType QuestOpType_MIN = QOp_Accept;
constexpr QuestOpType QuestOpType_MAX = QOp_GiveUp;
constexpr int QuestOpType_ARRAYSIZE = QuestOpType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestOpType_descriptor();
template<typename T>
inline const std::string& QuestOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestOpType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestOpType_descriptor(), enum_t_value);
}
inline bool QuestOpType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestOpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestOpType>(
    QuestOpType_descriptor(), name, value);
}
enum QuestSpecialRewardType : int {
  QSRT_FarmerFriendShip = 0,
  QuestSpecialRewardType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QuestSpecialRewardType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool QuestSpecialRewardType_IsValid(int value);
constexpr QuestSpecialRewardType QuestSpecialRewardType_MIN = QSRT_FarmerFriendShip;
constexpr QuestSpecialRewardType QuestSpecialRewardType_MAX = QSRT_FarmerFriendShip;
constexpr int QuestSpecialRewardType_ARRAYSIZE = QuestSpecialRewardType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestSpecialRewardType_descriptor();
template<typename T>
inline const std::string& QuestSpecialRewardType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestSpecialRewardType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestSpecialRewardType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestSpecialRewardType_descriptor(), enum_t_value);
}
inline bool QuestSpecialRewardType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestSpecialRewardType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestSpecialRewardType>(
    QuestSpecialRewardType_descriptor(), name, value);
}
enum LeaderboardType : int {
  LBT_Combat = 0,
  LBT_Magic = 1,
  LBT_Phy = 2,
  LBT_Rich = 3,
  LBT_Pet = 4,
  LBT_Sect = 5,
  LBT_Weapon = 6,
  LBT_Armor = 7,
  LBT_Jewelry = 8,
  LBT_Treasure = 9,
  LBT_Shanhetu = 10,
  LBT_Shanhetu_Week = 11,
  LBT_MonsterTower = 12,
  LBT_MainExp = 13,
  LBT_MaxNum = 14,
  LeaderboardType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LeaderboardType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool LeaderboardType_IsValid(int value);
constexpr LeaderboardType LeaderboardType_MIN = LBT_Combat;
constexpr LeaderboardType LeaderboardType_MAX = LBT_MaxNum;
constexpr int LeaderboardType_ARRAYSIZE = LeaderboardType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LeaderboardType_descriptor();
template<typename T>
inline const std::string& LeaderboardType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeaderboardType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeaderboardType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LeaderboardType_descriptor(), enum_t_value);
}
inline bool LeaderboardType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeaderboardType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LeaderboardType>(
    LeaderboardType_descriptor(), name, value);
}
enum AlchemyState : int {
  AlchemyState_None = 0,
  AlchemyState_Running = 1,
  AlchemyState_Done = 2,
  AlchemyState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AlchemyState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool AlchemyState_IsValid(int value);
constexpr AlchemyState AlchemyState_MIN = AlchemyState_None;
constexpr AlchemyState AlchemyState_MAX = AlchemyState_Done;
constexpr int AlchemyState_ARRAYSIZE = AlchemyState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AlchemyState_descriptor();
template<typename T>
inline const std::string& AlchemyState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AlchemyState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AlchemyState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AlchemyState_descriptor(), enum_t_value);
}
inline bool AlchemyState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AlchemyState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AlchemyState>(
    AlchemyState_descriptor(), name, value);
}
enum WorldState : int {
  WS_None = 0,
  WS_Init = 1,
  WS_Normal = 2,
  WS_Closing = 3,
  WS_Recycle = 4,
  WorldState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WorldState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool WorldState_IsValid(int value);
constexpr WorldState WorldState_MIN = WS_None;
constexpr WorldState WorldState_MAX = WS_Recycle;
constexpr int WorldState_ARRAYSIZE = WorldState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorldState_descriptor();
template<typename T>
inline const std::string& WorldState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorldState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorldState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorldState_descriptor(), enum_t_value);
}
inline bool WorldState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorldState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorldState>(
    WorldState_descriptor(), name, value);
}
enum GameStatsModuleType : int {
  GSMT_Summary = 0,
  GSMT_Base = 1,
  GSMT_CollectionBlue = 2,
  GSMT_CollectionPurple = 3,
  GSMT_CollectionOrange = 4,
  GSMT_CollectionRed = 5,
  GSMT_CollectionSuitBlue = 6,
  GSMT_CollectionSuitPurple = 7,
  GSMT_CollectionSuitOrange = 8,
  GSMT_CollectionSuitRed = 9,
  GSMT_EquipmentBase = 31,
  GSMT_EquipmentReinforce = 32,
  GSMT_EquipmentQiWen = 33,
  GSMT_EquipmentRefine = 34,
  GSMT_Debug = 50,
  GSMT_RankBreakthrough = 51,
  GSMT_RankPractice = 52,
  GSMT_Collection = 53,
  GSMT_CollectionSuit = 54,
  GSMT_PillElixir = 55,
  GSMT_PillProperty = 56,
  GSMT_GongFa = 57,
  GSMT_QiCollector = 58,
  GSMT_Sept = 59,
  GSMT_Equipment = 60,
  GSMT_Ability = 61,
  GSMT_EquipmentReinforceResonance = 62,
  GSMT_EquipmentQiWenResonance = 63,
  GSMT_Leaderboard = 91,
  GameStatsModuleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GameStatsModuleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool GameStatsModuleType_IsValid(int value);
constexpr GameStatsModuleType GameStatsModuleType_MIN = GSMT_Summary;
constexpr GameStatsModuleType GameStatsModuleType_MAX = GSMT_Leaderboard;
constexpr int GameStatsModuleType_ARRAYSIZE = GameStatsModuleType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameStatsModuleType_descriptor();
template<typename T>
inline const std::string& GameStatsModuleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameStatsModuleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameStatsModuleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameStatsModuleType_descriptor(), enum_t_value);
}
inline bool GameStatsModuleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GameStatsModuleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameStatsModuleType>(
    GameStatsModuleType_descriptor(), name, value);
}
enum ItemStatsModuleType : int {
  ISMT_Equipment = 0,
  ISMT_Reinforce = 2,
  ISMT_QiWen = 3,
  ISMT_Refine = 4,
  ItemStatsModuleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemStatsModuleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool ItemStatsModuleType_IsValid(int value);
constexpr ItemStatsModuleType ItemStatsModuleType_MIN = ISMT_Equipment;
constexpr ItemStatsModuleType ItemStatsModuleType_MAX = ISMT_Refine;
constexpr int ItemStatsModuleType_ARRAYSIZE = ItemStatsModuleType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemStatsModuleType_descriptor();
template<typename T>
inline const std::string& ItemStatsModuleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemStatsModuleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemStatsModuleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemStatsModuleType_descriptor(), enum_t_value);
}
inline bool ItemStatsModuleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemStatsModuleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemStatsModuleType>(
    ItemStatsModuleType_descriptor(), name, value);
}
enum FunctionModuleState : int {
  FMS_Hide = 0,
  FMS_Show = 1,
  FMS_CanUnlock = 2,
  FMS_Unlocked = 3,
  FunctionModuleState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FunctionModuleState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool FunctionModuleState_IsValid(int value);
constexpr FunctionModuleState FunctionModuleState_MIN = FMS_Hide;
constexpr FunctionModuleState FunctionModuleState_MAX = FMS_Unlocked;
constexpr int FunctionModuleState_ARRAYSIZE = FunctionModuleState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FunctionModuleState_descriptor();
template<typename T>
inline const std::string& FunctionModuleState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FunctionModuleState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FunctionModuleState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FunctionModuleState_descriptor(), enum_t_value);
}
inline bool FunctionModuleState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FunctionModuleState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FunctionModuleState>(
    FunctionModuleState_descriptor(), name, value);
}
enum FunctionModuleType : int {
  FMT_None = 0,
  FMT_Alchemy = 1,
  FMT_Shop = 2,
  FMT_DeluxShop = 3,
  FMT_Leaderboard = 4,
  FMT_Mail = 5,
  FMT_Forge = 6,
  FMT_MonsterTower = 7,
  FMT_PillElixir = 8,
  FMT_Ability = 9,
  FMT_GuBao = 10,
  FMT_GongFa = 11,
  FMT_Share = 12,
  FMT_HuangZhuang = 13,
  FMT_ZhuangPei = 14,
  FMT_QiCollector = 15,
  FMT_Checklist = 16,
  FMT_SwordPk = 17,
  FMT_TreasuryChest = 18,
  FMT_Appearance = 19,
  FMT_Farm = 20,
  FMT_Avatar = 21,
  FMT_Biography = 22,
  FMT_BiographyEvent = 23,
  FMT_VipShop = 24,
  FunctionModuleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FunctionModuleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool FunctionModuleType_IsValid(int value);
constexpr FunctionModuleType FunctionModuleType_MIN = FMT_None;
constexpr FunctionModuleType FunctionModuleType_MAX = FMT_VipShop;
constexpr int FunctionModuleType_ARRAYSIZE = FunctionModuleType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FunctionModuleType_descriptor();
template<typename T>
inline const std::string& FunctionModuleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FunctionModuleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FunctionModuleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FunctionModuleType_descriptor(), enum_t_value);
}
inline bool FunctionModuleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FunctionModuleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FunctionModuleType>(
    FunctionModuleType_descriptor(), name, value);
}
enum FunctionModuleUnlockType : int {
  FMUT_Click = 0,
  FMUT_Auto = 1,
  FunctionModuleUnlockType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FunctionModuleUnlockType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool FunctionModuleUnlockType_IsValid(int value);
constexpr FunctionModuleUnlockType FunctionModuleUnlockType_MIN = FMUT_Click;
constexpr FunctionModuleUnlockType FunctionModuleUnlockType_MAX = FMUT_Auto;
constexpr int FunctionModuleUnlockType_ARRAYSIZE = FunctionModuleUnlockType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FunctionModuleUnlockType_descriptor();
template<typename T>
inline const std::string& FunctionModuleUnlockType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FunctionModuleUnlockType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FunctionModuleUnlockType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FunctionModuleUnlockType_descriptor(), enum_t_value);
}
inline bool FunctionModuleUnlockType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FunctionModuleUnlockType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FunctionModuleUnlockType>(
    FunctionModuleUnlockType_descriptor(), name, value);
}
enum MailType : int {
  MT_System = 0,
  MT_Maintenance = 1,
  MT_Official = 2,
  MailType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MailType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool MailType_IsValid(int value);
constexpr MailType MailType_MIN = MT_System;
constexpr MailType MailType_MAX = MT_Official;
constexpr int MailType_ARRAYSIZE = MailType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MailType_descriptor();
template<typename T>
inline const std::string& MailType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MailType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MailType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MailType_descriptor(), enum_t_value);
}
inline bool MailType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MailType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MailType>(
    MailType_descriptor(), name, value);
}
enum MailOperation : int {
  MOP_Fail = 0,
  MOP_Done = 1,
  MOP_InventoryIsFull = 2,
  MailOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MailOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool MailOperation_IsValid(int value);
constexpr MailOperation MailOperation_MIN = MOP_Fail;
constexpr MailOperation MailOperation_MAX = MOP_InventoryIsFull;
constexpr int MailOperation_ARRAYSIZE = MailOperation_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MailOperation_descriptor();
template<typename T>
inline const std::string& MailOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MailOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MailOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MailOperation_descriptor(), enum_t_value);
}
inline bool MailOperation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MailOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MailOperation>(
    MailOperation_descriptor(), name, value);
}
enum ChatMessageType : int {
  CMT_Normal = 0,
  CMT_SystemNotice = 1,
  ChatMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool ChatMessageType_IsValid(int value);
constexpr ChatMessageType ChatMessageType_MIN = CMT_Normal;
constexpr ChatMessageType ChatMessageType_MAX = CMT_SystemNotice;
constexpr int ChatMessageType_ARRAYSIZE = ChatMessageType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatMessageType_descriptor();
template<typename T>
inline const std::string& ChatMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatMessageType_descriptor(), enum_t_value);
}
inline bool ChatMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatMessageType>(
    ChatMessageType_descriptor(), name, value);
}
enum ChatMessageChannel : int {
  CMC_ColonyServers = 0,
  CMC_QuadServers = 1,
  CMC_LocalServer = 2,
  CMC_Organization = 3,
  CMC_Private = 4,
  ChatMessageChannel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatMessageChannel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool ChatMessageChannel_IsValid(int value);
constexpr ChatMessageChannel ChatMessageChannel_MIN = CMC_ColonyServers;
constexpr ChatMessageChannel ChatMessageChannel_MAX = CMC_Private;
constexpr int ChatMessageChannel_ARRAYSIZE = ChatMessageChannel_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatMessageChannel_descriptor();
template<typename T>
inline const std::string& ChatMessageChannel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatMessageChannel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatMessageChannel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatMessageChannel_descriptor(), enum_t_value);
}
inline bool ChatMessageChannel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatMessageChannel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatMessageChannel>(
    ChatMessageChannel_descriptor(), name, value);
}
enum ForgeChanceType : int {
  ForgeChanceType_Normal = 0,
  ForgeChanceType_Small = 1,
  ForgeChanceType_Big = 2,
  ForgeChanceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ForgeChanceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool ForgeChanceType_IsValid(int value);
constexpr ForgeChanceType ForgeChanceType_MIN = ForgeChanceType_Normal;
constexpr ForgeChanceType ForgeChanceType_MAX = ForgeChanceType_Big;
constexpr int ForgeChanceType_ARRAYSIZE = ForgeChanceType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ForgeChanceType_descriptor();
template<typename T>
inline const std::string& ForgeChanceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ForgeChanceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ForgeChanceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ForgeChanceType_descriptor(), enum_t_value);
}
inline bool ForgeChanceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ForgeChanceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ForgeChanceType>(
    ForgeChanceType_descriptor(), name, value);
}
enum ForgeState : int {
  ForgeState_None = 0,
  ForgeState_Running = 1,
  ForgeState_Done = 2,
  ForgeState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ForgeState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool ForgeState_IsValid(int value);
constexpr ForgeState ForgeState_MIN = ForgeState_None;
constexpr ForgeState ForgeState_MAX = ForgeState_Done;
constexpr int ForgeState_ARRAYSIZE = ForgeState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ForgeState_descriptor();
template<typename T>
inline const std::string& ForgeState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ForgeState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ForgeState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ForgeState_descriptor(), enum_t_value);
}
inline bool ForgeState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ForgeState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ForgeState>(
    ForgeState_descriptor(), name, value);
}
enum PillElixirType : int {
  PillElixirType_Other = 0,
  PillElixirType_Exp = 1,
  PillElixirType_Property = 2,
  PillElixirType_Double = 3,
  PillElixirType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PillElixirType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool PillElixirType_IsValid(int value);
constexpr PillElixirType PillElixirType_MIN = PillElixirType_Other;
constexpr PillElixirType PillElixirType_MAX = PillElixirType_Double;
constexpr int PillElixirType_ARRAYSIZE = PillElixirType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PillElixirType_descriptor();
template<typename T>
inline const std::string& PillElixirType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PillElixirType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PillElixirType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PillElixirType_descriptor(), enum_t_value);
}
inline bool PillElixirType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PillElixirType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PillElixirType>(
    PillElixirType_descriptor(), name, value);
}
enum PillElixrEffectType : int {
  PillElixrEffectType_None = 0,
  PillElixrEffectType_PhyExp = 1,
  PillElixrEffectType_MagicExp = 2,
  PillElixrEffectType_CriticalResist = 3,
  PillElixrEffectType_Critical = 4,
  PillElixrEffectType_MagicDodge = 5,
  PillElixrEffectType_MagicAccuraccy = 6,
  PillElixrEffectType_PhyDodge = 7,
  PillElixrEffectType_PhyAccuraccy = 8,
  PillElixrEffectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PillElixrEffectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool PillElixrEffectType_IsValid(int value);
constexpr PillElixrEffectType PillElixrEffectType_MIN = PillElixrEffectType_None;
constexpr PillElixrEffectType PillElixrEffectType_MAX = PillElixrEffectType_PhyAccuraccy;
constexpr int PillElixrEffectType_ARRAYSIZE = PillElixrEffectType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PillElixrEffectType_descriptor();
template<typename T>
inline const std::string& PillElixrEffectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PillElixrEffectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PillElixrEffectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PillElixrEffectType_descriptor(), enum_t_value);
}
inline bool PillElixrEffectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PillElixrEffectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PillElixrEffectType>(
    PillElixrEffectType_descriptor(), name, value);
}
enum PlayerAbilityActionResult : int {
  PlayerAbilityAction_Success = 0,
  PlayerAbilityAction_Timeout = 1,
  PlayerAbilityAction_InvalidAbility = 2,
  PlayerAbilityAction_GiveFailed_ExistAlready = 10,
  PlayerAbilityAction_GiveFailed_OwnerFailed = 11,
  PlayerAbilityAction_UpgradeFailed_NonExist = 20,
  PlayerAbilityAction_UpgradeFailed_MaxGrade = 21,
  PlayerAbilityAction_UpgradeFailed_OwnerFailed = 22,
  PlayerAbilityAction_ResetAll_CoolDown = 50,
  PlayerAbilityActionResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerAbilityActionResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool PlayerAbilityActionResult_IsValid(int value);
constexpr PlayerAbilityActionResult PlayerAbilityActionResult_MIN = PlayerAbilityAction_Success;
constexpr PlayerAbilityActionResult PlayerAbilityActionResult_MAX = PlayerAbilityAction_ResetAll_CoolDown;
constexpr int PlayerAbilityActionResult_ARRAYSIZE = PlayerAbilityActionResult_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerAbilityActionResult_descriptor();
template<typename T>
inline const std::string& PlayerAbilityActionResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerAbilityActionResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerAbilityActionResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerAbilityActionResult_descriptor(), enum_t_value);
}
inline bool PlayerAbilityActionResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerAbilityActionResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerAbilityActionResult>(
    PlayerAbilityActionResult_descriptor(), name, value);
}
enum FightMode : int {
  FightMode_Peace = 0,
  FightMode_All = 1,
  FightMode_Sept = 2,
  FightMode_Neutral = 3,
  FightMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FightMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool FightMode_IsValid(int value);
constexpr FightMode FightMode_MIN = FightMode_Peace;
constexpr FightMode FightMode_MAX = FightMode_Neutral;
constexpr int FightMode_ARRAYSIZE = FightMode_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FightMode_descriptor();
template<typename T>
inline const std::string& FightMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FightMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FightMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FightMode_descriptor(), enum_t_value);
}
inline bool FightMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FightMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FightMode>(
    FightMode_descriptor(), name, value);
}
enum AttackLockType : int {
  AttackLockType_MinDistance = 0,
  AttackLockType_LowHpPct = 1,
  AttackLockType_LowHpMpValue = 2,
  AttackLockType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AttackLockType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool AttackLockType_IsValid(int value);
constexpr AttackLockType AttackLockType_MIN = AttackLockType_MinDistance;
constexpr AttackLockType AttackLockType_MAX = AttackLockType_LowHpMpValue;
constexpr int AttackLockType_ARRAYSIZE = AttackLockType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AttackLockType_descriptor();
template<typename T>
inline const std::string& AttackLockType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AttackLockType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AttackLockType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AttackLockType_descriptor(), enum_t_value);
}
inline bool AttackLockType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttackLockType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AttackLockType>(
    AttackLockType_descriptor(), name, value);
}
enum AttackUnlockType : int {
  AttackUnlockType_MaxDistance = 0,
  AttackUnlockType_NearDistance = 1,
  AttackUnlockType_Screen = 2,
  AttackUnlockType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AttackUnlockType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool AttackUnlockType_IsValid(int value);
constexpr AttackUnlockType AttackUnlockType_MIN = AttackUnlockType_MaxDistance;
constexpr AttackUnlockType AttackUnlockType_MAX = AttackUnlockType_Screen;
constexpr int AttackUnlockType_ARRAYSIZE = AttackUnlockType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AttackUnlockType_descriptor();
template<typename T>
inline const std::string& AttackUnlockType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AttackUnlockType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AttackUnlockType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AttackUnlockType_descriptor(), enum_t_value);
}
inline bool AttackUnlockType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttackUnlockType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AttackUnlockType>(
    AttackUnlockType_descriptor(), name, value);
}
enum BossInvasionState : int {
  BossInvasionState_None = 0,
  BossInvasionState_Wait = 1,
  BossInvasionState_Prepare = 2,
  BossInvasionState_Fight = 3,
  BossInvasionState_End = 4,
  BossInvasionState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BossInvasionState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool BossInvasionState_IsValid(int value);
constexpr BossInvasionState BossInvasionState_MIN = BossInvasionState_None;
constexpr BossInvasionState BossInvasionState_MAX = BossInvasionState_End;
constexpr int BossInvasionState_ARRAYSIZE = BossInvasionState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BossInvasionState_descriptor();
template<typename T>
inline const std::string& BossInvasionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BossInvasionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BossInvasionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BossInvasionState_descriptor(), enum_t_value);
}
inline bool BossInvasionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BossInvasionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BossInvasionState>(
    BossInvasionState_descriptor(), name, value);
}
enum SwordPkState : int {
  SwordPkState_None = 0,
  SwordPkState_Init = 1,
  SwordPkState_SeasonBegin = 2,
  SwordPkState_SeasonDuring = 3,
  SwordPkState_SeasonEnd = 4,
  SwordPkState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SwordPkState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool SwordPkState_IsValid(int value);
constexpr SwordPkState SwordPkState_MIN = SwordPkState_None;
constexpr SwordPkState SwordPkState_MAX = SwordPkState_SeasonEnd;
constexpr int SwordPkState_ARRAYSIZE = SwordPkState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SwordPkState_descriptor();
template<typename T>
inline const std::string& SwordPkState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SwordPkState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SwordPkState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SwordPkState_descriptor(), enum_t_value);
}
inline bool SwordPkState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SwordPkState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SwordPkState>(
    SwordPkState_descriptor(), name, value);
}
enum CheckListTaskType : int {
  CLTT_None = 0,
  CLTT_Login = 1,
  CLTT_EatPill = 2,
  CLTT_Practice = 3,
  CLTT_BuyInMarket = 4,
  CLTT_MakePill = 5,
  CLTT_GongFa = 6,
  CLTT_MonsterTower = 7,
  CLTT_Portal = 8,
  CLTT_Plant = 9,
  CLTT_Forge = 10,
  CLTT_Ad = 11,
  CLTT_Ability = 12,
  CLTT_LocalPk = 13,
  CLTT_Bounty = 14,
  CLTT_Reinforce = 15,
  CLTT_CommonPk = 16,
  CLTT_BuyInDeluxShop = 17,
  CLTT_MonsterInvasion = 18,
  CLTT_WorldInvasion = 19,
  CLTT_Mine = 20,
  CLTT_SectContribution = 21,
  CLTT_Quiz = 22,
  CLTT_Share = 23,
  CLTT_MineTime = 24,
  CheckListTaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CheckListTaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool CheckListTaskType_IsValid(int value);
constexpr CheckListTaskType CheckListTaskType_MIN = CLTT_None;
constexpr CheckListTaskType CheckListTaskType_MAX = CLTT_MineTime;
constexpr int CheckListTaskType_ARRAYSIZE = CheckListTaskType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CheckListTaskType_descriptor();
template<typename T>
inline const std::string& CheckListTaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CheckListTaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CheckListTaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CheckListTaskType_descriptor(), enum_t_value);
}
inline bool CheckListTaskType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckListTaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CheckListTaskType>(
    CheckListTaskType_descriptor(), name, value);
}
enum SeptPosition : int {
  SeptPosition_None = 0,
  SeptPosition_Normal = 1,
  SeptPosition_Manager = 2,
  SeptPosition_Senator = 3,
  SeptPosition_ViceChairman = 4,
  SeptPosition_Chairman = 5,
  SeptPosition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SeptPosition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool SeptPosition_IsValid(int value);
constexpr SeptPosition SeptPosition_MIN = SeptPosition_None;
constexpr SeptPosition SeptPosition_MAX = SeptPosition_Chairman;
constexpr int SeptPosition_ARRAYSIZE = SeptPosition_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SeptPosition_descriptor();
template<typename T>
inline const std::string& SeptPosition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SeptPosition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SeptPosition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SeptPosition_descriptor(), enum_t_value);
}
inline bool SeptPosition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SeptPosition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SeptPosition>(
    SeptPosition_descriptor(), name, value);
}
enum SeptLogType : int {
  SLT_None = 0,
  SLT_Join = 1,
  SLT_Leave = 2,
  SLT_ChangeUp = 3,
  SLT_ChangeDown = 4,
  SeptLogType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SeptLogType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool SeptLogType_IsValid(int value);
constexpr SeptLogType SeptLogType_MIN = SLT_None;
constexpr SeptLogType SeptLogType_MAX = SLT_ChangeDown;
constexpr int SeptLogType_ARRAYSIZE = SeptLogType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SeptLogType_descriptor();
template<typename T>
inline const std::string& SeptLogType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SeptLogType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SeptLogType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SeptLogType_descriptor(), enum_t_value);
}
inline bool SeptLogType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SeptLogType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SeptLogType>(
    SeptLogType_descriptor(), name, value);
}
enum SeptArenaStoneType : int {
  SeptArenaStoneType_None = 0,
  SeptArenaStoneType_Primary = 1,
  SeptArenaStoneType_Intermediate = 2,
  SeptArenaStoneType_Advanced = 3,
  SeptArenaStoneType_Top = 4,
  SeptArenaStoneType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SeptArenaStoneType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool SeptArenaStoneType_IsValid(int value);
constexpr SeptArenaStoneType SeptArenaStoneType_MIN = SeptArenaStoneType_None;
constexpr SeptArenaStoneType SeptArenaStoneType_MAX = SeptArenaStoneType_Top;
constexpr int SeptArenaStoneType_ARRAYSIZE = SeptArenaStoneType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SeptArenaStoneType_descriptor();
template<typename T>
inline const std::string& SeptArenaStoneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SeptArenaStoneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SeptArenaStoneType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SeptArenaStoneType_descriptor(), enum_t_value);
}
inline bool SeptArenaStoneType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SeptArenaStoneType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SeptArenaStoneType>(
    SeptArenaStoneType_descriptor(), name, value);
}
enum GongFaState : int {
  Unable = 0,
  ReadyToLearn = 1,
  Training = 2,
  Standby = 3,
  Activated = 4,
  GongFaState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GongFaState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool GongFaState_IsValid(int value);
constexpr GongFaState GongFaState_MIN = Unable;
constexpr GongFaState GongFaState_MAX = Activated;
constexpr int GongFaState_ARRAYSIZE = GongFaState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GongFaState_descriptor();
template<typename T>
inline const std::string& GongFaState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GongFaState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GongFaState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GongFaState_descriptor(), enum_t_value);
}
inline bool GongFaState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GongFaState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GongFaState>(
    GongFaState_descriptor(), name, value);
}
enum GongFaCondition : int {
  GFC_None = 0,
  GFC_HerbalBlock = 1,
  GFC_CostItem = 2,
  GFC_GuBao = 3,
  GFC_AvatarLevel = 4,
  GFC_OrangeAlchemy = 5,
  GFC_OrangeForge = 6,
  GFC_MaxHP = 7,
  GFC_MaxMP = 8,
  GFC_PetLevel = 9,
  GFC_SkillLevel = 10,
  GFC_ImmortalRoad = 11,
  GFC_Crit = 12,
  GFC_CritCoff = 13,
  GFC_MagBreak = 14,
  GFC_PhyBreak = 15,
  GFC_MagBlock = 16,
  GFC_PhyBlock = 17,
  GongFaCondition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GongFaCondition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool GongFaCondition_IsValid(int value);
constexpr GongFaCondition GongFaCondition_MIN = GFC_None;
constexpr GongFaCondition GongFaCondition_MAX = GFC_PhyBlock;
constexpr int GongFaCondition_ARRAYSIZE = GongFaCondition_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GongFaCondition_descriptor();
template<typename T>
inline const std::string& GongFaCondition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GongFaCondition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GongFaCondition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GongFaCondition_descriptor(), enum_t_value);
}
inline bool GongFaCondition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GongFaCondition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GongFaCondition>(
    GongFaCondition_descriptor(), name, value);
}
enum GongFaEffectType : int {
  GFET_None = 0,
  GFET_BaseAtt = 1,
  GFET_DongFu = 2,
  GFET_PracticeNum = 3,
  GFET_PracticeUp = 4,
  GFET_MergePractive = 5,
  GFET_PillUp = 6,
  GFET_PillUseNum = 7,
  GFET_MoneyUp = 8,
  GFET_AttackMonsterDamageAddPercent = 9,
  GFET_TakeMonsterDamageReducePercent = 10,
  GFET_FaBaoDamageToPlayerAddPercent = 11,
  GFET_FaBaoDamageToPlayerReducePercent = 12,
  GFET_ShenTongDamageToPlayerAddPercent = 13,
  GFET_ShenTongDamageToPlayerReducePercent = 14,
  GFET_Mind = 15,
  GFET_MpRecoverPercent = 16,
  GFET_Mp = 17,
  GFET_BaseMp = 18,
  GFET_HpRecoverPercent = 19,
  GFET_Hp = 20,
  GFET_BaseHp = 21,
  GFET_MagAtt = 22,
  GFET_PhyAtt = 23,
  GFET_Crit = 24,
  GFET_CritCoeff = 25,
  GFET_CritBlock = 26,
  GFET_ControlRateAtt = 27,
  GFET_ControlRateDef = 28,
  GFET_ControlTimeAtt = 29,
  GFET_ControlTimeDef = 30,
  GFET_MoveSpeed = 31,
  GFET_Intellect = 32,
  GFET_Strength = 33,
  GongFaEffectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GongFaEffectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool GongFaEffectType_IsValid(int value);
constexpr GongFaEffectType GongFaEffectType_MIN = GFET_None;
constexpr GongFaEffectType GongFaEffectType_MAX = GFET_Strength;
constexpr int GongFaEffectType_ARRAYSIZE = GongFaEffectType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GongFaEffectType_descriptor();
template<typename T>
inline const std::string& GongFaEffectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GongFaEffectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GongFaEffectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GongFaEffectType_descriptor(), enum_t_value);
}
inline bool GongFaEffectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GongFaEffectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GongFaEffectType>(
    GongFaEffectType_descriptor(), name, value);
}
enum FuZengType : int {
  FZT_None = 0,
  FZT_CombatPower = 1,
  FZT_MonsterTower = 2,
  FZT_Ability = 3,
  FZT_Pill = 4,
  FZT_GongFa = 5,
  FZT_GuBaoCollection = 6,
  FZT_GuBaoLevel = 7,
  FZT_GaCha = 8,
  FZT_MaxNum = 9,
  FuZengType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FuZengType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool FuZengType_IsValid(int value);
constexpr FuZengType FuZengType_MIN = FZT_None;
constexpr FuZengType FuZengType_MAX = FZT_MaxNum;
constexpr int FuZengType_ARRAYSIZE = FuZengType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FuZengType_descriptor();
template<typename T>
inline const std::string& FuZengType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FuZengType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FuZengType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FuZengType_descriptor(), enum_t_value);
}
inline bool FuZengType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FuZengType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FuZengType>(
    FuZengType_descriptor(), name, value);
}
enum FuZengState : int {
  FZS_UnFinished = 0,
  FZS_Finished = 1,
  FZS_Received = 2,
  FuZengState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FuZengState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool FuZengState_IsValid(int value);
constexpr FuZengState FuZengState_MIN = FZS_UnFinished;
constexpr FuZengState FuZengState_MAX = FZS_Received;
constexpr int FuZengState_ARRAYSIZE = FuZengState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FuZengState_descriptor();
template<typename T>
inline const std::string& FuZengState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FuZengState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FuZengState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FuZengState_descriptor(), enum_t_value);
}
inline bool FuZengState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FuZengState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FuZengState>(
    FuZengState_descriptor(), name, value);
}
enum CollectionStarAdditionType : int {
  CSAT_Times = 0,
  CSAT_Plus = 1,
  CollectionStarAdditionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CollectionStarAdditionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool CollectionStarAdditionType_IsValid(int value);
constexpr CollectionStarAdditionType CollectionStarAdditionType_MIN = CSAT_Times;
constexpr CollectionStarAdditionType CollectionStarAdditionType_MAX = CSAT_Plus;
constexpr int CollectionStarAdditionType_ARRAYSIZE = CollectionStarAdditionType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CollectionStarAdditionType_descriptor();
template<typename T>
inline const std::string& CollectionStarAdditionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CollectionStarAdditionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CollectionStarAdditionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CollectionStarAdditionType_descriptor(), enum_t_value);
}
inline bool CollectionStarAdditionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CollectionStarAdditionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CollectionStarAdditionType>(
    CollectionStarAdditionType_descriptor(), name, value);
}
enum CollectionUseType : int {
  CUT_Active = 0,
  CUT_Passive = 1,
  CUT_Functional = 2,
  CollectionUseType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CollectionUseType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool CollectionUseType_IsValid(int value);
constexpr CollectionUseType CollectionUseType_MIN = CUT_Active;
constexpr CollectionUseType CollectionUseType_MAX = CUT_Functional;
constexpr int CollectionUseType_ARRAYSIZE = CollectionUseType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CollectionUseType_descriptor();
template<typename T>
inline const std::string& CollectionUseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CollectionUseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CollectionUseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CollectionUseType_descriptor(), enum_t_value);
}
inline bool CollectionUseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CollectionUseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CollectionUseType>(
    CollectionUseType_descriptor(), name, value);
}
enum CollectionZoneType : int {
  CZT_Unknown = 0,
  CZT_RenJie = 1,
  CZT_LingJie = 2,
  CZT_XianMo = 3,
  CZT_LiuYu = 4,
  CZT_QiTa = 5,
  CollectionZoneType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CollectionZoneType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool CollectionZoneType_IsValid(int value);
constexpr CollectionZoneType CollectionZoneType_MIN = CZT_Unknown;
constexpr CollectionZoneType CollectionZoneType_MAX = CZT_QiTa;
constexpr int CollectionZoneType_ARRAYSIZE = CollectionZoneType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CollectionZoneType_descriptor();
template<typename T>
inline const std::string& CollectionZoneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CollectionZoneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CollectionZoneType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CollectionZoneType_descriptor(), enum_t_value);
}
inline bool CollectionZoneType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CollectionZoneType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CollectionZoneType>(
    CollectionZoneType_descriptor(), name, value);
}
enum CollectionFilterType : int {
  CFT_Owned = 0,
  CFT_All = 1,
  CFT_Source = 2,
  CFT_Suit = 3,
  CFT_CanUp = 4,
  CollectionFilterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CollectionFilterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool CollectionFilterType_IsValid(int value);
constexpr CollectionFilterType CollectionFilterType_MIN = CFT_Owned;
constexpr CollectionFilterType CollectionFilterType_MAX = CFT_CanUp;
constexpr int CollectionFilterType_ARRAYSIZE = CollectionFilterType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CollectionFilterType_descriptor();
template<typename T>
inline const std::string& CollectionFilterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CollectionFilterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CollectionFilterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CollectionFilterType_descriptor(), enum_t_value);
}
inline bool CollectionFilterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CollectionFilterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CollectionFilterType>(
    CollectionFilterType_descriptor(), name, value);
}
enum CollectionOrderType : int {
  COT_Quality = 0,
  COT_Property = 1,
  COT_Level = 2,
  COT_Active = 3,
  CollectionOrderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CollectionOrderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool CollectionOrderType_IsValid(int value);
constexpr CollectionOrderType CollectionOrderType_MIN = COT_Quality;
constexpr CollectionOrderType CollectionOrderType_MAX = COT_Active;
constexpr int CollectionOrderType_ARRAYSIZE = CollectionOrderType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CollectionOrderType_descriptor();
template<typename T>
inline const std::string& CollectionOrderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CollectionOrderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CollectionOrderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CollectionOrderType_descriptor(), enum_t_value);
}
inline bool CollectionOrderType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CollectionOrderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CollectionOrderType>(
    CollectionOrderType_descriptor(), name, value);
}
enum CollectionHistoryState : int {
  CHS_None = 0,
  CHS_NotActive = 1,
  CHS_CanDraw = 2,
  CHS_DrawDone = 3,
  CollectionHistoryState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CollectionHistoryState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool CollectionHistoryState_IsValid(int value);
constexpr CollectionHistoryState CollectionHistoryState_MIN = CHS_None;
constexpr CollectionHistoryState CollectionHistoryState_MAX = CHS_DrawDone;
constexpr int CollectionHistoryState_ARRAYSIZE = CollectionHistoryState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CollectionHistoryState_descriptor();
template<typename T>
inline const std::string& CollectionHistoryState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CollectionHistoryState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CollectionHistoryState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CollectionHistoryState_descriptor(), enum_t_value);
}
inline bool CollectionHistoryState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CollectionHistoryState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CollectionHistoryState>(
    CollectionHistoryState_descriptor(), name, value);
}
enum CollectionZoneActiveAwardState : int {
  CZAAS_None = 0,
  CZAAS_CanDraw = 1,
  CZAAS_DrawDone = 2,
  CollectionZoneActiveAwardState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CollectionZoneActiveAwardState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool CollectionZoneActiveAwardState_IsValid(int value);
constexpr CollectionZoneActiveAwardState CollectionZoneActiveAwardState_MIN = CZAAS_None;
constexpr CollectionZoneActiveAwardState CollectionZoneActiveAwardState_MAX = CZAAS_DrawDone;
constexpr int CollectionZoneActiveAwardState_ARRAYSIZE = CollectionZoneActiveAwardState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CollectionZoneActiveAwardState_descriptor();
template<typename T>
inline const std::string& CollectionZoneActiveAwardState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CollectionZoneActiveAwardState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CollectionZoneActiveAwardState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CollectionZoneActiveAwardState_descriptor(), enum_t_value);
}
inline bool CollectionZoneActiveAwardState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CollectionZoneActiveAwardState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CollectionZoneActiveAwardState>(
    CollectionZoneActiveAwardState_descriptor(), name, value);
}
enum LifeCounterType : int {
  LCT_Unknown = 0,
  LCT_AlchemyQuality = 1,
  LCT_ForgeEquipmentQuality = 2,
  LCT_ForgeSkillEquipmentQuality = 3,
  LCT_AbilityLevelPhy = 4,
  LCT_AbilityLevelMag = 5,
  LCT_KillCommonMonster = 6,
  LCT_KillEliteMonster = 7,
  LCT_KillBoss = 8,
  LCT_ActiveGongFaPoint = 9,
  LCT_FinishingGongFa = 10,
  LCT_PillElixirUsed = 11,
  LCT_InventoryItemUsed = 12,
  LCT_InventoryItemUsedType = 13,
  LCT_LoginGame = 14,
  LCT_FuYuanPoint = 15,
  LCT_SeptQuest = 16,
  LCT_MonsterTower = 17,
  LCT_CollectionStar = 18,
  LCT_CollectionNum = 19,
  LCT_GaChaOpen = 20,
  LCT_Shanhetu = 21,
  LCT_PropertyPillUse = 22,
  LCT_FarmBlockNum = 23,
  LCT_AlchemyType = 24,
  LifeCounterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LifeCounterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool LifeCounterType_IsValid(int value);
constexpr LifeCounterType LifeCounterType_MIN = LCT_Unknown;
constexpr LifeCounterType LifeCounterType_MAX = LCT_AlchemyType;
constexpr int LifeCounterType_ARRAYSIZE = LifeCounterType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LifeCounterType_descriptor();
template<typename T>
inline const std::string& LifeCounterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LifeCounterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LifeCounterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LifeCounterType_descriptor(), enum_t_value);
}
inline bool LifeCounterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LifeCounterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LifeCounterType>(
    LifeCounterType_descriptor(), name, value);
}
enum ModelType : int {
  MT_Unknown = 0,
  MT_HeadIcon = 1,
  MT_HeadFrame = 2,
  MT_Body = 3,
  MT_Hair = 4,
  MT_Hat = 5,
  MT_HeadDeco = 6,
  MT_FaceDeco = 7,
  MT_Mask = 8,
  MT_EarDeco = 9,
  MT_EyeBrows = 10,
  MT_Makeup = 11,
  MT_FacePaint = 12,
  MT_FacePrint = 13,
  MT_BackLight = 14,
  MT_MaxNum = 15,
  ModelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ModelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool ModelType_IsValid(int value);
constexpr ModelType ModelType_MIN = MT_Unknown;
constexpr ModelType ModelType_MAX = MT_MaxNum;
constexpr int ModelType_ARRAYSIZE = ModelType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelType_descriptor();
template<typename T>
inline const std::string& ModelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelType_descriptor(), enum_t_value);
}
inline bool ModelType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelType>(
    ModelType_descriptor(), name, value);
}
enum InventoryItemChangedType : int {
  IICT_Modify = 0,
  IICT_Add = 1,
  IICT_Del = 2,
  InventoryItemChangedType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InventoryItemChangedType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool InventoryItemChangedType_IsValid(int value);
constexpr InventoryItemChangedType InventoryItemChangedType_MIN = IICT_Modify;
constexpr InventoryItemChangedType InventoryItemChangedType_MAX = IICT_Del;
constexpr int InventoryItemChangedType_ARRAYSIZE = InventoryItemChangedType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InventoryItemChangedType_descriptor();
template<typename T>
inline const std::string& InventoryItemChangedType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InventoryItemChangedType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InventoryItemChangedType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InventoryItemChangedType_descriptor(), enum_t_value);
}
inline bool InventoryItemChangedType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InventoryItemChangedType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InventoryItemChangedType>(
    InventoryItemChangedType_descriptor(), name, value);
}
enum ArenaCheckListState : int {
  ACLS_None = 0,
  ACLS_UnFinished = 1,
  ACLS_Finished = 2,
  ACLS_Received = 3,
  ArenaCheckListState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ArenaCheckListState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool ArenaCheckListState_IsValid(int value);
constexpr ArenaCheckListState ArenaCheckListState_MIN = ACLS_None;
constexpr ArenaCheckListState ArenaCheckListState_MAX = ACLS_Received;
constexpr int ArenaCheckListState_ARRAYSIZE = ArenaCheckListState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArenaCheckListState_descriptor();
template<typename T>
inline const std::string& ArenaCheckListState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArenaCheckListState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArenaCheckListState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArenaCheckListState_descriptor(), enum_t_value);
}
inline bool ArenaCheckListState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArenaCheckListState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArenaCheckListState>(
    ArenaCheckListState_descriptor(), name, value);
}
enum ArenaCheckListRewardState : int {
  ACLRS_UnFinished = 0,
  ACLRS_UnReceived = 1,
  ACLRS_Received = 2,
  ArenaCheckListRewardState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ArenaCheckListRewardState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool ArenaCheckListRewardState_IsValid(int value);
constexpr ArenaCheckListRewardState ArenaCheckListRewardState_MIN = ACLRS_UnFinished;
constexpr ArenaCheckListRewardState ArenaCheckListRewardState_MAX = ACLRS_Received;
constexpr int ArenaCheckListRewardState_ARRAYSIZE = ArenaCheckListRewardState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArenaCheckListRewardState_descriptor();
template<typename T>
inline const std::string& ArenaCheckListRewardState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ArenaCheckListRewardState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ArenaCheckListRewardState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ArenaCheckListRewardState_descriptor(), enum_t_value);
}
inline bool ArenaCheckListRewardState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArenaCheckListRewardState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArenaCheckListRewardState>(
    ArenaCheckListRewardState_descriptor(), name, value);
}
enum FarmLandState : int {
  FLS_None = 0,
  FLS_Free = 1,
  FLS_InUse = 2,
  FarmLandState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FarmLandState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool FarmLandState_IsValid(int value);
constexpr FarmLandState FarmLandState_MIN = FLS_None;
constexpr FarmLandState FarmLandState_MAX = FLS_InUse;
constexpr int FarmLandState_ARRAYSIZE = FarmLandState_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FarmLandState_descriptor();
template<typename T>
inline const std::string& FarmLandState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FarmLandState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FarmLandState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FarmLandState_descriptor(), enum_t_value);
}
inline bool FarmLandState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FarmLandState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FarmLandState>(
    FarmLandState_descriptor(), name, value);
}
enum FarmerEffectType : int {
  FET_None = 0,
  FET_ReduceGrowthTime = 1,
  FET_RipeningUp = 2,
  FET_WateringUp = 3,
  FET_ExtraOneHarvest = 4,
  FET_WateringNumUp = 5,
  FET_ReduceGrowthPeriod = 6,
  FET_MaxNum = 7,
  FarmerEffectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FarmerEffectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool FarmerEffectType_IsValid(int value);
constexpr FarmerEffectType FarmerEffectType_MIN = FET_None;
constexpr FarmerEffectType FarmerEffectType_MAX = FET_MaxNum;
constexpr int FarmerEffectType_ARRAYSIZE = FarmerEffectType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FarmerEffectType_descriptor();
template<typename T>
inline const std::string& FarmerEffectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FarmerEffectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FarmerEffectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FarmerEffectType_descriptor(), enum_t_value);
}
inline bool FarmerEffectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FarmerEffectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FarmerEffectType>(
    FarmerEffectType_descriptor(), name, value);
}
enum ServerCounterType : int {
  SCT_None = 0,
  SCT_BiographyEventKillNpcWithHighDegree = 1,
  SCT_KillNpcWithHighDegree = 2,
  SCT_DegreeUpPhy = 3,
  SCT_DegreeUpMag = 4,
  ServerCounterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ServerCounterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool ServerCounterType_IsValid(int value);
constexpr ServerCounterType ServerCounterType_MIN = SCT_None;
constexpr ServerCounterType ServerCounterType_MAX = SCT_DegreeUpMag;
constexpr int ServerCounterType_ARRAYSIZE = ServerCounterType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServerCounterType_descriptor();
template<typename T>
inline const std::string& ServerCounterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServerCounterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServerCounterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServerCounterType_descriptor(), enum_t_value);
}
inline bool ServerCounterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServerCounterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServerCounterType>(
    ServerCounterType_descriptor(), name, value);
}
enum PeriodType : int {
  PT_None = 0,
  PT_Day = 1,
  PT_Week = 2,
  PT_Mouth = 3,
  PT_Year = 4,
  PeriodType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PeriodType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
MPROTOCOL_API bool PeriodType_IsValid(int value);
constexpr PeriodType PeriodType_MIN = PT_None;
constexpr PeriodType PeriodType_MAX = PT_Year;
constexpr int PeriodType_ARRAYSIZE = PeriodType_MAX + 1;

MPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PeriodType_descriptor();
template<typename T>
inline const std::string& PeriodType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PeriodType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PeriodType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PeriodType_descriptor(), enum_t_value);
}
inline bool PeriodType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PeriodType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PeriodType>(
    PeriodType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace idlepb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::idlepb::ItemQuality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::ItemQuality>() {
  return ::idlepb::ItemQuality_descriptor();
}
template <> struct is_proto_enum< ::idlepb::ItemShowType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::ItemShowType>() {
  return ::idlepb::ItemShowType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::ItemType>() {
  return ::idlepb::ItemType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::EquipmentMainType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::EquipmentMainType>() {
  return ::idlepb::EquipmentMainType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::PerkValueAddType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::PerkValueAddType>() {
  return ::idlepb::PerkValueAddType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::PerkValueEffectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::PerkValueEffectType>() {
  return ::idlepb::PerkValueEffectType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::PerkIdConsts> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::PerkIdConsts>() {
  return ::idlepb::PerkIdConsts_descriptor();
}
template <> struct is_proto_enum< ::idlepb::EquipmentSlotState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::EquipmentSlotState>() {
  return ::idlepb::EquipmentSlotState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::EquipmentSlotWearType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::EquipmentSlotWearType>() {
  return ::idlepb::EquipmentSlotWearType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::AlchemyChanceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::AlchemyChanceType>() {
  return ::idlepb::AlchemyChanceType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::PillType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::PillType>() {
  return ::idlepb::PillType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::CultivationDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::CultivationDirection>() {
  return ::idlepb::CultivationDirection_descriptor();
}
template <> struct is_proto_enum< ::idlepb::BreakthroughType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::BreakthroughType>() {
  return ::idlepb::BreakthroughType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::WorldType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::WorldType>() {
  return ::idlepb::WorldType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::EntityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::EntityType>() {
  return ::idlepb::EntityType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::EntityState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::EntityState>() {
  return ::idlepb::EntityState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::NpcType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::NpcType>() {
  return ::idlepb::NpcType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::MonsterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::MonsterType>() {
  return ::idlepb::MonsterType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::CurrencyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::CurrencyType>() {
  return ::idlepb::CurrencyType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::SoloType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::SoloType>() {
  return ::idlepb::SoloType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::QuestRequirementType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::QuestRequirementType>() {
  return ::idlepb::QuestRequirementType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::QuestOpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::QuestOpType>() {
  return ::idlepb::QuestOpType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::QuestSpecialRewardType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::QuestSpecialRewardType>() {
  return ::idlepb::QuestSpecialRewardType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::LeaderboardType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::LeaderboardType>() {
  return ::idlepb::LeaderboardType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::AlchemyState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::AlchemyState>() {
  return ::idlepb::AlchemyState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::WorldState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::WorldState>() {
  return ::idlepb::WorldState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::GameStatsModuleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::GameStatsModuleType>() {
  return ::idlepb::GameStatsModuleType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::ItemStatsModuleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::ItemStatsModuleType>() {
  return ::idlepb::ItemStatsModuleType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::FunctionModuleState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::FunctionModuleState>() {
  return ::idlepb::FunctionModuleState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::FunctionModuleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::FunctionModuleType>() {
  return ::idlepb::FunctionModuleType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::FunctionModuleUnlockType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::FunctionModuleUnlockType>() {
  return ::idlepb::FunctionModuleUnlockType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::MailType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::MailType>() {
  return ::idlepb::MailType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::MailOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::MailOperation>() {
  return ::idlepb::MailOperation_descriptor();
}
template <> struct is_proto_enum< ::idlepb::ChatMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::ChatMessageType>() {
  return ::idlepb::ChatMessageType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::ChatMessageChannel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::ChatMessageChannel>() {
  return ::idlepb::ChatMessageChannel_descriptor();
}
template <> struct is_proto_enum< ::idlepb::ForgeChanceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::ForgeChanceType>() {
  return ::idlepb::ForgeChanceType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::ForgeState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::ForgeState>() {
  return ::idlepb::ForgeState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::PillElixirType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::PillElixirType>() {
  return ::idlepb::PillElixirType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::PillElixrEffectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::PillElixrEffectType>() {
  return ::idlepb::PillElixrEffectType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::PlayerAbilityActionResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::PlayerAbilityActionResult>() {
  return ::idlepb::PlayerAbilityActionResult_descriptor();
}
template <> struct is_proto_enum< ::idlepb::FightMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::FightMode>() {
  return ::idlepb::FightMode_descriptor();
}
template <> struct is_proto_enum< ::idlepb::AttackLockType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::AttackLockType>() {
  return ::idlepb::AttackLockType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::AttackUnlockType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::AttackUnlockType>() {
  return ::idlepb::AttackUnlockType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::BossInvasionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::BossInvasionState>() {
  return ::idlepb::BossInvasionState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::SwordPkState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::SwordPkState>() {
  return ::idlepb::SwordPkState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::CheckListTaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::CheckListTaskType>() {
  return ::idlepb::CheckListTaskType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::SeptPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::SeptPosition>() {
  return ::idlepb::SeptPosition_descriptor();
}
template <> struct is_proto_enum< ::idlepb::SeptLogType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::SeptLogType>() {
  return ::idlepb::SeptLogType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::SeptArenaStoneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::SeptArenaStoneType>() {
  return ::idlepb::SeptArenaStoneType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::GongFaState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::GongFaState>() {
  return ::idlepb::GongFaState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::GongFaCondition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::GongFaCondition>() {
  return ::idlepb::GongFaCondition_descriptor();
}
template <> struct is_proto_enum< ::idlepb::GongFaEffectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::GongFaEffectType>() {
  return ::idlepb::GongFaEffectType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::FuZengType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::FuZengType>() {
  return ::idlepb::FuZengType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::FuZengState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::FuZengState>() {
  return ::idlepb::FuZengState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::CollectionStarAdditionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::CollectionStarAdditionType>() {
  return ::idlepb::CollectionStarAdditionType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::CollectionUseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::CollectionUseType>() {
  return ::idlepb::CollectionUseType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::CollectionZoneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::CollectionZoneType>() {
  return ::idlepb::CollectionZoneType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::CollectionFilterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::CollectionFilterType>() {
  return ::idlepb::CollectionFilterType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::CollectionOrderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::CollectionOrderType>() {
  return ::idlepb::CollectionOrderType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::CollectionHistoryState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::CollectionHistoryState>() {
  return ::idlepb::CollectionHistoryState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::CollectionZoneActiveAwardState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::CollectionZoneActiveAwardState>() {
  return ::idlepb::CollectionZoneActiveAwardState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::LifeCounterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::LifeCounterType>() {
  return ::idlepb::LifeCounterType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::ModelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::ModelType>() {
  return ::idlepb::ModelType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::InventoryItemChangedType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::InventoryItemChangedType>() {
  return ::idlepb::InventoryItemChangedType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::ArenaCheckListState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::ArenaCheckListState>() {
  return ::idlepb::ArenaCheckListState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::ArenaCheckListRewardState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::ArenaCheckListRewardState>() {
  return ::idlepb::ArenaCheckListRewardState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::FarmLandState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::FarmLandState>() {
  return ::idlepb::FarmLandState_descriptor();
}
template <> struct is_proto_enum< ::idlepb::FarmerEffectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::FarmerEffectType>() {
  return ::idlepb::FarmerEffectType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::ServerCounterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::ServerCounterType>() {
  return ::idlepb::ServerCounterType_descriptor();
}
template <> struct is_proto_enum< ::idlepb::PeriodType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlepb::PeriodType>() {
  return ::idlepb::PeriodType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_defines_2eproto
