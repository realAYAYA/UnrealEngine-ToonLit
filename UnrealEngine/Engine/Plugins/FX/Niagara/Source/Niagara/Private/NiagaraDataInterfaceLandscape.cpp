// Copyright Epic Games, Inc. All Rights Reserved.

#include "NiagaraDataInterfaceLandscape.h"

#include "NiagaraComponent.h"
#include "NiagaraShader.h"
#include "NiagaraShaderParametersBuilder.h"
#include "NiagaraStats.h"
#include "NiagaraWorldManager.h"

#include "Algo/RemoveIf.h"
#include "VT/RuntimeVirtualTexture.h"
#include "EngineModule.h"
#include "EngineUtils.h"
#include "Landscape.h"
#include "LandscapeHeightfieldCollisionComponent.h"
#include "LandscapeInfo.h"
#include "LandscapeProxy.h"
#include "ShaderCompilerCore.h"
#include "ShaderParameterUtils.h"
#include "PhysicalMaterials/PhysicalMaterial.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(NiagaraDataInterfaceLandscape)

#define LOCTEXT_NAMESPACE "UNiagaraDataInterfaceLandscape"

//////////////////////////////////////////////////////////////////////////
// remaining features
// -getting the albedo colour at a point
// -support for CPU

class FNDI_Landscape_SharedResource;
struct FNDILandscapeData_GameThread;

namespace NiagaraDataInterfaceLandscape
{
	enum Version
	{
		InitialVersion = 0,
		SupportVirtualTextures = 1,
		LWCPosition = 2,

		VersionPlusOne,
		LatestVersion = VersionPlusOne - 1
	};

	static const TCHAR* TemplateShaderFile = TEXT("/Plugin/FX/Niagara/Private/NiagaraDataInterfaceLandscape.ush");

	BEGIN_SHADER_PARAMETER_STRUCT(FShaderParameters,)
		SHADER_PARAMETER_SRV(Texture2D,				BaseColorVirtualTexture)
		SHADER_PARAMETER_TEXTURE(Texture2D<uint4>,	BaseColorVirtualTexturePageTable)
		SHADER_PARAMETER_SAMPLER(SamplerState,		BaseColorVirtualTextureSampler)
		SHADER_PARAMETER(FMatrix44f,				BaseColorVirtualTextureWorldToUvTransform)
		SHADER_PARAMETER(uint32,					BaseColorVirtualTextureSRGB)
		SHADER_PARAMETER(uint32,					BaseColorVirtualTextureEnabled)
		SHADER_PARAMETER(FUintVector4,				BaseColorVirtualTexturePackedUniform0)
		SHADER_PARAMETER(FUintVector4,				BaseColorVirtualTexturePackedUniform1)
		SHADER_PARAMETER(FUintVector4,				BaseColorVirtualTextureUniforms)
		SHADER_PARAMETER_SRV(Texture2D,				HeightVirtualTexture)
		SHADER_PARAMETER_TEXTURE(Texture2D<uint4>,	HeightVirtualTexturePageTable)
		SHADER_PARAMETER_SAMPLER(SamplerState,		HeightVirtualTextureSampler)
		SHADER_PARAMETER(FMatrix44f,				HeightVirtualTextureWorldToUvTransform)
		SHADER_PARAMETER(uint32,					HeightVirtualTextureEnabled)
		SHADER_PARAMETER(FUintVector4,				HeightVirtualTexturePackedUniform0)
		SHADER_PARAMETER(FUintVector4,				HeightVirtualTexturePackedUniform1)
		SHADER_PARAMETER(FUintVector4,				HeightVirtualTextureUniforms)
		SHADER_PARAMETER_SRV(Texture2D,				NormalVirtualTexture0)
		SHADER_PARAMETER_SRV(Texture2D,				NormalVirtualTexture1)
		SHADER_PARAMETER_TEXTURE(Texture2D<uint4>,	NormalVirtualTexturePageTable)
		SHADER_PARAMETER_SAMPLER(SamplerState,		NormalVirtualTexture0Sampler)
		SHADER_PARAMETER_SAMPLER(SamplerState,		NormalVirtualTexture1Sampler)
		SHADER_PARAMETER(FMatrix44f,				NormalVirtualTextureWorldToUvTransform)
		SHADER_PARAMETER(FUintVector4,				NormalVirtualTexturePackedUniform0)
		SHADER_PARAMETER(FUintVector4,				NormalVirtualTexturePackedUniform1)
		SHADER_PARAMETER(FUintVector4,				NormalVirtualTextureUniforms0)
		SHADER_PARAMETER(FUintVector4,				NormalVirtualTextureUniforms1)
		SHADER_PARAMETER(int32,						NormalVirtualTextureUnpackMode)
		SHADER_PARAMETER(uint32,					NormalVirtualTextureEnabled)
		SHADER_PARAMETER_SRV(Texture2D,				CachedHeightTexture)
		SHADER_PARAMETER_SAMPLER(SamplerState,		CachedHeightTextureSampler)
		SHADER_PARAMETER(uint32,					CachedHeightTextureEnabled)
		SHADER_PARAMETER(FMatrix44f,				CachedHeightTextureWorldToUvTransform)
		SHADER_PARAMETER(FMatrix44f,				CachedHeightTextureUvToWorldTransform)
		SHADER_PARAMETER(FVector4f,					CachedHeightTextureUvScaleBias)
		SHADER_PARAMETER(FVector2f,					CachedHeightTextureGridSize)
		SHADER_PARAMETER_SAMPLER(SamplerState,		PointClampedSampler)
		SHADER_PARAMETER_SRV(Texture2D<int>,		CachedPhysMatTexture)
		SHADER_PARAMETER(FIntPoint,					CachedPhysMatTextureDimension)
	END_SHADER_PARAMETER_STRUCT()
}

const FName UNiagaraDataInterfaceLandscape::GetBaseColorName(TEXT("GetBaseColor"));
const FName UNiagaraDataInterfaceLandscape::GetHeightName(TEXT("GetHeight"));
const FName UNiagaraDataInterfaceLandscape::GetWorldNormalName(TEXT("GetWorldNormal"));
const FName UNiagaraDataInterfaceLandscape::GetPhysicalMaterialIndexName(TEXT("GetPhysicalMaterialIndex"));

// RenderResource used to hold textures generated by this DI, pulled from the collision geometry of the terrain
class FLandscapeTextureResource : public FRenderResource
{
public:
	FLandscapeTextureResource(const FIntPoint& CellCount);
	virtual ~FLandscapeTextureResource() = default;

	FLandscapeTextureResource() = delete;
	FLandscapeTextureResource(const FLandscapeTextureResource&) = delete;
	FLandscapeTextureResource(const FLandscapeTextureResource&&) = delete;

	virtual void InitRHI() override;
	virtual void ReleaseRHI() override;

	void ReleaseSourceData();

	FRHIShaderResourceView* GetHeightTexture() const { return HeightTexture.SRV; }
	FRHIShaderResourceView* GetPhysMatTexture() const { return PhysMatTexture.SRV; }
	FIntPoint GetDimensions() const { return CellCount; }

	TArray<float>& EditHeightValues(int32 SampleCount);
	TArray<uint8>& EditPhysMatValues(int32 SampleCount);

private:
	FTextureReadBuffer2D HeightTexture;
	FTextureReadBuffer2D PhysMatTexture;
	FIntPoint CellCount;

	TArray<float> HeightValues;
	TArray<uint8> PhysMatValues;

	struct FTextureBulkData : public FResourceBulkDataInterface
	{
		void Init(const void* InData, uint32 InDataSize) { Data = InData; DataSize = InDataSize; }
		void Clear() { Data = nullptr; DataSize = 0; }
		virtual const void* GetResourceBulkData() const override { return Data; }
		virtual uint32 GetResourceBulkDataSize() const override { return DataSize; }
		virtual void Discard() override { }
		const void* Data = nullptr;
		uint32 DataSize = 0;
	};

	FTextureBulkData* GetHeightBulkData() { return HeightBulkData.DataSize > 0 ? &HeightBulkData : nullptr; }
	FTextureBulkData* GetPhysMatBulkData() { return PhysMatBulkData.DataSize > 0 ? &PhysMatBulkData : nullptr; }

	FTextureBulkData HeightBulkData;
	FTextureBulkData PhysMatBulkData;

#if STATS
	int32 GpuMemoryUsage = 0;
#endif
};

// SharedResource that can be held by multiple system instances which manages the resources created by this DI
class FNDI_Landscape_SharedResource
{
public:
	struct FResourceKey
	{
		TWeakObjectPtr<const ALandscape> Source = nullptr;
		TArray<TWeakObjectPtr<const UPhysicalMaterial>> PhysicalMaterials;
		TArray<FIntPoint> CapturedRegions;
		FIntPoint MinCaptureRegion = FIntPoint(ForceInitToZero);
		FIntPoint MaxCaptureRegion = FIntPoint(ForceInitToZero);
		bool IncludesCachedHeight = false;
		bool IncludesCachedPhysMat = false;
	};

	FNDI_Landscape_SharedResource() = delete;
	FNDI_Landscape_SharedResource(const FNDI_Landscape_SharedResource&) = delete;
	FNDI_Landscape_SharedResource(const FResourceKey& InKey);

	bool IsUsed() const;
	bool CanBeDestroyed() const;
	bool CanRepresent(const FResourceKey& InKey) const;

	void RegisterUser(const FNDI_SharedResourceUsage& Usage, bool bNeedsDataImmediately);
	void UnregisterUser(const FNDI_SharedResourceUsage& Usage);

	void UpdateState(bool& LandscapeRemoved);
	void Release();

	TUniquePtr<FLandscapeTextureResource> LandscapeTextures;
	FMatrix ActorToWorldTransform = FMatrix::Identity;
	FMatrix WorldToActorTransform = FMatrix::Identity;
	FVector4 UvScaleBias = FVector4(1.0f, 1.0f, 0.0f, 0.0f);
	FIntPoint CellCount = FIntPoint(ForceInitToZero);
	FVector2D TextureWorldGridSize = FVector2D(1.0f, 1.0f);

private:
	enum class EResourceState : uint8
	{
		Uninitialized,
		Initialized,
		Released,
	};

	void Initialize();

	FResourceKey ResourceKey;

	std::atomic<int32> ShaderPhysicsDataUserCount{ 0 };

	EResourceState CurrentState = EResourceState::Uninitialized;
	EResourceState NextState = EResourceState::Uninitialized;
};

using FNDI_Landscape_SharedResourceHandle = FNDI_SharedResourceHandle<FNDI_Landscape_SharedResource, FNDI_SharedResourceUsage>;

// Landscape data used for the game thread
struct FNDILandscapeData_GameThread
{
	TWeakObjectPtr<ALandscape> Landscape;
	FNDI_Landscape_SharedResourceHandle SharedResourceHandle;
	bool BaseColorVirtualTextureSRGB = false;
	int32 BaseColorVirtualTextureIndex = INDEX_NONE;
	int32 HeightVirtualTextureIndex = INDEX_NONE;
	int32 NormalVirtualTextureIndex = INDEX_NONE;
	ERuntimeVirtualTextureMaterialType NormalVirtualTextureMode = ERuntimeVirtualTextureMaterialType::Count;
	bool RequiresCollisionCacheCpu = false;
	bool RequiresCollisionCacheGpu = false;
	bool RequiresPhysMatCacheGpu = false;

	void Reset()
	{
		Landscape = nullptr;
		SharedResourceHandle = FNDI_Landscape_SharedResourceHandle();
		BaseColorVirtualTextureSRGB = false;
		BaseColorVirtualTextureIndex = INDEX_NONE;
		HeightVirtualTextureIndex = INDEX_NONE;
		NormalVirtualTextureIndex = INDEX_NONE;
		NormalVirtualTextureMode = ERuntimeVirtualTextureMaterialType::Count;
		RequiresCollisionCacheCpu = false;
		RequiresCollisionCacheGpu = false;
		RequiresPhysMatCacheGpu = false;
	}
};

// Landscape data used on the render thread
struct FNDILandscapeData_RenderThread
{
	TWeakObjectPtr<const URuntimeVirtualTexture> BaseColorVirtualTexture;
	TWeakObjectPtr<const URuntimeVirtualTexture> HeightVirtualTexture;
	TWeakObjectPtr<const URuntimeVirtualTexture> NormalVirtualTexture;
	const FLandscapeTextureResource* TextureResources = nullptr;
	bool BaseColorVirtualTextureSRGB = false;
	FVector4 BaseColorVirtualTextureWorldToUvParameters[3];
	FVector4 HeightVirtualTextureWorldToUvParameters[4];
	FVector4 NormalVirtualTextureWorldToUvParameters[3];
	FMatrix CachedHeightTextureWorldToUvTransform = FMatrix::Identity;
	FMatrix CachedHeightTextureUvToWorldTransform = FMatrix::Identity;
	FVector4 CachedHeightTextureUvScaleBias = FVector4(ForceInitToZero);
	FVector2D CachedHeightTextureGridSize = FVector2D(1.0f, 1.0f);
	ERuntimeVirtualTextureMaterialType NormalVirtualTextureMode = ERuntimeVirtualTextureMaterialType::Count;

	enum class ENormalUnpackType : int32
	{
		None = 0,
		BC3BC3,
		BC5BC1,
		B5G6R5
	};

	bool SetBaseColorVirtualTextureParameters(NiagaraDataInterfaceLandscape::FShaderParameters* ShaderParameters) const
	{
		const IAllocatedVirtualTexture* BaseColorAllocatedTexture = BaseColorVirtualTexture.IsValid()
			? BaseColorVirtualTexture->GetAllocatedVirtualTexture()
			: nullptr;

		if (!BaseColorAllocatedTexture)
		{
			return false;
		}

		// todo - need to figure out a way to confirm that this is in fact the best/only option for the basecolor
		constexpr uint32 BaseColorVirtualTextureLayerIndex = 0;
		constexpr uint32 BaseColorVirtualTexturePageIndex = 0;
		constexpr bool BaseColorVirtualTextureSrgb = false;

		FRHIShaderResourceView* PhysicalTextureSrv = BaseColorAllocatedTexture->GetPhysicalTextureSRV(BaseColorVirtualTextureLayerIndex, BaseColorVirtualTextureSrgb);
		if (!PhysicalTextureSrv)
		{
			return false;
		}

		FRHITexture* PageTableTexture = nullptr;

		if (FRHITexture* PageTable = BaseColorAllocatedTexture->GetPageTableTexture(BaseColorVirtualTexturePageIndex))
		{
			if (FRHITextureReference* TextureReference = PageTable->GetTextureReference())
			{
				PageTableTexture = TextureReference->GetReferencedTexture();
			}
		}

		if (!PageTableTexture)
		{
			return false;
		}

		FMatrix44f WorldToUvTransform(
			FVector3f((FVector4f)BaseColorVirtualTextureWorldToUvParameters[0]),
			FVector3f((FVector4f)BaseColorVirtualTextureWorldToUvParameters[1]),
			FVector3f((FVector4f)BaseColorVirtualTextureWorldToUvParameters[2]),
			FVector3f(0, 0, 0));

		ShaderParameters->BaseColorVirtualTexture = PhysicalTextureSrv;
		ShaderParameters->BaseColorVirtualTexturePageTable = PageTableTexture;
		ShaderParameters->BaseColorVirtualTextureWorldToUvTransform = WorldToUvTransform;
		ShaderParameters->BaseColorVirtualTextureSRGB = BaseColorVirtualTextureSRGB ? 1 : 0;
		ShaderParameters->BaseColorVirtualTextureEnabled = 1;

		FUintVector4 BaseColorVirtualTexturePageTableUniforms[2];
		FUintVector4 BaseColorVirtualTextureUniforms;

		BaseColorAllocatedTexture->GetPackedPageTableUniform(BaseColorVirtualTexturePageTableUniforms);
		BaseColorAllocatedTexture->GetPackedUniform(&BaseColorVirtualTextureUniforms, BaseColorVirtualTextureLayerIndex);
		ShaderParameters->BaseColorVirtualTexturePackedUniform0 = BaseColorVirtualTexturePageTableUniforms[0];
		ShaderParameters->BaseColorVirtualTexturePackedUniform1 = BaseColorVirtualTexturePageTableUniforms[1];

		ShaderParameters->BaseColorVirtualTextureUniforms = BaseColorVirtualTextureUniforms;

		return true;
	}

	static void SetBaseColorVirtualTextureParameters_Default(NiagaraDataInterfaceLandscape::FShaderParameters* ShaderParameters)
	{
		const FUintVector4 DummyUint4(ForceInitToZero);

		ShaderParameters->BaseColorVirtualTexture = GBlackTextureWithSRV->ShaderResourceViewRHI;
		ShaderParameters->BaseColorVirtualTexturePageTable = GBlackUintTexture->TextureRHI;
		ShaderParameters->BaseColorVirtualTextureWorldToUvTransform = FMatrix44f::Identity;
		ShaderParameters->BaseColorVirtualTextureSRGB = 0;
		ShaderParameters->BaseColorVirtualTextureEnabled = 0;
		ShaderParameters->BaseColorVirtualTexturePackedUniform0 = DummyUint4;
		ShaderParameters->BaseColorVirtualTexturePackedUniform1 = DummyUint4;
		ShaderParameters->BaseColorVirtualTextureUniforms = DummyUint4;
	}

	bool SetHeightVirtualTextureParameters(NiagaraDataInterfaceLandscape::FShaderParameters* ShaderParameters) const
	{
		const IAllocatedVirtualTexture* HeightAllocatedTexture = HeightVirtualTexture.IsValid()
			? HeightVirtualTexture->GetAllocatedVirtualTexture()
			: nullptr;

		if (!HeightAllocatedTexture)
		{
			return false;
		}

		// todo - need to figure out a way to confirm that this is in fact the best/only option for the height
		constexpr uint32 HeightVirtualTextureLayerIndex = 0;
		constexpr uint32 HeightVirtualTexturePageIndex = 0;
		constexpr bool HeightVirtualTextureSrgb = false;

		FRHIShaderResourceView* PhysicalTextureSrv = HeightAllocatedTexture->GetPhysicalTextureSRV(HeightVirtualTextureLayerIndex, HeightVirtualTextureSrgb);
		if (!PhysicalTextureSrv)
		{
			return false;
		}

		FRHITexture* PageTableTexture = nullptr;

		if (FRHITexture* PageTable = HeightAllocatedTexture->GetPageTableTexture(HeightVirtualTexturePageIndex))
		{
			if (FRHITextureReference* TextureReference = PageTable->GetTextureReference())
			{
				PageTableTexture = TextureReference->GetReferencedTexture();
			}
		}

		if (!PageTableTexture)
		{
			return false;
		}

		FMatrix44f WorldToUvTransform(
			FVector3f( (FVector4f)HeightVirtualTextureWorldToUvParameters[0]),
			FVector3f( (FVector4f)HeightVirtualTextureWorldToUvParameters[1]),
			FVector3f( (FVector4f)HeightVirtualTextureWorldToUvParameters[2]),
			FVector3f( (FVector4f)HeightVirtualTextureWorldToUvParameters[3]));

		ShaderParameters->HeightVirtualTexture = PhysicalTextureSrv;
		ShaderParameters->HeightVirtualTexturePageTable = PageTableTexture;
		ShaderParameters->HeightVirtualTextureWorldToUvTransform = WorldToUvTransform;
		ShaderParameters->HeightVirtualTextureEnabled = 1;

		FUintVector4 HeightVirtualTexturePageTableUniforms[2];
		FUintVector4 HeightVirtualTextureUniforms;

		HeightAllocatedTexture->GetPackedPageTableUniform(HeightVirtualTexturePageTableUniforms);
		HeightAllocatedTexture->GetPackedUniform(&HeightVirtualTextureUniforms, HeightVirtualTextureLayerIndex);
		ShaderParameters->HeightVirtualTexturePackedUniform0 = HeightVirtualTexturePageTableUniforms[0];
		ShaderParameters->HeightVirtualTexturePackedUniform1 = HeightVirtualTexturePageTableUniforms[1];

		ShaderParameters->HeightVirtualTextureUniforms = HeightVirtualTextureUniforms;

		return true;
	}

	static void SetHeightVirtualTextureParameters_Default(NiagaraDataInterfaceLandscape::FShaderParameters* ShaderParameters)
	{
		const FUintVector4 DummyUint4(ForceInitToZero);

		ShaderParameters->HeightVirtualTexture = GBlackTextureWithSRV->ShaderResourceViewRHI;
		ShaderParameters->HeightVirtualTexturePageTable = GBlackUintTexture->TextureRHI;
		ShaderParameters->HeightVirtualTextureWorldToUvTransform = FMatrix44f::Identity;
		ShaderParameters->HeightVirtualTextureEnabled = 0;
		ShaderParameters->HeightVirtualTexturePackedUniform0 = DummyUint4;
		ShaderParameters->HeightVirtualTexturePackedUniform1 = DummyUint4;
		ShaderParameters->HeightVirtualTextureUniforms = DummyUint4;
	}

	bool SetNormalVirtualTextureParameters(NiagaraDataInterfaceLandscape::FShaderParameters* ShaderParameters) const
	{
		const IAllocatedVirtualTexture* NormalAllocatedTexture = NormalVirtualTexture.IsValid()
			? NormalVirtualTexture->GetAllocatedVirtualTexture()
			: nullptr;

		if (!NormalAllocatedTexture)
		{
			return false;
		}

		constexpr uint32 NormalVirtualTexturePageIndex = 0;

		FRHITexture* PageTableTexture = nullptr;

		if (FRHITexture* PageTable = NormalAllocatedTexture->GetPageTableTexture(NormalVirtualTexturePageIndex))
		{
			if (FRHITextureReference* TextureReference = PageTable->GetTextureReference())
			{
				PageTableTexture = TextureReference->GetReferencedTexture();
			}
		}

		if (!PageTableTexture)
		{
			return false;
		}

		FRHIShaderResourceView* PhysicalTextureSrv[2] = { GBlackTextureWithSRV->ShaderResourceViewRHI, GBlackTextureWithSRV->ShaderResourceViewRHI };
		FUintVector4 NormalVirtualTextureUniforms[2];

		switch (NormalVirtualTextureMode)
		{
			case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Roughness:
				PhysicalTextureSrv[0] = NormalAllocatedTexture->GetPhysicalTextureSRV(0, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[0], 0);

				PhysicalTextureSrv[1] = NormalAllocatedTexture->GetPhysicalTextureSRV(1, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[1], 1);

				ShaderParameters->NormalVirtualTextureUnpackMode = (int32)ENormalUnpackType::B5G6R5;
				break;
			case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular:
				PhysicalTextureSrv[0] = NormalAllocatedTexture->GetPhysicalTextureSRV(0, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[0], 0);

				PhysicalTextureSrv[1] = NormalAllocatedTexture->GetPhysicalTextureSRV(1, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[1], 1);

				ShaderParameters->NormalVirtualTextureUnpackMode = (int32)ENormalUnpackType::BC3BC3;
				break;

			case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular_YCoCg:
			case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular_Mask_YCoCg:
				PhysicalTextureSrv[0] = NormalAllocatedTexture->GetPhysicalTextureSRV(1, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[0], 1);

				PhysicalTextureSrv[1] = NormalAllocatedTexture->GetPhysicalTextureSRV(2, false);
				NormalAllocatedTexture->GetPackedUniform(&NormalVirtualTextureUniforms[1], 2);

				ShaderParameters->NormalVirtualTextureUnpackMode = (int32)ENormalUnpackType::BC5BC1;
				break;

			default:
				return false;
		}

		FMatrix44f WorldToUvTransform(
			FPlane4f( (FVector4f)NormalVirtualTextureWorldToUvParameters[0]),
			FPlane4f( (FVector4f)NormalVirtualTextureWorldToUvParameters[1]),
			FPlane4f( (FVector4f)NormalVirtualTextureWorldToUvParameters[2]),
			FPlane4f(0.0f, 0.0f, 0.0f, 1.0f));

		ShaderParameters->NormalVirtualTexture0 = PhysicalTextureSrv[0];
		ShaderParameters->NormalVirtualTexture1 = PhysicalTextureSrv[1];
		ShaderParameters->NormalVirtualTexturePageTable = PageTableTexture;
		ShaderParameters->NormalVirtualTextureWorldToUvTransform = WorldToUvTransform;
		ShaderParameters->NormalVirtualTextureEnabled = 1;

		FUintVector4 NormalVirtualTexturePageTableUniforms[2];
		NormalAllocatedTexture->GetPackedPageTableUniform(NormalVirtualTexturePageTableUniforms);
		ShaderParameters->NormalVirtualTexturePackedUniform0 = NormalVirtualTexturePageTableUniforms[0];
		ShaderParameters->NormalVirtualTexturePackedUniform1 = NormalVirtualTexturePageTableUniforms[1];

		ShaderParameters->NormalVirtualTextureUniforms0 = NormalVirtualTextureUniforms[0];
		ShaderParameters->NormalVirtualTextureUniforms1 = NormalVirtualTextureUniforms[1];

		return true;
	}

	static void SetNormalVirtualTextureParameters_Default(NiagaraDataInterfaceLandscape::FShaderParameters* ShaderParameters)
	{
		const FUintVector4 DummyUint4(ForceInitToZero);

		ShaderParameters->NormalVirtualTexture0 =  GBlackTextureWithSRV->ShaderResourceViewRHI;
		ShaderParameters->NormalVirtualTexture1 = GBlackTextureWithSRV->ShaderResourceViewRHI;
		ShaderParameters->NormalVirtualTexturePageTable = GBlackUintTexture->TextureRHI;
		ShaderParameters->NormalVirtualTextureWorldToUvTransform = FMatrix44f::Identity;
		ShaderParameters->NormalVirtualTextureEnabled = 0;
		ShaderParameters->NormalVirtualTextureUnpackMode = (int32)ENormalUnpackType::None;
		ShaderParameters->NormalVirtualTexturePackedUniform0 = DummyUint4;
		ShaderParameters->NormalVirtualTexturePackedUniform1 = DummyUint4;
		ShaderParameters->NormalVirtualTextureUniforms0 = DummyUint4;
		ShaderParameters->NormalVirtualTextureUniforms1 = DummyUint4;
	}

	bool SetCachedHeightTextureParameters(NiagaraDataInterfaceLandscape::FShaderParameters* ShaderParameters) const
	{
		if (TextureResources)
		{
			FRHIShaderResourceView* HeightTextureSrv = TextureResources->GetHeightTexture();
			FRHIShaderResourceView* PhysMatTextureSrv = TextureResources->GetPhysMatTexture();

			if (HeightTextureSrv || PhysMatTextureSrv)
			{
				ShaderParameters->CachedHeightTextureWorldToUvTransform = (FMatrix44f)CachedHeightTextureWorldToUvTransform;
				ShaderParameters->CachedHeightTextureUvToWorldTransform = (FMatrix44f)CachedHeightTextureUvToWorldTransform;
				ShaderParameters->CachedHeightTextureUvScaleBias = (FVector4f)CachedHeightTextureUvScaleBias;
				ShaderParameters->CachedHeightTextureGridSize = (FVector2f)CachedHeightTextureGridSize;

				if (HeightTextureSrv)
				{
					ShaderParameters->CachedHeightTexture = HeightTextureSrv;
					ShaderParameters->CachedHeightTextureEnabled = 1;
				}
				else
				{
					ShaderParameters->CachedHeightTexture = GBlackTextureWithSRV->ShaderResourceViewRHI;
					ShaderParameters->CachedHeightTextureEnabled = 0;
				}

				if (PhysMatTextureSrv)
				{
					const FIntPoint PhysMatDimensions(TextureResources->GetDimensions());
					ShaderParameters->CachedPhysMatTexture = PhysMatTextureSrv;
					ShaderParameters->CachedPhysMatTextureDimension = PhysMatDimensions;
				}
				else
				{
					const FIntPoint PhysMatDimensions(ForceInitToZero);
					ShaderParameters->CachedPhysMatTexture = GBlackTextureWithSRV->ShaderResourceViewRHI;
					ShaderParameters->CachedPhysMatTextureDimension = PhysMatDimensions;
				}

				FRHISamplerState* PointClampedSampler = TStaticSamplerState<SF_Point, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
				ShaderParameters->PointClampedSampler = PointClampedSampler;

				return true;
			}
		}

		return false;
	}

	static void SetCachedHeightTextureParameters_Defaults(NiagaraDataInterfaceLandscape::FShaderParameters* ShaderParameters)
	{
		const FVector4f DummyVector4(ForceInitToZero);

		ShaderParameters->CachedHeightTexture = GBlackTextureWithSRV->ShaderResourceViewRHI;
		ShaderParameters->CachedHeightTextureWorldToUvTransform = FMatrix44f::Identity;
		ShaderParameters->CachedHeightTextureUvToWorldTransform = FMatrix44f::Identity;
		ShaderParameters->CachedHeightTextureUvScaleBias = DummyVector4;
		ShaderParameters->CachedHeightTextureGridSize = FVector2f::ZeroVector;
		ShaderParameters->CachedHeightTextureEnabled = 0;

		ShaderParameters->CachedPhysMatTexture = GBlackTextureWithSRV->ShaderResourceViewRHI;

		FRHISamplerState* PointClampedSampler = TStaticSamplerState<SF_Point, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
		ShaderParameters->PointClampedSampler = PointClampedSampler;
	}
};

class FNDI_Landscape_GeneratedData : public FNDI_GeneratedData
{
public:
	virtual ~FNDI_Landscape_GeneratedData();
	virtual void Tick(ETickingGroup TickGroup, float DeltaSeconds) override;

	static TypeHash GetTypeHash();

	FNDI_Landscape_SharedResourceHandle GetLandscapeData(const UNiagaraDataInterfaceLandscape& LandscapeDI, const FNiagaraSystemInstance& SystemInstance, const FNDILandscapeData_GameThread& InstanceData, FNDI_SharedResourceUsage Usage, bool bNeedsDataImmediately);

private:
	FRWLock LandscapeDataGuard;
	TArray<TSharedPtr<FNDI_Landscape_SharedResource>> LandscapeData;
	TArray<TSharedPtr<FNDI_Landscape_SharedResource>> ReleasedLandscapeData;
};

struct FNiagaraDataInterfaceProxyLandscape : public FNiagaraDataInterfaceProxy
{
	virtual void ConsumePerInstanceDataFromGameThread(void* PerInstanceData, const FNiagaraSystemInstanceID& Instance) override
	{
		const FNDILandscapeData_RenderThread& SourceData = *reinterpret_cast<const FNDILandscapeData_RenderThread*>(PerInstanceData);
		*SystemInstancesToProxyData_RT.Find(Instance) = SourceData;
	}

	virtual int32 PerInstanceDataPassedToRenderThreadSize() const override
	{
		return sizeof(FNDILandscapeData_RenderThread);
	}

	TMap<FNiagaraSystemInstanceID, FNDILandscapeData_RenderThread> SystemInstancesToProxyData_RT;
};

FLandscapeTextureResource::FLandscapeTextureResource(const FIntPoint& InCellCount)
: CellCount(InCellCount)
{
}

void FLandscapeTextureResource::InitRHI()
{
	if (HeightBulkData.DataSize > 0)
	{
		HeightTexture.Initialize(TEXT("FLandscapeTextureResource_HeightTexture"), sizeof(float), CellCount.X, CellCount.Y, EPixelFormat::PF_R32_FLOAT, FTextureReadBuffer2D::DefaultTextureInitFlag, &HeightBulkData);
	}

	if (PhysMatBulkData.DataSize > 0)
	{
		PhysMatTexture.Initialize(TEXT("FLandscapeTextureResource_PhysMatTexture"), sizeof(uint8), CellCount.X, CellCount.Y, EPixelFormat::PF_R8_UINT, FTextureReadBuffer2D::DefaultTextureInitFlag, &PhysMatBulkData);
	}

	ReleaseSourceData();

#if STATS
	check(GpuMemoryUsage == 0);
	GpuMemoryUsage = HeightTexture.NumBytes + PhysMatTexture.NumBytes;
	INC_MEMORY_STAT_BY(STAT_NiagaraGPUDataInterfaceMemory, GpuMemoryUsage);
#endif
}

void FLandscapeTextureResource::ReleaseRHI()
{
	HeightTexture.Release();
	PhysMatTexture.Release();

#if STATS
	INC_MEMORY_STAT_BY(STAT_NiagaraGPUDataInterfaceMemory, GpuMemoryUsage);
	GpuMemoryUsage = 0;
#endif
}

void FLandscapeTextureResource::ReleaseSourceData()
{
	HeightValues.Empty();
	PhysMatValues.Empty();
}

TArray<float>& FLandscapeTextureResource::EditHeightValues(int32 SampleCount)
{
	const float DefaultHeight = 0.0f;
	HeightValues.Reset(SampleCount);
	HeightValues.Init(DefaultHeight, SampleCount);
	HeightBulkData.Init(HeightValues.GetData(), HeightValues.Num() * HeightValues.GetTypeSize());

	return HeightValues;
}

TArray<uint8>& FLandscapeTextureResource::EditPhysMatValues(int32 SampleCount)
{
	const uint8 DefaultPhysMat = INDEX_NONE;
	PhysMatValues.Reset(SampleCount);
	PhysMatValues.Init(DefaultPhysMat, SampleCount);
	PhysMatBulkData.Init(PhysMatValues.GetData(), PhysMatValues.Num() * PhysMatValues.GetTypeSize());

	return PhysMatValues;
}

FNDI_Landscape_SharedResource::FNDI_Landscape_SharedResource(const FResourceKey& InKey)
: LandscapeTextures(nullptr)
, ResourceKey(InKey)
{
}

bool FNDI_Landscape_SharedResource::IsUsed() const
{
	return (ShaderPhysicsDataUserCount > 0) && CurrentState != EResourceState::Released;
}

bool FNDI_Landscape_SharedResource::CanBeDestroyed() const
{
	const bool ReadyForRemoval = !IsUsed();

	if (ReadyForRemoval && LandscapeTextures && LandscapeTextures->IsInitialized())
	{
		UE_LOG(LogNiagara, Error, TEXT("FNDI_Landscape_SharedResource::CanBeDestroyed returning true, but the LandscpaeTextures is still initialized! Source[%s] MinRegion[%d,%d] MaxRegion[%d,%d]"),
			*GetNameSafe(ResourceKey.Source.Get()), ResourceKey.MinCaptureRegion.X, ResourceKey.MinCaptureRegion.Y, ResourceKey.MaxCaptureRegion.X, ResourceKey.MaxCaptureRegion.Y);
	}

	return ReadyForRemoval;
}

bool FNDI_Landscape_SharedResource::CanRepresent(const FResourceKey& RequestKey) const
{
	if (CurrentState == EResourceState::Released)
	{
		return false;
	}

	if (ResourceKey.Source != RequestKey.Source)
	{
		return false;
	}

	if ((RequestKey.IncludesCachedHeight && !ResourceKey.IncludesCachedHeight)
		|| (RequestKey.IncludesCachedPhysMat && !ResourceKey.IncludesCachedPhysMat))
	{
		return false;
	}

	if (ResourceKey.MinCaptureRegion.X > RequestKey.MinCaptureRegion.X
		|| ResourceKey.MaxCaptureRegion.X < RequestKey.MaxCaptureRegion.X
		|| ResourceKey.MinCaptureRegion.Y > RequestKey.MinCaptureRegion.Y
		|| ResourceKey.MaxCaptureRegion.Y < RequestKey.MaxCaptureRegion.Y)
	{
		return false;
	}

	if (ResourceKey.PhysicalMaterials.Num() < RequestKey.PhysicalMaterials.Num())
	{
		return false;
	}

	for (int32 MaterialIt = 0; MaterialIt < RequestKey.PhysicalMaterials.Num(); ++MaterialIt)
	{
		if (ResourceKey.PhysicalMaterials[MaterialIt] != RequestKey.PhysicalMaterials[MaterialIt])
		{
			return false;
		}
	}

	const int32 CapturedRegionCount = ResourceKey.CapturedRegions.Num();
	int32 SearchIndex = 0;
	for (const FIntPoint& RequestRegion : RequestKey.CapturedRegions)
	{
		while (SearchIndex < CapturedRegionCount && ResourceKey.CapturedRegions[SearchIndex] != RequestRegion)
		{
			++SearchIndex;
		}
	}

	return SearchIndex < CapturedRegionCount;
}

void FNDI_Landscape_SharedResource::RegisterUser(const FNDI_SharedResourceUsage& Usage, bool bNeedsDataImmediately)
{
	check(Usage.RequiresCpuAccess == false);

	if (Usage.RequiresGpuAccess)
	{
		if (ShaderPhysicsDataUserCount++ == 0)
		{
			NextState = EResourceState::Initialized;
		}
	}
}

void FNDI_Landscape_SharedResource::UnregisterUser(const FNDI_SharedResourceUsage& Usage)
{
	check(Usage.RequiresCpuAccess == false);

	if (Usage.RequiresGpuAccess)
	{
		if (--ShaderPhysicsDataUserCount == 0)
		{
			NextState = EResourceState::Released;
		}
	}
}

void FNDI_Landscape_SharedResource::Initialize()
{
	if (const ULandscapeInfo* LandscapeInfo = ResourceKey.Source->GetLandscapeInfo())
	{
		const int32 ComponentQuadCount = ResourceKey.Source->ComponentSizeQuads;
		const FIntPoint RegionSpan = ResourceKey.MaxCaptureRegion - ResourceKey.MinCaptureRegion + FIntPoint(1, 1);
		const FIntPoint CaptureQuadSpan = RegionSpan * ComponentQuadCount;
		const FIntPoint CaptureVertexSpan = CaptureQuadSpan + FIntPoint(1, 1);
		const int32 SampleCount = CaptureVertexSpan.X * CaptureVertexSpan.Y;

		LandscapeTextures = MakeUnique<FLandscapeTextureResource>(CaptureVertexSpan);

		TArray<float>* HeightValues = ResourceKey.IncludesCachedHeight ? &LandscapeTextures->EditHeightValues(SampleCount) : nullptr;
		TArray<uint8>* PhysMatValues = ResourceKey.IncludesCachedPhysMat ? &LandscapeTextures->EditPhysMatValues(SampleCount) : nullptr;

		const FIntPoint RegionVertexBase = ResourceKey.MinCaptureRegion * ComponentQuadCount;

		for (const FIntPoint& Region : ResourceKey.CapturedRegions)
		{
			auto FoundCollisionComponent = LandscapeInfo->XYtoCollisionComponentMap.Find(Region);
			check(FoundCollisionComponent);

			if (FoundCollisionComponent)
			{
				if (const ULandscapeHeightfieldCollisionComponent* CollisionComponent = *FoundCollisionComponent)
				{
					if (HeightValues)
					{
						const FIntPoint SectionBase = (Region - ResourceKey.MinCaptureRegion) * ComponentQuadCount;
						CollisionComponent->FillHeightTile(*HeightValues, SectionBase.X + SectionBase.Y * CaptureVertexSpan.X, CaptureVertexSpan.X);
					}

					if (PhysMatValues)
					{
						const FIntPoint SectionBase = (Region - ResourceKey.MinCaptureRegion) * ComponentQuadCount;
						CollisionComponent->FillMaterialIndexTile(*PhysMatValues, SectionBase.X + SectionBase.Y * CaptureVertexSpan.X, CaptureVertexSpan.X);

						// remap the material index to the list we have on the DI
						TArray<uint8> PhysMatRemap;
						for (const UPhysicalMaterial* ComponentMaterial : CollisionComponent->CookedPhysicalMaterials)
						{
							PhysMatRemap.Emplace(ResourceKey.PhysicalMaterials.IndexOfByKey(ComponentMaterial));
						}

						for (int32 Y = 0; Y < ComponentQuadCount; ++Y)
						{
							for (int32 X = 0; X < ComponentQuadCount; ++X)
							{
								const int32 WriteIndex = SectionBase.X + X + (SectionBase.Y + Y) * CaptureVertexSpan.X;
								uint8& PhysMatIndex = (*PhysMatValues)[WriteIndex];
								PhysMatIndex = PhysMatRemap.IsValidIndex(PhysMatIndex) ? PhysMatRemap[PhysMatIndex] : INDEX_NONE;
							}
						}
					}
				}
			}
		}

		// number of cells that are represented in our heights array
		CellCount = CaptureVertexSpan;

		// mapping to get the UV from 'cell space' which is relative to the entire terrain (not just the captured regions)
		FVector2D UvScale(1.0f / CaptureVertexSpan.X, 1.0f / CaptureVertexSpan.Y);

		UvScaleBias = FVector4(
			UvScale.X,
			UvScale.Y,
			(0.5f - RegionVertexBase.X) * UvScale.X,
			(0.5f - RegionVertexBase.Y) * UvScale.Y);

		ActorToWorldTransform = ResourceKey.Source->GetTransform().ToMatrixWithScale();
		WorldToActorTransform = ActorToWorldTransform.Inverse();
		TextureWorldGridSize = FVector2D(ResourceKey.Source->GetTransform().GetScale3D());

		BeginInitResource(LandscapeTextures.Get());
	}
}

void FNDI_Landscape_SharedResource::Release()
{
	if (FLandscapeTextureResource* Resource = LandscapeTextures.Release())
	{
		ENQUEUE_RENDER_COMMAND(BeginDestroyCommand)([RT_Resource = Resource](FRHICommandListImmediate& RHICmdList)
		{
			RT_Resource->ReleaseResource();

			// On some RHIs textures will push data on the RHI thread
			// Therefore we are not 'released' until the RHI thread has processed all commands
			RHICmdList.EnqueueLambda([RT_Resource](FRHICommandListImmediate& RHICmdList)
				{
					delete RT_Resource;
				});
		});
	}
}

void FNDI_Landscape_SharedResource::UpdateState(bool& LandscapeReleased)
{
	const EResourceState RequestedState = NextState;

	LandscapeReleased = false;

	if (RequestedState == CurrentState)
	{
		return;
	}

	if (RequestedState == EResourceState::Initialized)
	{
		Initialize();
	}
	else if (RequestedState == EResourceState::Released)
	{
		Release();
		LandscapeReleased = true;
	}

	CurrentState = RequestedState;
}

FNDI_Landscape_GeneratedData::~FNDI_Landscape_GeneratedData()
{
	FRWScopeLock WriteLock(LandscapeDataGuard, SLT_Write);

	for (TSharedPtr<FNDI_Landscape_SharedResource> Landscape : LandscapeData)
	{
		Landscape->Release();
	}
}

void FNDI_Landscape_GeneratedData::Tick(ETickingGroup TickGroup, float DeltaSeconds)
{
	FRWScopeLock WriteLock(LandscapeDataGuard, SLT_Write);

	{ // handle any changes to the generated data
		TArray<int32, TInlineAllocator<32>> LandscapeToRemove;

		const int32 LandscapeCount = LandscapeData.Num();

		for (int32 LandscapeIt = 0; LandscapeIt < LandscapeCount; ++LandscapeIt)
		{
			TSharedPtr<FNDI_Landscape_SharedResource> Landscape = LandscapeData[LandscapeIt];

			bool LandscapeReleased = false;

			Landscape->UpdateState(LandscapeReleased);

			if (LandscapeReleased)
			{
				LandscapeToRemove.Add(LandscapeIt);
			}
		}

		while (LandscapeToRemove.Num())
		{
			const int32 LandscapeIt = LandscapeToRemove.Pop(false);

			TSharedPtr<FNDI_Landscape_SharedResource> Landscape = LandscapeData[LandscapeIt];
			LandscapeData.RemoveAtSwap(LandscapeIt);

			if (!Landscape->CanBeDestroyed())
			{
				ReleasedLandscapeData.Add(Landscape);
			}
		}
	}

	{ // check any shared resources that we've got pending release to see if they can now be destroyed
		ReleasedLandscapeData.SetNum(Algo::RemoveIf(ReleasedLandscapeData, [&](TSharedPtr<FNDI_Landscape_SharedResource>& Landscape)
		{
			return Landscape->CanBeDestroyed();
		}));
	}
}

FNDI_GeneratedData::TypeHash FNDI_Landscape_GeneratedData::GetTypeHash()
{
	static const TypeHash Hash = ::GetTypeHash(TEXT("FNDI_Landscape_GeneratedData"));
	return Hash;
}

FNDI_Landscape_SharedResourceHandle FNDI_Landscape_GeneratedData::GetLandscapeData(const UNiagaraDataInterfaceLandscape& LandscapeDI, const FNiagaraSystemInstance& SystemInstance, const FNDILandscapeData_GameThread& InstanceData, FNDI_SharedResourceUsage Usage, bool bNeedsDataImmediately)
{
	check(IsInGameThread());

	const ALandscape* Landscape = InstanceData.Landscape.Get();
	const ULandscapeInfo* LandscapeInfo = Landscape ? Landscape->GetLandscapeInfo() : nullptr;

	if (LandscapeInfo == nullptr)
	{
		return FNDI_Landscape_SharedResourceHandle();
	}

	// we want to use the bounds of the system to figure out which cells of the landscape that we need to handle
	const FBox SystemWorldBounds = SystemInstance.GetLocalBounds().TransformBy(SystemInstance.GetWorldTransform());
	const FTransform& LandscapeActorToWorld = Landscape->LandscapeActorToWorld();
	const FVector SystemMinInLandscape = LandscapeActorToWorld.InverseTransformPosition(SystemWorldBounds.Min);
	const FVector SystemMaxInLandscape = LandscapeActorToWorld.InverseTransformPosition(SystemWorldBounds.Max);

	const FBox SystemBoundsInLandscape(
		SystemMinInLandscape.ComponentMin(SystemMaxInLandscape),
		SystemMinInLandscape.ComponentMax(SystemMaxInLandscape));

	// at runtime we don't know the potential number of components in the landscape, so we can only clamp the values to start at 0.
	// Ideally, we'd be able to specify an upper bound as well to further refine the region of overlap.
	const FIntPoint MinBoundRegion = FIntPoint(SystemBoundsInLandscape.Min.X, SystemBoundsInLandscape.Min.Y).ComponentMax(FIntPoint(0, 0));
	const FIntPoint MaxBoundRegion = FIntPoint(SystemBoundsInLandscape.Max.X, SystemBoundsInLandscape.Max.Y).ComponentMax(FIntPoint(0, 0));

	const FIntRect SystemRect = FIntRect(MinBoundRegion, MaxBoundRegion).Scale(1.0f / Landscape->ComponentSizeQuads);

	FNDI_Landscape_SharedResource::FResourceKey Key;
	Key.Source = Landscape;
	Key.MinCaptureRegion = FIntPoint(TNumericLimits<int32>::Max(), TNumericLimits<int32>::Max());
	Key.MaxCaptureRegion = FIntPoint(TNumericLimits<int32>::Min(), TNumericLimits<int32>::Min());

	const int32 MaxSystemRegionCount = (SystemRect.Max.X - SystemRect.Min.X) * (SystemRect.Max.Y - SystemRect.Min.Y);
	const int32 MaxLandscapeRegionCount = LandscapeInfo->XYtoCollisionComponentMap.Num();

	Key.IncludesCachedHeight = InstanceData.RequiresCollisionCacheGpu;
	Key.IncludesCachedPhysMat = InstanceData.RequiresPhysMatCacheGpu;
	Key.PhysicalMaterials.Reserve(LandscapeDI.PhysicalMaterials.Num());
	for (const UPhysicalMaterial* Material : LandscapeDI.PhysicalMaterials)
	{
		Key.PhysicalMaterials.Emplace(Material);
	}

	auto AddRegion = [&](const FIntPoint& Region)
	{
		Key.CapturedRegions.Add(Region);
		Key.MinCaptureRegion = Key.MinCaptureRegion.ComponentMin(Region);
		Key.MaxCaptureRegion = Key.MaxCaptureRegion.ComponentMax(Region);
	};

	if (MaxSystemRegionCount > MaxLandscapeRegionCount)
	{
		Key.CapturedRegions.Reserve(MaxLandscapeRegionCount);

		for (const auto& LandscapeComponent : LandscapeInfo->XYtoCollisionComponentMap)
		{
			if (SystemRect.Contains(LandscapeComponent.Key))
			{
				AddRegion(LandscapeComponent.Key);
			}
		}
	}
	else
	{
		Key.CapturedRegions.Reserve(MaxSystemRegionCount);

		for (int32 GridY = SystemRect.Min.Y; GridY < SystemRect.Max.Y; ++GridY)
		{
			for (int32 GridX = SystemRect.Min.X; GridX < SystemRect.Max.X; ++GridX)
			{
				const FIntPoint CurrentRegion(GridX, GridY);
				if (LandscapeInfo->XYtoCollisionComponentMap.Contains(CurrentRegion))
				{
					AddRegion(CurrentRegion);
				}
			}
		}
	}

	if (!Key.CapturedRegions.Num())
	{
		return FNDI_Landscape_SharedResourceHandle();
	}

	// Attempt to Find data
	{
		FRWScopeLock ReadLock(LandscapeDataGuard, SLT_ReadOnly);
		TSharedPtr<FNDI_Landscape_SharedResource>* Existing = LandscapeData.FindByPredicate([&](const TSharedPtr<FNDI_Landscape_SharedResource>& LandscapeEntry)
		{
			return LandscapeEntry->CanRepresent(Key);
		});

		if (Existing)
		{
			return FNDI_Landscape_SharedResourceHandle(Usage, *Existing, bNeedsDataImmediately);
		}
	}

	// We need to add
	// Note we do not need to check for other threads adding here as it's only every done on the GameThread
	FRWScopeLock WriteLock(LandscapeDataGuard, SLT_Write);
	return FNDI_Landscape_SharedResourceHandle(
		Usage,
		LandscapeData.Add_GetRef(MakeShared<FNDI_Landscape_SharedResource>(Key)),
		bNeedsDataImmediately);
}

UNiagaraDataInterfaceLandscape::UNiagaraDataInterfaceLandscape(FObjectInitializer const& ObjectInitializer)
	: Super(ObjectInitializer)		
{
	SourceLandscape = nullptr;
	Proxy.Reset(new FNiagaraDataInterfaceProxyLandscape());
}

void UNiagaraDataInterfaceLandscape::PostInitProperties()
{
	Super::PostInitProperties();

	if (HasAnyFlags(RF_ClassDefaultObject))
	{
		ENiagaraTypeRegistryFlags Flags = ENiagaraTypeRegistryFlags::AllowAnyVariable | ENiagaraTypeRegistryFlags::AllowParameter;
		FNiagaraTypeRegistry::Register(FNiagaraTypeDefinition(GetClass()), Flags);
	}	
}

bool UNiagaraDataInterfaceLandscape::CopyToInternal(UNiagaraDataInterface* Destination) const
{
	if (!Super::CopyToInternal(Destination))
	{
		return false;
	}
	UNiagaraDataInterfaceLandscape* DestinationLandscape = CastChecked<UNiagaraDataInterfaceLandscape>(Destination);
	DestinationLandscape->SourceLandscape = SourceLandscape;	
	DestinationLandscape->SourceMode = SourceMode;
	DestinationLandscape->PhysicalMaterials = PhysicalMaterials;

	return true;
}

bool UNiagaraDataInterfaceLandscape::Equals(const UNiagaraDataInterface* Other) const
{
	if (!Super::Equals(Other))
	{
		return false;
	}
	const UNiagaraDataInterfaceLandscape* OtherLandscape = CastChecked<const UNiagaraDataInterfaceLandscape>(Other);
	return OtherLandscape->SourceLandscape == SourceLandscape
		&& OtherLandscape->SourceMode == SourceMode
		&& OtherLandscape->PhysicalMaterials == PhysicalMaterials;
}

void UNiagaraDataInterfaceLandscape::GetFunctions(TArray<FNiagaraFunctionSignature>& OutFunctions)
{
	{
		FNiagaraFunctionSignature Sig;
		Sig.Name = GetBaseColorName;
		Sig.bExperimental = true;
		Sig.bMemberFunction = true;
		Sig.bRequiresContext = false;
		Sig.bSupportsCPU = false;
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition(GetClass()), TEXT("Landscape")));
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetVec3Def(), TEXT("WorldPos")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetVec3Def(), TEXT("Color")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetBoolDef(), TEXT("IsValid")));

		OutFunctions.Add(Sig);
	}

	{
		FNiagaraFunctionSignature Sig;
		Sig.Name = GetHeightName;
		Sig.bExperimental = true;
		Sig.bMemberFunction = true;
		Sig.bRequiresContext = false;
		Sig.bSupportsCPU = false;
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition(GetClass()), TEXT("Landscape")));
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetPositionDef(), TEXT("WorldPos")));		
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetFloatDef(), TEXT("Value")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetBoolDef(), TEXT("IsValid")));

		OutFunctions.Add(Sig);
	}

	{
		FNiagaraFunctionSignature Sig;
		Sig.Name = GetWorldNormalName;
		Sig.bExperimental = true;
		Sig.bMemberFunction = true;
		Sig.bRequiresContext = false;
		Sig.bSupportsCPU = false;
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition(GetClass()), TEXT("Landscape")));
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetPositionDef(), TEXT("WorldPos")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetVec3Def(), TEXT("Value")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetBoolDef(), TEXT("IsValid")));

		OutFunctions.Add(Sig);
	}

	{
		FNiagaraFunctionSignature Sig;
		Sig.Name = GetPhysicalMaterialIndexName;
		Sig.bExperimental = true;
		Sig.bMemberFunction = true;
		Sig.bRequiresContext = false;
		Sig.bSupportsCPU = false;
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition(GetClass()), TEXT("Landscape")));
		Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetPositionDef(), TEXT("WorldPos")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetIntDef(), TEXT("Value")));
		Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetBoolDef(), TEXT("IsValid")));

		OutFunctions.Add(Sig);
	}

#if WITH_EDITORONLY_DATA
	for (FNiagaraFunctionSignature& Sig : OutFunctions)
	{
		Sig.FunctionVersion = NiagaraDataInterfaceLandscape::LatestVersion;
	}
#endif
}

#if WITH_EDITORONLY_DATA
bool UNiagaraDataInterfaceLandscape::UpgradeFunctionCall(FNiagaraFunctionSignature& FunctionSignature)
{
	// always upgrade to the latest version
	if (FunctionSignature.FunctionVersion < NiagaraDataInterfaceLandscape::LatestVersion)
	{
		TArray<FNiagaraFunctionSignature> AllFunctions;
		GetFunctions(AllFunctions);
		for (const FNiagaraFunctionSignature& Sig : AllFunctions)
		{
			if (FunctionSignature.Name == Sig.Name)
			{
				FunctionSignature = Sig;
				return true;
			}
		}
	}

	return false;
}
#endif

void UNiagaraDataInterfaceLandscape::ProvidePerInstanceDataForRenderThread(void* DataForRenderThread, void* PerInstanceData, const FNiagaraSystemInstanceID& SystemInstance)
{
	const FNDILandscapeData_GameThread& SourceData = *reinterpret_cast<const FNDILandscapeData_GameThread*>(PerInstanceData);
	FNDILandscapeData_RenderThread* TargetData = new(DataForRenderThread) FNDILandscapeData_RenderThread();

	if (SourceData.SharedResourceHandle)
	{
		const FNDI_Landscape_SharedResource& SourceResource = SourceData.SharedResourceHandle.ReadResource();

		TargetData->TextureResources = SourceResource.LandscapeTextures.Get();
		
		TargetData->CachedHeightTextureUvScaleBias = SourceResource.UvScaleBias;
		TargetData->CachedHeightTextureWorldToUvTransform = SourceResource.WorldToActorTransform;
		TargetData->CachedHeightTextureUvToWorldTransform = SourceResource.ActorToWorldTransform;
		TargetData->CachedHeightTextureGridSize = SourceResource.TextureWorldGridSize;
	}

	if (SourceData.BaseColorVirtualTextureIndex != INDEX_NONE)
	{
		if (const URuntimeVirtualTexture* VirtualTexture = SourceData.Landscape->RuntimeVirtualTextures[SourceData.BaseColorVirtualTextureIndex])
		{
			TargetData->BaseColorVirtualTexture = VirtualTexture;
			TargetData->BaseColorVirtualTextureSRGB = SourceData.BaseColorVirtualTextureSRGB;
			TargetData->BaseColorVirtualTextureWorldToUvParameters[0] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform0);
			TargetData->BaseColorVirtualTextureWorldToUvParameters[1] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform1);
			TargetData->BaseColorVirtualTextureWorldToUvParameters[2] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform2);
		}
	}

	if (SourceData.HeightVirtualTextureIndex != INDEX_NONE)
	{
		if (const URuntimeVirtualTexture* VirtualTexture = SourceData.Landscape->RuntimeVirtualTextures[SourceData.HeightVirtualTextureIndex])
		{
			TargetData->HeightVirtualTexture = VirtualTexture;
			TargetData->HeightVirtualTextureWorldToUvParameters[0] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform0);
			TargetData->HeightVirtualTextureWorldToUvParameters[1] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform1);
			TargetData->HeightVirtualTextureWorldToUvParameters[2] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform2);
			TargetData->HeightVirtualTextureWorldToUvParameters[3] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldHeightUnpack);
		}
	}

	if (SourceData.NormalVirtualTextureIndex != INDEX_NONE)
	{
		if (const URuntimeVirtualTexture* VirtualTexture = SourceData.Landscape->RuntimeVirtualTextures[SourceData.NormalVirtualTextureIndex])
		{
			TargetData->NormalVirtualTexture = VirtualTexture;
			TargetData->NormalVirtualTextureWorldToUvParameters[0] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform0);
			TargetData->NormalVirtualTextureWorldToUvParameters[1] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform1);
			TargetData->NormalVirtualTextureWorldToUvParameters[2] = VirtualTexture->GetUniformParameter(ERuntimeVirtualTextureShaderUniform_WorldToUVTransform2);
			TargetData->NormalVirtualTextureMode = SourceData.NormalVirtualTextureMode;
		}
	}
}

#if WITH_EDITORONLY_DATA
bool UNiagaraDataInterfaceLandscape::AppendCompileHash(FNiagaraCompileHashVisitor* InVisitor) const
{
	if (!Super::AppendCompileHash(InVisitor))
	{
		return false;
	}

	FSHAHash Hash = GetShaderFileHash(NiagaraDataInterfaceLandscape::TemplateShaderFile, EShaderPlatform::SP_PCD3D_SM5);
	InVisitor->UpdateString(TEXT("NiagaraDataInterfaceLandscapeHLSLSource"), Hash.ToString());
	InVisitor->UpdateShaderParameters<NiagaraDataInterfaceLandscape::FShaderParameters>();

	return true;

}

void UNiagaraDataInterfaceLandscape::GetParameterDefinitionHLSL(const FNiagaraDataInterfaceGPUParamInfo& ParamInfo, FString& OutHLSL)
{
	Super::GetParameterDefinitionHLSL(ParamInfo, OutHLSL);

	TMap<FString, FStringFormatArg> TemplateArgs =
	{
		{TEXT("ParameterName"),	ParamInfo.DataInterfaceHLSLSymbol},
	};

	FString TemplateFile;
	LoadShaderSourceFile(NiagaraDataInterfaceLandscape::TemplateShaderFile, EShaderPlatform::SP_PCD3D_SM5, &TemplateFile, nullptr);
	OutHLSL += FString::Format(*TemplateFile, TemplateArgs);
}

bool UNiagaraDataInterfaceLandscape::GetFunctionHLSL(const FNiagaraDataInterfaceGPUParamInfo& ParamInfo, const FNiagaraDataInterfaceGeneratedFunction& FunctionInfo, int FunctionInstanceIndex, FString& OutHLSL)
{
	if ( (FunctionInfo.DefinitionName == GetBaseColorName) ||
		 (FunctionInfo.DefinitionName == GetHeightName) ||
		 (FunctionInfo.DefinitionName == GetWorldNormalName) ||
		 (FunctionInfo.DefinitionName == GetPhysicalMaterialIndexName) )
	{
		return true;
	}

	return false;
}
#endif

void UNiagaraDataInterfaceLandscape::BuildShaderParameters(FNiagaraShaderParametersBuilder& ShaderParametersBuilder) const
{
	ShaderParametersBuilder.AddNestedStruct<NiagaraDataInterfaceLandscape::FShaderParameters>();
}

void UNiagaraDataInterfaceLandscape::SetShaderParameters(const FNiagaraDataInterfaceSetShaderParametersContext& Context) const
{
	FNiagaraDataInterfaceProxyLandscape& RT_Proxy = Context.GetProxy<FNiagaraDataInterfaceProxyLandscape>();
	FNDILandscapeData_RenderThread* ProxyData = RT_Proxy.SystemInstancesToProxyData_RT.Find(Context.GetSystemInstanceID());

	NiagaraDataInterfaceLandscape::FShaderParameters* ShaderParameters = Context.GetParameterNestedStruct<NiagaraDataInterfaceLandscape::FShaderParameters>();

	// Set Samplers
	FRHISamplerState* BilinearSamplerState				= TStaticSamplerState<SF_Bilinear, AM_Clamp, AM_Clamp, AM_Clamp>::GetRHI();
	ShaderParameters->BaseColorVirtualTextureSampler	= BilinearSamplerState;
	ShaderParameters->HeightVirtualTextureSampler		= BilinearSamplerState;
	ShaderParameters->NormalVirtualTexture0Sampler		= BilinearSamplerState;
	ShaderParameters->NormalVirtualTexture1Sampler		= BilinearSamplerState;
	ShaderParameters->CachedHeightTextureSampler		= BilinearSamplerState;

	// Set Textures
	bool ApplyBaseColorVirtualTextureDefaults = true;
	bool ApplyHeightVirtualTextureDefaults = true;
	bool ApplyNormalVirtualTextureDefaults = true;
	bool ApplyCachedHeightTextureDefaults = true;

	if (ProxyData)
	{
		ApplyBaseColorVirtualTextureDefaults = ProxyData->SetBaseColorVirtualTextureParameters(ShaderParameters) != true;
		ApplyHeightVirtualTextureDefaults = ProxyData->SetHeightVirtualTextureParameters(ShaderParameters) != true;
		ApplyNormalVirtualTextureDefaults = ProxyData->SetNormalVirtualTextureParameters(ShaderParameters) != true;
		ApplyCachedHeightTextureDefaults = ProxyData->SetCachedHeightTextureParameters(ShaderParameters) != true;
	}

	if (ApplyBaseColorVirtualTextureDefaults)
	{
		FNDILandscapeData_RenderThread::SetBaseColorVirtualTextureParameters_Default(ShaderParameters);
	}

	if (ApplyHeightVirtualTextureDefaults)
	{
		FNDILandscapeData_RenderThread::SetHeightVirtualTextureParameters_Default(ShaderParameters);
	}

	if (ApplyNormalVirtualTextureDefaults)
	{
		FNDILandscapeData_RenderThread::SetNormalVirtualTextureParameters_Default(ShaderParameters);
	}

	if (ApplyCachedHeightTextureDefaults)
	{
		FNDILandscapeData_RenderThread::SetCachedHeightTextureParameters_Defaults(ShaderParameters);
	}
}

bool UNiagaraDataInterfaceLandscape::InitPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance)
{
	FNDILandscapeData_GameThread* InstanceData = new(PerInstanceData) FNDILandscapeData_GameThread();
	ApplyLandscape(*SystemInstance, *InstanceData);

	FNiagaraDataInterfaceProxyLandscape* RT_Proxy = GetProxyAs<FNiagaraDataInterfaceProxyLandscape>();
	ENQUEUE_RENDER_COMMAND(FNiagaraDICreateProxy) (
		[RT_Proxy, InstanceID = SystemInstance->GetId()](FRHICommandListImmediate& CmdList)
	{
		check(!RT_Proxy->SystemInstancesToProxyData_RT.Contains(InstanceID));
		RT_Proxy->SystemInstancesToProxyData_RT.Add(InstanceID);
	});

	return true;
}

void UNiagaraDataInterfaceLandscape::DestroyPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance)
{
	if (FNDILandscapeData_GameThread* InstanceData = reinterpret_cast<FNDILandscapeData_GameThread*>(PerInstanceData))
	{
		InstanceData->~FNDILandscapeData_GameThread();

		FNiagaraDataInterfaceProxyLandscape* RT_Proxy = GetProxyAs<FNiagaraDataInterfaceProxyLandscape>();
		ENQUEUE_RENDER_COMMAND(FNiagaraDIDestroyProxy) (
			[RT_Proxy, InstanceID = SystemInstance->GetId()](FRHICommandListImmediate& CmdList)
		{
			RT_Proxy->SystemInstancesToProxyData_RT.Remove(InstanceID);
		});
	}
}

int32 UNiagaraDataInterfaceLandscape::PerInstanceDataSize() const
{
	return sizeof(FNDILandscapeData_GameThread);
}

bool UNiagaraDataInterfaceLandscape::PerInstanceTick(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance, float DeltaSeconds)
{
	bool ResetInstance = false;

	if (FNDILandscapeData_GameThread* InstanceData = reinterpret_cast<FNDILandscapeData_GameThread*>(PerInstanceData))
	{
		// todo - can we avoid checking this every tick?  currently it is required in case the landscape beneath us changes or new data
		// has stremaed in for the landscape and we need to update our capture of the data
		ApplyLandscape(*SystemInstance, *InstanceData);

		if (InstanceData->RequiresCollisionCacheGpu || InstanceData->RequiresPhysMatCacheGpu)
		{
			FNDI_Landscape_GeneratedData& GeneratedData = SystemInstance->GetWorldManager()->EditGeneratedData<FNDI_Landscape_GeneratedData>();
			InstanceData->SharedResourceHandle = GeneratedData.GetLandscapeData(*this, *SystemInstance, *InstanceData, FNDI_SharedResourceUsage(false, true), true);
		}
		else
		{
			InstanceData->SharedResourceHandle = FNDI_Landscape_SharedResourceHandle();
		}
	}

	return ResetInstance;
}

void UNiagaraDataInterfaceLandscape::ApplyLandscape(const FNiagaraSystemInstance& SystemInstance, FNDILandscapeData_GameThread& InstanceData) const
{
	ALandscape* Landscape = GetLandscape(SystemInstance, InstanceData.Landscape.Get());

	// when in editor the contents of the Landscape are volatile and so we'll make sure to
	// refresh our instance properties any time we apply
	#if !WITH_EDITOR
	if (InstanceData.Landscape == Landscape)
	{
		return;
	}
	#endif

	if (!Landscape)
	{
		InstanceData.Reset();
		return;
	}

	InstanceData.Landscape = Landscape;
	InstanceData.BaseColorVirtualTextureIndex = INDEX_NONE;
	InstanceData.HeightVirtualTextureIndex = INDEX_NONE;
	InstanceData.NormalVirtualTextureIndex = INDEX_NONE;

	// only worry about virtual textures if our current platform supports them
	if (UseVirtualTexturing(SystemInstance.GetFeatureLevel()))
	{
		const int32 RuntimeVirtualTextureCount = InstanceData.Landscape->RuntimeVirtualTextures.Num();
		for (int32 TextureIt = 0; TextureIt < RuntimeVirtualTextureCount; ++TextureIt)
		{
			if (const URuntimeVirtualTexture* Vt = InstanceData.Landscape->RuntimeVirtualTextures[TextureIt])
			{
				const ERuntimeVirtualTextureMaterialType VirtualMaterialType = Vt->GetMaterialType();

				switch (VirtualMaterialType)
				{
				case ERuntimeVirtualTextureMaterialType::BaseColor:
					if (InstanceData.BaseColorVirtualTextureIndex == INDEX_NONE)
					{
						InstanceData.BaseColorVirtualTextureIndex = TextureIt;
						InstanceData.BaseColorVirtualTextureSRGB = true;
					}
					break;
				case ERuntimeVirtualTextureMaterialType::WorldHeight:
					if (InstanceData.HeightVirtualTextureIndex == INDEX_NONE)
					{
						InstanceData.HeightVirtualTextureIndex = TextureIt;
					}
					break;
				case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Roughness:
				case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular:
				case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular_YCoCg:
				case ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular_Mask_YCoCg:
					if (InstanceData.NormalVirtualTextureIndex == INDEX_NONE)
					{
						InstanceData.NormalVirtualTextureIndex = TextureIt;
						InstanceData.NormalVirtualTextureMode = VirtualMaterialType;
					}
					if (InstanceData.BaseColorVirtualTextureIndex == INDEX_NONE)
					{
						InstanceData.BaseColorVirtualTextureIndex = TextureIt;
						InstanceData.BaseColorVirtualTextureSRGB =
							(VirtualMaterialType == ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Roughness) ||
							(VirtualMaterialType == ERuntimeVirtualTextureMaterialType::BaseColor_Normal_Specular);
					}
					break;
				}
			}
		}
	}

	bool SystemRequiresHeightsCpu = false;
	bool SystemRequiresHeightsGpu = false;
	SystemInstance.EvaluateBoundFunction(GetHeightName, SystemRequiresHeightsCpu, SystemRequiresHeightsGpu);

	bool SystemRequiresNormalsCpu = false;
	bool SystemRequiresNormalsGpu = false;
	SystemInstance.EvaluateBoundFunction(GetWorldNormalName, SystemRequiresNormalsCpu, SystemRequiresNormalsGpu);

	bool SystemRequiresPhysMatCpu = false;
	bool SystemRequiresPhysMatGpu = false;
	SystemInstance.EvaluateBoundFunction(GetPhysicalMaterialIndexName, SystemRequiresPhysMatCpu, SystemRequiresPhysMatGpu);

	bool SystemRequiresBaseColorCpu = false;
	bool SystemRequiresBaseColorGpu = false;
	SystemInstance.EvaluateBoundFunction(GetBaseColorName, SystemRequiresBaseColorCpu, SystemRequiresBaseColorGpu);

	// we need to create our own copy of the collision geometry if either the heights are needed, and they're not
	// provided by a virtual texture or if the normals are needed and they're not provided by a virtual texture
	InstanceData.RequiresCollisionCacheGpu =
		(SystemRequiresBaseColorGpu && InstanceData.BaseColorVirtualTextureIndex == INDEX_NONE) ||
		(SystemRequiresHeightsGpu && InstanceData.HeightVirtualTextureIndex == INDEX_NONE) ||
		(SystemRequiresNormalsGpu && InstanceData.NormalVirtualTextureIndex == INDEX_NONE);

	InstanceData.RequiresPhysMatCacheGpu = SystemRequiresPhysMatGpu;
}


// Users can supply a ALandscape actor
// if none is provided, then we use the World's LandscapeInfoMap to find an appropriate ALandscape actor
ALandscape* UNiagaraDataInterfaceLandscape::GetLandscape(const FNiagaraSystemInstance& SystemInstance, ALandscape* Hint) const
{
	if (ALandscape* Landscape = Cast<ALandscape>(SourceLandscape))
	{
		const bool HasValidSource = Landscape != nullptr;

		if (SourceMode == ENDILandscape_SourceMode::Source || (SourceMode == ENDILandscape_SourceMode::Default && HasValidSource))
		{
			return Landscape;
		}
	}

	const FBox WorldBounds = SystemInstance.GetLocalBounds().TransformBy(SystemInstance.GetWorldTransform());

	auto TestLandscape = [&](const ALandscape* InLandscape)
	{
		if (InLandscape->GetWorld() == SystemInstance.GetWorld())
		{
			if (const ULandscapeInfo* LandscapeInfo = InLandscape->GetLandscapeInfo())
			{
				for (const auto& ComponentIt : LandscapeInfo->XYtoCollisionComponentMap)
				{
					if (WorldBounds.IntersectXY(ComponentIt.Value->Bounds.GetBox()))
					{
						return true;
					}
				}
			}
		}

		return false;
	};

	if (Hint && TestLandscape(Hint))
	{
		return Hint;
	}

	for (TActorIterator<ALandscape> LandscapeIt(SystemInstance.GetWorld()); LandscapeIt; ++LandscapeIt)
	{
		if (ALandscape* Landscape = *LandscapeIt)
		{
			if (TestLandscape(Landscape))
			{
				return Landscape;
			}
		}
	}

	return nullptr;
}

#undef LOCTEXT_NAMESPACE

