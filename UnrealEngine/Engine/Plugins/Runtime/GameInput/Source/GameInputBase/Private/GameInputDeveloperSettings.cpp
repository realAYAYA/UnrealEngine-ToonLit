// Copyright Epic Games, Inc. All Rights Reserved.

#include "GameInputDeveloperSettings.h"
#include "Misc/DataDrivenPlatformInfoRegistry.h"
#include "GameInputLogging.h"

#if GAME_INPUT_SUPPORT
THIRD_PARTY_INCLUDES_START
#include "Microsoft/AllowMicrosoftPlatformTypes.h"
#include <GameInput.h>
#include "Microsoft/HideMicrosoftPlatformTypes.h"
THIRD_PARTY_INCLUDES_END
#endif	// GAME_INPUT_SUPPORT

FGameInputDeviceIdentifier::FGameInputDeviceIdentifier()
	: VendorId(0)
	, ProductId(0)
{
}

FGameInputDeviceIdentifier::FGameInputDeviceIdentifier(uint16 InVendorId, uint16 InProductId)
	: VendorId(InVendorId)
	, ProductId(InProductId)
{
}

uint32 GetTypeHash(const FGameInputDeviceIdentifier& InId)
{
	uint32 Hash = 0;
	Hash = HashCombine(Hash, GetTypeHash(InId.VendorId));
	Hash = HashCombine(Hash, GetTypeHash(InId.ProductId));
	return Hash;
}

FString FGameInputDeviceIdentifier::ToString() const
{
	return FString::Format(TEXT("VendorId: {0} ProductId {1}"), { VendorId, ProductId });
}

bool FGameInputDeviceIdentifier::operator==(const FGameInputDeviceIdentifier& Other) const
{
	return 
		VendorId == Other.VendorId && 
		ProductId == Other.ProductId;
}

bool FGameInputDeviceIdentifier::operator!=(const FGameInputDeviceIdentifier& Other) const
{
	return !FGameInputDeviceIdentifier::operator==(Other);
}

FGameInputDeviceConfiguration::FGameInputDeviceConfiguration()
	: DeviceIdentifier(0, 0)
	, bOverrideHardwareDeviceIdString(false)
	, OverriddenHardwareDeviceId(TEXT(""))
	, bProcessControllerButtons(true)
	, bProcessControllerSwitchState(true)
	, bProcessControllerAxis(true)
	, bProcessRawReportData(false)
	, RawReportReadingId(0)
{
}

#if GAME_INPUT_SUPPORT
const FGameInputDeviceConfiguration* UGameInputDeveloperSettings::FindDeviceConfiguration(const GameInputDeviceInfo* const Info) const
{
	if (!Info)
	{
		return nullptr;
	}

	return DeviceConfigurations.FindByPredicate([&Info](const FGameInputDeviceConfiguration& DeviceConfig)
	{
		// Look for a matching Vendor ID and Product ID
		return
			(DeviceConfig.DeviceIdentifier.VendorId == Info->vendorId &&
			DeviceConfig.DeviceIdentifier.ProductId == Info->productId);
	});
}

const FGameInputDeviceConfiguration* UGameInputDeveloperSettings::FindDeviceConfiguration(const FGameInputDeviceIdentifier& HardwareID) const
{
	return DeviceConfigurations.FindByPredicate([&HardwareID](const FGameInputDeviceConfiguration& DeviceConfig)
	{
		// Look for a matching Vendor ID and Product ID
		return
			(DeviceConfig.DeviceIdentifier.VendorId == HardwareID.VendorId &&
			DeviceConfig.DeviceIdentifier.ProductId == HardwareID.ProductId);
	});
}

#endif	// GAME_INPUT_SUPPORT

UGameInputPlatformSettings* UGameInputPlatformSettings::Get()
{
	return UPlatformSettingsManager::Get().GetSettingsForPlatform<UGameInputPlatformSettings>();
}

void UGameInputPlatformSettings::InitializePlatformDefaults()
{
	// For platforms who are defaulted to KBM (Desktops) we want to disable KBM processing by default because
	// it will already be handled by the SlateApplication and platform message pump
	const FName PlatformName = GetPlatformIniName();
	const FDataDrivenPlatformInfo& PlatformInfo = FDataDrivenPlatformInfoRegistry::GetPlatformInfo(PlatformName);
	if (PlatformInfo.DefaultInputType == "MouseAndKeyboard")
	{
		bProcessKeyboard = false;
		bProcessMouse = false;

		// We also want to disable gamepad processing by default here, because it is likely that your PC platform
		// will be using the existing Xinput implementation. If one day we can turn off XInput by default,
		// then we can change this to be default on
		bProcessGamepad = false;
		bProcessController = false;
		bProcessRawInput = false;
	}

	// Everything else can just use the default values already set until we want to change something else
}

UGameInputDeveloperSettings::UGameInputDeveloperSettings(const FObjectInitializer& Initializer)
	: Super(Initializer)
	, bDoNotProcessDuplicateCapabilitiesForSingleUser(true)
{
	PlatformSpecificSettings.Initialize(UGameInputPlatformSettings::StaticClass());
}

#if WITH_EDITOR

namespace UE::GameInput
{
	/** A set of FName's that, if change in PostEditChangeProperty, would require Game Input to update what device status updates it is listening for. */
	static const TSet<FName>& GetPropertyNamesThatRequireGameInputUpdate()
	{
		static const TSet<FName> PropertyNamesThatRequireGameInputUpdate
		{
			GET_MEMBER_NAME_CHECKED(UGameInputPlatformSettings, bProcessController),
		};
		return PropertyNamesThatRequireGameInputUpdate;
	}
}

const TArray<uint32>& UGameInputDeveloperSettings::GetControllerButtonMappingDataKeyOptions()
{
	// The controller button bitmask is generated by bit shifting the current index
	// so just display all the possible options here
	static const TArray<uint32> Options =
	{
		1 << 0,
		1 << 1,
		1 << 2,
		1 << 3,
		1 << 4,
		1 << 5,
		1 << 6,
		1 << 7,
		1 << 8,
		1 << 9,
		1 << 10,
		1 << 11,
		1 << 12,
		1 << 13,
		1 << 14,
		1 << 15,
		1 << 16,
		1 << 17,
		1 << 18,
		1 << 19,
		1 << 21,
		1 << 22,
		1 << 23,
		1 << 24,
		1 << 25,
		1 << 26,
		1 << 27,
		1 << 28,
		1 << 29,
		1 << 30,
	};

	return Options;
}

void UGameInputDeveloperSettings::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeProperty(PropertyChangedEvent);

	const FName PropertyName = (PropertyChangedEvent.Property != nullptr) ? PropertyChangedEvent.Property->GetFName() : NAME_None;

	if (UE::GameInput::GetPropertyNamesThatRequireGameInputUpdate().Contains(PropertyName))
	{
		if (OnInputSettingChanged.IsBound())
		{
			OnInputSettingChanged.Execute(PropertyName);
		}
	}
}
#endif	// WITH_EDITOR