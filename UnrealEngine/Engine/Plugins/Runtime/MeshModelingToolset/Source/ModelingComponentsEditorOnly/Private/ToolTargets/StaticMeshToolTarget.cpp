// Copyright Epic Games, Inc. All Rights Reserved.

#include "ToolTargets/StaticMeshToolTarget.h"

#include "AssetUtils/MeshDescriptionUtil.h"
#include "ConversionUtils/DynamicMeshViaMeshDescriptionUtil.h"
#include "DynamicMesh/DynamicMesh3.h"
#include "Engine/StaticMesh.h"
#include "MaterialDomain.h"
#include "Materials/Material.h"
#include "RenderingThread.h"
#include "Widgets/Notifications/SNotificationList.h"
#include "Framework/Notifications/NotificationManager.h"
#include "StaticMeshAttributes.h"
#include "StaticMeshOperations.h"
#include "UObject/Package.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(StaticMeshToolTarget)

using namespace UE::Geometry;

#define LOCTEXT_NAMESPACE "StaticMeshToolTarget"

namespace StaticMeshToolTargetLocals
{
	static void DisplayCriticalWarningMessage(const FString& Message)
	{
		FNotificationInfo Info(FText::FromString(Message));
		Info.ExpireDuration = 5.0f;
		FSlateNotificationManager::Get().AddNotification(Info);

		UE_LOG(LogTemp, Warning, TEXT("%s"), *Message);
	}
}

void UStaticMeshToolTarget::SetEditingLOD(EMeshLODIdentifier RequestedEditingLOD)
{
	EditingLOD = GetValidEditingLOD(StaticMesh.Get(), RequestedEditingLOD);
}

EMeshLODIdentifier UStaticMeshToolTarget::GetValidEditingLOD(const UStaticMesh* StaticMeshIn, 
	EMeshLODIdentifier RequestedEditingLOD)
{
	using namespace StaticMeshToolTargetLocals;

	EMeshLODIdentifier ValidEditingLOD = EMeshLODIdentifier::LOD0;

	if (ensure(StaticMeshIn != nullptr))
	{
		if (RequestedEditingLOD == EMeshLODIdentifier::MaxQuality)
		{
			ValidEditingLOD = StaticMeshIn->IsHiResMeshDescriptionValid() ? EMeshLODIdentifier::HiResSource : EMeshLODIdentifier::LOD0;
		}
		else if (RequestedEditingLOD == EMeshLODIdentifier::HiResSource)
		{
			ValidEditingLOD = StaticMeshIn->IsHiResMeshDescriptionValid() ? EMeshLODIdentifier::HiResSource : EMeshLODIdentifier::LOD0;
			if (ValidEditingLOD != EMeshLODIdentifier::HiResSource)
			{
				DisplayCriticalWarningMessage(FString(TEXT("HiRes Source selected but not available - Falling Back to LOD0")));
			}
		}
		else
		{
			ValidEditingLOD = RequestedEditingLOD;
			int32 MaxExistingLOD = StaticMeshIn->GetNumSourceModels() - 1;
			if ((int32)ValidEditingLOD > MaxExistingLOD)
			{
				DisplayCriticalWarningMessage(FString::Printf(TEXT("LOD%d Requested but not available - Falling Back to LOD%d"), (int32)ValidEditingLOD, MaxExistingLOD));
				ValidEditingLOD = (EMeshLODIdentifier)MaxExistingLOD;
			}
		}
	}

	return ValidEditingLOD;
}

TArray<EMeshLODIdentifier> UStaticMeshToolTarget::GetAvailableLODs(bool bSkipAutoGenerated) const
{
	return GetAvailableLODs(StaticMesh.Get(), bSkipAutoGenerated);
}

TArray<EMeshLODIdentifier> UStaticMeshToolTarget::GetAvailableLODs(const UStaticMesh* InStaticMesh, bool bSkipAutoGenerated)
{
	TArray<EMeshLODIdentifier> AvailableLODs;
	
	if (!InStaticMesh)
	{
		return AvailableLODs;
	}

	if (InStaticMesh->IsHiResMeshDescriptionValid())
	{
		AvailableLODs.Add(EMeshLODIdentifier::HiResSource);
	}
	int32 NumExistingLOD = FMath::Min(8, InStaticMesh->GetNumSourceModels());
	for (int32 LOD = 0; LOD < NumExistingLOD; ++LOD)
	{
		if (bSkipAutoGenerated)
		{
			// Generated LODs have no source model data
			if (!InStaticMesh->GetSourceModel(LOD).IsSourceModelInitialized())
			{
				continue;
			}
		}
		AvailableLODs.Add((EMeshLODIdentifier)LOD);
	}

	return AvailableLODs;
}


bool UStaticMeshToolTarget::IsValid() const
{
	// The StaticMesh.Get() call here will give a nullptr if object is not alive, which 
	// HasNonGeneratedLOD checks for.
	return HasNonGeneratedLOD(StaticMesh.Get(), EditingLOD);
}

bool UStaticMeshToolTarget::IsValid(const UStaticMesh* StaticMeshIn, EMeshLODIdentifier EditingLODIn)
{
	if (!StaticMeshIn || !IsValidChecked(StaticMeshIn) || StaticMeshIn->IsUnreachable() || !StaticMeshIn->IsValidLowLevel())
	{
		return false;
	}

	if (EditingLODIn == EMeshLODIdentifier::HiResSource)
	{
		if (StaticMeshIn->IsHiResMeshDescriptionValid() == false)
		{
			return false;
		}
	}
	else if ((int32)EditingLODIn >= StaticMeshIn->GetNumSourceModels())
	{
		return false;
	}

	return true;
}

bool UStaticMeshToolTarget::HasNonGeneratedLOD(const UStaticMesh* StaticMeshIn, EMeshLODIdentifier MeshLOD)
{
	if (!StaticMeshIn)
	{
		return false;
	}
	
	if (MeshLOD == EMeshLODIdentifier::Default)
	{
		MeshLOD = EMeshLODIdentifier::LOD0;
	}
	if (MeshLOD == EMeshLODIdentifier::HiResSource)
	{
		return StaticMeshIn->IsHiResMeshDescriptionValid();
	}
	const int32 NumExistingLOD = FMath::Min(8, StaticMeshIn->GetNumSourceModels());
	if (MeshLOD == EMeshLODIdentifier::MaxQuality)
	{
		const bool bHasHiRes = StaticMeshIn->IsHiResMeshDescriptionValid();
		const bool bHasLOD0 = (NumExistingLOD > 0) ? StaticMeshIn->GetSourceModel(0).IsSourceModelInitialized() : false;
		return (bHasHiRes || bHasLOD0);
	}
	else
	{
		const int32 LODint = static_cast<int32>(MeshLOD);
		if (LODint >= NumExistingLOD)
		{ 
			return false; 
		}

		return StaticMeshIn->GetSourceModel(LODint).IsSourceModelInitialized();
	}
}

int32 UStaticMeshToolTarget::GetNumMaterials() const
{
	return ensure(IsValid()) ? StaticMesh->GetStaticMaterials().Num() : 0;
}

UMaterialInterface* UStaticMeshToolTarget::GetMaterial(int32 MaterialIndex) const
{
	return ensure(IsValid()) ? StaticMesh->GetMaterial(MaterialIndex) : nullptr;
}

void UStaticMeshToolTarget::GetMaterialSet(FComponentMaterialSet& MaterialSetOut, bool bPreferAssetMaterials) const
{
	if (!ensure(IsValid())) return;

	GetMaterialSet(StaticMesh.Get(), MaterialSetOut, bPreferAssetMaterials);
}

void UStaticMeshToolTarget::GetMaterialSet(const UStaticMesh* StaticMeshIn, 
	FComponentMaterialSet& MaterialSetOut, bool bPreferAssetMaterials)
{
	int32 NumMaterials = StaticMeshIn->GetStaticMaterials().Num();
	MaterialSetOut.Materials.SetNum(NumMaterials);
	for (int32 k = 0; k < NumMaterials; ++k)
	{
		MaterialSetOut.Materials[k] = StaticMeshIn->GetMaterial(k);
	}
}

bool UStaticMeshToolTarget::CommitMaterialSetUpdate(const FComponentMaterialSet& MaterialSet, bool bApplyToAsset)
{
	if (!ensure(IsValid())) return false;

	return CommitMaterialSetUpdate(StaticMesh.Get(), MaterialSet, bApplyToAsset);
}

bool UStaticMeshToolTarget::CommitMaterialSetUpdate(UStaticMesh* StaticMeshIn,
	const FComponentMaterialSet& MaterialSet, bool bApplyToAsset)
{
	if (!bApplyToAsset)
	{
		return false;
	}

	if (StaticMeshIn->GetPathName().StartsWith(TEXT("/Engine/")))
	{
		UE_LOG(LogTemp, Warning, TEXT("CANNOT MODIFY BUILT-IN ENGINE ASSET %s"), *StaticMeshIn->GetPathName());
		return false;
	}

	// filter out any Engine materials that we don't want to be permanently assigning
	TArray<UMaterialInterface*> FilteredMaterials = MaterialSet.Materials;
	for (int32 k = 0; k < FilteredMaterials.Num(); ++k)
	{
		FString AssetPath = FilteredMaterials[k]->GetPathName();
		if (AssetPath.StartsWith(TEXT("/MeshModelingToolsetExp/")))
		{
			FilteredMaterials[k] = UMaterial::GetDefaultMaterial(MD_Surface);
		}
	}

	// flush any pending rendering commands, which might touch this component while we are rebuilding its mesh
	FlushRenderingCommands();

	// make sure transactional flag is on
	StaticMeshIn->SetFlags(RF_Transactional);

	StaticMeshIn->Modify();

	int NewNumMaterials = FilteredMaterials.Num();
	if (NewNumMaterials != StaticMeshIn->GetStaticMaterials().Num())
	{
		StaticMeshIn->GetStaticMaterials().SetNum(NewNumMaterials);
	}
	for (int k = 0; k < NewNumMaterials; ++k)
	{
		if (StaticMeshIn->GetMaterial(k) != FilteredMaterials[k])
		{
			StaticMeshIn->SetMaterial(k, FilteredMaterials[k]);
		}
	}

	StaticMeshIn->PostEditChange();

	return true;
}

const FMeshDescription* UStaticMeshToolTarget::GetMeshDescription(const FGetMeshParameters& GetMeshParams)
{
	if (ensure(IsValid()))
	{
		EMeshLODIdentifier UseLOD = EditingLOD;
		if (GetMeshParams.bHaveRequestLOD)
		{
			UseLOD = UStaticMeshToolTarget::GetValidEditingLOD(StaticMesh.Get(), GetMeshParams.RequestLOD);
			ensure(UseLOD == GetMeshParams.RequestLOD);		// probably a bug somewhere if this is not true
		}

		return GetMeshDescriptionWithScaleApplied(StaticMesh.Get(), (int32)UseLOD, CachedMeshDescriptions);
	}
	return nullptr;
}

const FMeshDescription* UStaticMeshToolTarget::GetMeshDescriptionWithScaleApplied(UStaticMesh* StaticMesh, int32 UseLOD, FMeshDescriptionCache& CachedMeshDescriptions)
{
	static FMeshDescription EmptyMeshDescription;
	static bool bFirst = true;
	if (bFirst)
	{
		FStaticMeshAttributes Attributes(EmptyMeshDescription);
		Attributes.Register();
		bFirst = false;
	}

	if (!StaticMesh)
	{
		return &EmptyMeshDescription;
	}

	FMeshDescription* FoundMeshDescription = nullptr;
	FVector BuildScale = FVector::One();
	if (UseLOD == (int32)EMeshLODIdentifier::HiResSource)
	{
		FoundMeshDescription = StaticMesh->GetHiResMeshDescription();
		BuildScale = StaticMesh->GetHiResSourceModel().BuildSettings.BuildScale3D;
	}
	else
	{
		FoundMeshDescription = StaticMesh->GetMeshDescription(UseLOD);
		if (FoundMeshDescription)
		{
			BuildScale = StaticMesh->GetSourceModel(UseLOD).BuildSettings.BuildScale3D;
		}
	}

	if (CachedMeshDescriptions.Contains(UseLOD))
	{
		if (CachedMeshDescriptions[UseLOD].Source == FoundMeshDescription)
		{
			return CachedMeshDescriptions[UseLOD].Copy.Get();
		}
		else // cache was stale; clear it
		{
			CachedMeshDescriptions.Remove(UseLOD);
		}
	}

	if (FoundMeshDescription && !BuildScale.Equals(FVector::OneVector))
	{
		FCachedMeshDescription& Cache = CachedMeshDescriptions.Emplace(UseLOD);
		Cache.Source = FoundMeshDescription;
		Cache.Copy = MakeUnique<FMeshDescription>(*FoundMeshDescription);
		FTransform ScaleTransform = FTransform::Identity;
		ScaleTransform.SetScale3D(BuildScale);
		FStaticMeshOperations::ApplyTransform(*Cache.Copy, ScaleTransform, true);
		FoundMeshDescription = Cache.Copy.Get();
	}

	return (FoundMeshDescription != nullptr) ? FoundMeshDescription : &EmptyMeshDescription;
}

FMeshDescription UStaticMeshToolTarget::GetEmptyMeshDescription()
{
	FMeshDescription EmptyMeshDescription;
	FStaticMeshAttributes Attributes(EmptyMeshDescription);
	Attributes.Register();
	return EmptyMeshDescription;
}

void UStaticMeshToolTarget::CommitMeshDescription(const FCommitter& Committer, const FCommitMeshParameters& CommitParams)
{
	if (ensure(IsValid()) == false) return;

	EMeshLODIdentifier WriteToLOD = (CommitParams.bHaveTargetLOD && CommitParams.TargetLOD != EMeshLODIdentifier::Default) ? CommitParams.TargetLOD : EditingLOD;

	CommitMeshDescription(StaticMesh.Get(), Committer, WriteToLOD);
}

void UStaticMeshToolTarget::CommitMeshDescription(UStaticMesh* StaticMeshIn, const FCommitter& Committer, EMeshLODIdentifier EditingLODIn)
{
	using namespace StaticMeshToolTargetLocals;

	if ( ! ensure(EditingLODIn != EMeshLODIdentifier::Default && EditingLODIn != EMeshLODIdentifier::MaxQuality) )
	{
		UE_LOG(LogGeometry, Warning, TEXT("UStaticMeshToolTarget::CommitMeshDescription: invalid Target LOD, must specify explicit LOD"));
		return;
	}
	if (StaticMeshIn->GetPathName().StartsWith(TEXT("/Engine/")))
	{
		DisplayCriticalWarningMessage(FString::Printf(TEXT("CANNOT MODIFY BUILT-IN ENGINE ASSET %s"), *StaticMeshIn->GetPathName()));
		return;
	}

	// flush any pending rendering commands, which might touch this component while we are rebuilding it's mesh
	FlushRenderingCommands();

	// make sure transactional flag is on for this asset
	StaticMeshIn->SetFlags(RF_Transactional);
	// mark as modified
	StaticMeshIn->Modify();

	FMeshDescription* UpdateMeshDescription = nullptr;
	if (EditingLODIn == EMeshLODIdentifier::HiResSource)
	{
		UpdateMeshDescription = StaticMeshIn->GetHiResMeshDescription();
		if (UpdateMeshDescription == nullptr)
		{
			UpdateMeshDescription = StaticMeshIn->CreateHiResMeshDescription();
		}
	}
	else
	{
		int32 UseLODIndex = static_cast<int32>(EditingLODIn);
		if (StaticMeshIn->GetNumSourceModels() < UseLODIndex+1)
		{
			StaticMeshIn->SetNumSourceModels(UseLODIndex+1);
		}

		UpdateMeshDescription = StaticMeshIn->GetMeshDescription(UseLODIndex);
		if (UpdateMeshDescription == nullptr)
		{
			UpdateMeshDescription = StaticMeshIn->CreateMeshDescription(UseLODIndex);
		}
	}

	// disable auto-generated normals StaticMesh build setting
	UE::MeshDescription::FStaticMeshBuildSettingChange SettingsChange;
	SettingsChange.AutoGeneratedNormals = UE::MeshDescription::EBuildSettingBoolChange::Disable;
	if (static_cast<int32>(EditingLODIn) <= (int32)EMeshLODIdentifier::LOD7)
	{
		UE::MeshDescription::ConfigureBuildSettings(StaticMeshIn, static_cast<int32>(EditingLODIn), SettingsChange);
	}
	// do we need to configure build settings for highres LOD?

	FVector BuildScale = FVector::OneVector;
	if (EditingLODIn == EMeshLODIdentifier::HiResSource)
	{
		StaticMeshIn->ModifyHiResMeshDescription();
		BuildScale = StaticMeshIn->GetHiResSourceModel().BuildSettings.BuildScale3D;
	}
	else
	{
		StaticMeshIn->ModifyMeshDescription((int32)EditingLODIn);
		if (StaticMeshIn->IsSourceModelValid((int32)EditingLODIn))
		{
			BuildScale = StaticMeshIn->GetSourceModel((int32)EditingLODIn).BuildSettings.BuildScale3D;
		}
	}

	FCommitterParams CommitterParams;
	CommitterParams.MeshDescriptionOut = UpdateMeshDescription;

	Committer(CommitterParams);
	if (!BuildScale.Equals(FVector::OneVector))
	{
		FTransform InverseBuildScaleTransform = FTransform::Identity;
		FVector InverseBuildScale;
		// Safely invert BuildScale
		for (int32 Idx = 0; Idx < 3; ++Idx)
		{
			InverseBuildScale[Idx] = FMath::IsNearlyZero(BuildScale[Idx], FMathd::Epsilon) ? 1.0 : 1.0 / BuildScale[Idx];
		}
		InverseBuildScaleTransform.SetScale3D(InverseBuildScale);
		FStaticMeshOperations::ApplyTransform(*UpdateMeshDescription, InverseBuildScaleTransform, true);
	}

	if (EditingLODIn == EMeshLODIdentifier::HiResSource)
	{
		StaticMeshIn->CommitHiResMeshDescription();
	}
	else
	{
		StaticMeshIn->CommitMeshDescription((int32)EditingLODIn);

		// configure build settings to prevent the standard static mesh reduction from running and replacing the render LOD.
		FStaticMeshSourceModel& ThisSourceModel = StaticMeshIn->GetSourceModel((int32)EditingLODIn);
		ThisSourceModel.ResetReductionSetting();
	}

	StaticMeshIn->PostEditChange();
}

FDynamicMesh3 UStaticMeshToolTarget::GetDynamicMesh()
{
	return GetDynamicMeshViaMeshDescription(*this);
}

FDynamicMesh3 UStaticMeshToolTarget::GetDynamicMesh(bool bRequestTangents)
{
	return GetDynamicMeshViaMeshDescription(*this, bRequestTangents);
}

void UStaticMeshToolTarget::CommitDynamicMesh(const FDynamicMesh3& Mesh, const FDynamicMeshCommitInfo& CommitInfo)
{
	FMeshDescription CurrentMeshDescription = *GetMeshDescription();
	CommitDynamicMeshViaMeshDescription(MoveTemp(CurrentMeshDescription), *this, Mesh, CommitInfo);
}

UStaticMesh* UStaticMeshToolTarget::GetStaticMesh() const
{
	return IsValid() ? StaticMesh.Get() : nullptr;
}


// Factory

bool UStaticMeshToolTargetFactory::CanBuildTarget(UObject* SourceObject, const FToolTargetTypeRequirements& Requirements) const
{
	const UStaticMesh* StaticMesh = GetValid(Cast<UStaticMesh>(SourceObject));
	return StaticMesh && !StaticMesh->IsUnreachable() && StaticMesh->IsValidLowLevel()
		&& !StaticMesh->GetOutermost()->bIsCookedForEditor
		&& UStaticMeshToolTarget::HasNonGeneratedLOD(StaticMesh, EditingLOD)
		&& Requirements.AreSatisfiedBy(UStaticMeshToolTarget::StaticClass());
}

UToolTarget* UStaticMeshToolTargetFactory::BuildTarget(UObject* SourceObject, const FToolTargetTypeRequirements& Requirements)
{
	UStaticMeshToolTarget* Target = NewObject<UStaticMeshToolTarget>();// TODO: Should we set an outer here?
	Target->StaticMesh = Cast<UStaticMesh>(SourceObject);
	Target->SetEditingLOD(EditingLOD);
	checkSlow(Target->StaticMesh.IsValid() && Requirements.AreSatisfiedBy(Target));

	return Target;
}


void UStaticMeshToolTargetFactory::SetActiveEditingLOD(EMeshLODIdentifier NewEditingLOD)
{
	EditingLOD = NewEditingLOD;
}

#undef LOCTEXT_NAMESPACE

