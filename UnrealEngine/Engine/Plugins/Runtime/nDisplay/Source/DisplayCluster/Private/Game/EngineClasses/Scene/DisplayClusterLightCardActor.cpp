// Copyright Epic Games, Inc. All Rights Reserved.

#include "DisplayClusterLightCardActor.h"

#include "DisplayClusterConfigurationTypes.h"
#include "DisplayClusterRootActor.h"
#include "IDisplayClusterLightCardActorExtender.h"

#include "Components/DisplayClusterLabelComponent.h"
#include "Components/StaticMeshComponent.h"
#include "GameFramework/SpringArmComponent.h"
#include "Materials/MaterialInstanceDynamic.h"
#include "Engine/StaticMesh.h"
#include "UObject/ConstructorHelpers.h"

#if WITH_EDITOR

#include "Editor.h"
#include "Layers/LayersSubsystem.h"

#endif

#if WITH_OPENCV

#include "OpenCVHelper.h"

#include "PreOpenCVHeaders.h"
#include "opencv2/imgproc.hpp"
#include "PostOpenCVHeaders.h"

#endif //WITH_OPENCV

int32 GDisplayClusterLightCardPolygonTextureSize = 128;
static FAutoConsoleVariableRef CVarDisplayClusterLightCardPolygonTextureSize(
	TEXT("DC.LightCardPolygonTextureSize"),
	GDisplayClusterLightCardPolygonTextureSize,
	TEXT("Size of the textures generated by light cards that use a polygon to define its alpha mask. Use a power of 2."),
	ECVF_Default
);

const float ADisplayClusterLightCardActor::UVPlaneDefaultSize = 200.0f;
const float ADisplayClusterLightCardActor::UVPlaneDefaultDistance = 100.0f;

ADisplayClusterLightCardActor::ADisplayClusterLightCardActor(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
	, DistanceFromCenter(300.f)
	, Longitude(0.f)
	, Latitude(30.f)
	, Spin(0.f)
	, Pitch(0.f)
	, Yaw(0.f)
	, Scale(FVector2D(1.f))
	, RadialOffset(-0.5)
	, Mask(EDisplayClusterLightCardMask::Circle)
	, Texture(nullptr)
	, Color(FLinearColor(1.f, 1.f, 1.f, 1.f))
	, Temperature(6500)
	, Tint(0.f)
	, Exposure(0.f)
	, Gain(1.f)
	, Opacity(1.f)
	, Feathering(0.f)
{
	PrimaryActorTick.bCanEverTick = true;

	DefaultSceneRootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("DefaultSceneRoot"));
	SetRootComponent(DefaultSceneRootComponent);

	MainSpringArmComponent = CreateDefaultSubobject<USpringArmComponent>(TEXT("MainSpringArm"));
	MainSpringArmComponent->AttachToComponent(DefaultSceneRootComponent, FAttachmentTransformRules::KeepRelativeTransform);
	MainSpringArmComponent->bDoCollisionTest = false;

	LightCardTransformerComponent = CreateDefaultSubobject<USceneComponent>(TEXT("LightCardTransformer"));
	LightCardTransformerComponent->AttachToComponent(MainSpringArmComponent, FAttachmentTransformRules::KeepRelativeTransform);

	{
		static ConstructorHelpers::FObjectFinder<UStaticMesh> PlaneObj(TEXT("/nDisplay/LightCard/SM_LightCardPlane"));

		LightCardComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("LightCard"));
		LightCardComponent->AttachToComponent(LightCardTransformerComponent, FAttachmentTransformRules::KeepRelativeTransform);
		LightCardComponent->SetCollisionProfileName(TEXT("OverlapAllDynamic"));
		LightCardComponent->Mobility = EComponentMobility::Movable;
		LightCardComponent->SetStaticMesh(PlaneObj.Object);
	}

#if WITH_EDITOR
	{
		static ConstructorHelpers::FObjectFinder<UStaticMesh> UVIndicatorObj(TEXT("/nDisplay/LightCard/SM_UVIndicator"));

		UVIndicatorComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("UVIndicator"));
		UVIndicatorComponent->AttachToComponent(LightCardComponent, FAttachmentTransformRules::KeepRelativeTransform);
		UVIndicatorComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);
		UVIndicatorComponent->Mobility = EComponentMobility::Movable;
		UVIndicatorComponent->SetStaticMesh(UVIndicatorObj.Object);

		UVIndicatorComponent->SetRelativeLocation(FVector(0, 0, 1)); // Slightly in front of the parent
		UVIndicatorComponent->SetVisibility(false);
	}
#endif // WITH_EDITOR

	UpdateStageActorTransform();

	LabelComponent = CreateOptionalDefaultSubobject<UDisplayClusterLabelComponent>(TEXT("Label"), true);
	LabelComponent->AttachToComponent(LightCardComponent, FAttachmentTransformRules::KeepRelativeTransform);

	CreateComponentsForExtenders();
}

void ADisplayClusterLightCardActor::PostLoad()
{
	Super::PostLoad();

	CleanUpComponentsForExtenders();
}

void ADisplayClusterLightCardActor::OnConstruction(const FTransform& Transform)
{
	Super::OnConstruction(Transform);

	UpdatePolygonTexture();

	UMaterialInterface* Material = LightCardComponent->GetMaterial(0);

	if (Material && !Material->IsA<UMaterialInstanceDynamic>())
	{
		UMaterialInstanceDynamic* LightCardMatInstance = UMaterialInstanceDynamic::Create(Material, LightCardComponent, TEXT("LightCardMID"));
		LightCardComponent->SetMaterial(0, LightCardMatInstance);

		UpdateLightCardMaterialInstance();
	}
}

void ADisplayClusterLightCardActor::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);

	ClampLatitudeAndLongitude(Latitude, Longitude);

	UpdateStageActorTransform();
	UpdateLightCardMaterialInstance();
	UpdateLightCardVisibility();
	UpdateUVIndicator();
}

#if WITH_EDITOR

void ADisplayClusterLightCardActor::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeProperty(PropertyChangedEvent);

	if (PropertyChangedEvent.Property && (
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, DistanceFromCenter) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Longitude) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Latitude) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Spin) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, RadialOffset) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Scale) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, bIsUVLightCard)))
	{
		UpdateStageActorTransform();
	}

	if (PropertyChangedEvent.Property && (
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Polygon) ||
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Feathering)))
	{
		UpdatePolygonTexture();
	}

	if (PropertyChangedEvent.Property && (
		   PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Mask)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Polygon) 
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Texture) 
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Color)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Exposure)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Gain)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Opacity)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Feathering)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, AlphaGradient)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Tint)
		|| PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, Temperature)
		))
	{
		UpdateLightCardMaterialInstance();
	}

	if (PropertyChangedEvent.Property && (
		PropertyChangedEvent.Property->GetFName() == GET_MEMBER_NAME_CHECKED(ADisplayClusterLightCardActor, bIsUVLightCard)))
	{
		UpdateLightCardVisibility();
	}
}

FName ADisplayClusterLightCardActor::GetCustomIconName() const
{
	if (bIsUVLightCard)
	{
		return TEXT("ClassIcon.DisplayClusterLightCardActor.UVLightCard");
	}

	return Super::GetCustomIconName();
}

#endif

void ADisplayClusterLightCardActor::GetLightCardMeshComponents(TArray<UMeshComponent*>& MeshComponents) const
{
	MeshComponents.Add(LightCardComponent.Get());

#if WITH_EDITOR
	if (GIsEditor && bIsUVLightCard)
	{
		MeshComponents.Add(UVIndicatorComponent.Get());
	}
#endif // WITH_EDITOR
}

UStaticMesh* ADisplayClusterLightCardActor::GetStaticMesh() const
{
	return LightCardComponent->GetStaticMesh();
}

void ADisplayClusterLightCardActor::SetStaticMesh(UStaticMesh* InStaticMesh)
{
	LightCardComponent->SetStaticMesh(InStaticMesh);
}

void ADisplayClusterLightCardActor::UpdateLightCardMaterialInstance()
{
	if (UMaterialInstanceDynamic* LightCardMaterialInstance = Cast<UMaterialInstanceDynamic>(LightCardComponent->GetMaterial(0)))
	{
		// Showing proxy with low opacity to make it less distracting when it doesn't line up well with its projection in the Light Card Editor.
		constexpr float ProxyOpacity = 0.25;

		LightCardMaterialInstance->ClearParameterValues();

		LightCardMaterialInstance->SetVectorParameterValue(TEXT("CardColor"), Color);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("Temperature"), Temperature);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("Tint"), Tint);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("Exposure"), Exposure);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("Gain"), Gain);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("Opacity"), IsProxy() ? ProxyOpacity : Opacity);
		LightCardMaterialInstance->SetTextureParameterValue(TEXT("Texture"), Texture);
		LightCardMaterialInstance->SetTextureParameterValue(TEXT("AlphaTexture"), PolygonMask);

		LightCardMaterialInstance->SetScalarParameterValue(TEXT("AlphaGradient"), AlphaGradient.bEnableAlphaGradient);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("AlphaGradientStartingAlpha"), AlphaGradient.StartingAlpha);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("AlphaGradientEndingAlpha"), AlphaGradient.EndingAlpha);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("AlphaGradientAngle"), AlphaGradient.Angle);

		bool bUseMask = true; // Enable masking
		bool bUseTextureAlpha = false; // Use the alpha channel of Texture as mask
		bool bUseAlphaTexture = false; // Use the AlphaTexture
		float FeatheringValue = Feathering;

		switch (Mask)
		{
		case EDisplayClusterLightCardMask::Square:
			bUseMask = false;
			break;

		case EDisplayClusterLightCardMask::UseTextureAlpha:
			bUseTextureAlpha = true;
			break;

		case EDisplayClusterLightCardMask::Polygon:
			bUseTextureAlpha = true;
			bUseAlphaTexture = true;
			FeatheringValue = 0.;
			break;
		}

		LightCardMaterialInstance->SetScalarParameterValue(TEXT("Feather"), FeatheringValue);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("UseMask"), bUseMask);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("UseTextureAlpha"), bUseTextureAlpha);
		LightCardMaterialInstance->SetScalarParameterValue(TEXT("UseAlphaTexture"), bUseAlphaTexture);
	}
}

void ADisplayClusterLightCardActor::UpdatePolygonTexture()
{
#if WITH_OPENCV

	if (Polygon.Num() < 3)
	{
		PolygonMask = nullptr;
		return;
	}

	if (GDisplayClusterLightCardPolygonTextureSize < 2)
	{
		return;
	}

	const int32 TextureWidth = GDisplayClusterLightCardPolygonTextureSize;
	const int32 TextureHeight = GDisplayClusterLightCardPolygonTextureSize;

	cv::Mat GrayMat(cv::Size(TextureHeight, TextureWidth), CV_8UC1, cv::Scalar(0));

	std::vector<cv::Point2i> PolyVec; // polygon with LC shape that to be filled with cv::fillPoly
	PolyVec.reserve(Polygon.Num());

	for (const FVector2d& PolyPoint : Polygon)
	{
		PolyVec.push_back(cv::Point2i(
			FMath::RoundToInt(TextureWidth  * PolyPoint.X), 
			FMath::RoundToInt(TextureHeight * PolyPoint.Y))
		);
	}

	// Fill the polygon pixels
	cv::fillPoly(GrayMat, PolyVec, 255, cv::LINE_AA); // Polygon inside is 255, outside is 0

	// Apply feathering effect
	if (Feathering > 0)
	{
		// Overscan it so that the effects near the edges are as desired
		const int32 Overscan = (TextureWidth + TextureHeight) / 16;
		const cv::Size OverscanMatSize(GrayMat.rows + 2 * Overscan, GrayMat.cols + 2 * Overscan);
		cv::Mat OverscanMat(OverscanMatSize, GrayMat.type(), cv::Scalar(0));

		const cv::Rect OverscanActiveRect(Overscan, Overscan, GrayMat.cols, GrayMat.rows);

		GrayMat.copyTo(OverscanMat(OverscanActiveRect));

		// Erode to compensate for the growth that the blur causes
		{
			const int32 KernelSize = int32((Feathering * TextureWidth) / 6) * 2 + 1;

			const cv::Mat ErodeKernel = cv::getStructuringElement(
				cv::MORPH_ERODE,
				cv::Size(KernelSize, KernelSize)
			);

			cv::erode(OverscanMat, OverscanMat, ErodeKernel);
		}

		// Blur
		{
			const int32 KernelSize = int32((Feathering * TextureWidth) / 2) * 2 + 1;

			// We are going to blur the outside
			OverscanMat = 255 - OverscanMat;

			const float SigmaX = 0.2 * ((KernelSize - 1) * 0.5 - 1) + 0.8;
			const float SigmaY = SigmaX;

			cv::GaussianBlur(OverscanMat, OverscanMat, cv::Size(KernelSize, KernelSize), SigmaX, SigmaY);

			// We recover the non-inverted alpha now
			OverscanMat = 255 - OverscanMat;
		}

		// Put back to Gray
		OverscanMat(OverscanActiveRect).copyTo(GrayMat);
	}

	// Create a texture, all white and and the shape goes in the alpha
	cv::Mat RGBAMat(cv::Size(TextureWidth, TextureHeight), CV_8UC4, cv::Scalar::all(255));
	cv::insertChannel(GrayMat, RGBAMat, 3);

	// Create UTexture
	PolygonMask = FOpenCVHelper::TextureFromCvMat(RGBAMat);

#endif // WITH_OPENCV
}

void ADisplayClusterLightCardActor::UpdateLightCardVisibility()
{
	if (bIsUVLightCard)
	{
		// Only render the UV light card if this is a proxy actor
		const bool bShouldBeVisible = IsProxy();

		if (LightCardComponent->IsVisible() != bShouldBeVisible)
		{
			LightCardComponent->SetVisibility(bShouldBeVisible);
		}
	}
}


void ADisplayClusterLightCardActor::UpdateUVIndicator()
{
#if WITH_EDITOR
	if (GIsEditor && bIsUVLightCard && IsProxy())
	{
		if (!UVIndicatorComponent->IsVisible())
		{
			UVIndicatorComponent->SetVisibility(true);
		}
	}
	else if (UVIndicatorComponent->IsVisible())
	{
		UVIndicatorComponent->SetVisibility(false);
	}

	if (GIsEditor && bIsUVLightCard)
	{
		// Always keep indicator on top of the light card
		UVIndicatorComponent->TranslucencySortPriority = LightCardComponent->TranslucencySortPriority;
		UVIndicatorComponent->TranslucencySortDistanceOffset = LightCardComponent->TranslucencySortDistanceOffset - 0.1f;
		
		// Keep 1:1 aspect ratio
		if (const USceneComponent* UVParentComponent = UVIndicatorComponent->GetAttachParent())
		{
			const FVector ParentWorldScale = UVParentComponent->GetComponentScale();

			const double ParentScaleAbsX = FMath::Abs(ParentWorldScale.X);
			const double ParentScaleAbsY = FMath::Abs(ParentWorldScale.Y);

			const double ParentScaleMin = FMath::Min(ParentScaleAbsX, ParentScaleAbsY);

			if (ParentScaleMin > KINDA_SMALL_NUMBER)
			{
				constexpr double UVScale = 0.25;
				FVector ScaleFactor(1, 1, 1);

				if (ParentScaleAbsX > ParentScaleAbsY)
				{
					ScaleFactor.X = ParentScaleAbsY / ParentScaleAbsX;
				}
				else
				{
					ScaleFactor.Y = ParentScaleAbsX / ParentScaleAbsY;
				}

				// Don't let the uv indicator be overly big if the light card itself is big.
				constexpr double MaxAllowedParentScale = 0.5;
				const double ClampScaleFactor = FMath::Clamp(MaxAllowedParentScale / ParentScaleMin, 0, 1);

				UVIndicatorComponent->SetRelativeScale3D(UVScale * ClampScaleFactor * ScaleFactor);
			}
		}
	}
#endif // WITH_EDITOR
}

void ADisplayClusterLightCardActor::ShowLightCardLabel(bool bValue, float ScaleValue, ADisplayClusterRootActor* InRootActor)
{
	if (IsUVActor())
	{
		// UV actors don't currently support labels
		return;
	}

#if WITH_EDITOR
	LabelComponent->Modify(false);
	LightCardComponent->Modify(false);
#endif
	LabelComponent->SetVisibility(bValue, true);
	LabelComponent->SetRootActor(InRootActor);
	LabelComponent->SetWidgetScale(ScaleValue);
	
	const float LightCardSortPriorityLow = -1.f;
	
	if (bValue)
	{
		// Change the translucent sort priority of the light card component so it will always be shown behind the
		// label component. When left at 0 the renderer will choose the sort order which may be wrong.
		// This does rely on the light card material being translucent as well.
		SavedTranslucencySortPriority = LightCardComponent->TranslucencySortPriority;
		LightCardComponent->SetTranslucentSortPriority(LightCardSortPriorityLow);
	}
	else if (SavedTranslucencySortPriority.IsSet() && *SavedTranslucencySortPriority != LightCardComponent->TranslucencySortPriority &&
			LightCardComponent->TranslucencySortPriority == LightCardSortPriorityLow)
	{
		// Change the sort order back to the original value and only if the user hasn't modified it since activating the label.
		// It's highly unlikely this will ever be anything besides 0.
		LightCardComponent->SetTranslucentSortPriority(*SavedTranslucencySortPriority);
		SavedTranslucencySortPriority.Reset();
	}
}

void ADisplayClusterLightCardActor::SetRootActorOwner(ADisplayClusterRootActor* InRootActor)
{
	RootActorOwner = MakeWeakObjectPtr(InRootActor);
}

void ADisplayClusterLightCardActor::AddToLightCardLayer(ADisplayClusterRootActor* InRootActor)
{
	check(InRootActor);

	UDisplayClusterConfigurationData* ConfigData = InRootActor->GetConfigData();
	check(ConfigData);
	
	// Add light cards to an existing layer or a new layer. This helps with restoring snapshots of a DCRA
	// so they can be done separately from light cards and still have access to all light cards in the layer.
				
	static const FString LightCardPrefix = TEXT("LightCards");
	FName LightCardLayerName = NAME_None;

	FDisplayClusterConfigurationICVFX_VisibilityList& RootActorLightCards = ConfigData->StageSettings.Lightcard.ShowOnlyList;
	
	if (const FActorLayer* ExistingLightCardLayer = RootActorLightCards.ActorLayers.FindByPredicate([](const FActorLayer& Layer)
	{
		return Layer.Name.ToString().StartsWith(LightCardPrefix);
	}))
	{
		LightCardLayerName = ExistingLightCardLayer->Name;
	}
	else
	{
		// Find a unique name so it's LightCards_XXXX
		do
		{
			const FGuid LayerGuid = FGuid::NewGuid();
			const FString GuidStr = LayerGuid.ToString().Left(4);
			LightCardLayerName = *FString::Printf(TEXT("%s_%s"), *LightCardPrefix, *GuidStr);
		}
		while (FindObject<UObject>(GetWorld(), *LightCardLayerName.ToString()) != nullptr);
		
		ConfigData->Modify();
		RootActorLightCards.ActorLayers.AddDefaulted_GetRef().Name = LightCardLayerName;
	}
	
	check(!LightCardLayerName.IsNone());

	bool bLayerAdded = false;
#if WITH_EDITOR
	ULayersSubsystem* LayersSubsystem = GEditor ? GEditor->GetEditorSubsystem<ULayersSubsystem>() : nullptr;
	if (LayersSubsystem)
	{
		// Adjust transparent sort order for UV light cards
		if (IsUVActor())
		{
			int32 HighestPriority = MIN_int32;
			bool bExistingPrioritiesFound = false;
			
			const TArray<AActor*> ActorsInLayer = LayersSubsystem->GetActorsFromLayer(LightCardLayerName);
			for (AActor* Actor : ActorsInLayer)
			{
				if (const ADisplayClusterLightCardActor* LightCard = Cast<ADisplayClusterLightCardActor>(Actor))
				{
					if (LightCard->IsUVActor())
					{
						if (LightCard->LightCardComponent->TranslucencySortPriority > HighestPriority)
						{
							HighestPriority = LightCard->LightCardComponent->TranslucencySortPriority;
						}
						bExistingPrioritiesFound = true;
					}
				}
			}

			if (bExistingPrioritiesFound)
			{
				// Newly added cards should be on the top-most visibility layer
				LightCardComponent->TranslucencySortPriority = HighestPriority < MAX_int32 ? HighestPriority + 1 : HighestPriority;
			}
		}

		LayersSubsystem->AddActorsToLayer(TArray<AActor*>{ this }, LightCardLayerName);
		bLayerAdded = true;
	}
#endif
	if (!bLayerAdded)
	{
		// Likely -game and we need to add the layer directly
		Layers.AddUnique(LightCardLayerName);
	}

	SetRootActorOwner(InRootActor);
}

void ADisplayClusterLightCardActor::UpdateStageActorTransform()
{
	// If the light card is in UV space, set the spring arm's trasform to be zero, effectively removing it from the transform hierarchy
	// This allows the light card to be positioned with the actor's cartesian coordinates instead of longitude and latitude
	if (bIsUVLightCard)
	{
		MainSpringArmComponent->TargetArmLength = 0.0f;
		MainSpringArmComponent->SetRelativeRotation(FRotator(0.0, 180.0, 0.0));

		// Set world location and rotation such that the light card is always projected onto a YZ plane a distance of UVPlaneDefaultDistance from the world origin, facing in the -X direction
		// This ensures that when the UV light cards are rendered to the light card map, they are always positioned and oriented correctly regardless of the stages location and rotation.
		
		// We place them slightly closer than UVPlaneDefaultDistance so that mouse clicks hit it first instead of DCRA meshes (avoids re-linetracing).
		// UV LCs operate in orthographic projection so this should have no visual effect.
		constexpr float DistanceFactor = 0.99f;

		LightCardTransformerComponent->SetWorldLocation(FVector(DistanceFactor * UVPlaneDefaultDistance, -UVPlaneDefaultSize * (0.5 - UVCoordinates.X), UVPlaneDefaultSize * (0.5 - UVCoordinates.Y)));
		LightCardTransformerComponent->SetWorldRotation(FVector(-1, 0, 0).Rotation());
		LightCardTransformerComponent->SetWorldScale3D(FVector::OneVector);
	}
	else
	{
		MainSpringArmComponent->TargetArmLength = DistanceFromCenter + RadialOffset;
		MainSpringArmComponent->SetRelativeRotation(FRotator(-Latitude, Longitude, 0.0));
	}

	FRotator LightCardOrientation = FRotator(-Pitch, Yaw, Spin);

	LightCardComponent->SetRelativeRotation((LightCardOrientation.Quaternion() * PlaneMeshRotation.Quaternion()).Rotator());
	LightCardComponent->SetRelativeScale3D(FVector(Scale, 1.f));
}

FTransform ADisplayClusterLightCardActor::GetStageActorTransform(bool bRemoveOrigin) const
{
	FTransform Transform;

	FVector Position = LightCardComponent->GetComponentLocation();
	if (bRemoveOrigin)
	{
		Position -= GetActorLocation();
	}
	Transform.SetLocation(MoveTemp(Position));

	// Use the light card component's orientation, but remove the plane mesh rotation so that the returned transform's local x axis
	// points radially inwards to match engine convention
	const FQuat LightCardOrientation = LightCardComponent->GetComponentQuat() * PlaneMeshRotation.Quaternion().Inverse();

	Transform.SetRotation(LightCardOrientation);

	return Transform;
}

FBox ADisplayClusterLightCardActor::GetBoxBounds(bool bLocalSpace) const
{
	FTransform ObjectOrientedTransform;
	ObjectOrientedTransform.SetRotation(PlaneMeshRotation.Quaternion());

	if (!bLocalSpace)
	{
		ObjectOrientedTransform.SetTranslation(LightCardComponent->GetComponentLocation());
		ObjectOrientedTransform.SetScale3D(LightCardComponent->GetComponentScale());
	}

	return LightCardComponent->CalcBounds(ObjectOrientedTransform).GetBox();
}

void ADisplayClusterLightCardActor::SetLongitude(double InValue)
{
	Longitude = InValue;
}

double ADisplayClusterLightCardActor::GetLongitude() const
{
	return Longitude;
}

void ADisplayClusterLightCardActor::SetLatitude(double InValue)
{
	Latitude = InValue;
}

double ADisplayClusterLightCardActor::GetLatitude() const
{
	return Latitude;
}

void ADisplayClusterLightCardActor::SetDistanceFromCenter(double InValue)
{
	DistanceFromCenter = InValue;
}

double ADisplayClusterLightCardActor::GetDistanceFromCenter() const
{
	return DistanceFromCenter;
}

void ADisplayClusterLightCardActor::SetSpin(double InValue)
{
	Spin = InValue;
}

void ADisplayClusterLightCardActor::SetPitch(double InValue)
{
	Pitch = InValue;
}

double ADisplayClusterLightCardActor::GetSpin() const
{
	return Spin;
}

double ADisplayClusterLightCardActor::GetPitch() const
{
	return Pitch;
}

void ADisplayClusterLightCardActor::SetYaw(double InValue)
{
	Yaw = InValue;
}

double ADisplayClusterLightCardActor::GetYaw() const
{
	return Yaw;
}

void ADisplayClusterLightCardActor::SetRadialOffset(double InValue)
{
	RadialOffset = InValue;
}

double ADisplayClusterLightCardActor::GetRadialOffset() const
{
	return RadialOffset;
}

bool ADisplayClusterLightCardActor::IsUVActor() const
{
	return bIsUVLightCard;
}

void ADisplayClusterLightCardActor::SetOrigin(const FTransform& InOrigin)
{
	SetActorLocation(InOrigin.GetLocation());
	SetActorRotation(InOrigin.GetRotation());
	// Scale not currently used for origin
}

FTransform ADisplayClusterLightCardActor::GetOrigin() const
{
	return {GetActorRotation(), GetActorLocation(), FVector::One()};
}

void ADisplayClusterLightCardActor::SetScale(const FVector2D& InScale)
{
	Scale = InScale;
}

FVector2D ADisplayClusterLightCardActor::GetScale() const
{
	return Scale;
}

void ADisplayClusterLightCardActor::SetUVCoordinates(const FVector2D& InUVCoordinates)
{
	UVCoordinates = InUVCoordinates;
}

FVector2D ADisplayClusterLightCardActor::GetUVCoordinates() const
{
	return UVCoordinates;
}

void ADisplayClusterLightCardActor::GetPositionalProperties(FPositionalPropertyArray& OutPropertyPairs) const
{
	void* Container = (void*)(this);

	const TSet<FName>& PropertyNames = GetPositionalPropertyNames();
	OutPropertyPairs.Reserve(PropertyNames.Num());

	for (const FName& PropertyName : PropertyNames)
	{
		if (FProperty* Property = FindFProperty<FProperty>(GetClass(), PropertyName))
		{
			OutPropertyPairs.Emplace(Container, Property);
		}
	}
}

void ADisplayClusterLightCardActor::CreateComponentsForExtenders()
{
	IModularFeatures& ModularFeatures = IModularFeatures::Get();
	const TArray<IDisplayClusterLightCardActorExtender*> Extenders = ModularFeatures.GetModularFeatureImplementations<IDisplayClusterLightCardActorExtender>(IDisplayClusterLightCardActorExtender::ModularFeatureName);
	for (IDisplayClusterLightCardActorExtender* Extender : Extenders)
	{
		UClass* ExtenderComponentClass = Extender->GetAdditionalSubobjectClass().Get();
		const FName ExtenderName = Extender->GetExtenderName();
		if (!ensureAlwaysMsgf(ExtenderComponentClass, TEXT("Cannot apply display cluster Extender. Invalid component class.")))
		{
			continue;
		}
		else if (!ensureAlwaysMsgf(!ExtenderName.IsNone(), TEXT("Cannot apply display cluster Extender. Extender name cannot be empty.")))
		{
			continue;
		}
		else if (!ensureAlwaysMsgf(!ExtenderNameToComponentMap.Contains(ExtenderName), TEXT("Cannot apply display cluster Extender. Extender name already in use.")))
		{
			continue;
		}

		const FName ObjectName = MakeUniqueObjectName(this, ExtenderComponentClass, ExtenderName);
		constexpr bool bIsRequired = false;
		constexpr bool bIsTransient = false;
		UObject* Component = CreateDefaultSubobject(ObjectName, UActorComponent::StaticClass(), ExtenderComponentClass, bIsRequired, bIsTransient);
		ExtenderNameToComponentMap.Add(ExtenderName, CastChecked<UActorComponent>(Component));
	}
}

void ADisplayClusterLightCardActor::CleanUpComponentsForExtenders()
{
	TArray<FName> AvailableExtenders;
	IModularFeatures& ModularFeatures = IModularFeatures::Get();
	const TArray<IDisplayClusterLightCardActorExtender*> Extenders = ModularFeatures.GetModularFeatureImplementations<IDisplayClusterLightCardActorExtender>(IDisplayClusterLightCardActorExtender::ModularFeatureName);
	for (IDisplayClusterLightCardActorExtender* Extender : Extenders)
	{
		AvailableExtenders.Add(Extender->GetExtenderName());
	}
	const TMap<FName, TObjectPtr<UActorComponent>> CachedExtenderNameToComponentMap(ExtenderNameToComponentMap);
	for (const TTuple<FName, TObjectPtr<UActorComponent>>& ExtenderNameToComponentPair : CachedExtenderNameToComponentMap)
	{
		if (!AvailableExtenders.Contains(ExtenderNameToComponentPair.Key))
		{
			ExtenderNameToComponentMap.Remove(ExtenderNameToComponentPair.Key);
		}
	}
}
