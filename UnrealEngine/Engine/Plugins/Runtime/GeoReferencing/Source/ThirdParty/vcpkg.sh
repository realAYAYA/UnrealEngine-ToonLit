#!/bin/bash

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

# this is a tag in the vcpkg repository
VCPKG_VERSION=2021.05.12

# this is where the artifacts get installed
VCPKG_INSTALLED=vcpkg-installed

VCPKG_TRIPLETS=()

# deduce vcpkg nomenclature for this system
if [ `uname` == "Linux" ]; then
  VCPKG_TRIPLETS+=( overlay-x64-linux )

  # Engine/Source/ThirdParty location
  THIRD_PARTY=$(cd "${DIR}/../../../../../Source/ThirdParty" ; pwd)

  # Folder containing HostLinux
  export UE_SDKS_ROOT="${UE_SDKS_ROOT:-/epic}"

  # Sanity SDKs existence
  if [[ ! -d "${UE_SDKS_ROOT}" ]]; then
      echo ERROR: UE_SDKS_ROOT envvar not set or specifies non-existant location
      exit 1
  fi

  # Full path to toolchain root
  export LINUX_MULTIARCH_ROOT="${LINUX_MULTIARCH_ROOT:-${UE_SDKS_ROOT}/HostLinux/Linux_x64/v17_clang-10.0.1-centos7}"

  # Sanity compiler existence
  if [[ ! -d "${LINUX_MULTIARCH_ROOT}" ]]; then
      echo ERROR: LINUX_MULTIARCH_ROOT envvar not set or specifies non-existant toolchain
      exit 1
  fi

  # Which toolchain in the root to use
  export ARCH="${ARCH:-x86_64-unknown-linux-gnu}"

  echo
  echo === Generating toolchain file /tmp/__cmake_toolchain.cmake, using compiler at: ${LINUX_MULTIARCH_ROOT} ===

( cat <<_EOF_
  ## autogenerated by ${BASH_SOURCE} script
  SET(LINUX_MULTIARCH_ROOT \$ENV{LINUX_MULTIARCH_ROOT})
  SET(ARCHITECTURE_TRIPLE \$ENV{ARCH})

  message (STATUS "LINUX_MULTIARCH_ROOT is '\${LINUX_MULTIARCH_ROOT}'")
  message (STATUS "ARCHITECTURE_TRIPLE is '\${ARCHITECTURE_TRIPLE}'")

  SET(CMAKE_CROSSCOMPILING TRUE)
  SET(CMAKE_SYSTEM_NAME Linux)
  SET(CMAKE_SYSTEM_VERSION 1)

  # sysroot
  SET(CMAKE_SYSROOT \${LINUX_MULTIARCH_ROOT}/\${ARCHITECTURE_TRIPLE})

  SET(CMAKE_LIBRARY_ARCHITECTURE \${ARCHITECTURE_TRIPLE})

  # specify the cross compiler
  SET(CMAKE_C_COMPILER            \${CMAKE_SYSROOT}/bin/clang)
  SET(CMAKE_C_COMPILER_TARGET     \${ARCHITECTURE_TRIPLE})
  SET(CMAKE_C_FLAGS "-fPIC -fms-extensions -target \${ARCHITECTURE_TRIPLE}")

  include_directories("${THIRD_PARTY}/Linux/LibCxx/include")
  include_directories("${THIRD_PARTY}/Linux/LibCxx/include/c++/v1")

  set(CMAKE_LINKER_FLAGS "-stdlib=libc++ -L${THIRD_PARTY}/Linux/LibCxx/lib/Linux/\${ARCHITECTURE_TRIPLE}/ ${THIRD_PARTY}/Linux/LibCxx/lib/Linux/\${ARCHITECTURE_TRIPLE}/libc++.a ${THIRD_PARTY}/Linux/LibCxx/lib/Linux/\${ARCHITECTURE_TRIPLE}/libc++abi.a -lpthread")
  set(CMAKE_EXE_LINKER_FLAGS      "\${CMAKE_LINKER_FLAGS}")
  set(CMAKE_MODULE_LINKER_FLAGS   "\${CMAKE_LINKER_FLAGS}")
  set(CMAKE_SHARED_LINKER_FLAGS   "\${CMAKE_LINKER_FLAGS}")
  #set(CMAKE_STATIC_LINKER_FLAGS   "\${CMAKE_LINKER_FLAGS}")

  SET(CMAKE_CXX_COMPILER          \${CMAKE_SYSROOT}/bin/clang++)
  SET(CMAKE_CXX_COMPILER_TARGET   \${ARCHITECTURE_TRIPLE})
  SET(CMAKE_CXX_FLAGS             "-fPIC -std=c++1z -fms-extensions")
  # https://stackoverflow.com/questions/25525047/cmake-generator-expression-differentiate-c-c-code
  add_compile_options($<$<COMPILE_LANGUAGE:CXX>:-nostdinc++>)

  SET(CMAKE_ASM_COMPILER          \${CMAKE_SYSROOT}/bin/clang)

  SET(CMAKE_FIND_ROOT_PATH        \${LINUX_MULTIARCH_ROOT})

  # hoping to force it to use ar
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

_EOF_
) > /tmp/__cmake_toolchain.cmake

elif [ `uname` == "Darwin" ]; then
  VCPKG_TRIPLETS+=( overlay-x64_arm64-osx )
  VCPKG_TRIPLETS+=( overlay-arm64-ios )
fi

# cleanup the git repo
[ -d "$DIR/vcpkg" ] && echo
[ -d "$DIR/vcpkg" ] && echo === Tidying up vcpkg and $VCPKG_INSTALLED/vcpkg ===
[ -d "$DIR/vcpkg" ] && rm -rf "$DIR/vcpkg" "$DIR/$VCPKG_INSTALLED/vcpkg"

echo
echo === Checking out vcpkg to $DIR/vcpkg ===
git clone https://github.com/microsoft/vcpkg.git --depth 1 --branch $VCPKG_VERSION "$DIR/vcpkg"

echo
echo === Bootstrapping vcpkg ===
"$DIR/vcpkg/bootstrap-vcpkg.sh"

for VCPKG_TRIPLET in ${VCPKG_TRIPLETS[@]}
do
  # cleanup the prior artifacts
  [ -d "$DIR/$VCPKG_INSTALLED" ] && echo
  [ -d "$DIR/$VCPKG_INSTALLED" ] && echo === Tidying up $VCPKG_INSTALLED/$VCPKG_TRIPLET ===
  [ -d "$DIR/$VCPKG_INSTALLED" ] && rm -rf "$DIR/$VCPKG_INSTALLED/$VCPKG_TRIPLET" 

  [ -d "$DIR/$VCPKG_INSTALLED/$VCPKG_TRIPLET" ] && echo
  [ -d "$DIR/$VCPKG_INSTALLED/$VCPKG_TRIPLET" ] && echo === Making $VCPKG_INSTALLED/$VCPKG_TRIPLET artifacts writeable ===
  [ -d "$DIR/$VCPKG_INSTALLED/$VCPKG_TRIPLET" ] && chmod -R u+w "$DIR/$VCPKG_INSTALLED/$VCPKG_TRIPLET"

  echo
  echo === Running vcpkg in manifest mode ===
  # --overlay-ports tells it to resolve a named port via additional paths outside vcpkg/, PWD relative
  # --overlay-triplets tells it to resolve a named triplet via additional paths outside vcpkg/, PWD relative
  # --triplet names the triplet to configure the build with, our custom triplet file w/o .cmake extentions
  # --debug will provide extra information to stdout
  "$DIR/vcpkg/vcpkg" install --x-install-root="$DIR/$VCPKG_INSTALLED" --overlay-ports=./overlay-ports --overlay-triplets=./overlay-triplets --triplet=$VCPKG_TRIPLET "proj4[core,database]"

  echo
  echo === Reconciling $VCPKG_INSTALLED artifacts ===
  p4 reconcile "$DIR/$VCPKG_INSTALLED/$VCPKG_TRIPLET/..."
done
  