// Copyright Epic Games, Inc. All Rights Reserved.

#include "USDClassesModule.h"

#include "USDLog.h"
#include "USDProjectSettings.h"

#include "AnalyticsEventAttribute.h"
#include "Animation/AnimBlueprint.h"
#include "Animation/AnimSequence.h"
#include "Animation/Skeleton.h"
#include "Engine/Engine.h"
#include "Engine/SkeletalMesh.h"
#include "Engine/SkinnedAssetCommon.h"
#include "Engine/StaticMesh.h"
#include "Engine/Texture.h"
#include "Engine/Texture2D.h"
#include "EngineAnalytics.h"
#include "GeometryCache.h"
#include "GroomAsset.h"
#include "GroomBindingAsset.h"
#include "GroomCache.h"
#include "HAL/FileManager.h"
#include "Materials/Material.h"
#include "Materials/MaterialInstance.h"
#include "Materials/MaterialInstanceConstant.h"
#include "Materials/MaterialInstanceDynamic.h"
#include "Misc/EngineVersion.h"
#include "Misc/FileHelper.h"
#include "Misc/PackageName.h"
#include "Misc/Paths.h"
#include "Misc/SecureHash.h"
#include "PhysicsEngine/PhysicsAsset.h"
#include "Serialization/JsonSerializer.h"
#include "SparseVolumeTexture/SparseVolumeTexture.h"
#include "UObject/NameTypes.h"
#include "UObject/ObjectSaveContext.h"
#include "UObject/Package.h"
#include "UObject/UObjectGlobals.h"

#if WITH_EDITOR
#include "Editor/MaterialEditor/Public/MaterialEditingLibrary.h"
#endif	  // WITH_EDITOR

DEFINE_LOG_CATEGORY(LogUsd);

namespace UE::USDClasses::Private
{
	static const FString DisplayColorID = TEXT("!DisplayColor");

	TSharedPtr<FJsonObject> ParseJSON(const FString& FileContents)
	{
		if (FileContents.IsEmpty())
		{
			return nullptr;
		}

		const TSharedRef<TJsonReader<>>& Reader = TJsonReaderFactory<>::Create(FileContents);

		TSharedPtr<FJsonObject> DescriptorObject;
		if (FJsonSerializer::Deserialize(Reader, DescriptorObject) && DescriptorObject.IsValid())
		{
			return DescriptorObject;
		}
		else
		{
			UE_LOG(LogUsd, Warning, TEXT("Failed to parse plugInfo.json file: '%s'"), *Reader->GetErrorMessage());
		}

		return nullptr;
	}

	TMap<FString, int32> PackagePathNameToDirtyCounter;
}

void IUsdClassesModule::UpdatePlugInfoFiles(const FString& PluginDirectory, const FString& TargetDllFolder)
{
	// Traverse all USD plugins
	TArray<FString> JsonPaths;
	const bool bFiles = true;
	const bool bDirectories = false;
	const bool bClearFileNames = false;	   // Whether it needs to reset the output array or not
	IFileManager::Get().FindFilesRecursive(JsonPaths, *PluginDirectory, TEXT("plugInfo.json"), bFiles, bDirectories, bClearFileNames);
	for (const FString& JsonFilePath : JsonPaths)
	{
		FString FileContent;
		if (!FFileHelper::LoadFileToString(FileContent, *JsonFilePath))
		{
			continue;
		}

		// Strip a preamble that looks like this:
		//		# Portions of this file auto-generated by usdGenSchema.
		//		# Edits will survive regeneration except for comments and
		//		# changes to types with autoGenerated=true.
		// We will not save this preamble back into the file, but that's not bad as the file is already in the binaries folder
		// and the preamble is actually invalid json anyway
		int32 FirstOpenBracketPos = FileContent.Find(TEXT("{"));
		int32 NewLen = FileContent.Len() - FirstOpenBracketPos;
		FileContent.RightInline(NewLen);

		TSharedPtr<FJsonObject> DescriptorObject = UE::USDClasses::Private::ParseJSON(FileContent);
		if (!DescriptorObject.IsValid())
		{
			continue;
		}

		TSharedPtr<FJsonValue> PluginsField = DescriptorObject->TryGetField(TEXT("Plugins"));
		if (!PluginsField.IsValid())
		{
			continue;
		}

		bool bUpdatedFile = false;

		const TArray<TSharedPtr<FJsonValue>>* PluginEntriesPtr = nullptr;
		if (!PluginsField->TryGetArray(PluginEntriesPtr) || !PluginEntriesPtr)
		{
			continue;
		}

		for (const TSharedPtr<FJsonValue>& PluginEntry : *PluginEntriesPtr)
		{
			const TSharedPtr<FJsonObject>* PluginEntryObjectPtr = nullptr;
			if (!PluginEntry->TryGetObject(PluginEntryObjectPtr) || !PluginEntryObjectPtr || !PluginEntryObjectPtr->IsValid())
			{
				continue;
			}

			TSharedPtr<FJsonValue> LibraryPathField = (*PluginEntryObjectPtr)->TryGetField(TEXT("LibraryPath"));
			if (!LibraryPathField.IsValid())
			{
				continue;
			}

			// e.g. "../../../../../../Win64/sdf.dll"
			FString LibraryPath;
			if (!LibraryPathField->TryGetString(LibraryPath))
			{
				continue;
			}

			// e.g. "sdf.dll"
			FString DllName = FPaths::GetCleanFilename(LibraryPath);
			if (DllName.IsEmpty())
			{
				continue;
			}

			// e.g. ".."
			FString RootPath;
			if (TSharedPtr<FJsonValue> RootPathField = (*PluginEntryObjectPtr)->TryGetField(TEXT("Root")))
			{
				RootPathField->TryGetString(RootPath);
			}

			// e.g. "E:/Folder/Workspace/Engine/Binaries/ThirdParty/USD/UsdResources/Win64/plugins/ar/resources/.."
			RootPath = FPaths::Combine(FPaths::GetPath(JsonFilePath), RootPath);
			FPaths::NormalizeDirectoryName(RootPath);
			FPaths::CollapseRelativeDirectories(RootPath);

			FString PathToDll = TargetDllFolder;

			// Ensure directories end with a slash, otherwise FPaths::MakePathRelativeTo may strip the last folder thinking it's a filename
			if (!PathToDll.EndsWith(TEXT("/")))
			{
				PathToDll.AppendChar(TEXT('/'));
			}
			if (!RootPath.EndsWith(TEXT("/")))
			{
				RootPath.AppendChar(TEXT('/'));
			}

			// e.g. "../../../../../../Win64"
			// This can fail if we're in different drives. Then we're forced to assume that CurrentDllLocation is an absolute path and use it directly
			if (!FPaths::MakePathRelativeTo(PathToDll, *RootPath))
			{
				if (FPaths::IsRelative(PathToDll) && !FPaths::DirectoryExists(PathToDll))
				{
					UE_LOG(LogUsd, Warning, TEXT("Failed to handle Current DLL Location '%s' when trying to update plugInfo.json paths"), *PathToDll);
					continue;
				}
			}

			// e.g. "../../../../../../Win64/sdf.dll"
			FString NewLibraryPath = FPaths::Combine(PathToDll, DllName);
			(*PluginEntryObjectPtr)->SetField(TEXT("LibraryPath"), MakeShared<FJsonValueString>(NewLibraryPath));
			bUpdatedFile = true;
		}

		// Serialize them back to JSON if we changed anything
		if (bUpdatedFile)
		{
			FString OutputString;
			TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&OutputString);
			FJsonSerializer::Serialize(DescriptorObject.ToSharedRef(), Writer);

			if (FFileHelper::SaveStringToFile(
					OutputString,
					*JsonFilePath,
					FFileHelper::EEncodingOptions::AutoDetect,
					&IFileManager::Get(),
					FILEWRITE_EvenIfReadOnly
				))
			{
				UE_LOG(LogUsd, Log, TEXT("Updated LibraryPaths for USD plugInfo.json file '%s'"), *JsonFilePath);
			}
			else
			{
				UE_LOG(LogUsd, Warning, TEXT("Failed to update LibraryPath for USD plugInfo.json file '%s'"), *JsonFilePath);
			}
		}
	}
}

void IUsdClassesModule::SendAnalytics(
	TArray<FAnalyticsEventAttribute>&& InAttributes,
	const FString& EventName,
	bool bAutomated,
	double ElapsedSeconds,
	double NumberOfFrames,
	const FString& Extension
)
{
	if (FEngineAnalytics::IsAvailable())
	{
		TArray<FAnalyticsEventAttribute> Attributes(InAttributes);

		Attributes.Emplace(TEXT("Automated"), LexToString(bAutomated));
		Attributes.Emplace(TEXT("FileExtension"), Extension);
		Attributes.Emplace(TEXT("NumberOfFrames"), LexToString(FMath::Abs(NumberOfFrames)));
		Attributes.Emplace(TEXT("TimeTaken.Seconds"), ElapsedSeconds);
		Attributes.Emplace(TEXT("Platform"), FPlatformProperties::IniPlatformName());
		Attributes.Emplace(TEXT("EngineVersion"), FEngineVersion::Current().ToString());
		Attributes.Emplace(TEXT("EngineMode"), FPlatformMisc::GetEngineMode());

		const FString EventText = FString::Printf(TEXT("Engine.Usage.USD.%s"), *EventName);
		FEngineAnalytics::GetProvider().RecordEvent(EventText, Attributes);
	}
}

void IUsdClassesModule::SendAnalytics(TArray<FAnalyticsEventAttribute>&& InAttributes, const FString& EventName)
{
	if (FEngineAnalytics::IsAvailable())
	{
		TArray<FAnalyticsEventAttribute> Attributes(InAttributes);

		Attributes.Emplace(TEXT("Platform"), FPlatformProperties::IniPlatformName());
		Attributes.Emplace(TEXT("EngineVersion"), FEngineVersion::Current().ToString());
		Attributes.Emplace(TEXT("EngineMode"), FPlatformMisc::GetEngineMode());

		const FString EventText = FString::Printf(TEXT("Engine.Usage.USD.%s"), *EventName);
		FEngineAnalytics::GetProvider().RecordEvent(EventText, Attributes);
	}
}

bool IUsdClassesModule::HashObjectPackage(const UObject* Object, FSHA1& HashToUpdate)
{
#if WITH_EDITOR
	if (!Object)
	{
		return false;
	}

	UPackage* Package = Object->GetOutermost();
	if (!Package)
	{
		return false;
	}

	// Hash package's persistent Guid
	const FGuid& Guid = Package->GetPersistentGuid();
	HashToUpdate.Update(reinterpret_cast<const uint8*>(&Guid), sizeof(Guid));

	// Hash last modified date
	FString PackageFullName = Package->GetPathName();
	FString FileName;
	if (FPackageName::TryConvertLongPackageNameToFilename(PackageFullName, FileName))
	{
		FFileStatData StatData = IFileManager::Get().GetStatData(*FileName);
		if (StatData.bIsValid)
		{
			FString ModifiedTimeString = StatData.ModificationTime.ToString();
			HashToUpdate.UpdateWithString(*ModifiedTimeString, ModifiedTimeString.Len());
		}
	}

	// If this asset is currently dirty, also hash how many times it was dirtied in this session.
	// If it's ever saved, we'll reset this counter but update the last saved date
	if (int32* DirtyCounter = UE::USDClasses::Private::PackagePathNameToDirtyCounter.Find(PackageFullName))
	{
		HashToUpdate.Update(reinterpret_cast<const uint8*>(DirtyCounter), sizeof(*DirtyCounter));
	}

	return true;
#else
	return false;
#endif	  // WITH_EDITOR
}

UWorld* IUsdClassesModule::GetCurrentWorld(bool bEditorWorldsOnly)
{
	UWorld* EditorWorld = nullptr;
	UWorld* LowestPIEWorld = nullptr;
	int32 LowestPIEInstance = TNumericLimits<int32>::Max();

	for (const FWorldContext& Context : GEngine->GetWorldContexts())
	{
		UWorld* World = Context.World();
		if (!World)
		{
			continue;
		}

		if (!bEditorWorldsOnly && Context.WorldType == EWorldType::PIE)
		{
			if (!LowestPIEInstance || Context.PIEInstance < LowestPIEInstance)
			{
				LowestPIEWorld = World;
				LowestPIEInstance = Context.PIEInstance;
			}
		}
		else if (Context.WorldType == EWorldType::Editor)
		{
			EditorWorld = World;
		}
	}

	if (LowestPIEWorld)
	{
		return LowestPIEWorld;
	}

	return EditorWorld;
}

TSet<UObject*> IUsdClassesModule::GetAssetDependencies(UObject* Asset)
{
	TSet<UObject*> Result;

	if (UMaterial* Material = Cast<UMaterial>(Asset))
	{
		TArray<UTexture*> UsedTextures;
		const bool bAllQualityLevels = true;
		const bool bAllFeatureLevels = true;
		Material->GetUsedTextures(UsedTextures, EMaterialQualityLevel::High, bAllQualityLevels, ERHIFeatureLevel::SM5, bAllFeatureLevels);

		Result.Reserve(Result.Num() + UsedTextures.Num());
		for (UTexture* UsedTexture : UsedTextures)
		{
			Result.Add(UsedTexture);
		}
	}
	else if (UMaterialInstance* MaterialInstance = Cast<UMaterialInstance>(Asset))
	{
		Result.Reserve(Result.Num() + MaterialInstance->TextureParameterValues.Num());
		for (const FTextureParameterValue& TextureValue : MaterialInstance->TextureParameterValues)
		{
			Result.Add(TextureValue.ParameterValue);
		}

		// We'll have a dependency on our reference material too of course (this happens for Mdl
		// materials for example, that create new UMaterial assets every time, and also material instances).
		Result.Add(MaterialInstance->Parent.Get());
	}
	else if (USkeletalMesh* SkeletalMesh = Cast<USkeletalMesh>(Asset))
	{
		Result.Add(SkeletalMesh->GetSkeleton());
		Result.Add(SkeletalMesh->GetPhysicsAsset());

		Result.Reserve(Result.Num() + SkeletalMesh->GetMaterials().Num());
		for (const FSkeletalMaterial& SkeletalMaterial : SkeletalMesh->GetMaterials())
		{
			Result.Add(SkeletalMaterial.MaterialInterface);
		}
	}
	else if (UStaticMesh* StaticMesh = Cast<UStaticMesh>(Asset))
	{
		Result.Reserve(Result.Num() + StaticMesh->GetStaticMaterials().Num());
		for (const FStaticMaterial& StaticMaterial : StaticMesh->GetStaticMaterials())
		{
			Result.Add(StaticMaterial.MaterialInterface);
		}
	}
	else if (UGeometryCache* GeometryCache = Cast<UGeometryCache>(Asset))
	{
		for (UMaterialInterface* UsedMaterial : GeometryCache->Materials)
		{
			Result.Add(UsedMaterial);
		}
	}
	else if (UAnimSequence* AnimSequence = Cast<UAnimSequence>(Asset))
	{
		Result.Add(AnimSequence->GetPreviewMesh());
		Result.Add(AnimSequence->GetSkeleton());
	}
	else if (UGroomBindingAsset* GroomBinding = Cast<UGroomBindingAsset>(Asset))
	{
		Result.Add(GroomBinding->GetGroom());
		Result.Add(GroomBinding->GetTargetSkeletalMesh());
		Result.Add(GroomBinding->GetSourceSkeletalMesh());
		Result.Add(GroomBinding->GetSourceGeometryCache());
		Result.Add(GroomBinding->GetTargetGeometryCache());
	}
	else if (UGroomAsset* GroomAsset = Cast<UGroomAsset>(Asset))
	{
		// Do nothing. The atual groom assets have no additional dependencies
	}
	else if (UGroomCache* GroomCache = Cast<UGroomCache>(Asset))
	{
		// Do nothing. The groom cache doesn't have any additional dependencies
	}
	else if (UTexture* Texture = Cast<UTexture>(Asset))
	{
		// Do nothing. Textures have no additional dependencies
	}
	else if (USkeleton* Skeleton = Cast<USkeleton>(Asset))
	{
		// Do nothing. Skeletons have no additional dependencies
	}
	else if (UPhysicsAsset* PhysicsAsset = Cast<UPhysicsAsset>(Asset))
	{
		// Do nothing. PhysicsAssets have no additional dependencies
	}
	else if (UAnimBlueprint* AnimBP = Cast<UAnimBlueprint>(Asset))
	{
		// Do nothing. AnimBlueprints have no additional dependencies
	}
	else if (USparseVolumeTexture* SparseVolumeTexture = Cast<USparseVolumeTexture>(Asset))
	{
		// Do nothing. SparseVolumeTextures have no additional dependencies
	}
	else
	{
		UE_LOG(LogUsd, Warning, TEXT("Unknown asset '%s' encountered when collecting dependencies."), Asset ? *Asset->GetName() : TEXT("nullptr"));
	}

	// This way we don't have to nullptr check everything we add to the set
	Result.Remove(nullptr);
	return Result;
}

FString IUsdClassesModule::SanitizeObjectName(const FString& InObjectName)
{
	FString SanitizedText = InObjectName;
	const TCHAR* InvalidChar = INVALID_OBJECTNAME_CHARACTERS;
	while (*InvalidChar)
	{
		SanitizedText.ReplaceCharInline(*InvalidChar, TCHAR('_'), ESearchCase::CaseSensitive);
		++InvalidChar;
	}

	return SanitizedText;
}

FString IUsdClassesModule::FDisplayColorMaterial::ToString()
{
	return FString::Printf(TEXT("%s_%d_%d"), *UE::USDClasses::Private::DisplayColorID, bHasOpacity, bIsDoubleSided);
}

TOptional<IUsdClassesModule::FDisplayColorMaterial> IUsdClassesModule::FDisplayColorMaterial::FromString(const FString& DisplayColorString)
{
	TArray<FString> Tokens;
	DisplayColorString.ParseIntoArray(Tokens, TEXT("_"));

	if (Tokens.Num() != 3 || Tokens[0] != UE::USDClasses::Private::DisplayColorID)
	{
		return {};
	}

	IUsdClassesModule::FDisplayColorMaterial Result;
	Result.bHasOpacity = static_cast<bool>(FCString::Atoi(*Tokens[1]));
	Result.bIsDoubleSided = static_cast<bool>(FCString::Atoi(*Tokens[2]));
	return Result;
}

const FSoftObjectPath* IUsdClassesModule::GetReferenceMaterialPath(const FDisplayColorMaterial& DisplayColorDescription)
{
	const UUsdProjectSettings* Settings = GetDefault<UUsdProjectSettings>();
	if (!Settings)
	{
		return nullptr;
	}

	if (DisplayColorDescription.bHasOpacity)
	{
		if (DisplayColorDescription.bIsDoubleSided)
		{
			return &Settings->ReferenceDisplayColorAndOpacityTwoSidedMaterial;
		}
		else
		{
			return &Settings->ReferenceDisplayColorAndOpacityMaterial;
		}
	}
	else
	{
		if (DisplayColorDescription.bIsDoubleSided)
		{
			return &Settings->ReferenceDisplayColorTwoSidedMaterial;
		}
		else
		{
			return &Settings->ReferenceDisplayColorMaterial;
		}
	}
}

UMaterialInstanceDynamic* IUsdClassesModule::CreateDisplayColorMaterialInstanceDynamic(const FDisplayColorMaterial& DisplayColorDescription)
{
	const FSoftObjectPath* ParentPathPtr = GetReferenceMaterialPath(DisplayColorDescription);
	if (!ParentPathPtr)
	{
		return nullptr;
	}

	if (UMaterialInterface* ParentMaterial = Cast<UMaterialInterface>(ParentPathPtr->TryLoad()))
	{
		FName AssetName = MakeUniqueObjectName(
			GetTransientPackage(),
			UMaterialInstanceConstant::StaticClass(),
			*FString::Printf(
				TEXT("DisplayColor_%s_%s"),
				DisplayColorDescription.bHasOpacity ? TEXT("Opacity") : TEXT("NoOpacity"),
				DisplayColorDescription.bIsDoubleSided ? TEXT("DoubleSided") : TEXT("SingleSided")
			)
		);

		if (UMaterialInstanceDynamic* NewMaterial = UMaterialInstanceDynamic::Create(ParentMaterial, GetTransientPackage(), AssetName))
		{
			return NewMaterial;
		}
	}

	return nullptr;
}

UMaterialInstanceConstant* IUsdClassesModule::CreateDisplayColorMaterialInstanceConstant(const FDisplayColorMaterial& DisplayColorDescription)
{
#if WITH_EDITOR
	const FSoftObjectPath* ParentPathPtr = GetReferenceMaterialPath(DisplayColorDescription);
	if (!ParentPathPtr)
	{
		return nullptr;
	}

	if (UMaterialInterface* ParentMaterial = Cast<UMaterialInterface>(ParentPathPtr->TryLoad()))
	{
		FName AssetName = MakeUniqueObjectName(
			GetTransientPackage(),
			UMaterialInstanceConstant::StaticClass(),
			*FString::Printf(
				TEXT("DisplayColor_%s_%s"),
				DisplayColorDescription.bHasOpacity ? TEXT("Opacity") : TEXT("NoOpacity"),
				DisplayColorDescription.bIsDoubleSided ? TEXT("DoubleSided") : TEXT("SingleSided")
			)
		);

		if (UMaterialInstanceConstant* MaterialInstance = NewObject<UMaterialInstanceConstant>(GetTransientPackage(), AssetName, RF_NoFlags))
		{
			UMaterialEditingLibrary::SetMaterialInstanceParent(MaterialInstance, ParentMaterial);
			return MaterialInstance;
		}
	}
#endif	  // WITH_EDITOR
	return nullptr;
}

class FUsdClassesModule : public IUsdClassesModule
{
public:
	virtual void StartupModule() override
	{
		PackageMarkedDirtyEventHandle = UPackage::PackageMarkedDirtyEvent.AddLambda(
			[](const UPackage* Package, bool bWasDirty)
			{
				if (Package)
				{
					UE::USDClasses::Private::PackagePathNameToDirtyCounter.FindOrAdd(Package->GetPathName())++;
				}
			}
		);

		PackageSavedWithContextEventHandle = UPackage::PackageSavedWithContextEvent.AddLambda(
			[](const FString& PackageFilename, UPackage* Package, FObjectPostSaveContext ObjectSaveContext)
			{
				if (Package)
				{
					UE::USDClasses::Private::PackagePathNameToDirtyCounter.Remove(Package->GetPathName());
				}
			}
		);
	}

	virtual void ShutdownModule() override
	{
		UPackage::PackageSavedWithContextEvent.Remove(PackageSavedWithContextEventHandle);
		UPackage::PackageMarkedDirtyEvent.Remove(PackageMarkedDirtyEventHandle);
	}

private:
	FDelegateHandle PackageMarkedDirtyEventHandle;
	FDelegateHandle PackageSavedWithContextEventHandle;
};

IMPLEMENT_MODULE(FUsdClassesModule, USDClasses);
