// Copyright Epic Games, Inc. All Rights Reserved.

#include "USDClassesModule.h"

#include "USDLog.h"

#include "AnalyticsEventAttribute.h"
#include "EngineAnalytics.h"
#include "HAL/FileManager.h"
#include "Misc/EngineVersion.h"
#include "Misc/FileHelper.h"
#include "Misc/PackageName.h"
#include "Misc/Paths.h"
#include "Misc/SecureHash.h"
#include "Modules/ModuleManager.h"
#include "Serialization/JsonSerializer.h"
#include "UObject/ObjectSaveContext.h"
#include "UObject/Package.h"

DEFINE_LOG_CATEGORY( LogUsd );

namespace UE::USDClasses::Private
{
	TSharedPtr<FJsonObject> ParseJSON( const FString& FileContents )
	{
		if ( FileContents.IsEmpty() )
		{
			return nullptr;
		}

		const TSharedRef< TJsonReader<> >& Reader = TJsonReaderFactory<>::Create( FileContents );

		TSharedPtr<FJsonObject> DescriptorObject;
		if ( FJsonSerializer::Deserialize( Reader, DescriptorObject ) && DescriptorObject.IsValid() )
		{
			return DescriptorObject;
		}
		else
		{
			UE_LOG( LogUsd, Warning, TEXT( "Failed to parse plugInfo.json file: '%s'" ), *Reader->GetErrorMessage() );
		}

		return nullptr;
	}

	TMap<FString, int32> PackagePathNameToDirtyCounter;
}

void IUsdClassesModule::UpdatePlugInfoFiles( const FString& PluginDirectory, const FString& TargetDllFolder )
{
	// Traverse all USD plugins
	TArray<FString> JsonPaths;
	const bool bFiles = true;
	const bool bDirectories = false;
	const bool bClearFileNames = false;  // Whether it needs to reset the output array or not
	IFileManager::Get().FindFilesRecursive( JsonPaths, *PluginDirectory, TEXT( "plugInfo.json" ), bFiles, bDirectories, bClearFileNames );
	for ( const FString& JsonFilePath : JsonPaths )
	{
		FString FileContent;
		if ( !FFileHelper::LoadFileToString( FileContent, *JsonFilePath ) )
		{
			continue;
		}

		// Strip a preamble that looks like this:
		//		# Portions of this file auto-generated by usdGenSchema.
		//		# Edits will survive regeneration except for comments and
		//		# changes to types with autoGenerated=true.
		// We will not save this preamble back into the file, but that's not bad as the file is already in the binaries folder
		// and the preamble is actually invalid json anyway
		int32 FirstOpenBracketPos = FileContent.Find( TEXT( "{" ) );
		int32 NewLen = FileContent.Len() - FirstOpenBracketPos;
		FileContent.RightInline( NewLen );

		TSharedPtr<FJsonObject> DescriptorObject = UE::USDClasses::Private::ParseJSON( FileContent );
		if ( !DescriptorObject.IsValid() )
		{
			continue;
		}

		TSharedPtr<FJsonValue> PluginsField = DescriptorObject->TryGetField( TEXT( "Plugins" ) );
		if ( !PluginsField.IsValid() )
		{
			continue;
		}

		bool bUpdatedFile = false;

		const TArray< TSharedPtr<FJsonValue> >* PluginEntriesPtr = nullptr;
		if ( !PluginsField->TryGetArray( PluginEntriesPtr ) || !PluginEntriesPtr )
		{
			continue;
		}

		for ( const TSharedPtr<FJsonValue>& PluginEntry : *PluginEntriesPtr )
		{
			const TSharedPtr<FJsonObject>* PluginEntryObjectPtr = nullptr;
			if ( !PluginEntry->TryGetObject( PluginEntryObjectPtr ) || !PluginEntryObjectPtr || !PluginEntryObjectPtr->IsValid() )
			{
				continue;
			}

			TSharedPtr<FJsonValue> LibraryPathField = ( *PluginEntryObjectPtr )->TryGetField( TEXT( "LibraryPath" ) );
			if ( !LibraryPathField.IsValid() )
			{
				continue;
			}

			// e.g. "../../../../../../Win64/sdf.dll"
			FString LibraryPath;
			if ( !LibraryPathField->TryGetString( LibraryPath ) )
			{
				continue;
			}

			// e.g. "sdf.dll"
			FString DllName = FPaths::GetCleanFilename( LibraryPath );
			if ( DllName.IsEmpty() )
			{
				continue;
			}

			// e.g. ".."
			FString RootPath;
			if ( TSharedPtr<FJsonValue> RootPathField = ( *PluginEntryObjectPtr )->TryGetField( TEXT( "Root" ) ) )
			{
				RootPathField->TryGetString( RootPath );
			}

			// e.g. "E:/Folder/Workspace/Engine/Binaries/ThirdParty/USD/UsdResources/Win64/plugins/ar/resources/.."
			RootPath = FPaths::Combine( FPaths::GetPath( JsonFilePath ), RootPath );
			FPaths::NormalizeDirectoryName( RootPath );
			FPaths::CollapseRelativeDirectories( RootPath );

			FString PathToDll = TargetDllFolder;

			// Ensure directories end with a slash, otherwise FPaths::MakePathRelativeTo may strip the last folder thinking it's a filename
			if ( !PathToDll.EndsWith( TEXT( "/" ) ) )
			{
				PathToDll.AppendChar( TEXT( '/' ) );
			}
			if ( !RootPath.EndsWith( TEXT( "/" ) ) )
			{
				RootPath.AppendChar( TEXT( '/' ) );
			}

			// e.g. "../../../../../../Win64"
			// This can fail if we're in different drives. Then we're forced to assume that CurrentDllLocation is an absolute path and use it directly
			if ( !FPaths::MakePathRelativeTo( PathToDll, *RootPath ) )
			{
				if ( FPaths::IsRelative( PathToDll ) && !FPaths::DirectoryExists( PathToDll ) )
				{
					UE_LOG( LogUsd, Warning, TEXT( "Failed to handle Current DLL Location '%s' when trying to update plugInfo.json paths" ), *PathToDll );
					continue;
				}
			}

			// e.g. "../../../../../../Win64/sdf.dll"
			FString NewLibraryPath = FPaths::Combine( PathToDll, DllName );
			( *PluginEntryObjectPtr )->SetField( TEXT( "LibraryPath" ), MakeShared<FJsonValueString>( NewLibraryPath ) );
			bUpdatedFile = true;
		}

		// Serialize them back to JSON if we changed anything
		if ( bUpdatedFile )
		{
			FString OutputString;
			TSharedRef< TJsonWriter<> > Writer = TJsonWriterFactory<>::Create( &OutputString );
			FJsonSerializer::Serialize( DescriptorObject.ToSharedRef(), Writer );

			if ( FFileHelper::SaveStringToFile( OutputString, *JsonFilePath, FFileHelper::EEncodingOptions::AutoDetect, &IFileManager::Get(), FILEWRITE_EvenIfReadOnly ) )
			{
				UE_LOG( LogUsd, Log, TEXT( "Updated LibraryPaths for USD plugInfo.json file '%s'" ), *JsonFilePath );
			}
			else
			{
				UE_LOG( LogUsd, Warning, TEXT( "Failed to update LibraryPath for USD plugInfo.json file '%s'" ), *JsonFilePath );
			}
		}
	}
}

void IUsdClassesModule::SendAnalytics( TArray<FAnalyticsEventAttribute>&& InAttributes, const FString& EventName, bool bAutomated, double ElapsedSeconds, double NumberOfFrames, const FString& Extension )
{
	if ( FEngineAnalytics::IsAvailable() )
	{
		TArray<FAnalyticsEventAttribute> Attributes( InAttributes );

		Attributes.Emplace( TEXT( "Automated" ), LexToString( bAutomated ) );
		Attributes.Emplace( TEXT( "FileExtension" ), Extension );
		Attributes.Emplace( TEXT( "NumberOfFrames" ), LexToString( FMath::Abs( NumberOfFrames ) ) );
		Attributes.Emplace( TEXT( "TimeTaken.Seconds" ), ElapsedSeconds );
		Attributes.Emplace( TEXT( "Platform" ), FPlatformProperties::IniPlatformName() );
		Attributes.Emplace( TEXT( "EngineVersion" ), FEngineVersion::Current().ToString() );
		Attributes.Emplace( TEXT( "EngineMode" ), FPlatformMisc::GetEngineMode() );
		Attributes.Emplace( TEXT( "EpicAccountId" ), FPlatformMisc::GetEpicAccountId() );

		const FString EventText = FString::Printf( TEXT( "Engine.Usage.USD.%s" ), *EventName);
		FEngineAnalytics::GetProvider().RecordEvent( EventText, Attributes );
	}
}

bool IUsdClassesModule::HashObjectPackage( const UObject* Object, FSHA1& HashToUpdate )
{
#if WITH_EDITOR
	if ( !Object )
	{
		return false;
	}

	UPackage* Package = Object->GetOutermost();
	if ( !Package )
	{
		return false;
	}

	// Hash package's persistent Guid
	const FGuid& Guid = Package->GetPersistentGuid();
	HashToUpdate.Update( reinterpret_cast< const uint8* >( &Guid ), sizeof( Guid ) );

	// Hash last modified date
	FString PackageFullName = Package->GetPathName();
	FString FileName;
	if ( FPackageName::TryConvertLongPackageNameToFilename( PackageFullName, FileName ) )
	{
		FFileStatData StatData = IFileManager::Get().GetStatData( *FileName );
		if ( StatData.bIsValid )
		{
			FString ModifiedTimeString = StatData.ModificationTime.ToString();
			HashToUpdate.UpdateWithString( *ModifiedTimeString, ModifiedTimeString.Len() );
		}
	}

	// If this asset is currently dirty, also hash how many times it was dirtied in this session.
	// If it's ever saved, we'll reset this counter but update the last saved date
	if ( int32* DirtyCounter = UE::USDClasses::Private::PackagePathNameToDirtyCounter.Find( PackageFullName ) )
	{
		HashToUpdate.Update( reinterpret_cast< const uint8* >( DirtyCounter ), sizeof( *DirtyCounter ) );
	}

	return true;
#else
	return false;
#endif // WITH_EDITOR
}

class FUsdClassesModule : public IUsdClassesModule
{

public:
	virtual void StartupModule() override
	{
		PackageMarkedDirtyEventHandle = UPackage::PackageMarkedDirtyEvent.AddLambda(
			[]( const UPackage* Package, bool bWasDirty )
			{
				if ( Package )
				{
					UE::USDClasses::Private::PackagePathNameToDirtyCounter.FindOrAdd( Package->GetPathName() )++;
				}
			}
		);

		PackageSavedWithContextEventHandle = UPackage::PackageSavedWithContextEvent.AddLambda(
			[]( const FString& PackageFilename, UPackage* Package, FObjectPostSaveContext ObjectSaveContext )
			{
				if ( Package )
				{
					UE::USDClasses::Private::PackagePathNameToDirtyCounter.Remove( Package->GetPathName() );
				}
			}
		);
	}

	virtual void ShutdownModule() override
	{
		UPackage::PackageSavedWithContextEvent.Remove( PackageSavedWithContextEventHandle );
		UPackage::PackageMarkedDirtyEvent.Remove( PackageMarkedDirtyEventHandle );
	}

private:
	FDelegateHandle PackageMarkedDirtyEventHandle;
	FDelegateHandle PackageSavedWithContextEventHandle;
};

IMPLEMENT_MODULE( FUsdClassesModule, USDClasses );

