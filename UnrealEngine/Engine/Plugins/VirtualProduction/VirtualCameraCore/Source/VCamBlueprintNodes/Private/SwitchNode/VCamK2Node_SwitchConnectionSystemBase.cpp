// Copyright Epic Games, Inc. All Rights Reserved.

#include "VCamK2Node_SwitchConnectionSystemBase.h"

#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "Algo/AnyOf.h"
#include "Algo/RemoveIf.h"
#include "Engine/Blueprint.h"
#include "Kismet/KismetMathLibrary.h"

UVCamK2Node_SwitchConnectionSystemBase::UVCamK2Node_SwitchConnectionSystemBase()
{
	FunctionName = TEXT("NotEqual_NameName");
	FunctionClass = UKismetMathLibrary::StaticClass();
	AdvancedPinDisplay = ENodeAdvancedPins::Shown;
}

void UVCamK2Node_SwitchConnectionSystemBase::RefreshPins()
{
	const TArray<FName> PinData = GetPinsToCreate();
	RemoveOrOrphanInvalidCases(PinData);
	AddMissingCasePins(PinData);

	// The cases should have the same sort order as PinData
	SortCasePinsToHaveSameOrderAsPinData(PinData);
	
	GetGraph()->NotifyGraphChanged();
}

void UVCamK2Node_SwitchConnectionSystemBase::BeginDestroy()
{
	Super::BeginDestroy();
	CleanUpCallbacks();
}

void UVCamK2Node_SwitchConnectionSystemBase::PostLoad()
{
	Super::PostLoad();
	SetupBlueprintModifiedCallbacks();

	for (UEdGraphPin* Pin : Pins)
	{
		if (Pin->Direction == EGPD_Output)
		{
			Pin->bAdvancedView = true;
		}
	}
}

void UVCamK2Node_SwitchConnectionSystemBase::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	if (PropertyChangedEvent.MemberProperty
		&& PropertyChangedEvent.MemberProperty->GetFName() == GET_MEMBER_NAME_CHECKED(UEdGraphNode, AdvancedPinDisplay))
	{
		RefreshPins();
	}
	
	Super::PostEditChangeProperty(PropertyChangedEvent);
}

void UVCamK2Node_SwitchConnectionSystemBase::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	UClass* NodeClass = GetClass();
	if (ActionRegistrar.IsOpenForRegistration(NodeClass))
	{
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(NodeClass);
		check(NodeSpawner);

		NodeSpawner->CustomizeNodeDelegate = UBlueprintNodeSpawner::FCustomizeNodeDelegate::CreateLambda([](UEdGraphNode* Node, bool bIsTemplateNode)
		{
			if (!bIsTemplateNode)
			{
				UVCamK2Node_SwitchConnectionSystemBase* CastNode = Cast<UVCamK2Node_SwitchConnectionSystemBase>(Node);
				CastNode->SetupBlueprintModifiedCallbacks();
			}
		});
		
		ActionRegistrar.AddBlueprintAction(NodeClass, NodeSpawner);
	}
}

bool UVCamK2Node_SwitchConnectionSystemBase::IsActionFilteredOut(FBlueprintActionFilter const& Filter)
{
	const FBlueprintActionContext& FilterContext = Filter.Context;
	return Algo::AnyOf(FilterContext.Blueprints, [this](UBlueprint* Blueprint){ return !SupportsBlueprintClass(Blueprint->GeneratedClass); });
}

void UVCamK2Node_SwitchConnectionSystemBase::ReconstructNode()
{
	Super::ReconstructNode();
	SetupBlueprintModifiedCallbacks();
}

FEdGraphPinType UVCamK2Node_SwitchConnectionSystemBase::GetPinType() const
{
	FEdGraphPinType PinType;
	PinType.PinCategory = UEdGraphSchema_K2::PC_Name;
	return PinType;
}

void UVCamK2Node_SwitchConnectionSystemBase::CreateSelectionPin()
{
	UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Name, TEXT("Selection"));
	GetDefault<UEdGraphSchema_K2>()->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
}

void UVCamK2Node_SwitchConnectionSystemBase::CreateCasePins()
{
	RefreshPins();
}

void UVCamK2Node_SwitchConnectionSystemBase::RemoveOrOrphanInvalidCases(const TArray<FName>& PinData)
{
	for (UEdGraphPin* Pin : TArray<UEdGraphPin*>(Pins))
	{
		const bool bIsCasePin = Pin != GetDefaultPin() && Pin->Direction == EGPD_Output;
		const bool bIsInvalidNode = bIsCasePin && !PinData.Contains(Pin->PinName);
		if (!bIsInvalidNode)
		{
			// In case it was removed the previous time it was updated
			Pin->bOrphanedPin = false;
			continue;
		}
		
		if (Pin->HasAnyConnections())
		{
			Pin->bOrphanedPin = bIsInvalidNode;
		}
		else
		{
			Pin->BreakAllPinLinks();
			UEdGraphNode::RemovePin(Pin);
		}
	}
}

void UVCamK2Node_SwitchConnectionSystemBase::AddMissingCasePins(const TArray<FName>& PinData)
{
	for (const FName& PinName : PinData)
	{
		const bool bContainsOutputPin = Pins.ContainsByPredicate([PinName](UEdGraphPin* Item)
		{
			return Item->PinName == PinName && Item->Direction == EGPD_Output;
		});
		if (!bContainsOutputPin)
		{
			UEdGraphPin* Pin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinName);
			Pin->bAdvancedView = true;
		}
	}
}

void UVCamK2Node_SwitchConnectionSystemBase::SortCasePinsToHaveSameOrderAsPinData(const TArray<FName>& PinData)
{
	TArray<UEdGraphPin*> OnlyCaseNodes;
	Algo::TransformIf(
		Pins,
		OnlyCaseNodes,
		[this](UEdGraphPin* Node){ return Node->Direction == EGPD_Output && Node != GetDefaultPin(); },
		[](UEdGraphPin* Node){  return Node; }
	);
	Pins.SetNum(Algo::RemoveIf(Pins, [&OnlyCaseNodes](UEdGraphPin* Node){ return OnlyCaseNodes.Contains(Node); }));
	
	OnlyCaseNodes.Sort([&PinData](const UEdGraphPin& Left, const UEdGraphPin& Right)
	{
		const int32 LeftIndex = PinData.IndexOfByKey(Left.PinName);
		const int32 RightIndex = PinData.IndexOfByKey(Right.PinName);
		// Fyi: LeftIndex and RightIndex could have INDEX_NONE value (e.g. input and default exec pins are not found).
		return LeftIndex < RightIndex;
	});
	Pins.Append(OnlyCaseNodes);
}

void UVCamK2Node_SwitchConnectionSystemBase::SetupBlueprintModifiedCallbacks()
{
	if (!DelegateHandle.IsValid())
	{
		DelegateHandle = FCoreUObjectDelegates::OnObjectTransacted.AddUObject(this, &UVCamK2Node_SwitchConnectionSystemBase::OnObjectTransacted);
	}
}

void UVCamK2Node_SwitchConnectionSystemBase::CleanUpCallbacks()
{
	FCoreUObjectDelegates::OnObjectTransacted.Remove(DelegateHandle);
	DelegateHandle.Reset();
}

void UVCamK2Node_SwitchConnectionSystemBase::OnObjectTransacted(UObject* Object, const FTransactionObjectEvent&)
{
	UBlueprint* Blueprint = GetBlueprint();
	const bool bModifiedBlueprintCDO = Object && Blueprint && Blueprint->GeneratedClass && Object == Blueprint->GeneratedClass->GetDefaultObject();
	if (bModifiedBlueprintCDO)
	{
		RefreshPins();
	}
}
