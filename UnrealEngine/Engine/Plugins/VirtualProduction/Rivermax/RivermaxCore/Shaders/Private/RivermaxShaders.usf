// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	RivermaxShaders.usf
=============================================================================*/

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/ColorUtils.ush"
#include "/Engine/Private/GammaCorrectionCommon.ush"

Texture2D InputTexture;
SamplerState InputSampler;
float4x4 ColorTransform;
uint DoLinearToSrgb;
float OnePixelDeltaX;
float OnePixelDeltaY;
float InputPixelOffsetX;
float InputPixelOffsetY;
uint HorizontalElementCount;
uint VerticalElementCount;
uint InputTexturePixelsPerThread;
RWTexture2D<float4> OutTexture;

struct FYUV8Bit422Buffer
{
	uint DWord0;
};
RWStructuredBuffer<FYUV8Bit422Buffer>	OutYUV4228bitBuffer;
StructuredBuffer<FYUV8Bit422Buffer>	InputYUV4228bitBuffer;

struct FYCbCr10Bit422
{
	uint DWord0;
	uint DWord1;
	uint DWord2;
	uint DWord3;
	uint DWord4;
};
RWStructuredBuffer<FYCbCr10Bit422>	OutYCbCrBuffer;
StructuredBuffer<FYCbCr10Bit422>	InputYCbCrBuffer;

struct FRGB8BitBuffer
{
	uint DWord0;
	uint DWord1;
	uint DWord2;
};
RWStructuredBuffer<FRGB8BitBuffer>	OutRGB8Buffer;
StructuredBuffer<FRGB8BitBuffer> InputRGB8Buffer;

struct FRGB10BitBuffer
{
	uint DWords[15];
};
RWStructuredBuffer<FRGB10BitBuffer>	OutRGB10Buffer;
StructuredBuffer<FRGB10BitBuffer> InputBuffer;

struct FRGB12BitBuffer
{
	uint DWords[9];
};
RWStructuredBuffer<FRGB12BitBuffer>	OutRGB12Buffer;
StructuredBuffer<FRGB12BitBuffer> InputRGB12Buffer;

struct FRGB16fBuffer
{
	uint DWords[3];
};
RWStructuredBuffer<FRGB16fBuffer> OutRGB16fBuffer;
StructuredBuffer<FRGB16fBuffer> InputRGB16fBuffer;



// Shader to convert from RGB to YUV 422 8 bits

[numthreads(8,8,1)]
void RGBToYUV8Bit422(uint3 ThreadId : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Make sure it's a valid thread
	if(ThreadId.x >= HorizontalElementCount || ThreadId.y >= VerticalElementCount)
	{
		return;
	}

	uint Index = ThreadId.y * HorizontalElementCount + ThreadId.x;

	float X = (ThreadId.x * InputTexturePixelsPerThread) + InputPixelOffsetX;
	float Y = (ThreadId.y + InputPixelOffsetY) * OnePixelDeltaY;

	// We process 2 RGB pixels per thread
	float3 RGB0 = InputTexture.SampleLevel(InputSampler, float2(((X + 0.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb;
	float3 RGB1 = InputTexture.SampleLevel(InputSampler, float2(((X + 1.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb;

	// The 8 RGB needs to be converted to YUV. Each encoded pixel will use 2 RGB pixels (YnUnVnYn+1)
	uint3 YUV0 = RgbToYuv(RGB0, ColorTransform, DoLinearToSrgb) * 255;
	uint3 YUV1 = RgbToYuv(RGB1, ColorTransform, DoLinearToSrgb) * 255;

	OutYUV4228bitBuffer[Index].DWord0 = (YUV1.x << 24) | (YUV0.z << 16) | (YUV0.x << 8) | (YUV0.y << 0);
}


// Shader to convert from RGB to YUV 422 10 bits packed little endian

[numthreads(8,8,1)]
void RGBToYUV10Bit422(uint3 ThreadId : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Make sure it's a valid thread
	if(ThreadId.x >= HorizontalElementCount || ThreadId.y >= VerticalElementCount)
	{
		return;
	}

	uint Index = ThreadId.y * HorizontalElementCount + ThreadId.x;

	float X = (ThreadId.x * InputTexturePixelsPerThread) + InputPixelOffsetX;
	float Y = (ThreadId.y + InputPixelOffsetY) * OnePixelDeltaY;

	// We process 8 RGB pixels per thread
	float3 RGB0 = InputTexture.SampleLevel(InputSampler, float2(((X + 0.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb;
	float3 RGB1 = InputTexture.SampleLevel(InputSampler, float2(((X + 1.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb;
	float3 RGB2 = InputTexture.SampleLevel(InputSampler, float2(((X + 2.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb;
	float3 RGB3 = InputTexture.SampleLevel(InputSampler, float2(((X + 3.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb;
	float3 RGB4 = InputTexture.SampleLevel(InputSampler, float2(((X + 4.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb;
	float3 RGB5 = InputTexture.SampleLevel(InputSampler, float2(((X + 5.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb;
	float3 RGB6 = InputTexture.SampleLevel(InputSampler, float2(((X + 6.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb;
	float3 RGB7 = InputTexture.SampleLevel(InputSampler, float2(((X + 7.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb;

	// The 8 RGB needs to be converted to YUV. Each encoded pixel will use 2 RGB pixels (YnUnVnYn+1)
	uint3 YUV0 = RgbToYuv(RGB0, ColorTransform, DoLinearToSrgb) * 1023;
	uint3 YUV1 = RgbToYuv(RGB1, ColorTransform, DoLinearToSrgb) * 1023;
	uint3 YUV2 = RgbToYuv(RGB2, ColorTransform, DoLinearToSrgb) * 1023;
	uint3 YUV3 = RgbToYuv(RGB3, ColorTransform, DoLinearToSrgb) * 1023;
	uint3 YUV4 = RgbToYuv(RGB4, ColorTransform, DoLinearToSrgb) * 1023;
	uint3 YUV5 = RgbToYuv(RGB5, ColorTransform, DoLinearToSrgb) * 1023;
	uint3 YUV6 = RgbToYuv(RGB6, ColorTransform, DoLinearToSrgb) * 1023;
	uint3 YUV7 = RgbToYuv(RGB7, ColorTransform, DoLinearToSrgb) * 1023;

	// We write the 4 YUV pixels (40 bits * 4 = 160 bits = 5x32 bits) following the little endian packing 2110 expects
	OutYCbCrBuffer[Index].DWord0 = ((YUV0.z & 0x3F) << 26) | ((YUV1.x >> 8) << 24) | ((YUV0.x & 0xF) << 20) | ((YUV0.z >> 6) << 16) | ((YUV0.y & 0x3) << 14) | ((YUV0.x >> 4) << 8) | (YUV0.y >> 2);
	OutYCbCrBuffer[Index].DWord1 = ((YUV2.x & 0xF) << 28) | ((YUV2.z >> 6) << 24) | ((YUV2.y & 0x3) << 22) | ((YUV2.x >> 4) << 16) | ((YUV2.y >> 2) << 8) | (YUV1.x & 0xFF);
	OutYCbCrBuffer[Index].DWord2 = ((YUV4.y & 0x3) << 30) | ((YUV4.x >> 4) << 24) | ((YUV4.y >> 2) << 16) | ((YUV3.x & 0xFF) << 8) | ((YUV2.z & 0x3F) << 2) | (YUV3.x >> 8);
	OutYCbCrBuffer[Index].DWord3 = ((YUV6.y >> 2) << 24) | ((YUV5.x & 0xFF) << 16) | ((YUV4.z & 0x3F) << 10) | ((YUV5.x >> 8) << 8) | ((YUV4.x & 0xF) << 4) | (YUV4.z >> 6);
	OutYCbCrBuffer[Index].DWord4 = ((YUV7.x & 0xFF) << 24) | ((YUV6.z & 0x3F) << 18) | ((YUV7.x >> 8) << 16) | ((YUV6.x & 0xF) << 12) | ((YUV6.z >> 6) << 8) | ((YUV6.y & 0x3) << 6) | (YUV6.x >> 4);
}

// Shader to convert from RGBA to RGB10

[numthreads(8,8,1)]
void RGBToRGB10BitCS(uint3 ThreadId : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Make sure it's a valid thread
	if(ThreadId.x >= HorizontalElementCount || ThreadId.y >= VerticalElementCount)
	{
		return;
	}

	uint Index = ThreadId.y * HorizontalElementCount + ThreadId.x;

	float X = (ThreadId.x * InputTexturePixelsPerThread) + InputPixelOffsetX;
	float Y = (ThreadId.y + InputPixelOffsetY) * OnePixelDeltaY;

	uint Denormalizer = 1023;
	uint3 RGB00 = InputTexture.SampleLevel(InputSampler, float2(((X + 0.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB01 = InputTexture.SampleLevel(InputSampler, float2(((X + 1.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB02 = InputTexture.SampleLevel(InputSampler, float2(((X + 2.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB03 = InputTexture.SampleLevel(InputSampler, float2(((X + 3.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB04 = InputTexture.SampleLevel(InputSampler, float2(((X + 4.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB05 = InputTexture.SampleLevel(InputSampler, float2(((X + 5.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB06 = InputTexture.SampleLevel(InputSampler, float2(((X + 6.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB07 = InputTexture.SampleLevel(InputSampler, float2(((X + 7.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB08 = InputTexture.SampleLevel(InputSampler, float2(((X + 8.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB09 = InputTexture.SampleLevel(InputSampler, float2(((X + 9.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB10 = InputTexture.SampleLevel(InputSampler, float2(((X + 10.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB11 = InputTexture.SampleLevel(InputSampler, float2(((X + 11.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB12 = InputTexture.SampleLevel(InputSampler, float2(((X + 12.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB13 = InputTexture.SampleLevel(InputSampler, float2(((X + 13.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB14 = InputTexture.SampleLevel(InputSampler, float2(((X + 14.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB15 = InputTexture.SampleLevel(InputSampler, float2(((X + 15.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;

	// Cap values to be in range
	RGB00 = min(RGB00, Denormalizer);
	RGB01 = min(RGB01, Denormalizer);
	RGB02 = min(RGB02, Denormalizer);
	RGB03 = min(RGB03, Denormalizer);
	RGB04 = min(RGB04, Denormalizer);
	RGB05 = min(RGB05, Denormalizer);
	RGB06 = min(RGB06, Denormalizer);
	RGB07 = min(RGB07, Denormalizer);
	RGB08 = min(RGB08, Denormalizer);
	RGB09 = min(RGB09, Denormalizer);
	RGB10 = min(RGB10, Denormalizer);
	RGB11 = min(RGB11, Denormalizer);
	RGB12 = min(RGB12, Denormalizer);
	RGB13 = min(RGB13, Denormalizer);
	RGB14 = min(RGB14, Denormalizer);
	RGB15 = min(RGB15, Denormalizer);


	// All this bit swizzling is to pack 3 channels of 10 bits with R being in LSB of the first 32 bits and subsequent channels following until we used all 16 pixels.
	// Example : RGB = (0x123, 0x245, 0x0AB)
	// Binary  : 0100 1000 1110 0100 0101 0011 0011 0100
	// Bytes   : 0x48 0xE4 0x53 0x34
	// 32 bits : 34 << 24 | 53 << 16 | E4 << 8 | 48 << 0
	// The bits of each channel not being next to each other seems weird but when you look at the byte ordering you can see it
	// The E in the second byte is the LSB of R and it's separated from the rest of R by the MSB of G.
	// We want 48 at the first adress so it goes in LSB of the 32 bits as it's written as little endian. 
	// 2110 on the wire will read it as big endian which will give us R going out first

	OutRGB10Buffer[Index].DWords[0] = ((RGB00.z & 0x03F) << 26) | ((RGB01.x >> 8)   << 24)   | ((RGB00.y & 0xF)  << 20) | ((RGB00.z >> 6)   << 16) | ((RGB00.x & 0x3)  << 14) | ((RGB00.y >> 4)   << 8)								| (RGB00.x >> 2);
	OutRGB10Buffer[Index].DWords[1] = ((RGB01.z & 0x00F) << 28) | ((RGB02.x >> 6)   << 24)   | ((RGB01.y & 0x3)  << 22) | ((RGB01.z >> 4)   << 16)							  | ((RGB01.y >> 2)   << 8)								| (RGB01.x & 0xFF);
	OutRGB10Buffer[Index].DWords[2] = ((RGB02.z & 0x003) << 30) | ((RGB03.x >> 4)   << 24)								| ((RGB02.z >> 2)   << 16)							  | ((RGB02.y & 0xFF) << 8)  | ((RGB02.x & 0x3F) << 2)  | (RGB02.y >> 8);
	OutRGB10Buffer[Index].DWords[3] =							  ((RGB04.x >> 2)   << 24)								| ((RGB03.z & 0xFF) << 16) | ((RGB03.y & 0x3F) << 10) | ((RGB03.z >> 8)   << 8)  | ((RGB03.x & 0xF)  << 4)  | (RGB03.y >> 6);
	OutRGB10Buffer[Index].DWords[4] =							  ((RGB05.x & 0xFF) << 24)   | ((RGB04.z & 0x3F) << 18) | ((RGB05.x >> 8)   << 16) | ((RGB04.y & 0xF)  << 12) | ((RGB04.z >> 6)   << 8)  | ((RGB04.x & 0x3)  << 6)  | (RGB04.y >> 4);
	
	OutRGB10Buffer[Index].DWords[5] = ((RGB06.x & 0x03F) << 26) | ((RGB06.y >> 8)   << 24)   | ((RGB05.z & 0xF)  << 20) | ((RGB06.x >> 6)   << 16) | ((RGB05.y & 0x3)  << 14) | ((RGB05.z >> 4)   << 8)								| (RGB05.y >> 2);
	OutRGB10Buffer[Index].DWords[6] = ((RGB07.x & 0x00F) << 28) | ((RGB07.y >> 6)   << 24)   | ((RGB06.z & 0x3)  << 22) | ((RGB07.x >> 4)   << 16)							  | ((RGB06.z >> 2)   << 8)								| (RGB06.y & 0xFF);
	OutRGB10Buffer[Index].DWords[7] = ((RGB08.x & 0x003) << 30) | ((RGB08.y >> 4)   << 24)								| ((RGB08.x >> 2)   << 16)							  | ((RGB07.z & 0xFF) << 8)  | ((RGB07.y & 0x3F) << 2)  | (RGB07.z >> 8);
	OutRGB10Buffer[Index].DWords[8] =							  ((RGB09.y >> 2)   << 24)								| ((RGB09.x & 0xFF) << 16) | ((RGB08.z & 0x3F) << 10) | ((RGB09.x >> 8)   << 8)  | ((RGB08.y & 0xF)  << 4)  | (RGB08.z >> 6);
	OutRGB10Buffer[Index].DWords[9] =							  ((RGB10.y & 0xFF) << 24)   | ((RGB10.x & 0x3F) << 18) | ((RGB10.y >> 8)   << 16) | ((RGB09.z & 0xF)  << 12) | ((RGB10.x >> 6)   << 8)  | ((RGB09.y & 0x3)  << 6)  | (RGB09.z >> 4);

	OutRGB10Buffer[Index].DWords[10] = ((RGB11.y & 0x03F) << 26) | ((RGB11.z >> 8)   << 24)  | ((RGB11.x & 0xF)  << 20) | ((RGB11.y >> 6)   << 16) | ((RGB10.z & 0x3)  << 14) | ((RGB11.x >> 4)   << 8)								| (RGB10.z >> 2);
	OutRGB10Buffer[Index].DWords[11] = ((RGB12.y & 0x00F) << 28) | ((RGB12.z >> 6)   << 24)  | ((RGB12.x & 0x3)  << 22) | ((RGB12.y >> 4)   << 16)							  | ((RGB12.x >> 2)   << 8)								| (RGB11.z & 0xFF);
	OutRGB10Buffer[Index].DWords[12] = ((RGB13.y & 0x003) << 30) | ((RGB13.z >> 4)   << 24)								| ((RGB13.y >> 2)   << 16)							  | ((RGB13.x & 0xFF) << 8)  | ((RGB12.z & 0x3F) << 2)  | (RGB13.x >> 8);
	OutRGB10Buffer[Index].DWords[13] =							   ((RGB14.z >> 2)   << 24)								| ((RGB14.y & 0xFF) << 16) | ((RGB14.x & 0x3F) << 10) | ((RGB14.y >> 8)   << 8)  | ((RGB13.z & 0xF)  << 4)  | (RGB14.x >> 6);
	OutRGB10Buffer[Index].DWords[14] =							   ((RGB15.z & 0xFF) << 24)  | ((RGB15.y & 0x3F) << 18) | ((RGB15.z >> 8)   << 16) | ((RGB15.x & 0xF)  << 12) | ((RGB15.y >> 6)   << 8)  | ((RGB14.z & 0x3)  << 6)  | (RGB15.x >> 4);
}

// Shader to convert from packed RGB10 to RGB10A2 texture

[numthreads(8,8,1)]
void RGB10BitToRGBACS(uint3 ThreadId : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Make sure it's a valid thread
	if(ThreadId.x >= HorizontalElementCount || ThreadId.y >= VerticalElementCount)
	{
		return;
	}

	// Pixels we treat in shader is pretty much hardcoded to 16 so no parameter has been used
	const uint OutputTexturePixelsPerThread = 16;

	// Scale U (x index) based on the number of pixels we treat per thread
	const uint BaseU = ThreadId.x * OutputTexturePixelsPerThread;
	const uint BaseV = ThreadId.y;

	// Input buffer indexing is done in one dimension so adjust using thread Id and elements per row
	const uint BufferIndex = ThreadId.y * HorizontalElementCount + ThreadId.x;

	// Used to normalize pixel values based on 10 bits input
	const float Mul = 1.0 / 1023.0;

	float3 RGB00 = uint3(0,0,0);
	RGB00.x = ((((InputBuffer[BufferIndex].DWords[00] >>  0)  << 2) | ((InputBuffer[BufferIndex].DWords[00] >> 14) & 0x003)) & 0x3FF) * Mul;
	RGB00.y = ((((InputBuffer[BufferIndex].DWords[00] >>  8)  << 4) | ((InputBuffer[BufferIndex].DWords[00] >> 20) & 0x00F)) & 0x3FF) * Mul;
	RGB00.z = ((((InputBuffer[BufferIndex].DWords[00] >> 16)  << 6) | ((InputBuffer[BufferIndex].DWords[00] >> 26) & 0x03F)) & 0x3FF) * Mul;

	float3 RGB01 = uint3(0,0,0);
	RGB01.x = ((((InputBuffer[BufferIndex].DWords[00] >> 24) << 8) | ((InputBuffer[BufferIndex].DWords[01] >> 00) & 0x0FF)) & 0x3FF) * Mul;
	RGB01.y = ((((InputBuffer[BufferIndex].DWords[01] >>  8) << 2) | ((InputBuffer[BufferIndex].DWords[01] >> 22) & 0x003)) & 0x3FF) * Mul;
	RGB01.z = ((((InputBuffer[BufferIndex].DWords[01] >> 16) << 4) | ((InputBuffer[BufferIndex].DWords[01] >> 28) & 0x00F)) & 0x3FF) * Mul;

	float3 RGB02 = uint3(0,0,0);
	RGB02.x = ((((InputBuffer[BufferIndex].DWords[01] >> 24) << 6) | ((InputBuffer[BufferIndex].DWords[02] >> 02) & 0x03F)) & 0x3FF) * Mul;
	RGB02.y = ((((InputBuffer[BufferIndex].DWords[02] >>  0) << 8) | ((InputBuffer[BufferIndex].DWords[02] >>  8) & 0x0FF)) & 0x3FF) * Mul;
	RGB02.z = ((((InputBuffer[BufferIndex].DWords[02] >> 16) << 2) | ((InputBuffer[BufferIndex].DWords[02] >> 30) & 0x002)) & 0x3FF) * Mul;
	
	float3 RGB03 = uint3(0,0,0);
	RGB03.x = ((((InputBuffer[BufferIndex].DWords[02] >> 24) << 4) | ((InputBuffer[BufferIndex].DWords[03] >> 04) & 0x00F)) & 0x3FF) * Mul;
	RGB03.y = ((((InputBuffer[BufferIndex].DWords[03] >> 00) << 6) | ((InputBuffer[BufferIndex].DWords[03] >> 10) & 0x03F)) & 0x3FF) * Mul;
	RGB03.z = ((((InputBuffer[BufferIndex].DWords[03] >>  8) << 8) | ((InputBuffer[BufferIndex].DWords[03] >> 16) & 0x0FF)) & 0x3FF) * Mul;
	
	float3 RGB04 = uint3(0,0,0);
	RGB04.x = ((((InputBuffer[BufferIndex].DWords[03] >> 24) << 2) | ((InputBuffer[BufferIndex].DWords[04] >> 06) & 0x003)) & 0x3FF) * Mul;
	RGB04.y = ((((InputBuffer[BufferIndex].DWords[04] >> 00) << 4) | ((InputBuffer[BufferIndex].DWords[04] >> 12) & 0x00F)) & 0x3FF) * Mul;
	RGB04.z = ((((InputBuffer[BufferIndex].DWords[04] >>  8) << 6) | ((InputBuffer[BufferIndex].DWords[04] >> 18) & 0x03F)) & 0x3FF) * Mul;
	
	float3 RGB05;
	RGB05.x = ((((InputBuffer[BufferIndex].DWords[04] >> 16) << 8) | ((InputBuffer[BufferIndex].DWords[04] >> 24) & 0x0FF)) & 0x3FF) * Mul;
	RGB05.y = ((((InputBuffer[BufferIndex].DWords[05] >> 00) << 2) | ((InputBuffer[BufferIndex].DWords[05] >> 14) & 0x003)) & 0x3FF) * Mul;
	RGB05.z = ((((InputBuffer[BufferIndex].DWords[05] >>  8) << 4) | ((InputBuffer[BufferIndex].DWords[05] >> 20) & 0x00F)) & 0x3FF) * Mul;

	float3 RGB06 = uint3(0,0,0);
	RGB06.x = ((((InputBuffer[BufferIndex].DWords[05] >> 16) << 6) | ((InputBuffer[BufferIndex].DWords[05] >> 26) & 0x03F)) & 0x3FF) * Mul;
	RGB06.y = ((((InputBuffer[BufferIndex].DWords[05] >> 24) << 8) | ((InputBuffer[BufferIndex].DWords[06] >> 00) & 0x0FF)) & 0x3FF) * Mul;
	RGB06.z = ((((InputBuffer[BufferIndex].DWords[06] >>  8) << 2) | ((InputBuffer[BufferIndex].DWords[06] >> 22) & 0x003)) & 0x3FF) * Mul;

	float3 RGB07 = uint3(0,0,0);
	RGB07.x = ((((InputBuffer[BufferIndex].DWords[06] >> 16) << 4) | ((InputBuffer[BufferIndex].DWords[06] >> 28) & 0x00F)) & 0x3FF) * Mul;
	RGB07.y = ((((InputBuffer[BufferIndex].DWords[06] >> 24) << 6) | ((InputBuffer[BufferIndex].DWords[07] >> 02) & 0x03F)) & 0x3FF) * Mul;
	RGB07.z = ((((InputBuffer[BufferIndex].DWords[07] >>  0) << 8) | ((InputBuffer[BufferIndex].DWords[07] >>  8) & 0x0FF)) & 0x3FF) * Mul;

	float3 RGB08 = uint3(0,0,0);
	RGB08.x = ((((InputBuffer[BufferIndex].DWords[07] >> 16) << 2) | ((InputBuffer[BufferIndex].DWords[07] >> 30) & 0x003)) & 0x3FF) * Mul;
	RGB08.y = ((((InputBuffer[BufferIndex].DWords[07] >> 24) << 4) | ((InputBuffer[BufferIndex].DWords[ 8] >> 04) & 0x00F)) & 0x3FF) * Mul;
	RGB08.z = ((((InputBuffer[BufferIndex].DWords[ 8] >>  0) << 6) | ((InputBuffer[BufferIndex].DWords[ 8] >> 10) & 0x03F)) & 0x3FF) * Mul;

	float3 RGB09 = uint3(0,0,0);
	RGB09.x = ((((InputBuffer[BufferIndex].DWords[ 8] >>  8) << 8) | ((InputBuffer[BufferIndex].DWords[ 8] >> 16) & 0x0FF)) & 0x3FF) * Mul;
	RGB09.y = ((((InputBuffer[BufferIndex].DWords[ 8] >> 24) << 2) | ((InputBuffer[BufferIndex].DWords[ 9] >> 06) & 0x003)) & 0x3FF) * Mul;
	RGB09.z = ((((InputBuffer[BufferIndex].DWords[ 9] >>  0) << 4) | ((InputBuffer[BufferIndex].DWords[ 9] >> 12) & 0x00F)) & 0x3FF) * Mul;

	float3 RGB10 = uint3(0,0,0);
	RGB10.x = ((((InputBuffer[BufferIndex].DWords[ 9] >>  8) << 6) | ((InputBuffer[BufferIndex].DWords[ 9] >> 18) & 0x03F)) & 0x3FF) * Mul;
	RGB10.y = ((((InputBuffer[BufferIndex].DWords[ 9] >> 16) << 8) | ((InputBuffer[BufferIndex].DWords[ 9] >> 24) & 0x0FF)) & 0x3FF) * Mul;
	RGB10.z = ((((InputBuffer[BufferIndex].DWords[10] >>  0) << 2) | ((InputBuffer[BufferIndex].DWords[10] >> 14) & 0x003)) & 0x3FF) * Mul;

	float3 RGB11 = uint3(0,0,0);
	RGB11.x = ((((InputBuffer[BufferIndex].DWords[10] >>  8) << 4) | ((InputBuffer[BufferIndex].DWords[10] >> 20) & 0x00F)) & 0x3FF) * Mul;
	RGB11.y = ((((InputBuffer[BufferIndex].DWords[10] >> 16) << 6) | ((InputBuffer[BufferIndex].DWords[10] >> 26) & 0x03F)) & 0x3FF) * Mul;
	RGB11.z = ((((InputBuffer[BufferIndex].DWords[10] >>  24) << 8) | ((InputBuffer[BufferIndex].DWords[11] >> 00) & 0x0FF)) & 0x3FF) * Mul;
	
	//OutRGB10Buffer[Index].DWords[12] = ((RGB13.y & 0x003) << 30) | ((RGB13.z >> 4)   << 24)								| ((RGB13.y >> 2)   << 16)							  | ((RGB13.x & 0xFF) << 8)  | ((RGB12.z & 0x3F) << 2)  | (RGB13.x >> 8);
	float3 RGB12 = uint3(0,0,0);
	RGB12.x = ((((InputBuffer[BufferIndex].DWords[11] >>  8) << 2) | ((InputBuffer[BufferIndex].DWords[11] >> 22) & 0x003)) & 0x3FF) * Mul;
	RGB12.y = ((((InputBuffer[BufferIndex].DWords[11] >> 16) << 4) | ((InputBuffer[BufferIndex].DWords[11] >> 28) & 0x00F)) & 0x3FF) * Mul;
	RGB12.z = ((((InputBuffer[BufferIndex].DWords[11] >> 24) << 6) | ((InputBuffer[BufferIndex].DWords[12] >> 02) & 0x03F)) & 0x3FF) * Mul;

	float3 RGB13 = uint3(0,0,0);
	RGB13.x = ((((InputBuffer[BufferIndex].DWords[12] >>  0) << 8) | ((InputBuffer[BufferIndex].DWords[12] >>  8) & 0x0FF)) & 0x3FF) * Mul;
	RGB13.y = ((((InputBuffer[BufferIndex].DWords[12] >> 16) << 2) | ((InputBuffer[BufferIndex].DWords[12] >> 30) & 0x003)) & 0x3FF) * Mul;
	RGB13.z = ((((InputBuffer[BufferIndex].DWords[12] >> 24) << 4) | ((InputBuffer[BufferIndex].DWords[13] >> 04) & 0x00F)) & 0x3FF) * Mul;

	float3 RGB14 = uint3(0,0,0);
	RGB14.x = ((((InputBuffer[BufferIndex].DWords[13] >>  0) << 6) | ((InputBuffer[BufferIndex].DWords[13] >> 10) & 0x03F)) & 0x3FF) * Mul;
	RGB14.y = ((((InputBuffer[BufferIndex].DWords[13] >>  8) << 8) | ((InputBuffer[BufferIndex].DWords[13] >> 16) & 0x0FF)) & 0x3FF) * Mul;
	RGB14.z = ((((InputBuffer[BufferIndex].DWords[13] >> 24) << 2) | ((InputBuffer[BufferIndex].DWords[14] >> 06) & 0x003)) & 0x3FF) * Mul;

	float3 RGB15 = uint3(0,0,0);
	RGB15.x = ((((InputBuffer[BufferIndex].DWords[14] >>  0) << 4) | ((InputBuffer[BufferIndex].DWords[14] >> 12) & 0x00F)) & 0x3FF) * Mul;
	RGB15.y = ((((InputBuffer[BufferIndex].DWords[14] >>  8) << 6) | ((InputBuffer[BufferIndex].DWords[14] >> 18) & 0x03F)) & 0x3FF) * Mul;
	RGB15.z = ((((InputBuffer[BufferIndex].DWords[14] >> 16) << 8) | ((InputBuffer[BufferIndex].DWords[14] >> 24) & 0x0FF)) & 0x3FF) * Mul;

	#if DO_SRGB_TO_LINEAR
		RGB00 = sRGBToLinear(RGB00);
		RGB01 = sRGBToLinear(RGB01);
		RGB02 = sRGBToLinear(RGB02);
		RGB03 = sRGBToLinear(RGB03);
		RGB04 = sRGBToLinear(RGB04);
		RGB05 = sRGBToLinear(RGB05);
		RGB06 = sRGBToLinear(RGB06);
		RGB07 = sRGBToLinear(RGB07);
		RGB08 = sRGBToLinear(RGB08);
		RGB09 = sRGBToLinear(RGB09);
		RGB10 = sRGBToLinear(RGB10);
		RGB11 = sRGBToLinear(RGB11);
		RGB12 = sRGBToLinear(RGB12);
		RGB13 = sRGBToLinear(RGB13);
		RGB14 = sRGBToLinear(RGB14);
		RGB15 = sRGBToLinear(RGB15);
	#endif

	OutTexture[uint2(BaseU + 0, BaseV)] = float4(RGB00, 1.0);
	OutTexture[uint2(BaseU + 1, BaseV)] = float4(RGB01, 1.0);
	OutTexture[uint2(BaseU + 2, BaseV)] = float4(RGB02, 1.0);
	OutTexture[uint2(BaseU + 3, BaseV)] = float4(RGB03, 1.0);
	OutTexture[uint2(BaseU + 4, BaseV)] = float4(RGB04, 1.0);
	OutTexture[uint2(BaseU + 5, BaseV)] = float4(RGB05, 1.0);
	OutTexture[uint2(BaseU + 6, BaseV)] = float4(RGB06, 1.0);
	OutTexture[uint2(BaseU + 7, BaseV)] = float4(RGB07, 1.0);
	OutTexture[uint2(BaseU + 8, BaseV)] = float4(RGB08, 1.0);
	OutTexture[uint2(BaseU + 9, BaseV)] = float4(RGB09, 1.0);
	OutTexture[uint2(BaseU + 10, BaseV)] = float4(RGB10, 1.0);
	OutTexture[uint2(BaseU + 11, BaseV)] = float4(RGB11, 1.0);
	OutTexture[uint2(BaseU + 12, BaseV)] = float4(RGB12, 1.0);
	OutTexture[uint2(BaseU + 13, BaseV)] = float4(RGB13, 1.0);
	OutTexture[uint2(BaseU + 14, BaseV)] = float4(RGB14, 1.0);
	OutTexture[uint2(BaseU + 15, BaseV)] = float4(RGB15, 1.0);
}

// Shader to convert from RGBA to RGB8

[numthreads(8,8,1)]
void RGBToRGB8BitCS(uint3 ThreadId : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Make sure it's a valid thread
	if(ThreadId.x >= HorizontalElementCount || ThreadId.y >= VerticalElementCount)
	{
		return;
	}

	uint Index = ThreadId.y * HorizontalElementCount + ThreadId.x;

	float X = (ThreadId.x * InputTexturePixelsPerThread) + InputPixelOffsetX;
	float Y = (ThreadId.y + InputPixelOffsetY) * OnePixelDeltaY;

	// We process 4 RGB pixels per thread
	uint Denormalizer = 255;
	uint3 RGB0 = InputTexture.SampleLevel(InputSampler, float2(((X + 0.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB1 = InputTexture.SampleLevel(InputSampler, float2(((X + 1.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB2 = InputTexture.SampleLevel(InputSampler, float2(((X + 2.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB3 = InputTexture.SampleLevel(InputSampler, float2(((X + 3.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;

	// Cap values to be in range
	RGB0 = min(RGB0, Denormalizer);
	RGB1 = min(RGB1, Denormalizer);
	RGB2 = min(RGB2, Denormalizer);
	RGB3 = min(RGB3, Denormalizer);

	// We write the 4 RGB pixels (24 bits * 4 = 96 bits = 3x32 bits) following the packing 2110 expects
	OutRGB8Buffer[Index].DWord0 = (RGB1.x << 24) | (RGB0.z << 16) | (RGB0.y << 8) | (RGB0.x << 0);
	OutRGB8Buffer[Index].DWord1 = (RGB2.y << 24) | (RGB2.x << 16) | (RGB1.z << 8) | (RGB1.y << 0);
	OutRGB8Buffer[Index].DWord2 = (RGB3.z << 24) | (RGB3.y << 16) | (RGB3.x << 8) | (RGB2.z << 0);
}

// Shader to convert from packed RGB8 to RGBA8 texture

[numthreads(8,8,1)]
void RGB8BitToRGBA8CS(uint3 ThreadId : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Make sure it's a valid thread
	if(ThreadId.x >= HorizontalElementCount || ThreadId.y >= VerticalElementCount)
	{
		return;
	}

	// Pixels we treat in shader is pretty much hardcoded to 16 so no parameter has been used
	const uint OutputTexturePixelsPerThread = 4;

	// Scale U (x index) based on the number of pixels we treat per thread
	const uint BaseU = ThreadId.x * OutputTexturePixelsPerThread;
	const uint BaseV = ThreadId.y;

	// Input buffer indexing is done in one dimension so adjust using thread Id and elements per row
	const uint BufferIndex = ThreadId.y * HorizontalElementCount + ThreadId.x;

	// Used to normalize pixel values based on 8 bits input
	const float Mul = 1.0 / 255.0;

	float3 RGB00;
	RGB00.x = (((InputRGB8Buffer[BufferIndex].DWord0 >> 00) & 0xFF)) * Mul;
	RGB00.y = (((InputRGB8Buffer[BufferIndex].DWord0 >>  8) & 0xFF)) * Mul;
	RGB00.z = (((InputRGB8Buffer[BufferIndex].DWord0 >> 16) & 0xFF)) * Mul;

	float3 RGB01;
	RGB01.x = (((InputRGB8Buffer[BufferIndex].DWord0 >> 24) & 0xFF)) * Mul;
	RGB01.y = (((InputRGB8Buffer[BufferIndex].DWord1 >> 00) & 0xFF)) * Mul;
	RGB01.z = (((InputRGB8Buffer[BufferIndex].DWord1 >>  8) & 0xFF)) * Mul;

	float3 RGB02;
	RGB02.x = (((InputRGB8Buffer[BufferIndex].DWord1 >> 16) & 0xFF)) * Mul;
	RGB02.y = (((InputRGB8Buffer[BufferIndex].DWord1 >> 24) & 0xFF)) * Mul;
	RGB02.z = (((InputRGB8Buffer[BufferIndex].DWord2 >> 00) & 0xFF)) * Mul;
	
	float3 RGB03;
	RGB03.x = (((InputRGB8Buffer[BufferIndex].DWord2 >>  8) & 0xFF)) * Mul;
	RGB03.y = (((InputRGB8Buffer[BufferIndex].DWord2 >> 16) & 0xFF)) * Mul;
	RGB03.z = (((InputRGB8Buffer[BufferIndex].DWord2 >> 24) & 0xFF)) * Mul;
	

	#if DO_SRGB_TO_LINEAR
		RGB00 = sRGBToLinear(RGB00);
		RGB01 = sRGBToLinear(RGB01);
		RGB02 = sRGBToLinear(RGB02);
		RGB03 = sRGBToLinear(RGB03);
	#endif

	OutTexture[uint2(BaseU + 0, BaseV)] = float4(RGB00, 1.0);
	OutTexture[uint2(BaseU + 1, BaseV)] = float4(RGB01, 1.0);
	OutTexture[uint2(BaseU + 2, BaseV)] = float4(RGB02, 1.0);
	OutTexture[uint2(BaseU + 3, BaseV)] = float4(RGB03, 1.0);
}

// Shader to convert from RGBA to RGB12

[numthreads(8,8,1)]
void RGBToRGB12BitCS(uint3 ThreadId : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Make sure it's a valid thread
	if(ThreadId.x >= HorizontalElementCount || ThreadId.y >= VerticalElementCount)
	{
		return;
	}

	uint Index = ThreadId.y * HorizontalElementCount + ThreadId.x;

	float X = (ThreadId.x * InputTexturePixelsPerThread) + InputPixelOffsetX;
	float Y = (ThreadId.y + InputPixelOffsetY) * OnePixelDeltaY;

	//12 bits max value
	uint Denormalizer = 4095;
	uint3 RGB00 = InputTexture.SampleLevel(InputSampler, float2(((X + 0.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB01 = InputTexture.SampleLevel(InputSampler, float2(((X + 1.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB02 = InputTexture.SampleLevel(InputSampler, float2(((X + 2.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB03 = InputTexture.SampleLevel(InputSampler, float2(((X + 3.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB04 = InputTexture.SampleLevel(InputSampler, float2(((X + 4.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB05 = InputTexture.SampleLevel(InputSampler, float2(((X + 5.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB06 = InputTexture.SampleLevel(InputSampler, float2(((X + 6.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;
	uint3 RGB07 = InputTexture.SampleLevel(InputSampler, float2(((X + 7.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb * Denormalizer;

	// Cap values to be in range
	RGB00 = min(RGB00, Denormalizer);
	RGB01 = min(RGB01, Denormalizer);
	RGB02 = min(RGB02, Denormalizer);
	RGB03 = min(RGB03, Denormalizer);
	RGB04 = min(RGB04, Denormalizer);
	RGB05 = min(RGB05, Denormalizer);
	RGB06 = min(RGB06, Denormalizer);
	RGB07 = min(RGB07, Denormalizer);

	OutRGB12Buffer[Index].DWords[0] =							  ((RGB00.z >> 4)   << 24) |							 ((RGB00.y & 0xFF)  << 16) |((RGB00.x & 0xF)  << 12) | ((RGB00.y >> 8)    << 8)								| (RGB00.x >> 4);
	OutRGB12Buffer[Index].DWords[1] = ((RGB01.y & 0x00F) << 28) | ((RGB01.z >> 8)   << 24) |							 ((RGB01.y >> 4)    << 16)							 | ((RGB01.x & 0xFF)  << 8) | ((RGB00.z & 0x00F) << 4)	| (RGB01.x >> 8);
	OutRGB12Buffer[Index].DWords[2] =							  ((RGB02.y & 0xFF) << 24) | ((RGB02.x & 0xF) << 20)	| ((RGB02.y >> 8)   << 16)							  | ((RGB02.x >> 4)	  << 8)								| (RGB01.z & 0xFF);
	OutRGB12Buffer[Index].DWords[3] =							  ((RGB03.y >> 4)   << 24)								| ((RGB03.x & 0xFF) << 16) | ((RGB02.z & 0xF) << 12) | ((RGB03.x >> 8)   << 8)								| (RGB02.z >> 4);
	OutRGB12Buffer[Index].DWords[4] = ((RGB04.x & 0x00F) << 28) | ((RGB04.y >> 8)   << 24)								| ((RGB04.x >> 4)   << 16)							  | ((RGB03.z & 0xFF) << 8)  | ((RGB03.y & 0x00F)  << 4)| (RGB03.z >> 8);
	OutRGB12Buffer[Index].DWords[5] =							  ((RGB05.x & 0xFF) << 24) | ((RGB04.z & 0xF) << 20)	| ((RGB05.x >> 8)   << 16)							  | ((RGB04.z >> 4)   << 8)								| (RGB04.y & 0xFF);
	OutRGB12Buffer[Index].DWords[6] =							  ((RGB06.x >> 4)   << 24)								| ((RGB05.z & 0xFF) << 16) | ((RGB05.y & 0xF) << 12)  | ((RGB05.z >> 8)   << 8)								| (RGB05.y >> 4);
	OutRGB12Buffer[Index].DWords[7] = ((RGB06.z & 0x00F) << 28) | ((RGB07.x >> 8)   << 24)								| ((RGB06.z >> 4)   << 16)							  | ((RGB06.y & 0xFF) << 8)  | ((RGB06.x & 0x00F) << 4) | (RGB06.y >> 8);
	OutRGB12Buffer[Index].DWords[8] =							  ((RGB07.z & 0xFF) << 24) | ((RGB07.y & 0xF) << 20)	| ((RGB07.z >> 8)   << 16)							  | ((RGB07.y >> 4)   << 8)								| (RGB07.x & 0xFF);
}

// Shader to convert from packed RGB12 to float RGBA texture

[numthreads(8,8,1)]
void RGB12BitToRGBACS(uint3 ThreadId : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Make sure it's a valid thread
	if(ThreadId.x >= HorizontalElementCount || ThreadId.y >= VerticalElementCount)
	{
		return;
	}

	// Pixels we treat in shader is pretty much hardcoded to 16 so no parameter has been used
	const uint OutputTexturePixelsPerThread = 8;

	// Scale U (x index) based on the number of pixels we treat per thread
	const uint BaseU = ThreadId.x * OutputTexturePixelsPerThread;
	const uint BaseV = ThreadId.y;

	// Input buffer indexing is done in one dimension so adjust using thread Id and elements per row
	const uint BufferIndex = ThreadId.y * HorizontalElementCount + ThreadId.x;

	// Used to normalize pixel values based on 12 bits input
	const float Mul = 1.0 / 4095.0;

	float3 RGB00 = uint3(0,0,0);
	RGB00.x = ((((InputRGB12Buffer[BufferIndex].DWords[00] >>  0)  << 4) | ((InputRGB12Buffer[BufferIndex].DWords[00] >> 12) & 0x00F)) & 0xFFF) * Mul;
	RGB00.y = ((((InputRGB12Buffer[BufferIndex].DWords[00] >>  8)  << 8) | ((InputRGB12Buffer[BufferIndex].DWords[00] >> 16) & 0x0FF)) & 0xFFF) * Mul;
	RGB00.z = ((((InputRGB12Buffer[BufferIndex].DWords[00] >> 24)  << 4) | ((InputRGB12Buffer[BufferIndex].DWords[01] >> 04) & 0x00F)) & 0xFFF) * Mul;

	float3 RGB01 = uint3(0,0,0);
	RGB01.x = ((((InputRGB12Buffer[BufferIndex].DWords[01] >>  0) << 8) | ((InputRGB12Buffer[BufferIndex].DWords[01] >>  8) & 0x0FF)) & 0xFFF) * Mul;
	RGB01.y = ((((InputRGB12Buffer[BufferIndex].DWords[01] >> 16) << 4) | ((InputRGB12Buffer[BufferIndex].DWords[01] >> 28) & 0x00F)) & 0xFFF) * Mul;
	RGB01.z = ((((InputRGB12Buffer[BufferIndex].DWords[01] >> 24) << 8) | ((InputRGB12Buffer[BufferIndex].DWords[02] >> 00) & 0x0FF)) & 0xFFF) * Mul;

	float3 RGB02 = uint3(0,0,0);
	RGB02.x = ((((InputRGB12Buffer[BufferIndex].DWords[02] >>  8) << 4) | ((InputRGB12Buffer[BufferIndex].DWords[02] >> 20) & 0x00F)) & 0xFFF) * Mul;
	RGB02.y = ((((InputRGB12Buffer[BufferIndex].DWords[02] >> 16) << 8) | ((InputRGB12Buffer[BufferIndex].DWords[02] >> 24) & 0x0FF)) & 0xFFF) * Mul;
	RGB02.z = ((((InputRGB12Buffer[BufferIndex].DWords[03] >>  0) << 4) | ((InputRGB12Buffer[BufferIndex].DWords[03] >> 12) & 0x00F)) & 0xFFF) * Mul;
	
	float3 RGB03 = uint3(0,0,0);
	RGB03.x = ((((InputRGB12Buffer[BufferIndex].DWords[03] >>  8) << 8) | ((InputRGB12Buffer[BufferIndex].DWords[03] >> 16) & 0x0FF)) & 0xFFF) * Mul;
	RGB03.y = ((((InputRGB12Buffer[BufferIndex].DWords[03] >> 24) << 4) | ((InputRGB12Buffer[BufferIndex].DWords[04] >> 04) & 0x00F)) & 0xFFF) * Mul;
	RGB03.z = ((((InputRGB12Buffer[BufferIndex].DWords[04] >>  0) << 8) | ((InputRGB12Buffer[BufferIndex].DWords[04] >>  8) & 0x0FF)) & 0xFFF) * Mul;
	
	float3 RGB04 = uint3(0,0,0);
	RGB04.x = ((((InputRGB12Buffer[BufferIndex].DWords[04] >> 16) << 4) | ((InputRGB12Buffer[BufferIndex].DWords[04] >> 28) & 0x00F)) & 0xFFF) * Mul;
	RGB04.y = ((((InputRGB12Buffer[BufferIndex].DWords[04] >> 24) << 8) | ((InputRGB12Buffer[BufferIndex].DWords[05] >>  0) & 0x0FF)) & 0xFFF) * Mul;
	RGB04.z = ((((InputRGB12Buffer[BufferIndex].DWords[05] >>  8) << 4) | ((InputRGB12Buffer[BufferIndex].DWords[05] >> 20) & 0x00F)) & 0xFFF) * Mul;
	
	float3 RGB05;
	RGB05.x = ((((InputRGB12Buffer[BufferIndex].DWords[05] >> 16) << 8) | ((InputRGB12Buffer[BufferIndex].DWords[05] >> 24) & 0x0FF)) & 0xFFF) * Mul;
	RGB05.y = ((((InputRGB12Buffer[BufferIndex].DWords[06] >> 00) << 4) | ((InputRGB12Buffer[BufferIndex].DWords[06] >> 12) & 0x00F)) & 0xFFF) * Mul;
	RGB05.z = ((((InputRGB12Buffer[BufferIndex].DWords[06] >>  8) << 8) | ((InputRGB12Buffer[BufferIndex].DWords[06] >> 16) & 0x0FF)) & 0xFFF) * Mul;

	float3 RGB06 = uint3(0,0,0);
	RGB06.x = ((((InputRGB12Buffer[BufferIndex].DWords[06] >> 24) << 4) | ((InputRGB12Buffer[BufferIndex].DWords[07] >> 04) & 0x00F)) & 0xFFF) * Mul;
	RGB06.y = ((((InputRGB12Buffer[BufferIndex].DWords[07] >>  0) << 8) | ((InputRGB12Buffer[BufferIndex].DWords[07] >>  8) & 0x0FF)) & 0xFFF) * Mul;
	RGB06.z = ((((InputRGB12Buffer[BufferIndex].DWords[07] >>  16) << 4) | ((InputRGB12Buffer[BufferIndex].DWords[07] >> 28) & 0x00F)) & 0xFFF) * Mul;

	float3 RGB07 = uint3(0,0,0);
	RGB07.x = ((((InputRGB12Buffer[BufferIndex].DWords[07] >> 24) << 8) | ((InputRGB12Buffer[BufferIndex].DWords[8] >> 00) & 0x0FF)) & 0xFFF) * Mul;
	RGB07.y = ((((InputRGB12Buffer[BufferIndex].DWords[8] >>  8) << 4) | ((InputRGB12Buffer[BufferIndex].DWords[8] >> 20) & 0x00F)) & 0xFFF) * Mul;
	RGB07.z = ((((InputRGB12Buffer[BufferIndex].DWords[8] >>  16) << 8) | ((InputRGB12Buffer[BufferIndex].DWords[8] >> 24) & 0x0FF)) & 0xFFF) * Mul;

	#if DO_SRGB_TO_LINEAR
		RGB00 = sRGBToLinear(RGB00);
		RGB01 = sRGBToLinear(RGB01);
		RGB02 = sRGBToLinear(RGB02);
		RGB03 = sRGBToLinear(RGB03);
		RGB04 = sRGBToLinear(RGB04);
		RGB05 = sRGBToLinear(RGB05);
		RGB06 = sRGBToLinear(RGB06);
		RGB07 = sRGBToLinear(RGB07);
	#endif

	OutTexture[uint2(BaseU + 0, BaseV)] = float4(RGB00, 1.0);
	OutTexture[uint2(BaseU + 1, BaseV)] = float4(RGB01, 1.0);
	OutTexture[uint2(BaseU + 2, BaseV)] = float4(RGB02, 1.0);
	OutTexture[uint2(BaseU + 3, BaseV)] = float4(RGB03, 1.0);
	OutTexture[uint2(BaseU + 4, BaseV)] = float4(RGB04, 1.0);
	OutTexture[uint2(BaseU + 5, BaseV)] = float4(RGB05, 1.0);
	OutTexture[uint2(BaseU + 6, BaseV)] = float4(RGB06, 1.0);
	OutTexture[uint2(BaseU + 7, BaseV)] = float4(RGB07, 1.0);
}

// Shader to convert from RGBA to RGB Float16



[numthreads(8,8,1)]
void RGBToRGB16fBitCS(uint3 ThreadId : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Make sure it's a valid thread
	if(ThreadId.x >= HorizontalElementCount || ThreadId.y >= VerticalElementCount)
	{
		return;
	}

	float X = (ThreadId.x * InputTexturePixelsPerThread) + InputPixelOffsetX;
	float Y = (ThreadId.y + InputPixelOffsetY) * OnePixelDeltaY;

	float3 RGB0 = InputTexture.SampleLevel(InputSampler, float2(((X + 0.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb;
	float3 RGB1 = InputTexture.SampleLevel(InputSampler, float2(((X + 1.0) + 0.5) * OnePixelDeltaX, Y), 0).rgb;
	//RGB0 = float3(1,0,1);
	//RGB1 = float3(0,1,0);

	// Storage has been untested as no available supported that viewer. Will need to be validated. 
	uint Index = ThreadId.y * HorizontalElementCount + ThreadId.x;

	// Convert float to half representation and write it in lowest 16 bits of a uint
	uint IntR0 = f32tof16(RGB0.x);
	uint IntG0 = f32tof16(RGB0.y);
	uint IntB0 = f32tof16(RGB0.z);
	uint IntR1 = f32tof16(RGB1.x);
	uint IntG1 = f32tof16(RGB1.y);
	uint IntB1 = f32tof16(RGB1.z);

	#if 1
	OutRGB16fBuffer[Index].DWords[0]  = ((IntG0 & 0xFF) << 24) | ((IntG0 >> 8) << 16) | ((IntR0 & 0xFF) << 8) | ((IntR0 >> 8) << 0);
	OutRGB16fBuffer[Index].DWords[1]  = ((IntR1 & 0xFF) << 24) | ((IntR1 >> 8) << 16) | ((IntB0 & 0xFF) << 8) | ((IntB0 >> 8) << 0);
	OutRGB16fBuffer[Index].DWords[2]  = ((IntB1 & 0xFF) << 24) | ((IntB1 >> 8) << 16) | ((IntG1 & 0xFF) << 8) | ((IntG1 >> 8) << 0);
	#else
	OutRGB16fBuffer[Index].DWords[0]  = IntR0;
	OutRGB16fBuffer[Index].DWords[1]  = IntG0;
	OutRGB16fBuffer[Index].DWords[2]  = IntB0;
	#endif
}

/**
 * This function extracts the 16bit (float) data stored in uint (32 bit)
 * Same used in EXRSwizzler. 
 */
float UintContainingFloatToFloat(in uint Value)
{
	int Sign = (Value >> 15) & 0x00000001;
	int Exponent = (Value >> 10) & 0x0000001f;
	int Mantissa = Value & 0x000003ff;

	Exponent = Exponent + (127 - 15);
	Mantissa = Mantissa << 13;

	return asfloat((Sign << 31) | (Exponent << 23) | Mantissa);
}

float GetEncodedFloatValue(in uint Value)
{
	uint LowerWord = Value & 0xFFFF;
	uint Swizzled = (LowerWord << 8);
	Swizzled += (LowerWord >> 8) & 0xFF;

	#if SM6_PROFILE
	return UintContainingFloatToFloat(Swizzled);
	#else
	return f16tof32(Swizzled);
	#endif
}

// Shader to convert from packed RGB16f to float RGBA texture

[numthreads(8,8,1)]
void RGB16fBitToRGBACS(uint3 ThreadId : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Make sure it's a valid thread
	if(ThreadId.x >= HorizontalElementCount || ThreadId.y >= VerticalElementCount)
	{
		return;
	}

	// Pixels we treat in shader is pretty much hardcoded to 2 so no parameter has been used
	const uint OutputTexturePixelsPerThread = 2;

	// Scale U (x index) based on the number of pixels we treat per thread
	const uint BaseU = ThreadId.x * OutputTexturePixelsPerThread;
	const uint BaseV = ThreadId.y;

	// Input buffer indexing is done in one dimension so adjust using thread Id and elements per row
	const uint BufferIndex = ThreadId.y * HorizontalElementCount + ThreadId.x;

	const uint Dword0 = InputRGB16fBuffer[BufferIndex].DWords[00];
	const uint Dword1 = InputRGB16fBuffer[BufferIndex].DWords[01];
	const uint Dword2 = InputRGB16fBuffer[BufferIndex].DWords[02];

	const uint IntRed0 = Dword0 & 0xFFFF;
	const uint IntGreen0 = (Dword0 >> 16) & 0xFFFF;
	const uint IntBlue0 = Dword1 & 0xFFFF;
	const uint IntRed1 = (Dword1 >> 16) & 0xFFFF;
	const uint IntGreen1 = Dword2 & 0xFFFF;
	const uint IntBlue1 = (Dword2 >> 16) & 0xFFFF;

	float4 RGB00 = float4(0,0,0,1);
	float4 RGB01 = float4(0,0,0,1);
	RGB00.x = GetEncodedFloatValue(IntRed0);
	RGB00.y = GetEncodedFloatValue(IntGreen0);
	RGB00.z = GetEncodedFloatValue(IntBlue0);
	RGB01.x = GetEncodedFloatValue(IntRed1);
	RGB01.y = GetEncodedFloatValue(IntGreen1);
	RGB01.z = GetEncodedFloatValue(IntBlue1);
	
	OutTexture[uint2(BaseU + 0, BaseV)] = RGB00;
	OutTexture[uint2(BaseU + 1, BaseV)] = RGB01;
}

// Shader to convert from YUV 422 8 bits to RGBA

[numthreads(8,8,1)]
void YUV8Bit422ToRGBACS(uint3 ThreadId : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Make sure it's a valid thread
	if(ThreadId.x >= HorizontalElementCount || ThreadId.y >= VerticalElementCount)
	{
		return;
	}

	// Pixels we treat in shader is pretty much hardcoded to 2 so no parameter has been used
	const uint OutputTexturePixelsPerThread = 2;

	// Scale U (x index) based on the number of pixels we treat per thread
	const uint BaseU = ThreadId.x * OutputTexturePixelsPerThread;
	const uint BaseV = ThreadId.y;

	// Input buffer indexing is done in one dimension so adjust using thread Id and elements per row
	const uint BufferIndex = ThreadId.y * HorizontalElementCount + ThreadId.x;

	// Used to normalize pixel values based on 8 bits input
	const float Mul = 1.0 / 255.0;
	
	float U0 = ((InputYUV4228bitBuffer[BufferIndex].DWord0 >>  0) & 0xFF) * Mul;
	float Y0 = ((InputYUV4228bitBuffer[BufferIndex].DWord0 >>  8) & 0xFF) * Mul;
	float V0 = ((InputYUV4228bitBuffer[BufferIndex].DWord0 >> 16) & 0xFF) * Mul;
	float Y1 = ((InputYUV4228bitBuffer[BufferIndex].DWord0 >> 24) & 0xFF) * Mul;

	#if DO_SRGB_TO_LINEAR
	int DoSRGBToLinear = 1;
	#else
	int DoSRGBToLinear = 0;
	#endif

	float3 RGB00 = YuvToRgb(float3(Y0, U0, V0), ColorTransform, DoSRGBToLinear);
	float3 RGB01 = YuvToRgb(float3(Y1, U0, V0), ColorTransform, DoSRGBToLinear);

	OutTexture[uint2(BaseU + 0, BaseV)] = float4(RGB00, 1.0);
	OutTexture[uint2(BaseU + 1, BaseV)] = float4(RGB01, 1.0);
}

// Shader to convert from YUV 422 10 bits packed little endian to RGBA

[numthreads(8,8,1)]
void YUV10Bit422ToRGBACS(uint3 ThreadId : SV_DispatchThreadID, uint GroupIndex : SV_GroupIndex)
{
	// Make sure it's a valid thread
	if(ThreadId.x >= HorizontalElementCount || ThreadId.y >= VerticalElementCount)
	{
		return;
	}

	// Pixels we treat in shader is pretty much hardcoded to 8 so no parameter has been used
	const uint OutputTexturePixelsPerThread = 8;

	// Scale U (x index) based on the number of pixels we treat per thread
	const uint BaseU = ThreadId.x * OutputTexturePixelsPerThread;
	const uint BaseV = ThreadId.y;

	// Input buffer indexing is done in one dimension so adjust using thread Id and elements per row
	const uint BufferIndex = ThreadId.y * HorizontalElementCount + ThreadId.x;

	// Used to normalize pixel values based on 10 bits input
	const float Mul = 1.0 / 1023.0;

	float Y0 = ((((InputYCbCrBuffer[BufferIndex].DWord0 >>  8)  << 4) | ((InputYCbCrBuffer[BufferIndex].DWord0 >> 20) & 0x00F)) & 0x3FF) * Mul;
	float U0 = ((((InputYCbCrBuffer[BufferIndex].DWord0 >>  0)  << 2) | ((InputYCbCrBuffer[BufferIndex].DWord0 >> 14) & 0x003)) & 0x3FF) * Mul;
	float V0 = ((((InputYCbCrBuffer[BufferIndex].DWord0 >> 16)  << 6) | ((InputYCbCrBuffer[BufferIndex].DWord0 >> 26) & 0x03F)) & 0x3FF) * Mul;
	float Y1 = ((((InputYCbCrBuffer[BufferIndex].DWord0 >> 24)  << 8) | ((InputYCbCrBuffer[BufferIndex].DWord1 >> 00) & 0x0FF)) & 0x3FF) * Mul;
	float Y2 = ((((InputYCbCrBuffer[BufferIndex].DWord1 >> 16)  << 4) | ((InputYCbCrBuffer[BufferIndex].DWord1 >> 28) & 0x00F)) & 0x3FF) * Mul;
	float U2 = ((((InputYCbCrBuffer[BufferIndex].DWord1 >>  8)  << 2) | ((InputYCbCrBuffer[BufferIndex].DWord1 >> 22) & 0x003)) & 0x3FF) * Mul;
	float V2 = ((((InputYCbCrBuffer[BufferIndex].DWord1 >> 24)  << 6) | ((InputYCbCrBuffer[BufferIndex].DWord2 >> 02) & 0x03F)) & 0x3FF) * Mul;
	float Y3 = ((((InputYCbCrBuffer[BufferIndex].DWord2 >> 00)  << 8) | ((InputYCbCrBuffer[BufferIndex].DWord2 >>  8) & 0x0FF)) & 0x3FF) * Mul;
	float Y4 = ((((InputYCbCrBuffer[BufferIndex].DWord2 >> 24)  << 4) | ((InputYCbCrBuffer[BufferIndex].DWord3 >> 04) & 0x00F)) & 0x3FF) * Mul;
	float U4 = ((((InputYCbCrBuffer[BufferIndex].DWord2 >> 16)  << 2) | ((InputYCbCrBuffer[BufferIndex].DWord2 >> 30) & 0x003)) & 0x3FF) * Mul;
	float V4 = ((((InputYCbCrBuffer[BufferIndex].DWord3 >> 00)  << 6) | ((InputYCbCrBuffer[BufferIndex].DWord3 >> 10) & 0x03F)) & 0x3FF) * Mul;
	float Y5 = ((((InputYCbCrBuffer[BufferIndex].DWord3 >>  8)  << 8) | ((InputYCbCrBuffer[BufferIndex].DWord3 >> 16) & 0x0FF)) & 0x3FF) * Mul;
	float Y6 = ((((InputYCbCrBuffer[BufferIndex].DWord4 >>  0)  << 4) | ((InputYCbCrBuffer[BufferIndex].DWord3 >> 12) & 0x00F)) & 0x3FF) * Mul;
	float U6 = ((((InputYCbCrBuffer[BufferIndex].DWord3 >> 24)  << 2) | ((InputYCbCrBuffer[BufferIndex].DWord4 >> 06) & 0x003)) & 0x3FF) * Mul;
	float V6 = ((((InputYCbCrBuffer[BufferIndex].DWord4 >>  8)  << 6) | ((InputYCbCrBuffer[BufferIndex].DWord4 >> 18) & 0x03F)) & 0x3FF) * Mul;
	float Y7 = ((((InputYCbCrBuffer[BufferIndex].DWord4 >> 16)  << 8) | ((InputYCbCrBuffer[BufferIndex].DWord4 >> 24) & 0x0FF)) & 0x3FF) * Mul;

	#if DO_SRGB_TO_LINEAR
	int DoSRGBToLinear = 1;
	#else
	int DoSRGBToLinear = 0;
	#endif

	float3 RGB00 = YuvToRgb(float3(Y0, U0, V0), ColorTransform, DoSRGBToLinear);
	float3 RGB01 = YuvToRgb(float3(Y1, U0, V0), ColorTransform, DoSRGBToLinear);
	float3 RGB02 = YuvToRgb(float3(Y2, U2, V2), ColorTransform, DoSRGBToLinear);
	float3 RGB03 = YuvToRgb(float3(Y3, U2, V2), ColorTransform, DoSRGBToLinear);
	float3 RGB04 = YuvToRgb(float3(Y4, U4, V4), ColorTransform, DoSRGBToLinear);
	float3 RGB05 = YuvToRgb(float3(Y5, U4, V4), ColorTransform, DoSRGBToLinear);
	float3 RGB06 = YuvToRgb(float3(Y6, U6, V6), ColorTransform, DoSRGBToLinear);
	float3 RGB07 = YuvToRgb(float3(Y7, U6, V6), ColorTransform, DoSRGBToLinear);

	OutTexture[uint2(BaseU + 0, BaseV)] = float4(RGB00, 1.0);
	OutTexture[uint2(BaseU + 1, BaseV)] = float4(RGB01, 1.0);
	OutTexture[uint2(BaseU + 2, BaseV)] = float4(RGB02, 1.0);
	OutTexture[uint2(BaseU + 3, BaseV)] = float4(RGB03, 1.0);
	OutTexture[uint2(BaseU + 4, BaseV)] = float4(RGB04, 1.0);
	OutTexture[uint2(BaseU + 5, BaseV)] = float4(RGB05, 1.0);
	OutTexture[uint2(BaseU + 6, BaseV)] = float4(RGB06, 1.0);
	OutTexture[uint2(BaseU + 7, BaseV)] = float4(RGB07, 1.0);
}
