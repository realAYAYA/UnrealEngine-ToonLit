// Copyright Epic Games, Inc. All Rights Reserved.

#include "Trace/ChaosVDTraceProvider.h"

#include "ChaosVDModule.h"
#include "ChaosVDRecording.h"

#include "ChaosVisualDebugger/ChaosVDSerializedNameTable.h"
#include "ChaosVisualDebugger/ChaosVisualDebuggerTrace.h"

#include "Compression/OodleDataCompressionUtil.h"
#include "Trace/DataProcessors/ChaosVDConstraintDataProcessor.h"
#include "Trace/DataProcessors/ChaosVDJointConstraintDataProcessor.h"
#include "Trace/DataProcessors/ChaosVDMidPhaseDataProcessor.h"
#include "Trace/DataProcessors/ChaosVDSceneQueryDataProcessor.h"
#include "Trace/DataProcessors/ChaosVDSceneQueryVisitDataProcessor.h"
#include "Trace/DataProcessors/ChaosVDSerializedNameEntryDataProcessor.h"
#include "Trace/DataProcessors/ChaosVDTraceImplicitObjectProcessor.h"
#include "Trace/DataProcessors/ChaosVDTraceParticleDataProcessor.h"
#include "Trace/DataProcessors/ChaosVDArchiveHeaderProcessor.h"
#include "Trace/DataProcessors/IChaosVDDataProcessor.h"

FName FChaosVDTraceProvider::ProviderName("ChaosVDProvider");

FChaosVDTraceProvider::FChaosVDTraceProvider(TraceServices::IAnalysisSession& InSession): Session(InSession)
{
	DefaultHeaderData = Chaos::VisualDebugger::FChaosVDArchiveHeader::Current();
}

void FChaosVDTraceProvider::CreateRecordingInstanceForSession(const FString& InSessionName)
{
	DeleteRecordingInstanceForSession();

	InternalRecording = MakeShared<FChaosVDRecording>();
	InternalRecording->SessionName = InSessionName;
}

void FChaosVDTraceProvider::DeleteRecordingInstanceForSession()
{
	InternalRecording.Reset();
}

void FChaosVDTraceProvider::StartSolverFrame(const int32 InSolverID, FChaosVDSolverFrameData&& FrameData)
{
	if (!InternalRecording.IsValid())
	{
		return;
	}

	if (FChaosVDSolverFrameData* SolveFrameData = CurrentSolverFramesByID.Find(InSolverID))
	{
		InternalRecording->AddFrameForSolver(InSolverID, MoveTemp(*SolveFrameData));
		CurrentSolverFramesByID[InSolverID] = FrameData;
	}
	else
	{
		CurrentSolverFramesByID.Add(InSolverID, FrameData);
	}
}

void FChaosVDTraceProvider::CommitProcessedGameFramesToRecording()
{
	// This is a kind of made up number, this includes RBAN solvers so we have more than 1 for sure.
	constexpr int32 MinSolverIDsExpected = 10;
	
	static TArray<int32> SolverIDs;
	SolverIDs.Reserve(MinSolverIDsExpected);

	// The Game Frame events are not generated by CVD trace code and we don't have control over them
	// we use them as general timestamps.
	// These are generated even when no solvers are available (specially in PIE), so we need to discard any game frame that will not resolve to a solver frame
	// Solver data might be slightly behind, so to make sure we have all the solver data for that time range, we queue a handful of game frames before processing them.
	constexpr int32 MaxQueueSize = 2;
	if (CurrentGameFrameQueueSize > MaxQueueSize)
	{
		TSharedPtr<FChaosVDGameFrameData> ProcessedGameFrameData;
		DeQueueGameFrameForProcessing(ProcessedGameFrameData);

		if (ProcessedGameFrameData.IsValid())
		{
			InternalRecording->GetAvailableSolverIDsAtGameFrame(*ProcessedGameFrameData, SolverIDs);

			if (!SolverIDs.IsEmpty())
			{
				InternalRecording->AddGameFrameData(*ProcessedGameFrameData);	
			}
		}	
	}

	SolverIDs.Reset();
}

void FChaosVDTraceProvider::StartGameFrame(const TSharedPtr<FChaosVDGameFrameData>& InFrameData)
{
	if (!InternalRecording.IsValid())
	{
		return;
	}

	CommitProcessedGameFramesToRecording();

	EnqueueGameFrameForProcessing(InFrameData);
}

FChaosVDSolverFrameData* FChaosVDTraceProvider::GetCurrentSolverFrame(const int32 InSolverID)
{
	if (FChaosVDSolverFrameData* SolveFrameData = CurrentSolverFramesByID.Find(InSolverID))
	{
		return SolveFrameData;
	}

	return nullptr;
}

TWeakPtr<FChaosVDGameFrameData> FChaosVDTraceProvider::GetCurrentGameFrame()
{
	return CurrentGameFrame;
}

FChaosVDBinaryDataContainer& FChaosVDTraceProvider::FindOrAddUnprocessedData(const int32 DataID)
{
	if (const TSharedPtr<FChaosVDBinaryDataContainer>* UnprocessedData = UnprocessedDataByID.Find(DataID))
	{
		check(UnprocessedData->IsValid());
		return *UnprocessedData->Get();
	}
	else
	{
		const TSharedPtr<FChaosVDBinaryDataContainer> DataContainer = MakeShared<FChaosVDBinaryDataContainer>(DataID);
		UnprocessedDataByID.Add(DataID, DataContainer);
		return *DataContainer.Get();
	}
}

bool FChaosVDTraceProvider::ProcessBinaryData(const int32 DataID)
{
	RegisterDefaultDataProcessorsIfNeeded();

	if (const TSharedPtr<FChaosVDBinaryDataContainer>* UnprocessedDataPtr = UnprocessedDataByID.Find(DataID))
	{
		const TSharedPtr<FChaosVDBinaryDataContainer> UnprocessedData = *UnprocessedDataPtr;
		if (UnprocessedData.IsValid())
		{
			UnprocessedData->bIsReady = true;

			const TArray<uint8>* RawData = nullptr;
			TArray<uint8> UncompressedData;
			if (UnprocessedData->bIsCompressed)
			{
				UncompressedData.Reserve(UnprocessedData->UncompressedSize);
				FOodleCompressedArray::DecompressToTArray(UncompressedData, UnprocessedData->RawData);
				RawData = &UncompressedData;
			}
			else
			{
				RawData = &UnprocessedData->RawData;
			}

			if (TSharedPtr<IChaosVDDataProcessor>* DataProcessorPtrPtr = RegisteredDataProcessors.Find(UnprocessedData->TypeName))
			{
				if (TSharedPtr<IChaosVDDataProcessor> DataProcessorPtr = *DataProcessorPtrPtr)
				{
					if (ensure(DataProcessorPtr->ProcessRawData(*RawData)))
					{
						return true;
					}
					else
					{
						UE_LOG(LogChaosVDEditor, Warning, TEXT("[%s] Failed to serialize Binary Data with ID [%d] | Type [%s]"), ANSI_TO_TCHAR(__FUNCTION__), DataID, *UnprocessedData->TypeName);
					}
				}
			}
			else
			{
				UE_LOG(LogChaosVDEditor, Warning, TEXT("[%s] Data processor for type [%s] not found"), ANSI_TO_TCHAR(__FUNCTION__), *UnprocessedData->TypeName);
			}
		}
	}

	return false;
}

TSharedPtr<FChaosVDRecording> FChaosVDTraceProvider::GetRecordingForSession() const
{
	return InternalRecording;
}

void FChaosVDTraceProvider::RegisterDataProcessor(TSharedPtr<IChaosVDDataProcessor> InDataProcessor)
{
	RegisteredDataProcessors.Add(InDataProcessor->GetCompatibleTypeName(), InDataProcessor);
}

void FChaosVDTraceProvider::RegisterDefaultDataProcessorsIfNeeded()
{
	if (bDefaultDataProcessorsRegistered)
	{
		return;
	}
	
	TSharedPtr<FChaosVDTraceImplicitObjectProcessor> ImplicitObjectProcessor = MakeShared<FChaosVDTraceImplicitObjectProcessor>();
	ImplicitObjectProcessor->SetTraceProvider(AsShared());
	RegisterDataProcessor(ImplicitObjectProcessor);

	TSharedPtr<FChaosVDTraceParticleDataProcessor> ParticleDataProcessor = MakeShared<FChaosVDTraceParticleDataProcessor>();
	ParticleDataProcessor->SetTraceProvider(AsShared());
	RegisterDataProcessor(ParticleDataProcessor);

	TSharedPtr<FChaosVDMidPhaseDataProcessor> MidPhaseDataProcessor = MakeShared<FChaosVDMidPhaseDataProcessor>();
	MidPhaseDataProcessor->SetTraceProvider(AsShared());
	RegisterDataProcessor(MidPhaseDataProcessor);

	TSharedPtr<FChaosVDConstraintDataProcessor> ConstraintDataProcessor = MakeShared<FChaosVDConstraintDataProcessor>();
	ConstraintDataProcessor->SetTraceProvider(AsShared());
	RegisterDataProcessor(ConstraintDataProcessor);

	TSharedPtr<FChaosVDSceneQueryDataProcessor> SceneQueryDataProcessor = MakeShared<FChaosVDSceneQueryDataProcessor>();
	SceneQueryDataProcessor->SetTraceProvider(AsShared());
	RegisterDataProcessor(SceneQueryDataProcessor);

	TSharedPtr<FChaosVDSceneQueryVisitDataProcessor> SceneQueryVisitDataProcessor = MakeShared<FChaosVDSceneQueryVisitDataProcessor>();
	SceneQueryVisitDataProcessor->SetTraceProvider(AsShared());
	RegisterDataProcessor(SceneQueryVisitDataProcessor);

	TSharedPtr<FChaosVDSerializedNameEntryDataProcessor> NameEntryDataProcessor = MakeShared<FChaosVDSerializedNameEntryDataProcessor>();
	NameEntryDataProcessor->SetTraceProvider(AsShared());
	RegisterDataProcessor(NameEntryDataProcessor);
	
	TSharedPtr<FChaosVDJointConstraintDataProcessor> JointConstraintDataProcessor = MakeShared<FChaosVDJointConstraintDataProcessor>();
	JointConstraintDataProcessor->SetTraceProvider(AsShared());
	RegisterDataProcessor(JointConstraintDataProcessor);

	TSharedPtr<FChaosVDArchiveHeaderProcessor> ArchiveHeaderDataProcessor = MakeShared<FChaosVDArchiveHeaderProcessor>();
	ArchiveHeaderDataProcessor->SetTraceProvider(AsShared());
	RegisterDataProcessor(ArchiveHeaderDataProcessor);

	bDefaultDataProcessorsRegistered = true;
}

void FChaosVDTraceProvider::EnqueueGameFrameForProcessing(const TSharedPtr<FChaosVDGameFrameData>& FrameData)
{
	CurrentGameFrame = FrameData;
	CurrentGameFrameQueue.Enqueue(FrameData);
	CurrentGameFrameQueueSize++;
}

void FChaosVDTraceProvider::DeQueueGameFrameForProcessing(TSharedPtr<FChaosVDGameFrameData>& OutFrameData)
{
	CurrentGameFrameQueue.Dequeue(OutFrameData);
	CurrentGameFrameQueueSize--;
}
