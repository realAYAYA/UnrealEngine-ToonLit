// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Graph/MovieGraphNode.h"
#include "MovieRenderPipelineDataTypes.h"
#include "MovieGraphExecuteScriptNode.generated.h"

/**
* This is the base class used for writing scripts that can be executed as part
* of a Movie Graph Pipeline. After creating a UMovieGraphExecuteScriptNode 
* (named 'Execute Script' in the UI) in your Movie Graph Configuration asset,
* and choosing the type of your script, an instance will be created when
* the job starts. This instance will persist until the end of the job. The instance
* will recieve callbacks during the render which contain data that you can 
* manipulate with your script, or data that was generated by the pipeline.
*
* This can be implemented in either C++ or Python. For C++ you can use standard
* inheritance but for Python you need to write a UClass implemented in Python.
* This has slightly different syntax than standard Python;
* 
* In this example, create a "Python" folder in your Content folder. Then create
* a file named "MovieGraphPipelineScriptExample.py", and a file named "init_unreal.py"
* 
* In "init_unreal.py" add "import MovieGraphPipelineScriptExample" as the contents.
* In "MovieGraphPipelineScriptExample.py" use the following:
*
*import unreal
*
*@unreal.uclass()
*class MovieGraphPipelineScriptExample(unreal.MovieGraphScriptBase):

*    @unreal.ufunction(override=True)
*    def on_job_start(self, inJobCopy):
*        super().on_job_start(inJobCopy)
*        unreal.log_warning("OnJobStart")
*        for shot in inOutputData.graph_data:
*            for layerIdentifier in shot.render_layer_data:
*                unreal.log("render layer: " + layerIdentifier.layer_name)
*                for file in shot.render_layer_data[layerIdentifier].file_paths:
*                    unreal.log("file: " + file)
* 
* Save and restart Unreal Editor, then create a Movie Graph Configuration
* with an Execute Script Node, and set it to run MovieGraphPipelineScriptExample. 
* When the job is run, the output console should print "OnJobStart" as a warning.
* 
* Use "help(unreal.MovieGraphScriptBase)" in the Python Console to see all available 
* overridable functions.
* 
* See /Engine/Plugins/MovieScene/MovieRenderPipeline/Content/Python for more 
* python examples.
*/
UCLASS(BlueprintType, Abstract)
class MOVIERENDERPIPELINECORE_API UMovieGraphScriptBase : public UObject
{
	GENERATED_BODY()

public:
	/**
	* This callback is called very early on in the Movie Graph Pipeline, before
	* data is read from the job. The provided job is a duplicate of the job defined
	* in the UMoviePipelineQueue, allowing you to make changes to the job without
	* worrying about restoring them at the end of a render. Additionally, the 
	* Graph Configuration assets (for both the Primary configuration, and shot
	* overrides) have been duplicated to allow mutation of the graph configuration
	* without worrying about leaking these changes to the assets on disk. Other
	* pointers to external packages (such as the Level Sequence on the job) have
	* not been duplicated though, so be aware that changes to these assets will
	* leak, unless you restore the changes in OnJobFinished. OnJobFinished will
	* be called even if the job is canceled.
	* 
	* For C++ implementations override `virtual void OnJobStart_Implementation(UMoviePipelineExecutorJob* InJobCopy) override`
	* For Python implementations override
	*	@unreal.ufunction(override=True)
	*	def on_job_start(self, inJobCopy):
	*		super().on_job_start(inJobCopy)
	* 
	* 
	* @param InJobCopy - A copy of the job being rendered with this graph config,
	*					 with its Graph Preset configurations also copied to avoid
	*					 accidental mutation of assests on disk.
	*/
	UFUNCTION(BlueprintNativeEvent, Category = "Movie Graph")
	void OnJobStart(UMoviePipelineExecutorJob* InJobCopy);
	virtual void OnJobStart_Implementation(UMoviePipelineExecutorJob* InJobCopy) {}

	/**
	* This callback is called at the very end of the Movie Graph Pipeline, right before
	* shutting down. The files specified by the OutputData should have been written
	* to disk by this point. This function will get called both in the case of a successful
	* job, or one canceled by the user. You can use OutputData.bSuccess to determine if
	* the render was successfuly completed.
	* 
	* For C++ implementations override `virtual void OnJobFinished_Implementation(UMoviePipelineExecutorJob* InJobCopy, const FMovieGraphPipelineOutputData& OutputData) override`
	* For Python implementations override
	*	@unreal.ufunction(override=True)
	*	def on_job_finished(self, inJobCopy, inOutputData):
	*		super().on_job_finished(inJobCopy, inOutputData)
	* 
	* 
	* @param InJobCopy - A copy of the job being rendered with this graph config,
	*					 with its Graph Preset configurations also copied to avoid
	*					 accidental mutation of assests on disk.
	* @param InOutputData - Information about the files generated during this render.
	* 						Contains a flag (bSuccess) for checking if the job was 
	*						successful or not, and contains a list of render layers,
	* 						and the files written to disk for that render layer. Contains
	*						data for all shots rendered up to this point.
	*/
	UFUNCTION(BlueprintNativeEvent, Category = "Movie Graph")
	void OnJobFinished(UMoviePipelineExecutorJob* InJobCopy, const FMoviePipelineOutputData& InOutputData);
	virtual void OnJobFinished_Implementation(UMoviePipelineExecutorJob* InJobCopy, const FMoviePipelineOutputData& InOutputData ) {}

	/**
	* This is similar to OnJobStart but called before a shot is set up. This is only called
	* if IsPerShotCallbackNeeded() returns true.
	* 
	* For C++ implementations override `virtual void OnShotStart_Implementation(UMoviePipelineExecutorJob* InJobCopy,  UMoviePipelineExecutorShot* InShotCopy) override`
	* For Python implementations override
	*	@unreal.ufunction(override=True)
	*	def on_shot_start(self, inJobCopy, inShotCopy):
	*		super().on_shot_start(inJobCopy, inShotCopy)
	* 
	* 
	* @param InJobCopy - A copy of the job being rendered with this graph config,
	*					 with its Graph Preset configurations also copied to avoid
	*					 accidental mutation of assests on disk.
	* @param InShotCopy - A copy of the shot that is about to be started.
	*/
	UFUNCTION(BlueprintNativeEvent, Category = "Movie Graph")
	void OnShotStart(UMoviePipelineExecutorJob* InJobCopy, UMoviePipelineExecutorShot* InShotCopy);
	virtual void OnShotStart_Implementation(UMoviePipelineExecutorJob* InJobCopy, UMoviePipelineExecutorShot* InShotCopy) {}

	/**
	* This is similar to OnJobFinished but called after a shot is completed. This is only called
	* if IsPerShotCallbackNeeded() returns true.
	* 
	* For C++ implementations override `virtual void OnShotFinished_Implementation(UMoviePipelineExecutorJob* InJobCopy,  UMoviePipelineExecutorShot* InShotCopy, const FMovieGraphPipelineOutputData& InOutputData) override`
	* For Python implementations override
	*	@unreal.ufunction(override=True)
	*	def on_shot_finished(self, inJobCopy, inShotCopy, inOutputData):
	*		super().on_shot_finished(inJobCopy, inShotCopy, inOutputData)
	* 
	* 
	* @param InJobCopy - A copy of the job being rendered with this graph config,
	*					 with its Graph Preset configurations also copied to avoid
	*					 accidental mutation of assests on disk.
	* @param InShotCopy - A copy of the shot that was just finished.
	* @param InOutputData - The data generated by this shot. Only contains the files
	* 						rendered for this particular shot, not all files generated
	* 						by the movie render (use OnJobFinished for that).
	*/
	UFUNCTION(BlueprintNativeEvent, Category = "Movie Graph")
	void OnShotFinished(UMoviePipelineExecutorJob* InJobCopy, UMoviePipelineExecutorShot* InShotCopy, const FMoviePipelineOutputData& OutputData);
	virtual void OnShotFinished_Implementation(UMoviePipelineExecutorJob* InJobCopy, UMoviePipelineExecutorShot* InShotCopy, const FMoviePipelineOutputData& OutputData) {}


	/**
	* If you return true here the system will stall at the end of every shot and wait until
	* all files have been written to disk before invoking this callback. This can increase 
	* render times but is important if you need to operate on the files on disk as part of 
	* the callback.
	*
	* For C++ implementations override `virtual bool IsPerShotCallbackNeeded_Implementation() const override`
	* For Python implementations override
	*	@unreal.ufunction(override=True)
	*	def is_per_shot_callback_needed():
	*		return False;
	*/
	UFUNCTION(BlueprintNativeEvent, Category = "Movie Graph")
	bool IsPerShotCallbackNeeded() const;
	virtual bool IsPerShotCallbackNeeded_Implementation() const
	{
		return false;
	}
};

/** 
 This node allows users to run code before and after a movie graph is being executed. Example use cases
 would be to run custom logic that overrides the output directory, or to trigger an event after a shot finishes.
 These bits of script can be implemented in either C++, or in Python (as a UClass) because we don't serialize the
 object and only create it at runtime during the render. See UMovieGraphScriptBase for details.
*/
UCLASS()
class MOVIERENDERPIPELINECORE_API UMovieGraphExecuteScriptNode : public UMovieGraphSettingNode
{
	GENERATED_BODY()

public:
	UMovieGraphExecuteScriptNode() = default;

	virtual EMovieGraphBranchRestriction GetBranchRestriction() const override { return EMovieGraphBranchRestriction::Globals; }

#if WITH_EDITOR
	virtual FText GetNodeTitle(const bool bGetDescriptive = false) const override;
	virtual FText GetMenuCategory() const override;
	virtual FLinearColor GetNodeTitleColor() const override;
	virtual FSlateIcon GetIconAndTint(FLinearColor& OutColor) const override;
#endif

	/** 
	* Allocate an instance of the specifed script type.
	* Can return nullptr.
	*/
	UMovieGraphScriptBase* AllocateScriptInstance() const;

public:
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Overrides, meta = (InlineEditConditionToggle))
	uint8 bOverride_Script: 1;
	

	/**
	* Which script should this node instantiate? The class will be instantiated when the job starts,
	* and then different functions will be called on that instance throughout the life-time of the 
	* movie render. Scripts can be implemented in Python or C++, see MovieGraphExecuteScriptNode.h
	* for more details.
	*/
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Settings", meta = (EditCondition = "bOverride_Script", MetaClass = "/Script/MovieRenderPipelineCore.MovieGraphScriptBase"))
	FSoftClassPath Script;
};