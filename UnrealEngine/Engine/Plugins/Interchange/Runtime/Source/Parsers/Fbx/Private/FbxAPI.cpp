// Copyright Epic Games, Inc. All Rights Reserved.

#include "FbxAPI.h"

#include "CoreMinimal.h"
#include "FbxCamera.h"
#include "FbxConvert.h"
#include "FbxHelper.h"
#include "FbxInclude.h"
#include "FbxLight.h"
#include "FbxMaterial.h"
#include "FbxMesh.h"
#include "FbxScene.h"
#include "InterchangeTextureNode.h"
#if WITH_ENGINE
#include "Mesh/InterchangeMeshPayload.h"
#endif
#include "Nodes/InterchangeBaseNodeContainer.h"
#include "Misc/SecureHash.h"

#define LOCTEXT_NAMESPACE "InterchangeFbxParser"

#define DESTROY_FBX_OBJECT(Object) \
if(Object) \
{ \
	Object->Destroy(); \
	Object = nullptr; \
}

namespace UE
{
	namespace Interchange
	{
		namespace Private
		{
			FFbxParser::~FFbxParser()
			{
				FbxHelper = nullptr;
				Reset();
			}
			
			void FFbxParser::Reset()
			{
				PayloadContexts.Reset();

				DESTROY_FBX_OBJECT(SDKImporter);
				DESTROY_FBX_OBJECT(SDKScene);
				if (SDKGeometryConverter)
				{
					delete SDKGeometryConverter;
					SDKGeometryConverter = nullptr;
				}
				DESTROY_FBX_OBJECT(SDKIoSettings);
				DESTROY_FBX_OBJECT(SDKManager);
				if (FbxHelper.IsValid())
				{
					FbxHelper->Reset();
				}
			}

			const TSharedPtr<FFbxHelper> FFbxParser::GetFbxHelper()
			{
				if (!FbxHelper.IsValid())
				{
					FbxHelper = MakeShared<FFbxHelper>();
				}
				check(FbxHelper.IsValid());
				return FbxHelper;
			}

			bool FFbxParser::LoadFbxFile(const FString& Filename)
			{
				SourceFilename = Filename;
				int32 SDKMajor, SDKMinor, SDKRevision;
				
				//The first thing to do is to create the FBX Manager which is the object allocator for almost all the classes in the SDK
				SDKManager = FbxManager::Create();
				if (!SDKManager)
				{
					UInterchangeResultError_Generic* Message = AddMessage<UInterchangeResultError_Generic>();
					Message->Text = LOCTEXT("CannotCreateFBXManager", "Cannot create FBX SDK manager.");
					return false;
				}

				//Create an IOSettings object. This object holds all import/export settings.
				SDKIoSettings = FbxIOSettings::Create(SDKManager, IOSROOT);
				SDKIoSettings->SetBoolProp(IMP_FBX_MATERIAL, true);
				SDKIoSettings->SetBoolProp(IMP_FBX_TEXTURE, true);
				SDKIoSettings->SetBoolProp(IMP_FBX_LINK, true);
				SDKIoSettings->SetBoolProp(IMP_FBX_SHAPE, true);
				SDKIoSettings->SetBoolProp(IMP_FBX_GOBO, true);
				SDKIoSettings->SetBoolProp(IMP_FBX_ANIMATION, true);
				SDKIoSettings->SetBoolProp(IMP_SKINS, true);
				SDKIoSettings->SetBoolProp(IMP_DEFORMATION, true);
				SDKIoSettings->SetBoolProp(IMP_FBX_GLOBAL_SETTINGS, true);
				SDKIoSettings->SetBoolProp(IMP_TAKE, true);
				SDKManager->SetIOSettings(SDKIoSettings);

				SDKGeometryConverter = new FbxGeometryConverter(SDKManager);

				//Create an FBX scene. This object holds most objects imported/exported from/to files.
				SDKScene = FbxScene::Create(SDKManager, "My Scene");
				if (!SDKScene)
				{
					UInterchangeResultError_Generic* Message = AddMessage<UInterchangeResultError_Generic>();
					Message->Text = LOCTEXT("CannotCreateFBXScene", "Cannot create FBX SDK scene.");
					return false;
				}
				
				// Create an importer.
				SDKImporter = FbxImporter::Create(SDKManager, "");

				// Get the version number of the FBX files generated by the
				// version of FBX SDK that you are using.
				FbxManager::GetFileFormatVersion(SDKMajor, SDKMinor, SDKRevision);

				// Initialize the importer by providing a filename.
				const bool bImportStatus = SDKImporter->Initialize(TCHAR_TO_UTF8(*Filename));
				if (!bImportStatus)
				{
					FFormatNamedArguments FilenameText
					{
						{ TEXT("Filename"), FText::FromString(Filename) }
					};
					UInterchangeResultError_Generic* Message = AddMessage<UInterchangeResultError_Generic>();
					Message->Text = FText::Format(LOCTEXT("CannotOpenFBXFile", "Cannot open FBX file '{Filename}'."), FilenameText);
					return false;
				}

				bool bStatus = SDKImporter->Import(SDKScene);

				//We always convert scene to UE axis and units
				FFbxConvert::ConvertScene(SDKScene, bConvertScene, bForceFrontXAxis, bConvertSceneUnit);

				FrameRate = FbxTime::GetFrameRate(SDKScene->GetGlobalSettings().GetTimeMode());

				return true;
			}

			void FFbxParser::FillContainerWithFbxScene(UInterchangeBaseNodeContainer& NodeContainer)
			{
				CleanupFbxData();

				FFbxMaterial FbxMaterial(*this);
				FbxMaterial.AddAllTextures(SDKScene, NodeContainer);
				FbxMaterial.AddAllMaterials(SDKScene, NodeContainer);

				FFbxMesh FbxMesh(*this);
				FbxMesh.AddAllMeshes(SDKScene, SDKGeometryConverter, NodeContainer, PayloadContexts);

				FFbxLight FbxLight(*this);
				FbxLight.AddAllLights(SDKScene, NodeContainer);

				FFbxCamera FbxCamera(*this);
				FbxCamera.AddAllCameras(SDKScene, NodeContainer);

				FFbxScene FbxScene(*this);
				FbxScene.AddHierarchy(SDKScene, NodeContainer, PayloadContexts);
				FbxScene.AddAnimation(SDKScene, NodeContainer, PayloadContexts);
				FbxScene.AddMorphTargetAnimations(SDKScene, NodeContainer, PayloadContexts, FbxMesh.GetMorphTargetAnimationsBuildingData());
			}

			bool FFbxParser::FetchPayloadData(const FString& PayloadKey, const FString& PayloadFilepath)
			{
				if (!PayloadContexts.Contains(PayloadKey))
				{
					UInterchangeResultError_Generic* Message = AddMessage<UInterchangeResultError_Generic>();
					Message->Text = LOCTEXT("CannotRetrievePayload", "Cannot retrieve payload; payload key doesn't have any context.");
					return false;
				}

				{
					//Critical section to force payload to be fetch one by one with no concurrency.
					FScopeLock Lock(&PayloadCriticalSection);
					TSharedPtr<FPayloadContextBase>& PayloadContext = PayloadContexts.FindChecked(PayloadKey);
					return PayloadContext->FetchPayloadToFile(*this, PayloadFilepath);
				}
			}

			bool FFbxParser::FetchMeshPayloadData(const FString& PayloadKey, const FTransform& MeshGlobalTransform, const FString& PayloadFilepath)
			{
				if (!PayloadContexts.Contains(PayloadKey))
				{
					UInterchangeResultError_Generic* Message = AddMessage<UInterchangeResultError_Generic>();
					Message->Text = LOCTEXT("CannotRetrievePayload", "Cannot retrieve payload; payload key doesn't have any context.");
					return false;
				}

				{
					//Critical section to force payload to be fetch one by one with no concurrency.
					FScopeLock Lock(&PayloadCriticalSection);
					TSharedPtr<FPayloadContextBase>& PayloadContext = PayloadContexts.FindChecked(PayloadKey);
					return PayloadContext->FetchMeshPayloadToFile(*this, MeshGlobalTransform, PayloadFilepath);
				}
			}

#if WITH_ENGINE
			bool FFbxParser::FetchMeshPayloadData(const FString& PayloadKey, const FTransform& MeshGlobalTransform, FMeshPayloadData& OutMeshPayloadData)
			{
				if (!PayloadContexts.Contains(PayloadKey))
				{
					UInterchangeResultError_Generic* Message = AddMessage<UInterchangeResultError_Generic>();
					Message->Text = LOCTEXT("CannotRetrievePayload", "Cannot retrieve payload; payload key doesn't have any context.");
					return false;
				}

				{
					//Critical section to force payload to be fetch one by one with no concurrency.
					FScopeLock Lock(&PayloadCriticalSection);
					TSharedPtr<FPayloadContextBase>& PayloadContext = PayloadContexts.FindChecked(PayloadKey);
					return PayloadContext->FetchMeshPayload(*this, MeshGlobalTransform, OutMeshPayloadData);
				}
			}
#endif

			bool FFbxParser::FetchAnimationBakeTransformPayload(const FString& PayloadKey, const double BakeFrequency, const double RangeStartTime, const double RangeEndTime, const FString& PayloadFilepath)
			{
				if (!PayloadContexts.Contains(PayloadKey))
				{
					UInterchangeResultError_Generic* Message = AddMessage<UInterchangeResultError_Generic>();
					Message->Text = LOCTEXT("CannotRetrievePayload", "Cannot retrieve payload; payload key doesn't have any context.");
					return false;
				}

				{
					//Critical section to force payload to be fetch one by one with no concurrency.
					FScopeLock Lock(&PayloadCriticalSection);
					TSharedPtr<FPayloadContextBase>& PayloadContext = PayloadContexts.FindChecked(PayloadKey);
					return PayloadContext->FetchAnimationBakeTransformPayloadToFile(*this, BakeFrequency, RangeStartTime, RangeEndTime, PayloadFilepath);
				}
			}

			void FFbxParser::CleanupFbxData()
			{
				//////////////////////////////////////////////////////////////////////////
				// Make sure there is a valid bind pose

				//Find root bones
				const int32 Default_NbPoses = SDKScene->GetFbxManager()->GetBindPoseCount(SDKScene);
				// If there are no BindPoses, the following will generate them.
				SDKScene->GetFbxManager()->CreateMissingBindPoses(SDKScene);
				//if we created missing bind poses, update the number of bind poses
				const int32 NbPoses = SDKScene->GetFbxManager()->GetBindPoseCount(SDKScene);
				if (NbPoses != Default_NbPoses && !GIsAutomationTesting)
				{
					UInterchangeResultWarning_Generic* Message = AddMessage<UInterchangeResultWarning_Generic>();
					Message->Text = LOCTEXT("MissingBindPose", "Missing bind pose - the FBX SDK has created one.");
				}

				auto MakeFbxObjectNameUnique = [](FbxObject* Object, TMap<FString, int32>& Names)
					{
						FString ObjectName = UTF8_TO_TCHAR(Object->GetName());
						if (int32* Count = Names.Find(ObjectName))
						{
							(*Count)++;
							ObjectName += TEXT("_ncl_") + FString::FromInt(*Count);
							Object->SetName(TCHAR_TO_UTF8(*ObjectName));
						}
						else
						{
							Names.Add(ObjectName, 0);
						}
					};

				//////////////////////////////////////////////////////////////////////////
				// Ensure Node Name Validity (uniqueness)
				// Name clash must be global because unreal bones do not support name conflict (they are stored in an array, no hierarchy)
				TMap<FString, int32> NodeNames;
				for (int32 NodeIndex = 0; NodeIndex < SDKScene->GetNodeCount(); ++NodeIndex)
				{
					FbxNode* Node = SDKScene->GetNode(NodeIndex);
					MakeFbxObjectNameUnique(Node, NodeNames);
				}

				//////////////////////////////////////////////////////////////////////////
				// Ensure Mesh Name Validity (uniqueness)
				// Name clash must be global because we will build Unique ID from the mesh name
				TMap<FString, int32> MeshNames;
				for (int32 GeometryIndex = 0; GeometryIndex < SDKScene->GetGeometryCount(); ++GeometryIndex)
				{
					FbxGeometry* Geometry = SDKScene->GetGeometry(GeometryIndex);
					if (Geometry->GetAttributeType() != FbxNodeAttribute::eMesh)
					{
						continue;
					}
					FbxMesh* Mesh = static_cast<FbxMesh*>(Geometry);
					if (!Mesh)
					{
						continue;
					}
					MakeFbxObjectNameUnique(Mesh, MeshNames);
				}
			}
		} //ns Private
	} //ns Interchange
} //ns UE

#undef LOCTEXT_NAMESPACE
