// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Animation/AnimSequence.h"
#include "Templates/SubclassOf.h"
#include "GameFramework/Actor.h"
#include "GameplayTagContainer.h"
#include "ContextualAnimTypes.generated.h"

CONTEXTUALANIMATION_API DECLARE_LOG_CATEGORY_EXTERN(LogContextualAnim, Log, All);

class AActor;
class UAnimInstance;
class UAnimSequenceBase;
class UContextualAnimSelectionCriterion;
class UContextualAnimSceneAsset;
class UContextualAnimSceneInstance;
class UContextualAnimSceneActorComponent;
struct FAnimMontageInstance;

namespace UE 
{
	namespace ContextualAnim 
	{
		enum class EForEachResult : uint8
		{
			Break,
			Continue,
		};
	}
}

/** Container for alignment tracks */
USTRUCT()
struct CONTEXTUALANIMATION_API FContextualAnimAlignmentTrackContainer
{
	GENERATED_BODY()

	UPROPERTY()
	FAnimSequenceTrackContainer Tracks;

	UPROPERTY()
	float SampleInterval = 0.f;

	void Initialize(int32 InNumTracks, float InSampleInterval)
	{
		Tracks.AnimationTracks.Empty(InNumTracks);
		Tracks.TrackNames.Empty(InNumTracks);
		SampleInterval = InSampleInterval;
	}

	void Empty()
	{
		Tracks.AnimationTracks.Empty();
		Tracks.TrackNames.Empty();
		SampleInterval = 0.f;
	}

	FTransform ExtractTransformAtTime(int32 TrackIndex, float Time) const;
	FTransform ExtractTransformAtTime(const FName& TrackName, float Time) const;
};

USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimTrack
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	TObjectPtr<UAnimSequenceBase> Animation = nullptr;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	float AnimMaxStartTime = 0.f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	bool bRequireFlyingMode = false;

	/** Container for alignment tracks */
	UPROPERTY()
	FContextualAnimAlignmentTrackContainer AlignmentData;

	/** Container for auto generate IK Target Tracks */
	UPROPERTY()
	FContextualAnimAlignmentTrackContainer IKTargetData;

	UPROPERTY(EditAnywhere, Instanced, Category = "Defaults")
	TArray<TObjectPtr<UContextualAnimSelectionCriterion>> SelectionCriteria;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FTransform MeshToScene;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Defaults", meta = (GetOptions = "GetRoles"))
	FName Role = NAME_None;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Defaults")
	int32 SectionIdx = INDEX_NONE;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Defaults")
	int32 AnimSetIdx = INDEX_NONE;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Defaults")
	int32 AnimTrackIdx = INDEX_NONE;

	// DEPRECATED: Will go away soon
	float GetSyncTimeForWarpSection(int32 WarpSectionIndex) const;
	float GetSyncTimeForWarpSection(const FName& WarpSectionName) const;

	void GetStartAndEndTimeForWarpSection(int32 WarpSectionIndex, float& OutStartTime, float& OutEndTime) const;
	void GetStartAndEndTimeForWarpSection(const FName& WarpSectionName, float& OutStartTime, float& OutEndTime) const;

	FORCEINLINE FTransform GetAlignmentTransformAtTime(float Time) const { return AlignmentData.ExtractTransformAtTime(0, Time); }
	FORCEINLINE FTransform GetAlignmentTransformAtEntryTime() const { return AlignmentData.ExtractTransformAtTime(0, 0.f); }
	FORCEINLINE FTransform GetAlignmentTransformAtSyncTime() const { return AlignmentData.ExtractTransformAtTime(0, GetSyncTimeForWarpSection(0)); }

	float FindBestAnimStartTime(const FVector& LocalLocation) const;

	bool DoesQuerierPassSelectionCriteria(const FContextualAnimSceneBindingContext& PrimaryActorData, const FContextualAnimSceneBindingContext& QuerierData) const;

	FTransform GetRootTransformAtTime(float Time) const;

	static const FContextualAnimTrack EmptyTrack;
};

/** Defines when the actor should start playing the animation */
UENUM(BlueprintType)
enum class EContextualAnimJoinRule : uint8
{
	Default,
	Late
};

UENUM(BlueprintType)
enum class EContextualAnimIKTargetProvider : uint8
{
	/** 
	 * IK Targets are auto generated from the animations 
	 * @see: UContextualAnimSceneAssetBase::GenerateIKTargetTracks
	 */
	Autogenerated,

	/** IK Target defined by a bone or a socket in the animation */
	Bone,

	//@TODO: Add collision query methods
};

USTRUCT(BlueprintType)
struct FContextualAnimIKTargetDefinition
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName GoalName = NAME_None;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName BoneName = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	EContextualAnimIKTargetProvider Provider = EContextualAnimIKTargetProvider::Autogenerated;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName TargetRoleName = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName TargetBoneName = NAME_None;

	bool operator==(const FContextualAnimIKTargetDefinition& Other) const 
	{
		return  GoalName == Other.GoalName && 
				BoneName == Other.BoneName && 
				Provider == Other.Provider && 
				TargetRoleName == Other.TargetRoleName &&
				TargetBoneName == Other.TargetBoneName;
	}
};

USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimIKTarget
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName GoalName = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	float Alpha = 0.f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FTransform Transform;

	FContextualAnimIKTarget() {}
	FContextualAnimIKTarget(const FName& InGoalName, float InAlpha, const FTransform& InTransform)
		: GoalName(InGoalName), Alpha(InAlpha), Transform(InTransform) {}

	static const FContextualAnimIKTarget InvalidIKTarget;
};

USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimIKTargetDefContainer
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	TArray<FContextualAnimIKTargetDefinition> IKTargetDefs;

	static const FContextualAnimIKTargetDefContainer EmptyContainer;
};

// FContextualAnimRoleDefinition
///////////////////////////////////////////////////////////////////////

USTRUCT(BlueprintType)
struct FContextualAnimRoleDefinition
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName Name = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	bool bIsCharacter = false;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FTransform MeshToComponent = FTransform(FRotator(0.f, -90.f, 0.f));

	static const FContextualAnimRoleDefinition InvalidRoleDefinition;
};

// FContextualAnimSetPivotDefinition
///////////////////////////////////////////////////////////////////////

/** Rules used to compute the pivot for a AnimSet */
USTRUCT(BlueprintType)
struct FContextualAnimSetPivotDefinition
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName Name = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults", meta = (GetOptions = "GetRoles"))
	FName Origin = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	bool bAlongClosestDistance = false;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults", meta = (GetOptions = "GetRoles", EditCondition = "bAlongClosestDistance"))
	FName OtherRole = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults", meta = (ClampMin = "0.0", ClampMax = "1.0", UIMin = "0.0", UIMax = "1.0", EditCondition = "bAlongClosestDistance"))
	float Weight = 0.f;
};

// FContextualAnimSetPivot
///////////////////////////////////////////////////////////////////////

/** Pivot for a AnimSet */
USTRUCT(BlueprintType)
struct FContextualAnimSetPivot
{
	GENERATED_BODY()

	FContextualAnimSetPivot() = default;
	FContextualAnimSetPivot(const FName InName, const FTransform& InTransform) : Name(InName), Transform(InTransform) {}
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName Name = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FTransform Transform;
};

// FContextualAnimSceneBindingContext
///////////////////////////////////////////////////////////////////////

USTRUCT(BlueprintType, meta = (HasNativeMake = "/Script/ContextualAnimation.ContextualAnimUtilities:BP_SceneBindingContext_MakeFromActor"))
struct CONTEXTUALANIMATION_API FContextualAnimSceneBindingContext
{
	GENERATED_BODY()

	FContextualAnimSceneBindingContext() {}

	FContextualAnimSceneBindingContext(AActor* InActor, const TOptional<FTransform>& InExternalTransform = TOptional<FTransform>(), const TOptional<FVector>& InExternalVelocity = TOptional<FVector>())
		: Actor(InActor), ExternalTransform(InExternalTransform), ExternalVelocity(InExternalVelocity) {}

	FContextualAnimSceneBindingContext(const FTransform& InExternalTransform, const TOptional<FVector>& InExternalVelocity = TOptional<FVector>())
		: ExternalTransform(InExternalTransform), ExternalVelocity(InExternalVelocity) {}

	AActor* GetActor() const { return Actor.Get(); }

	void SetExternalTransform(const FTransform& InTransform);

	FTransform GetTransform() const;

	FVector GetVelocity() const;

	//@TODO: Add accessors for GameplayTags

	bool NetSerialize(FArchive& Ar, class UPackageMap* Map, bool& bOutSuccess);

private:

	TWeakObjectPtr<AActor> Actor = nullptr;

	TOptional<FTransform> ExternalTransform;

	TOptional<FVector> ExternalVelocity;

	FGameplayTagContainer ExternalGameplayTags;
};

template<>
struct TStructOpsTypeTraits<FContextualAnimSceneBindingContext> : public TStructOpsTypeTraitsBase2<FContextualAnimSceneBindingContext>
{
	enum
	{
		WithNetSerializer = true
	};
};

/** Represent an actor bound to a role in the scene */
USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimSceneBinding
{
	GENERATED_BODY()

	FContextualAnimSceneBinding() {}
	FContextualAnimSceneBinding(const FContextualAnimSceneBindingContext& InContext, const FContextualAnimTrack& InAnimTrack);

	FORCEINLINE const FContextualAnimSceneBindingContext& GetContext() const { return Context; }
	FORCEINLINE FContextualAnimSceneBindingContext& GetContext() { return Context; }
	FORCEINLINE AActor* GetActor() const { return GetContext().GetActor(); }
	FORCEINLINE FTransform GetTransform() const { return GetContext().GetTransform(); }
	FORCEINLINE FVector GetVelocity()  const { return GetContext().GetVelocity(); }

	FORCEINLINE int32 GetAnimTrackIdx() const { return AnimTrackIdx; }
	
	void SetAnimTrack(const FContextualAnimTrack& InAnimTrack);

	/** Return the current playback time of the animation this actor is playing */
	float GetAnimMontageTime() const;

	FName GetCurrentSection() const;

	int32 GetCurrentSectionIndex() const;

	/** Returns the ActiveMontageInstance or null in the case of static actors */
	FAnimMontageInstance* GetAnimMontageInstance() const;

	UAnimInstance* GetAnimInstance() const;

	USkeletalMeshComponent* GetSkeletalMeshComponent() const;

	UContextualAnimSceneActorComponent* GetSceneActorComponent() const;

	bool NetSerialize(FArchive& Ar, class UPackageMap* Map, bool& bOutSuccess);

	static const FContextualAnimSceneBinding InvalidBinding;

private:

	friend UContextualAnimSceneInstance;
	friend struct FContextualAnimSceneBindings;

	FContextualAnimSceneBindingContext Context;

	int32 AnimTrackIdx = INDEX_NONE;
};

template<>
struct TStructOpsTypeTraits<FContextualAnimSceneBinding> : public TStructOpsTypeTraitsBase2<FContextualAnimSceneBinding>
{
	enum
	{
		WithNetSerializer = true
	};
};

USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimSceneBindings
{
	GENERATED_BODY()

	FContextualAnimSceneBindings(){}
	FContextualAnimSceneBindings(const UContextualAnimSceneAsset& InSceneAsset, int32 InSectionIdx, int32 InAnimSetIdx);

	const FContextualAnimSceneBinding* FindBindingByActor(const AActor* Actor) const
	{
		return Actor ? Data.FindByPredicate([Actor](const FContextualAnimSceneBinding& Item) { return Item.GetActor() == Actor; }) : nullptr;
	}

	const FContextualAnimSceneBinding* FindBindingByRole(const FName& Role) const
	{
		return Role != NAME_None ? Data.FindByPredicate([this, &Role](const FContextualAnimSceneBinding& Item) { return GetAnimTrackFromBinding(Item).Role == Role; }) : nullptr;
	}

	FORCEINLINE const UContextualAnimSceneAsset* GetSceneAsset() const { return SceneAsset.Get(); }
	FORCEINLINE int32 GetSectionIdx() const { return SectionIdx; }
	FORCEINLINE int32 GetAnimSetIdx() const { return AnimSetIdx; }
	FORCEINLINE int32 Num() const { return Data.Num(); }
	FORCEINLINE int32 Add(const FContextualAnimSceneBinding& NewData) { return Data.Add(NewData); }
	FORCEINLINE const TArray<FContextualAnimSceneBinding>& GetBindings() const { return Data; }
	FORCEINLINE const UContextualAnimSceneInstance* GetSceneInstance() const { return SceneInstancePtr.Get(); }

	FORCEINLINE TArray<FContextualAnimSceneBinding>::RangedForIteratorType      begin() { return Data.begin(); }
	FORCEINLINE TArray<FContextualAnimSceneBinding>::RangedForConstIteratorType begin() const { return Data.begin(); }
	FORCEINLINE TArray<FContextualAnimSceneBinding>::RangedForIteratorType      end() { return Data.end(); }
	FORCEINLINE TArray<FContextualAnimSceneBinding>::RangedForConstIteratorType end() const { return Data.end(); }

	static bool TryCreateBindings(const UContextualAnimSceneAsset& SceneAsset, int32 SectionIdx, int32 AnimSetIdx, const TMap<FName, FContextualAnimSceneBindingContext>& Params, FContextualAnimSceneBindings& OutBindings);
	static bool TryCreateBindings(const UContextualAnimSceneAsset& SceneAsset, int32 SectionIdx, const TMap<FName, FContextualAnimSceneBindingContext>& Params, FContextualAnimSceneBindings& OutBindings);
	static bool TryCreateBindings(const UContextualAnimSceneAsset& SceneAsset, int32 SectionIdx, int32 AnimSetIdx, const FContextualAnimSceneBindingContext& Primary, const FContextualAnimSceneBindingContext& Secondary, FContextualAnimSceneBindings& OutBindings);
	static bool TryCreateBindings(const UContextualAnimSceneAsset& SceneAsset, int32 SectionIdx, const FContextualAnimSceneBindingContext& Primary, const FContextualAnimSceneBindingContext& Secondary, FContextualAnimSceneBindings& OutBindings);

	void CalculateAnimSetPivots(TArray<FContextualAnimSetPivot>& OutScenePivots) const;
	bool CalculateAnimSetPivot(const FContextualAnimSetPivotDefinition& AnimSetPivotDef, FContextualAnimSetPivot& OutScenePivot) const;

	const FContextualAnimTrack& GetAnimTrackFromBinding(const FContextualAnimSceneBinding& Binding) const;
	const FName& GetRoleFromBinding(const FContextualAnimSceneBinding& Binding) const;
	FTransform GetAlignmentTransformFromBinding(const FContextualAnimSceneBinding& Binding, const FName& TrackName, float Time) const;
	const FContextualAnimIKTargetDefContainer& GetIKTargetDefContainerFromBinding(const FContextualAnimSceneBinding& Binding) const;
	FTransform GetIKTargetTransformFromBinding(const FContextualAnimSceneBinding& Binding, const FName& TrackName, float Time) const;

	bool IsValid() const;

	void Reset();

	bool NetSerialize(FArchive& Ar, class UPackageMap* Map, bool& bOutSuccess);

private:

	friend class UContextualAnimManager;

	UPROPERTY()
	TWeakObjectPtr<const UContextualAnimSceneAsset> SceneAsset = nullptr;

	UPROPERTY()
	int32 SectionIdx = INDEX_NONE;

	UPROPERTY()
	int32 AnimSetIdx = INDEX_NONE;

	/** List of actors bound to each role in the SceneAsset */
	UPROPERTY()
	TArray<FContextualAnimSceneBinding> Data;

	/** Ptr back to the scene instance we belong to (if any) */
	UPROPERTY()
	TWeakObjectPtr<const UContextualAnimSceneInstance> SceneInstancePtr = nullptr;
};

template<>
struct TStructOpsTypeTraits<FContextualAnimSceneBindings> : public TStructOpsTypeTraitsBase2<FContextualAnimSceneBindings>
{
	enum
	{
		WithNetSerializer = true
	};
};

USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimStartSceneParams
{
	GENERATED_BODY()

	/** Map with actors to bind to each role in the scene */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	TMap<FName, FContextualAnimSceneBindingContext> RoleToActorMap;

	/** Desired section. If INDEX_NONE the Manager will use or find best set in the first section. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	int32 SectionIdx = INDEX_NONE;

	/** Desired set. If INDEX_NONE the Manager will attempt to find the best set to use by running the selection criteria.
	 * The selection will be performed in the section specified by SectionIdx or in the first section if SectionIdx == INDEX_NONE.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	int32 AnimSetIdx = INDEX_NONE;

	/** Precomputed pivots that could be provided when starting a scene.
	 * When not provided, the pivots will be automatically computed using local context information.
	 */
	TArray<FContextualAnimSetPivot> Pivots;

	void Reset()
	{
		RoleToActorMap.Reset();
		SectionIdx = INDEX_NONE;
		AnimSetIdx = INDEX_NONE;
		Pivots.Reset();
	}
};

///////////////////////////////////////////////////////////////////////

/** 
 * Stores the result of a query function 
 * @TODO: Only used by UContextualAnimSceneAsset::Query. Kept around only to do not break existing content. It will go away in the future.
 */
USTRUCT(BlueprintType)
struct FContextualAnimQueryResult
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite, Category = "Defaults")
	TWeakObjectPtr<UAnimMontage> Animation;

	UPROPERTY(BlueprintReadWrite, Category = "Defaults")
	FTransform EntryTransform;

	UPROPERTY(BlueprintReadWrite, Category = "Defaults")
	FTransform SyncTransform;

	UPROPERTY(BlueprintReadWrite, Category = "Defaults")
	float AnimStartTime = 0.f;

	UPROPERTY(BlueprintReadWrite, Category = "Defaults")
	int32 AnimSetIdx = INDEX_NONE;

	void Reset()
	{
		Animation.Reset();
		EntryTransform = SyncTransform = FTransform::Identity;
		AnimStartTime = 0.f;
		AnimSetIdx = INDEX_NONE;
	}

	FORCEINLINE bool IsValid() const { return AnimSetIdx != INDEX_NONE; }
};

/** 
 * Stores the parameters passed into query function 
 * @TODO: Only used by UContextualAnimSceneAsset::Query. Kept around only to do not break existing content. It will go away in the future.
 */
USTRUCT(BlueprintType)
struct FContextualAnimQueryParams
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	TWeakObjectPtr<const AActor> Querier;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FTransform QueryTransform;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	bool bComplexQuery = false;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	bool bFindAnimStartTime = false;

	FContextualAnimQueryParams() {}

	FContextualAnimQueryParams(const AActor* InQuerier, bool bInComplexQuery, bool bInFindAnimStartTime)
		: Querier(InQuerier), bComplexQuery(bInComplexQuery), bFindAnimStartTime(bInFindAnimStartTime) {}

	FContextualAnimQueryParams(const FTransform& InQueryTransform, bool bInComplexQuery, bool bInFindAnimStartTime)
		: QueryTransform(InQueryTransform), bComplexQuery(bInComplexQuery), bFindAnimStartTime(bInFindAnimStartTime) {}
};
