// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Animation/AnimSequence.h"
#include "GameFramework/Actor.h"
#include "GameplayTagContainer.h"
#include "ContextualAnimTypes.generated.h"

struct FContextualAnimSceneBindingContext;

CONTEXTUALANIMATION_API DECLARE_LOG_CATEGORY_EXTERN(LogContextualAnim, Log, All);

class AActor;
class UAnimInstance;
class UAnimSequenceBase;
class UContextualAnimSelectionCriterion;
class UContextualAnimSceneAsset;
class UContextualAnimSceneActorComponent;
class UCharacterMovementComponent;
class UMotionWarpingComponent;
struct FAnimMontageInstance;

namespace UE 
{
	namespace ContextualAnim 
	{
		enum class EForEachResult : uint8
		{
			Break,
			Continue,
		};
	}
}

/** Container for alignment tracks */
USTRUCT()
struct CONTEXTUALANIMATION_API FContextualAnimAlignmentTrackContainer
{
	GENERATED_BODY()

	UPROPERTY()
	FAnimSequenceTrackContainer Tracks;

	UPROPERTY()
	float SampleInterval = 0.f;

	void Initialize(int32 InNumTracks, float InSampleInterval)
	{
		Tracks.AnimationTracks.Empty(InNumTracks);
		Tracks.TrackNames.Empty(InNumTracks);
		SampleInterval = InSampleInterval;
	}

	void Empty()
	{
		Tracks.AnimationTracks.Empty();
		Tracks.TrackNames.Empty();
		SampleInterval = 0.f;
	}

	FTransform ExtractTransformAtTime(int32 TrackIndex, float Time) const;
	FTransform ExtractTransformAtTime(const FName& TrackName, float Time) const;
};

USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimTrack
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	TObjectPtr<UAnimSequenceBase> Animation = nullptr;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	float AnimMaxStartTime = 0.f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	TEnumAsByte<enum EMovementMode> MovementMode = EMovementMode::MOVE_Walking;

	/** Whether the actor that should play this animation is optional */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	bool bOptional = false;

	/** Container for alignment tracks */
	UPROPERTY()
	FContextualAnimAlignmentTrackContainer AlignmentData;

	/** Container for auto generate IK Target Tracks */
	UPROPERTY()
	FContextualAnimAlignmentTrackContainer IKTargetData;

	UPROPERTY(EditAnywhere, Instanced, Category = "Defaults")
	TArray<TObjectPtr<UContextualAnimSelectionCriterion>> SelectionCriteria;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FTransform MeshToScene;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Defaults")
	FName Role = NAME_None;

	UPROPERTY(BlueprintReadOnly, Category = "Defaults")
	int32 SectionIdx = INDEX_NONE;

	UPROPERTY(BlueprintReadOnly, Category = "Defaults")
	int32 AnimSetIdx = INDEX_NONE;

	UPROPERTY(BlueprintReadOnly, Category = "Defaults")
	int32 AnimTrackIdx = INDEX_NONE;

	// DEPRECATED: Will go away soon
	float GetSyncTimeForWarpSection(int32 WarpSectionIndex) const;
	float GetSyncTimeForWarpSection(const FName& WarpSectionName) const;

	void GetStartAndEndTimeForWarpSection(int32 WarpSectionIndex, float& OutStartTime, float& OutEndTime) const;
	void GetStartAndEndTimeForWarpSection(const FName& WarpSectionName, float& OutStartTime, float& OutEndTime) const;

	bool DoesQuerierPassSelectionCriteria(const FContextualAnimSceneBindingContext& PrimaryActorData, const FContextualAnimSceneBindingContext& QuerierData) const;

	FTransform GetRootTransformAtTime(float Time) const;

	static const FContextualAnimTrack EmptyTrack;
};

/** Defines when the actor should start playing the animation */
UENUM(BlueprintType)
enum class EContextualAnimJoinRule : uint8
{
	Default,
	Late
};

UENUM(BlueprintType)
enum class EContextualAnimIKTargetProvider : uint8
{
	/** 
	 * IK Targets are auto generated from the animations 
	 * @see: UContextualAnimSceneAssetBase::GenerateIKTargetTracks
	 */
	Autogenerated,

	/** IK Target defined by a bone or a socket in the animation */
	Bone,

	//@TODO: Add collision query methods
};

USTRUCT(BlueprintType)
struct FContextualAnimIKTargetDefinition
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName GoalName = NAME_None;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName BoneName = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	EContextualAnimIKTargetProvider Provider = EContextualAnimIKTargetProvider::Autogenerated;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName TargetRoleName = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName TargetBoneName = NAME_None;

	bool operator==(const FContextualAnimIKTargetDefinition& Other) const 
	{
		return  GoalName == Other.GoalName && 
				BoneName == Other.BoneName && 
				Provider == Other.Provider && 
				TargetRoleName == Other.TargetRoleName &&
				TargetBoneName == Other.TargetBoneName;
	}
};

USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimIKTarget
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName GoalName = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	float Alpha = 0.f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FTransform Transform;

	FContextualAnimIKTarget() {}
	FContextualAnimIKTarget(const FName& InGoalName, float InAlpha, const FTransform& InTransform)
		: GoalName(InGoalName), Alpha(InAlpha), Transform(InTransform) {}

	static const FContextualAnimIKTarget InvalidIKTarget;
};

USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimIKTargetDefContainer
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	TArray<FContextualAnimIKTargetDefinition> IKTargetDefs;

	static const FContextualAnimIKTargetDefContainer EmptyContainer;
};

// FContextualAnimRoleDefinition
///////////////////////////////////////////////////////////////////////

USTRUCT(BlueprintType)
struct FContextualAnimRoleDefinition
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName Name = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	bool bIsCharacter = false;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults", meta = (EditCondition = "bIsCharacter", EditConditionHides))
	float PreviewCapsuleHalfHeight = 88.f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults", meta = (EditCondition = "bIsCharacter", EditConditionHides))
	float PreviewCapsuleRadius = 34.f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FTransform MeshToComponent = FTransform(FRotator(0.f, -90.f, 0.f));

	static const FContextualAnimRoleDefinition InvalidRoleDefinition;
};

// EContextualAnimWarpPointDefinitionMode
///////////////////////////////////////////////////////////////////////

/** Different modes for defining warp points */
UENUM(BlueprintType)
enum class EContextualAnimWarpPointDefinitionMode : uint8
{
	/** 
	 * Warp point will be at the location/rotation of the primary actor. 
	 * Commonly used when interacting with static objects 
	*/
	PrimaryActor,

	/** 
	 * Warp point will be at the location/rotation of a socket on the primary actor. 
	 * Commonly used when re-using the same interaction animations to interact with objects with different proportions 
	*/
	Socket,

	/**
	 * Warp point will be calculated based on a set of rules.
	 * Commonly used when we want actors to align at some point between them
	*/
	Custom
};

/** Parameters used to calculate a warp point when using 'Custom' mode */
USTRUCT(BlueprintType)
struct FContextualAnimWarpPointCustomParams
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults", meta = (GetOptions = "GetRoles"))
	FName Origin = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	bool bAlongClosestDistance = false;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults", meta = (GetOptions = "GetRoles", EditCondition = "bAlongClosestDistance"))
	FName OtherRole = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults", meta = (ClampMin = "0.0", ClampMax = "1.0", UIMin = "0.0", UIMax = "1.0", EditCondition = "bAlongClosestDistance"))
	float Weight = 0.f;
};

/**
 * Contain the params necessary to calculate a warp point for the scene. 
 * A warp point is a transform in the scene that can be used as reference to calculate alignment between actors
*/
USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimWarpPointDefinition
{
	GENERATED_BODY()

	/** Name of the warp target in the warping window this warp point is for */
	UPROPERTY(EditAnywhere, Category = "Defaults")
	FName WarpTargetName = NAME_None;

	/** Method used to calculate this warp point */
	UPROPERTY(EditAnywhere, Category = "Defaults")
	EContextualAnimWarpPointDefinitionMode Mode = EContextualAnimWarpPointDefinitionMode::PrimaryActor;

	/** Name of the socket in the primary actor acting as warping point. Only relevant when Mode is Socket */
	UPROPERTY(EditAnywhere, Category = "Defaults", meta = (EditCondition = "Mode==EContextualAnimWarpPointDefinitionMode::Socket", EditConditionHides))
	FName SocketName = NAME_None;

	/** Set of rules used to calculate the warp point. Only relevant when Mode is Custom */
	UPROPERTY(EditAnywhere, Category = "Defaults", meta = (EditCondition = "Mode==EContextualAnimWarpPointDefinitionMode::Custom", EditConditionHides, FullyExpand = "true"))
	FContextualAnimWarpPointCustomParams Params;
};

// FContextualAnimWarpPoint
///////////////////////////////////////////////////////////////////////

USTRUCT(BlueprintType)
struct FContextualAnimWarpPoint
{
	GENERATED_BODY()

	FContextualAnimWarpPoint() = default;
	FContextualAnimWarpPoint(const FName InName, const FTransform& InTransform) : Name(InName), Transform(InTransform) {}
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FName Name = NAME_None;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FTransform Transform;
};

// FContextualAnimSceneBindingContext
///////////////////////////////////////////////////////////////////////

USTRUCT(BlueprintType, meta = (HasNativeMake = "/Script/ContextualAnimation.ContextualAnimUtilities:BP_SceneBindingContext_MakeFromActor"))
struct CONTEXTUALANIMATION_API FContextualAnimSceneBindingContext
{
	GENERATED_BODY()

	FContextualAnimSceneBindingContext() {}

	FContextualAnimSceneBindingContext(AActor* InActor, const TOptional<FTransform>& InExternalTransform = TOptional<FTransform>(), const TOptional<FVector>& InExternalVelocity = TOptional<FVector>())
		: Actor(InActor), ExternalTransform(InExternalTransform), ExternalVelocity(InExternalVelocity) {}

	FContextualAnimSceneBindingContext(const FTransform& InExternalTransform, const TOptional<FVector>& InExternalVelocity = TOptional<FVector>())
		: ExternalTransform(InExternalTransform), ExternalVelocity(InExternalVelocity) {}

	FContextualAnimSceneBindingContext(AActor* InActor, const FGameplayTagContainer& InExternalTags)
		: Actor(InActor), ExternalGameplayTags(InExternalTags) {}

	AActor* GetActor() const { return Actor.Get(); }

	UAnimInstance* GetAnimInstance() const;

	USkeletalMeshComponent* GetSkeletalMeshComponent() const;

	UContextualAnimSceneActorComponent* GetSceneActorComponent() const;

	UCharacterMovementComponent* GetCharacterMovementComponent() const;

	UMotionWarpingComponent* GetMotionWarpingComponent() const;

	void SetExternalTransform(const FTransform& InTransform);

	FTransform GetTransform() const;

	FVector GetVelocity() const;

	void AddGameplayTag(const FGameplayTag& Tag);
	
	const FGameplayTagContainer& GetGameplayTags() const { return ExternalGameplayTags; }

	bool HasMatchingGameplayTag(const FGameplayTag& TagToCheck) const;

	bool HasAllMatchingGameplayTags(const FGameplayTagContainer& TagContainer) const;

	bool HasAnyMatchingGameplayTags(const FGameplayTagContainer& TagContainer) const;

private:

	UPROPERTY()
	TWeakObjectPtr<AActor> Actor = nullptr;

	UPROPERTY(NotReplicated)
	mutable TWeakObjectPtr<UContextualAnimSceneActorComponent> CachedSceneActorComp = nullptr;

	UPROPERTY(NotReplicated)
	mutable TWeakObjectPtr<UAnimInstance> CachedAnimInstance = nullptr;

	UPROPERTY(NotReplicated)
	mutable TWeakObjectPtr<USkeletalMeshComponent> CachedSkeletalMesh = nullptr;

	UPROPERTY(NotReplicated)
	mutable TWeakObjectPtr<UCharacterMovementComponent> CachedMovementComp = nullptr;

	UPROPERTY(NotReplicated)
	mutable TWeakObjectPtr<UMotionWarpingComponent> CachedMotionWarpingComp = nullptr;

	TOptional<FTransform> ExternalTransform;

	TOptional<FVector> ExternalVelocity;

	FGameplayTagContainer ExternalGameplayTags;
};

/** Represent an actor bound to a role in the scene */
USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimSceneBinding
{
	GENERATED_BODY()

	FContextualAnimSceneBinding() {}
	FContextualAnimSceneBinding(const FContextualAnimSceneBindingContext& InContext, const FContextualAnimTrack& InAnimTrack);

	FORCEINLINE const FContextualAnimSceneBindingContext& GetContext() const { return Context; }
	FORCEINLINE FContextualAnimSceneBindingContext& GetContext() { return Context; }
	FORCEINLINE AActor* GetActor() const { return GetContext().GetActor(); }
	FORCEINLINE FTransform GetTransform() const { return GetContext().GetTransform(); }
	FORCEINLINE FVector GetVelocity()  const { return GetContext().GetVelocity(); }
	FORCEINLINE UAnimInstance* GetAnimInstance() const { return Context.GetAnimInstance(); }
	FORCEINLINE USkeletalMeshComponent* GetSkeletalMeshComponent() const { return Context.GetSkeletalMeshComponent(); }
	FORCEINLINE UContextualAnimSceneActorComponent* GetSceneActorComponent() const { return Context.GetSceneActorComponent(); }
	FORCEINLINE UCharacterMovementComponent* GetCharacterMovementComponent() const { return Context.GetCharacterMovementComponent(); }
	FORCEINLINE UMotionWarpingComponent* GetMotionWarpingComponent() const { return Context.GetMotionWarpingComponent(); }
	FORCEINLINE int32 GetAnimTrackIdx() const { return AnimTrackIdx; }
	
	void SetAnimTrack(const FContextualAnimTrack& InAnimTrack);

	/** Return the current playback time of the animation this actor is playing */
	float GetAnimMontageTime() const;

	FName GetCurrentSection() const;

	int32 GetCurrentSectionIndex() const;

	/** Returns the ActiveMontageInstance or null in the case of static actors */
	FAnimMontageInstance* GetAnimMontageInstance() const;

	static const FContextualAnimSceneBinding InvalidBinding;

private:

	friend class UContextualAnimSceneInstance;
	friend struct FContextualAnimSceneBindings;

	UPROPERTY()
	FContextualAnimSceneBindingContext Context;

	UPROPERTY()
	int32 AnimTrackIdx = INDEX_NONE;
};

USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimSceneBindings
{
	GENERATED_BODY()

	FContextualAnimSceneBindings(){}
	FContextualAnimSceneBindings(const UContextualAnimSceneAsset& InSceneAsset, int32 InSectionIdx, int32 InAnimSetIdx);

	const FContextualAnimSceneBinding* FindBindingByActor(const AActor* Actor) const
	{
		return Actor ? Data.FindByPredicate([Actor](const FContextualAnimSceneBinding& Item) { return Item.GetActor() == Actor; }) : nullptr;
	}

	const FContextualAnimSceneBinding* FindBindingByRole(const FName& Role) const
	{
		return Role != NAME_None ? Data.FindByPredicate([this, &Role](const FContextualAnimSceneBinding& Item) { return GetAnimTrackFromBinding(Item).Role == Role; }) : nullptr;
	}

	void AddReferencedObjects(FReferenceCollector& Collector);

	FORCEINLINE uint8 GetID() const { return Id; }
	FORCEINLINE const UContextualAnimSceneAsset* GetSceneAsset() const { return SceneAsset; }
	FORCEINLINE int32 GetSectionIdx() const { return SectionIdx; }
	FORCEINLINE int32 GetAnimSetIdx() const { return AnimSetIdx; }
	FORCEINLINE int32 Num() const { return Data.Num(); }
	FORCEINLINE int32 Add(const FContextualAnimSceneBinding& NewData) { return Data.Add(NewData); }
	FORCEINLINE const TArray<FContextualAnimSceneBinding>& GetBindings() const { return Data; }

	FORCEINLINE TArray<FContextualAnimSceneBinding>::RangedForIteratorType      begin() { return Data.begin(); }
	FORCEINLINE TArray<FContextualAnimSceneBinding>::RangedForConstIteratorType begin() const { return Data.begin(); }
	FORCEINLINE TArray<FContextualAnimSceneBinding>::RangedForIteratorType      end() { return Data.end(); }
	FORCEINLINE TArray<FContextualAnimSceneBinding>::RangedForConstIteratorType end() const { return Data.end(); }

	static bool CheckConditions(const UContextualAnimSceneAsset& SceneAsset, int32 SectionIdx, int32 AnimSetIdx, const TMap<FName, FContextualAnimSceneBindingContext>& Params);
	static bool TryCreateBindings(const UContextualAnimSceneAsset& SceneAsset, int32 SectionIdx, int32 AnimSetIdx, const TMap<FName, FContextualAnimSceneBindingContext>& Params, FContextualAnimSceneBindings& OutBindings);
	static bool TryCreateBindings(const UContextualAnimSceneAsset& SceneAsset, int32 SectionIdx, const TMap<FName, FContextualAnimSceneBindingContext>& Params, FContextualAnimSceneBindings& OutBindings);
	static bool TryCreateBindings(const UContextualAnimSceneAsset& SceneAsset, int32 SectionIdx, int32 AnimSetIdx, const FContextualAnimSceneBindingContext& Primary, const FContextualAnimSceneBindingContext& Secondary, FContextualAnimSceneBindings& OutBindings);
	static bool TryCreateBindings(const UContextualAnimSceneAsset& SceneAsset, int32 SectionIdx, const FContextualAnimSceneBindingContext& Primary, const FContextualAnimSceneBindingContext& Secondary, FContextualAnimSceneBindings& OutBindings);
	static int32 FindAnimSet(const UContextualAnimSceneAsset& SceneAsset, int32 SectionIdx, const TMap<FName, FContextualAnimSceneBindingContext>& Params);

	bool BindActorToRole(AActor& ActorRef, FName Role);

	bool SetRoleWarpTarget(const FName Role, const FName WarpTargetName, const FTransform& Transform);

	void CalculateWarpPoints(TArray<FContextualAnimWarpPoint>& OutWarpPoints) const;
	bool CalculateWarpPoint(const FContextualAnimWarpPointDefinition& WarpPointDef, FContextualAnimWarpPoint& OutWarpPoint) const;

	const FContextualAnimTrack& GetAnimTrackFromBinding(const FContextualAnimSceneBinding& Binding) const;
	const FName& GetRoleFromBinding(const FContextualAnimSceneBinding& Binding) const;
	FTransform GetAlignmentTransformFromBinding(const FContextualAnimSceneBinding& Binding, const FName& TrackName, float Time) const;
	const FContextualAnimIKTargetDefContainer& GetIKTargetDefContainerFromBinding(const FContextualAnimSceneBinding& Binding) const;
	FTransform GetIKTargetTransformFromBinding(const FContextualAnimSceneBinding& Binding, const FName& TrackName, float Time) const;

	const FContextualAnimSceneBinding* GetSyncLeader() const;
	const FContextualAnimSceneBinding* GetPrimaryBinding() const;

	bool IsValid() const;

	void Reset();

	void Clear();

	void GenerateUniqueId();

	int32 FindAnimSetForTransitionTo(int32 NewSectionIdx) const;
	void TransitionTo(int32 NewSectionIdx, int32 NewAnimSetIdx);

	bool RemoveActor(AActor& ActorRef);

private:

	friend class UContextualAnimManager;

	UPROPERTY()
	uint8 Id = 0;

	UPROPERTY()
	TObjectPtr<const UContextualAnimSceneAsset> SceneAsset = nullptr;

	UPROPERTY()
	int32 SectionIdx = INDEX_NONE;

	UPROPERTY()
	int32 AnimSetIdx = INDEX_NONE;

	/** List of actors bound to each role in the SceneAsset */
	UPROPERTY()
	TArray<FContextualAnimSceneBinding> Data;
};

// DEPRECATED: Kept around only to do not break existing content. It will go away in the future.

USTRUCT(BlueprintType)
struct CONTEXTUALANIMATION_API FContextualAnimStartSceneParams
{
	GENERATED_BODY()

	/** Map with actors to bind to each role in the scene */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	TMap<FName, FContextualAnimSceneBindingContext> RoleToActorMap;

	/** Desired section. If INDEX_NONE the Manager will use or find best set in the first section. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	int32 SectionIdx = INDEX_NONE;

	/** Desired set. If INDEX_NONE the Manager will attempt to find the best set to use by running the selection criteria.
	 * The selection will be performed in the section specified by SectionIdx or in the first section if SectionIdx == INDEX_NONE.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	int32 AnimSetIdx = INDEX_NONE;

	/** Precomputed warp points that could be provided when starting a scene.
	 * When not provided, the warp points will be automatically computed using local context information.
	 */
	TArray<FContextualAnimWarpPoint> WarpPoints;

	void Reset()
	{
		RoleToActorMap.Reset();
		SectionIdx = INDEX_NONE;
		AnimSetIdx = INDEX_NONE;
		WarpPoints.Reset();
	}
};

///////////////////////////////////////////////////////////////////////

/** 
 * Stores the result of a query function 
 * @TODO: Only used by UContextualAnimSceneAsset::Query. Kept around only to do not break existing content. It will go away in the future.
 */
USTRUCT(BlueprintType)
struct FContextualAnimQueryResult
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite, Category = "Defaults")
	TWeakObjectPtr<UAnimMontage> Animation;

	UPROPERTY(BlueprintReadWrite, Category = "Defaults")
	FTransform EntryTransform;

	UPROPERTY(BlueprintReadWrite, Category = "Defaults")
	FTransform SyncTransform;

	UPROPERTY(BlueprintReadWrite, Category = "Defaults")
	float AnimStartTime = 0.f;

	UPROPERTY(BlueprintReadWrite, Category = "Defaults")
	int32 AnimSetIdx = INDEX_NONE;

	void Reset()
	{
		Animation.Reset();
		EntryTransform = SyncTransform = FTransform::Identity;
		AnimStartTime = 0.f;
		AnimSetIdx = INDEX_NONE;
	}

	FORCEINLINE bool IsValid() const { return AnimSetIdx != INDEX_NONE; }
};

/** 
 * Stores the parameters passed into query function 
 * @TODO: Only used by UContextualAnimSceneAsset::Query. Kept around only to do not break existing content. It will go away in the future.
 */
USTRUCT(BlueprintType)
struct FContextualAnimQueryParams
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	TWeakObjectPtr<const AActor> Querier;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	FTransform QueryTransform;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	bool bComplexQuery = false;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Defaults")
	bool bFindAnimStartTime = false;

	FContextualAnimQueryParams() {}

	FContextualAnimQueryParams(const AActor* InQuerier, bool bInComplexQuery, bool bInFindAnimStartTime)
		: Querier(InQuerier), bComplexQuery(bInComplexQuery), bFindAnimStartTime(bInFindAnimStartTime) {}

	FContextualAnimQueryParams(const FTransform& InQueryTransform, bool bInComplexQuery, bool bInFindAnimStartTime)
		: QueryTransform(InQueryTransform), bComplexQuery(bInComplexQuery), bFindAnimStartTime(bInFindAnimStartTime) {}
};
