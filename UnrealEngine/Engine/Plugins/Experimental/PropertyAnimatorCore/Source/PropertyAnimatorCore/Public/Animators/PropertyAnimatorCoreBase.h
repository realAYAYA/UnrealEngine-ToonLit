// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Properties/PropertyAnimatorCoreContext.h"
#include "Properties/PropertyAnimatorCoreData.h"
#include "UObject/Object.h"
#include "PropertyAnimatorCoreBase.generated.h"

class UPropertyAnimatorCoreComponent;
class UPropertyAnimatorCoreGroupBase;
class UPropertyAnimatorCoreTimeSourceBase;

/** Parameters to use for the current evaluation results */
struct FPropertyAnimatorCoreEvaluationParameters
{
	/** Time elapsed generated by the active time source */
	double TimeElapsed = 0.f;

	/** Global magnitude for all animators */
	float AnimatorsMagnitude = 1.f;
};

/** Abstract base class for any Animator, holds a set of linked properties */
UCLASS(MinimalAPI, Abstract, EditInlineNew, AutoExpandCategories=("Animator"))
class UPropertyAnimatorCoreBase : public UObject
{
	GENERATED_BODY()

	friend class UPropertyAnimatorCoreComponent;
	friend class UPropertyAnimatorCoreContext;
	friend class UPropertyAnimatorCoreEditorStackCustomization;
	friend class FPropertyAnimatorCoreEditorDetailCustomization;

public:
	DECLARE_MULTICAST_DELEGATE_OneParam(FOnAnimatorUpdated, UPropertyAnimatorCoreBase* /* InAnimator */)

	/** Called when a Animator is created */
	PROPERTYANIMATORCORE_API static FOnAnimatorUpdated OnAnimatorCreatedDelegate;

	/** Called when a Animator is removed */
	PROPERTYANIMATORCORE_API static FOnAnimatorUpdated OnAnimatorRemovedDelegate;

	/** Called when a Animator is renamed */
	PROPERTYANIMATORCORE_API static FOnAnimatorUpdated OnAnimatorRenamedDelegate;

	DECLARE_MULTICAST_DELEGATE_TwoParams(FOnAnimatorPropertyUpdated, UPropertyAnimatorCoreBase* /* InAnimator */, const FPropertyAnimatorCoreData& /** InProperty */)

	/** Called when a property is linked to a Animator */
	PROPERTYANIMATORCORE_API static FOnAnimatorPropertyUpdated OnAnimatorPropertyLinkedDelegate;

	/** Called when a property is unlinked to a Animator */
	PROPERTYANIMATORCORE_API static FOnAnimatorPropertyUpdated OnAnimatorPropertyUnlinkedDelegate;

	PROPERTYANIMATORCORE_API UPropertyAnimatorCoreBase();

	PROPERTYANIMATORCORE_API AActor* GetAnimatorActor() const;

	UPropertyAnimatorCoreComponent* GetAnimatorComponent() const;

	/** Get the global animators magnitude */
	float GetAnimatorComponentMagnitude() const;

	/** Set the state of this animator */
	PROPERTYANIMATORCORE_API void SetAnimatorEnabled(bool bInIsEnabled);
	bool GetAnimatorEnabled() const
	{
		return bAnimatorEnabled;
	}

	/** Set the time source name to use */
	PROPERTYANIMATORCORE_API void SetTimeSourceName(FName InTimeSourceName);
	FName GetTimeSourceName() const
	{
		return TimeSourceName;
	}

	/** Get the active time source */
	UPropertyAnimatorCoreTimeSourceBase* GetActiveTimeSource() const
	{
		return ActiveTimeSource;
	}

	/** Set the display name of this animator */
	PROPERTYANIMATORCORE_API void SetAnimatorDisplayName(FName InName);
	FString GetAnimatorDisplayName() const
	{
		return AnimatorDisplayName.ToString();
	}

	/** Gets the Animator original name */
	PROPERTYANIMATORCORE_API FName GetAnimatorOriginalName() const;

	/** Get all linked properties within this animator */
	PROPERTYANIMATORCORE_API TSet<FPropertyAnimatorCoreData> GetLinkedProperties() const;

	/** Get linked properties count within this animator */
	PROPERTYANIMATORCORE_API int32 GetLinkedPropertiesCount() const;

	/** Link property to this Animator to be able to drive it */
	PROPERTYANIMATORCORE_API bool LinkProperty(const FPropertyAnimatorCoreData& InLinkProperty);

	/** Unlink property from this Animator */
	PROPERTYANIMATORCORE_API bool UnlinkProperty(const FPropertyAnimatorCoreData& InUnlinkProperty);

	/** Checks if this Animator is controlling this property */
	PROPERTYANIMATORCORE_API bool IsPropertyLinked(const FPropertyAnimatorCoreData& InPropertyData) const;

	/** Checks if this animator is controlling all properties */
	bool IsPropertiesLinked(const TSet<FPropertyAnimatorCoreData>& InProperties) const;

	/** Returns all inner properties that are controlled by this Animator linked to member property */
	PROPERTYANIMATORCORE_API TSet<FPropertyAnimatorCoreData> GetInnerPropertiesLinked(const FPropertyAnimatorCoreData& InPropertyData) const;

	/**
	 * Checks recursively for properties inside that member property that are supported by this Animator
	 * if the member property is directly supported only returns that one, calls IsPropertySupported to check
	 * When recursive is false, it will stop if member property or children is controllable and not look further in the chain
	 */
	PROPERTYANIMATORCORE_API bool GetPropertiesSupported(const FPropertyAnimatorCoreData& InPropertyData, TSet<FPropertyAnimatorCoreData>& OutProperties, bool bInRecursiveSearch = false) const;

	/** Does not recurse, checks if this Animator supports this specific property, use GetPropertiesSupported to check if nested properties are supported */
	PROPERTYANIMATORCORE_API bool IsPropertySupported(const FPropertyAnimatorCoreData& InPropertyData) const;

	/** Override this to check if a property is directly supported by this animator */
	virtual bool IsPropertyDirectlySupported(const FPropertyAnimatorCoreData& InPropertyData) const
	{
		return false;
	}

	/** Override this to check if a property is indirectly supported by this animator with conversions */
	virtual bool IsPropertyIndirectlySupported(const FPropertyAnimatorCoreData& InPropertyData) const
	{
		return false;
	}

	/** Get the context for the linked property */
	PROPERTYANIMATORCORE_API UPropertyAnimatorCoreContext* GetLinkedPropertyContext(const FPropertyAnimatorCoreData& InProperty) const;

	/** Get the casted context for the linked property */
	template<typename InContextClass
		UE_REQUIRES(TIsDerivedFrom<InContextClass, UPropertyAnimatorCoreContext>::Value)>
	InContextClass* GetLinkedPropertyContext(const FPropertyAnimatorCoreData& InProperty) const
	{
		return Cast<InContextClass>(GetLinkedPropertyContext(InProperty));
	}

protected:
	//~ Begin UObject
	PROPERTYANIMATORCORE_API virtual void BeginDestroy() override;
	PROPERTYANIMATORCORE_API virtual void PostLoad() override;
	PROPERTYANIMATORCORE_API virtual void PreDuplicate(FObjectDuplicationParameters& InDupParams) override;
#if WITH_EDITOR
	PROPERTYANIMATORCORE_API virtual void PreEditUndo() override;
	PROPERTYANIMATORCORE_API virtual void PostEditUndo() override;
	PROPERTYANIMATORCORE_API virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
#endif
	//~ End UObject

	/** Update display name based on linked properties */
	void UpdateAnimatorDisplayName();

	/** Use this to process each linked properties and resolve it, even virtual ones */
	template<typename InContextClass
		UE_REQUIRES(TIsDerivedFrom<InContextClass, UPropertyAnimatorCoreContext>::Value)>
	bool ForEachLinkedProperty(TFunctionRef<bool(InContextClass*, const FPropertyAnimatorCoreData&)> InFunction, bool bInResolve = true) const
	{
		for (const TObjectPtr<UPropertyAnimatorCoreContext>& LinkedProperty : LinkedProperties)
		{
			if (InContextClass* PropertyContext = Cast<InContextClass>(LinkedProperty.Get()))
			{
				if (bInResolve)
				{
					for (const FPropertyAnimatorCoreData& ResolvedPropertyData : PropertyContext->ResolveProperty(false))
					{
						if (!ResolvedPropertyData.IsResolved())
						{
							continue;
						}

						if (!InFunction(PropertyContext, ResolvedPropertyData))
						{
							return false;
						}
					}
				}
				else
				{
					if (!InFunction(PropertyContext, LinkedProperty->GetAnimatedProperty()))
					{
						return false;
					}
				}
			}
		}

		return true;
	}

	/** Used to evaluate linked properties, assign the result in the property bag and return true on success to update property value */
	template<typename InContextClass
		UE_REQUIRES(TIsDerivedFrom<InContextClass, UPropertyAnimatorCoreContext>::Value)>
	void EvaluateEachLinkedProperty(
		TFunctionRef<bool(
			InContextClass* /** InPropertyContext */
			, const FPropertyAnimatorCoreData& /** InResolvedProperty */
			, FInstancedPropertyBag& /** OutEvaluation */)> InFunction
		)
	{
		checkf(bEvaluatingProperties, TEXT("EvaluateEachLinkedProperty can only be called in EvaluateProperties"))

		for (const TObjectPtr<UPropertyAnimatorCoreContext>& LinkedProperty : LinkedProperties)
		{
			if (InContextClass* PropertyContext = Cast<InContextClass>(LinkedProperty.Get()))
			{
				if (!PropertyContext->IsAnimated())
				{
					continue;
				}

				for (const FPropertyAnimatorCoreData& ResolvedPropertyData : PropertyContext->ResolveProperty(true))
				{
					if (!ResolvedPropertyData.IsResolved())
					{
						continue;
					}

					if (InFunction(PropertyContext, ResolvedPropertyData, EvaluatedPropertyValues))
					{
						PropertyContext->SetEvaluationResult(ResolvedPropertyData, EvaluatedPropertyValues);
					}
				}
			}
		}
	}

	virtual void OnAnimatorDisplayNameChanged() {}

	virtual void OnAnimatorAdded() {}
	virtual void OnAnimatorRemoved() {}

	PROPERTYANIMATORCORE_API virtual void OnAnimatorEnabled();
	PROPERTYANIMATORCORE_API virtual void OnAnimatorDisabled();

	/** Returns the property context class to use */
	PROPERTYANIMATORCORE_API virtual TSubclassOf<UPropertyAnimatorCoreContext> GetPropertyContextClass(const FPropertyAnimatorCoreData& InProperty);

	virtual void OnPropertyLinked(UPropertyAnimatorCoreContext* InLinkedProperty) {}
	virtual void OnPropertyUnlinked(UPropertyAnimatorCoreContext* InUnlinkedProperty) {}

	/** Apply animators effect on linked properties */
	virtual void EvaluateProperties(const FPropertyAnimatorCoreEvaluationParameters& InParameters) {}

private:
	/** Restore modified properties to original state */
	void RestoreProperties(bool bInForce = false);

	/** Allocate and saves properties in the property bag */
	void SaveProperties();

	/** Called by the component to evaluate this animator */
	void EvaluateAnimator();

	void OnObjectReplaced(const TMap<UObject*, UObject*>& InReplacementMap);

	void OnPropertyGroupsChanged();

	void OnAnimatorEnabledChanged();

	void CleanLinkedProperties();

	/** Clean invalid or renamed time sources */
	void CleanTimeSources();

	void OnTimeSourceNameChanged();

	UPropertyAnimatorCoreTimeSourceBase* FindOrAddTimeSource(FName InTimeSourceName);

	UFUNCTION()
	TArray<FString> GetTimeSourceNames() const;

	/** Enable control of properties linked to this Animator */
	UPROPERTY(EditInstanceOnly, Getter="GetAnimatorEnabled", Setter="SetAnimatorEnabled", Category="Animator", meta=(DisplayPriority="0", AllowPrivateAccess="true"))
	bool bAnimatorEnabled = true;

	/** Display name as title property for component array, hide it but must be visible to editor for array title property */
	UPROPERTY(VisibleInstanceOnly, Category="Animator", meta=(EditCondition="false", EditConditionHides))
	FName AnimatorDisplayName;

	/** Context for properties linked to this Animator */
	UPROPERTY(EditInstanceOnly, Category="Animator", EditFixedSize, meta=(EditFixedOrder))
	TArray<TObjectPtr<UPropertyAnimatorCoreContext>> LinkedProperties;

	/** Groups for properties linked to this Animator */
	UPROPERTY(EditInstanceOnly, Instanced, Category="Animator")
	TArray<TObjectPtr<UPropertyAnimatorCoreGroupBase>> PropertyGroups;

	/** The time source to use */
	UPROPERTY(EditInstanceOnly, Setter="SetTimeSourceName", Getter="GetTimeSourceName", Category="Animator", meta=(GetOptions="GetTimeSourceNames"))
	FName TimeSourceName = NAME_None;

	/** Active time source with its options, determined by its name */
	UPROPERTY(VisibleInstanceOnly, Instanced, Transient, DuplicateTransient, Category="Animator")
	TObjectPtr<UPropertyAnimatorCoreTimeSourceBase> ActiveTimeSource;

	/** The cached time source used by this Animator */
	UPROPERTY()
	TMap<FName, TObjectPtr<UPropertyAnimatorCoreTimeSourceBase>> TimeSourcesInstances;

	/** Evaluated property container, reset on every update round */
	UPROPERTY(Transient, DuplicateTransient, NonTransactional)
	FInstancedPropertyBag EvaluatedPropertyValues;

	/** Are we evaluating properties currently */
	bool bEvaluatingProperties = false;
};