// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "LearningArray.h"

#include "UObject/NameTypes.h"

namespace UE::Learning::Action
{
	/**
	 * Action Type
	 * 
	 * The core type of an action object for which different loss functions and behaviors are defined.
	 */
	enum class EType : uint8
	{
		// Empty Action
		Null				= 0,	

		// Vector of continuous float actions
		Continuous			= 1,

		// Set of exclusive discrete actions
		DiscreteExclusive	= 2,

		// Set of inclusive discrete actions
		DiscreteInclusive	= 3,

		// Combination of multiple actions
		And					= 4,

		// Exclusive choice from a set of actions
		OrExclusive			= 5,

		// Inclusive choice from a set of actions
		OrInclusive			= 6,

		// Fixed sized array of actions
		Array				= 7,

		// Encoding of another action
		Encoding			= 8,
	};

	/**
	 * Action Schema Element
	 * 
	 * A single element in the action schema representing a part of an action. Internally this consists of a index used by the schema to look up 
	 * the associated action data and a generation id which can be used to check when this index is no longer valid.
	 */
	struct FSchemaElement { int32 Index = INDEX_NONE; uint32 Generation = INDEX_NONE; };

	struct FSchemaContinuousParameters
	{
		// Number of values in the continuous action
		int32 Num = 0;
	};

	struct FSchemaDiscreteExclusiveParameters
	{
		// Number of choices in the discrete action
		int32 Num = 0;

		// Prior Probabilities of the discrete actions.
		TArrayView<const float> PriorProbabilities;
	};

	struct FSchemaDiscreteInclusiveParameters
	{
		// Number of choices in the discrete action
		int32 Num = 0;

		// Prior Probabilities of the discrete actions.
		TArrayView<const float> PriorProbabilities;
	};

	struct FSchemaAndParameters
	{
		// Names of the sub-actions.
		TArrayView<const FName> ElementNames;

		// The associated sub-elements.
		TArrayView<const FSchemaElement> Elements;
	};

	struct FSchemaOrExclusiveParameters
	{
		// Names of the sub-actions.
		TArrayView<const FName> ElementNames;

		// The associated sub-elements.
		TArrayView<const FSchemaElement> Elements;

		// Prior Probabilities of the sub-actions.
		TArrayView<const float> PriorProbabilities;
	};

	struct FSchemaOrInclusiveParameters
	{
		// Names of the sub-actions.
		TArrayView<const FName> ElementNames;

		// The associated sub-elements.
		TArrayView<const FSchemaElement> Elements;

		// Prior Probabilities of the sub-actions.
		TArrayView<const float> PriorProbabilities;
	};

	struct FSchemaArrayParameters
	{
		// The array sub-element.
		FSchemaElement Element;

		// The number of elements in the array.
		int32 Num = 0;
	};

	/** Activation Function to use for encoding */
	enum class EEncodingActivationFunction : uint8
	{
		ELU = 0,
		ReLU = 1,
		TanH = 2,
	};

	struct FSchemaEncodingParameters
	{
		// The sub-element.
		FSchemaElement Element;

		// The size at which the sub-element should be encoded.
		int32 EncodingSize = 32;

		// The number of layers in the encoding
		int32 LayerNum = 1;

		// The activation function to use for encoding
		EEncodingActivationFunction ActivationFunction = EEncodingActivationFunction::ELU;
	};

	/**
	 * Action Schema
	 *
	 * This object allows you to construct a description of the kind of actions you might want to be generated by a policy. Internally this object
	 * contains a pool of individual elements. This allows them to be constructed performantly and in a cache efficient way. This object is therefore
	 * required to access any data about the individual action elements that are created.
	 */
	struct LEARNING_API FSchema
	{
		FSchemaElement CreateNull(const FName Tag = NAME_None);
		FSchemaElement CreateContinuous(const FSchemaContinuousParameters Parameters, const FName Tag = NAME_None);
		FSchemaElement CreateDiscreteExclusive(const FSchemaDiscreteExclusiveParameters Parameters, const FName Tag = NAME_None);
		FSchemaElement CreateDiscreteInclusive(const FSchemaDiscreteInclusiveParameters Parameters, const FName Tag = NAME_None);
		FSchemaElement CreateAnd(const FSchemaAndParameters Parameters, const FName Tag = NAME_None);
		FSchemaElement CreateOrExclusive(const FSchemaOrExclusiveParameters Parameters, const FName Tag = NAME_None);
		FSchemaElement CreateOrInclusive(const FSchemaOrInclusiveParameters Parameters, const FName Tag = NAME_None);
		FSchemaElement CreateArray(const FSchemaArrayParameters Parameters, const FName Tag = NAME_None);
		FSchemaElement CreateEncoding(const FSchemaEncodingParameters Parameters, const FName Tag = NAME_None);

		FSchemaContinuousParameters GetContinuous(const FSchemaElement Element) const;
		FSchemaDiscreteExclusiveParameters GetDiscreteExclusive(const FSchemaElement Element) const;
		FSchemaDiscreteInclusiveParameters GetDiscreteInclusive(const FSchemaElement Element) const;
		FSchemaAndParameters GetAnd(const FSchemaElement Element) const;
		FSchemaOrExclusiveParameters GetOrExclusive(const FSchemaElement Element) const;
		FSchemaOrInclusiveParameters GetOrInclusive(const FSchemaElement Element) const;
		FSchemaArrayParameters GetArray(const FSchemaElement Element) const;
		FSchemaEncodingParameters GetEncoding(const FSchemaElement Element) const;

		// Checks if the given element is valid
		bool IsValid(const FSchemaElement Element) const;

		// Gets the type of the given element
		EType GetType(const FSchemaElement Element) const;

		// Gets the tag of the given element
		FName GetTag(const FSchemaElement Element) const;

		// Get the encoded vector size of the given element
		int32 GetEncodedVectorSize(const FSchemaElement Element) const;

		// Get the action vector size of the given element
		int32 GetActionVectorSize(const FSchemaElement Element) const;

		// Get the action distribution vector size of the given element
		int32 GetActionDistributionVectorSize(const FSchemaElement Element) const;

		// Get the current generation
		uint32 GetGeneration() const;
		
		// Empty all internal buffers of elements. This invalidates all existing elements.
		void Empty();

		// Reset all internal buffers (without freeing memory). This invalidates all existing elements.
		void Reset();

	private:

		struct FContinuousData
		{
			int32 Num = INDEX_NONE;
		};

		struct FDiscreteExclusiveData
		{
			int32 Num = INDEX_NONE;
			int32 PriorProbabilitiesOffset = INDEX_NONE;
		};

		struct FDiscreteInclusiveData
		{
			int32 Num = INDEX_NONE;
			int32 PriorProbabilitiesOffset = INDEX_NONE;
		};

		struct FAndData
		{
			int32 Num = INDEX_NONE;
			int32 ElementsOffset = INDEX_NONE;
		};

		struct FOrExclusiveData
		{
			int32 Num = INDEX_NONE;
			int32 ElementsOffset = INDEX_NONE;
			int32 PriorProbabilitiesOffset = INDEX_NONE;
		};

		struct FOrInclusiveData
		{
			int32 Num = INDEX_NONE;
			int32 ElementsOffset = INDEX_NONE;
			int32 PriorProbabilitiesOffset = INDEX_NONE;
		};

		struct FArrayData
		{
			int32 Num = INDEX_NONE;
			int32 ElementIndex = INDEX_NONE;
		};

		struct FEncodingData
		{
			int32 EncodingSize = INDEX_NONE;
			int32 ElementIndex = INDEX_NONE;
			int32 LayerNum = INDEX_NONE;
			EEncodingActivationFunction ActivationFunction = EEncodingActivationFunction::ELU;
		};

		uint32 Generation = 0;

		/** These have entries for each Schema Element */
		TArray<EType> Types;
		TArray<FName> Tags;
		TArray<int32> EncodedVectorSizes;
		TArray<int32> ActionVectorSizes;
		TArray<int32> ActionDistributionVectorSizes;
		TArray<int32> TypeDataIndices;

		/** These are indexed based on the type and the index found in TypeDataIndices */
		TArray<FContinuousData> ContinuousData;
		TArray<FDiscreteExclusiveData> DiscreteExclusiveData;
		TArray<FDiscreteInclusiveData> DiscreteInclusiveData;
		TArray<FAndData> AndData;
		TArray<FOrExclusiveData> OrExclusiveData;
		TArray<FOrInclusiveData> OrInclusiveData;
		TArray<FArrayData> ArrayData;
		TArray<FEncodingData> EncodingData;

		/** This is an array of all the SubElements and their names, referenced by other elements */
		TArray<FName> SubElementNames;
		TArray<FSchemaElement> SubElementObjects;

		/** This is an array of all the prior probabilities, referenced by other elements. */
		TArray<float> PriorProbabilities;
	};

	/**
	 * Action Object Element
	 *
	 * A single element in the action object representing part of an action. Internally this consists of a index used by the object to look up
	 * the associated action data and a generation id which can be used to check when this index is no longer valid.
	 */
	struct FObjectElement { int32 Index = INDEX_NONE; uint32 Generation = INDEX_NONE; };

	struct FObjectContinuousParameters
	{
		// Continuous action values
		TArrayView<const float> Values;
	};

	struct FObjectDiscreteExclusiveParameters
	{
		// Exclusive discrete action index
		int32 DiscreteIndex = INDEX_NONE;
	};

	struct FObjectDiscreteInclusiveParameters
	{
		// Inclusive discrete action indices
		TArrayView<const int32> DiscreteIndices;
	};

	struct FObjectAndParameters
	{
		// Names of the sub-actions.
		TArrayView<const FName> ElementNames;

		// The associated sub-elements.
		TArrayView<const FObjectElement> Elements;
	};

	struct FObjectOrExclusiveParameters
	{
		// Name of the chosen sub-action.
		FName ElementName;

		// The associated chosen sub-element.
		FObjectElement Element;
	};

	struct FObjectOrInclusiveParameters
	{
		// Names of the chosen sub-actions.
		TArrayView<const FName> ElementNames;

		// The associated chosen sub-elements.
		TArrayView<const FObjectElement> Elements;
	};

	struct FObjectArrayParameters
	{
		// Array of sub-elements.
		TArrayView<const FObjectElement> Elements;
	};

	struct FObjectEncodingParameters
	{
		// Encoded sub-element.
		FObjectElement Element;
	};

	/**
	 * Action Object
	 *
	 * This object allows you to construct or get data from an instance of an action you might have generated from a policy. Internally this object
	 * contains a pool of individual elements. This allows them to be constructed performantly and in a cache efficient way. This object is therefore
	 * required to access any data about the individual action elements that are created.
	 */
	struct LEARNING_API FObject
	{
		FObjectElement CreateNull(const FName Tag = NAME_None);
		FObjectElement CreateContinuous(const FObjectContinuousParameters Parameters, const FName Tag = NAME_None);
		FObjectElement CreateDiscreteExclusive(const FObjectDiscreteExclusiveParameters Parameters, const FName Tag = NAME_None);
		FObjectElement CreateDiscreteInclusive(const FObjectDiscreteInclusiveParameters Parameters, const FName Tag = NAME_None);
		FObjectElement CreateAnd(const FObjectAndParameters Parameters, const FName Tag = NAME_None);
		FObjectElement CreateOrExclusive(const FObjectOrExclusiveParameters Parameters, const FName Tag = NAME_None);
		FObjectElement CreateOrInclusive(const FObjectOrInclusiveParameters Parameters, const FName Tag = NAME_None);
		FObjectElement CreateArray(const FObjectArrayParameters Parameters, const FName Tag = NAME_None);
		FObjectElement CreateEncoding(const FObjectEncodingParameters Parameters, const FName Tag = NAME_None);

		FObjectContinuousParameters GetContinuous(const FObjectElement Element) const;
		FObjectDiscreteExclusiveParameters GetDiscreteExclusive(const FObjectElement Element) const;
		FObjectDiscreteInclusiveParameters GetDiscreteInclusive(const FObjectElement Element) const;
		FObjectAndParameters GetAnd(const FObjectElement Element) const;
		FObjectOrExclusiveParameters GetOrExclusive(const FObjectElement Element) const;
		FObjectOrInclusiveParameters GetOrInclusive(const FObjectElement Element) const;
		FObjectArrayParameters GetArray(const FObjectElement Element) const;
		FObjectEncodingParameters GetEncoding(const FObjectElement Element) const;

		// Checks if the given element is valid
		bool IsValid(const FObjectElement Element) const;

		// Gets the type of the given element
		EType GetType(const FObjectElement Element) const;

		// Gets the tag of the given element
		FName GetTag(const FObjectElement Element) const;

		// Get the current generation
		uint32 GetGeneration() const;

		// Empty all internal buffers of elements. This invalidates all existing elements.
		void Empty();

		// Reset all internal buffers (without freeing memory). This invalidates all existing elements.
		void Reset();

	private:

		uint32 Generation = 0;

		TArray<EType> Types;
		TArray<FName> Tags;
		TArray<int32> ContinuousDataOffsets;
		TArray<int32> ContinuousDataNums;
		TArray<int32> DiscreteDataOffsets;
		TArray<int32> DiscreteDataNums;
		TArray<int32> ElementDataOffsets;
		TArray<int32> ElementDataNums;

		TArray<float> ContinuousValues;
		TArray<int32> DiscreteValues;
		TArray<FName> SubElementNames;
		TArray<FObjectElement> SubElementObjects;
	};

	/**
	 * Gets a hash value representing object compatibility between schemas i.e. if objects from one schema can be used by objects expecting another 
	 * schema. This is not a cryptographic hash, and so `AreSchemaObjectsCompatible` should still be used as the ultimate source of truth.
	 * This function returns an int32 so that it can be used in blueprints.
	 * 
	 * @param Schema					Action Schema
	 * @param SchemaElement				Action Schema Element
	 * @param Salt						Hash salt
	 */
	LEARNING_API int32 GetSchemaObjectsCompatibilityHash(
		const FSchema& Schema,
		const FSchemaElement SchemaElement,
		const int32 Salt = 0x49710e77);

	/**
	 * Test if two schemas are compatible i.e. if objects from one schema can be used by objects expecting another schema. 
	 *
	 * @param SchemaA					First Schema
	 * @param SchemaElementA			First Schema Element
	 * @param SchemaB					Second Schema
	 * @param SchemaElementB			Second Schema Element
	 * @returns							true when the schemas are compatible
	 */
	LEARNING_API bool AreSchemaObjectsCompatible(
		const FSchema& SchemaA,
		const FSchemaElement SchemaElementA,
		const FSchema& SchemaB,
		const FSchemaElement SchemaElementB);

	/**
	 * Generate FileData for a Neural Network that can act as a Decoder for the given schema. This network will take as input a vector of size
	 * EncodedActionSize and produce a vector of size ActionDistributionVectorSize.
	 *
	 * @param OutFileData				Output File Data to write to
	 * @param OutInputSize				Size of the vector this network takes as input
	 * @param OutOutputSize				Size of the vector this network takes as output
	 * @param Schema					Action Schema
	 * @param SchemaElement				Action Schema Element
	 * @param Seed						The random seed used in initializing the network weights
	 */
	LEARNING_API void GenerateDecoderNetworkFileDataFromSchema(
		TArray<uint8>& OutFileData,
		uint32& OutInputSize,
		uint32& OutOutputSize,
		const FSchema& Schema,
		const FSchemaElement SchemaElement,
		const uint32 Seed = 0x05dbd1f5);

	/**
	 * Sample an action vector from a vector representing the action distribution.
	 *
	 * @param InOutSeed					Seed to use when sampling the action vector
	 * @param OutActionVector			Output action vector
	 * @param ActionDistributionVector	Input Action Distribution vector
	 * @param Schema					Action Schema
	 * @param SchemaElement				Action Schema Element
	 * @param ActionNoiseScale			Scale factor for the noise. Set this to zero to always choose the mean (expected) action.
	 */
	LEARNING_API void SampleVectorFromDistributionVector(
		uint32& InOutSeed,
		TLearningArrayView<1, float> OutActionVector,
		const TLearningArrayView<1, const float> ActionDistributionVector,
		const FSchema& Schema,
		const FSchemaElement SchemaElement,
		const float ActionNoiseScale = 1.0f);

	/**
	 * Convert an action object into an action vector.
	 *
	 * @param OutActionVector			Output action vector
	 * @param Schema					Action Schema
	 * @param SchemaElement				Action Schema Element
	 * @param Object					Action Object
	 * @param ObjectElement				Action Object Element
	 */
	LEARNING_API void SetVectorFromObject(
		TLearningArrayView<1, float> OutActionVector,
		const FSchema& Schema,
		const FSchemaElement SchemaElement,
		const FObject& Object,
		const FObjectElement ObjectElement);

	/**
	 * Convert an action vector into an action object
	 *
	 * @param OutObject					Output Action Object
	 * @param OutObjectElement			Output Action Object Element
	 * @param Schema					Action Schema
	 * @param SchemaElement				Action Schema Element
	 * @param ActionVector				Input Action vector
	 */
	LEARNING_API void GetObjectFromVector(
		FObject& OutObject,
		FObjectElement& OutObjectElement,
		const FSchema& Schema,
		const FSchemaElement SchemaElement,
		const TLearningArrayView<1, const float> ActionVector);
}