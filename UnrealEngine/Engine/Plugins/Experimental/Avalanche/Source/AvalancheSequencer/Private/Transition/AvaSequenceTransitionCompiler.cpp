// Copyright Epic Games, Inc. All Rights Reserved.

#include "AvaSequenceTransitionCompiler.h"
#include "AvaTransitionTreeEditorData.h"
#include "IAvaTransitionEditorModule.h"
#include "Tasks/AvaTransitionDelayTask.h"
#include "Tasks/AvaTransitionWaitForLayerTask.h"
#include "Transition/AvaTransitionInitializeSequence.h"
#include "Transition/AvaTransitionPlaySequenceTask.h"

#define LOCTEXT_NAMESPACE "AvaSequenceTransitionCompiler"

namespace UE::AvaSequencer::Private
{
	struct FPlayState
	{
		const UStateTreeState* State = nullptr;

		// Play Tasks pending to be updated. These are removed as their counterpart Init Tasks are added/updated
		TArray<const FStateTreeEditorNode*, TInlineAllocator<1>> PlayTaskNodes;

		int32 StateIndex = INDEX_NONE;
	};

	// Returns true if the state is recognized by this compiler to be a next state
	bool IsNextState(const UStateTreeState& InState)
	{
		// State transition must be only 1
		if (InState.Transitions.Num() != 1)
		{
			return false;
		}

		const FStateTreeTransition& Transition = InState.Transitions[0];

		// Must be enabled, set to trigger on state completed and transition to next selectable with no condition preventing it from transitioning
		return Transition.bTransitionEnabled
			&& Transition.Trigger == EStateTreeTransitionTrigger::OnStateCompleted
			&& Transition.State.LinkType == EStateTreeTransitionType::NextSelectableState
			&& Transition.Conditions.IsEmpty();
	}

	// note: This only checks for WaitForLayer/DelayTask. There could be Delayed Transitions,
	// or Transitions on an Event, etc that this does not account for.
	// This is only to cover these basic tasks. It's not meant to cover all possible cases
	bool IsWaitState(const UStateTreeState& InState)
	{
		return InState.Tasks.ContainsByPredicate([](const FStateTreeEditorNode& InNode)
		{
			const UScriptStruct* ScriptStruct = InNode.Node.GetScriptStruct();
			if (!ScriptStruct)
			{
				return false;
			}
			return ScriptStruct->IsChildOf(FAvaTransitionWaitForLayerTask::StaticStruct())
				|| ScriptStruct->IsChildOf(FAvaTransitionDelayTask::StaticStruct());
		});
	}

	void SetInitState(UStateTreeState& InInitState, const FPlayState& InPlayState)
	{
		InInitState.Modify();

		check(InPlayState.State);

		// Copy Enter Conditions of Play State (ensure a new ID is generated)
		InInitState.EnterConditions.Empty(InPlayState.State->EnterConditions.Num());
		for (const FStateTreeEditorNode& PlayEnterCondition : InPlayState.State->EnterConditions)
		{
			FStateTreeEditorNode& InitEnterCondition = InInitState.EnterConditions.Add_GetRef(PlayEnterCondition);
			InitEnterCondition.ID = FGuid::NewGuid();
		}

		// Set Transition to Next Selectable. These new Init states all go before a wait state, so it will never be set to "Tree Completed"
		InInitState.Transitions.Empty(1);
		InInitState.AddTransition(EStateTreeTransitionTrigger::OnStateCompleted, EStateTreeTransitionType::NextSelectableState);

		InInitState.Tasks.Empty(1);
		for (const FStateTreeEditorNode* PlayTaskNode : InPlayState.PlayTaskNodes)
		{
			if (PlayTaskNode)
			{
				const FAvaTransitionPlaySequenceTask& PlayTask = PlayTaskNode->Node.Get<FAvaTransitionPlaySequenceTask>();

				FAvaTransitionInitializeSequence& InitTask = InInitState.AddTask<FAvaTransitionInitializeSequence>().GetNode();
				InitTask.InitializeTime     = PlayTask.PlaySettings.Start;
				InitTask.PlayMode           = PlayTask.PlaySettings.PlayMode;
				InitTask.QueryType          = PlayTask.QueryType;
				InitTask.SequenceName       = PlayTask.SequenceName;
				InitTask.SequenceTag        = PlayTask.SequenceTag;
				InitTask.bPerformExactMatch = PlayTask.bPerformExactMatch;
			}
		}
	}
}

FAvaSequenceTransitionCompiler& FAvaSequenceTransitionCompiler::Get()
{
	static FAvaSequenceTransitionCompiler Instance;
	return Instance;
}

FAvaSequenceTransitionCompiler::FAvaSequenceTransitionCompiler()
	: AutogeneratedStateContext(FGuid(0x66DD5961, 0x12B24F60, 0x93E8E63D, 0x812B7E49), LOCTEXT("ContextLabel", "Motion Design Sequence Transition Compiler"))
{
}

void FAvaSequenceTransitionCompiler::Register()
{
	IAvaTransitionEditorModule::Get().GetOnCompileTransitionTree().AddRaw(this, &FAvaSequenceTransitionCompiler::OnCompileTransitionTree);
}

void FAvaSequenceTransitionCompiler::Unregister()
{
	if (IAvaTransitionEditorModule::IsLoaded())
	{
		IAvaTransitionEditorModule::Get().GetOnCompileTransitionTree().RemoveAll(this);
	}
}

void FAvaSequenceTransitionCompiler::OnCompileTransitionTree(UAvaTransitionTreeEditorData& InEditorData)
{
	CompileStatesRecursive(InEditorData, InEditorData.SubTrees);
}

void FAvaSequenceTransitionCompiler::CompileStatesRecursive(UAvaTransitionTreeEditorData& InEditorData, TArray<TObjectPtr<UStateTreeState>>& InStates)
{
	using namespace UE::AvaSequencer;

	// Remove invalid States
	InStates.RemoveAll(
		[](const UStateTreeState* InState)
		{
			return !IsValid(InState);
		});

	if (InStates.IsEmpty())
	{
		return;
	}

	// Recurse first as anything after this will aim towards adding new states which don't need to be recursively compiled
	for (UStateTreeState* State : InStates)
	{
		CompileStatesRecursive(InEditorData, State->Children);
	}

	// Do not compile any auto-generated nodes if the conditions are not 'right'... in that all the states must be set to next selectable (except the very last one)
	// Iterate from first state to the one before last. The Last state is already assumed to be a finishing state
	for (int32 StateIndex = 0; StateIndex < InStates.Num() - 1; ++StateIndex)
	{
		if (!Private::IsNextState(*InStates[StateIndex]))
		{
			return;
		}
	}

	TArray<Private::FPlayState> PlayStates;

	const UStateTreeState* WaitState = nullptr;
	int32 WaitStateIndex = INDEX_NONE;

	// Iterate Backwards: Gather the States with Play Sequence Tasks and keep track of the lowest indexed State with Delay/Wait
	for (int32 StateIndex = InStates.Num() - 1; StateIndex >= 0; --StateIndex)
	{
		const UStateTreeState* State = InStates[StateIndex];
		if (Private::IsWaitState(*State))
		{
			WaitState = State;
			WaitStateIndex = StateIndex;
		}

		Private::FPlayState PlayState;
		PlayState.State = State;
		PlayState.StateIndex = StateIndex;

		for (const FStateTreeEditorNode& Task : State->Tasks)
		{
			if (Task.Node.GetPtr<FAvaTransitionPlaySequenceTask>())
			{
				PlayState.PlayTaskNodes.Add(&Task);	
			}
		}

		if (!PlayState.PlayTaskNodes.IsEmpty())
		{
			PlayStates.Add(MoveTemp(PlayState));
		}
	}

	// No Wait State found. Nothing to compile. Return
	if (WaitStateIndex == INDEX_NONE)
	{
		return;
	}

	// Remove all the Play States that come prior to the Wait State Index
	// (they come before the waiting so they don't need to be initialized)
	PlayStates.RemoveAll(
		[WaitStateIndex](const Private::FPlayState& InPlayState)
		{
			return InPlayState.StateIndex <= WaitStateIndex;
		});

	// Since WaitStateIndex is valid, WaitState should also be
	check(WaitState);

	// Removes all the states from the provided index all the way to the Wait State Index
	auto CleanupUnusedStates = [this, &InStates, &InEditorData, WaitStateIndex](int32 InStateIndex)
	{
		TSet<UStateTreeState*> StatesToRemove;

		while (InStateIndex < WaitStateIndex)
		{
			UStateTreeState* UnhandledState = InStates[InStateIndex];
			if (InEditorData.IsAutogeneratedState(*UnhandledState, AutogeneratedStateContext))
			{
				StatesToRemove.Add(UnhandledState);
			}
			++InStateIndex;
		}

		InStates.RemoveAll(
			[&StatesToRemove](UStateTreeState* InState)
			{
				return StatesToRemove.Contains(InState);
			});
	
	};

	// If no play states are present, cleanup all the auto-generated states
	if (PlayStates.IsEmpty())
	{
		CleanupUnusedStates(0);
		return;
	}

	// Find existing Initialize Nodes and update them
	for (int32 StateIndex = 0; StateIndex < WaitStateIndex; ++StateIndex)
	{
		UStateTreeState& State = *InStates[StateIndex];

		// Skip if this State is not autogenerated by this Context
		if (!InEditorData.IsAutogeneratedState(State, AutogeneratedStateContext))
		{
			continue;
		}

		Private::SetInitState(State, PlayStates.Pop());

		// Break as there are no more Play States left. However, there could still be remaining previously generated states that are now unhandled and need to be removed
		if (PlayStates.IsEmpty())
		{
			CleanupUnusedStates(StateIndex + 1);
			break;
		}
	}

	while (!PlayStates.IsEmpty())
	{
		UStateTreeState& NewState = InEditorData.CreateState(*WaitState, /*bAfter*/false);
		InEditorData.SetAutogeneratedState(NewState.ID, AutogeneratedStateContext);
		Private::SetInitState(NewState, PlayStates.Pop());
	}

	// todo: at the moment, refresh is called even if all the states are up-to-date
	InEditorData.GetOnTreeRequestRefresh().Broadcast();
}

#undef LOCTEXT_NAMESPACE
