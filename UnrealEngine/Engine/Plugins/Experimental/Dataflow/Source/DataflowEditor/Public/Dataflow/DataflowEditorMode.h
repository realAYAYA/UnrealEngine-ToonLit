// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseCharacterFXEditorMode.h"
#include "Dataflow/DataflowContent.h"
#include "DataflowEditorMode.generated.h"

class UDataflowComponent;
class FDataflowConstructionScene;
class SDataflowGraphEditor;
class FDataflowEditorViewportClient;
class IDataflowEditorToolBuilder;
struct FManagedArrayCollection;
class UEdGraphNode;
class FViewport;


/**
 * The dataflow editor mode is the mode used in the cloth asset editor. It holds most of the inter-tool state.
 * We put things in a mode instead of directly into the asset editor in case we want to someday use the mode
 * in multiple asset editors.
 */
UCLASS(Transient)
class DATAFLOWEDITOR_API UDataflowEditorMode final : public UBaseCharacterFXEditorMode
{
	GENERATED_BODY()

public:

	const static FEditorModeID EM_DataflowEditorModeId;

	UDataflowEditorMode();

	/**
	* Gets the scene bounding box
	*/
	virtual FBox SceneBoundingBox() const override;

	// Bounding box for selected rest space mesh components
	FBox SelectionBoundingBox() const;

	/**
	* Gets the tool target requirements for the mode.
	*/
	static const FToolTargetTypeRequirements& GetToolTargetRequirements();

	/**
	* Construction View Mode
	*/
	void SetConstructionViewMode(Dataflow::EDataflowPatternVertexType InMode);
	Dataflow::EDataflowPatternVertexType GetConstructionViewMode() const;
	bool CanChangeConstructionViewModeTo(Dataflow::EDataflowPatternVertexType NewViewMode) const;

	void ToggleConstructionViewWireframe();
	bool CanSetConstructionViewWireframeActive() const;
	bool IsConstructionViewWireframeActive() const
	{
		return bConstructionViewWireframe;
	}

	/** Set the data flow preview scene to store the dynamic meshes generated by the tools */
	void SetDataflowConstructionScene(FDataflowConstructionScene* DataflowPreviewScene);
	const FDataflowConstructionScene* GetDataflowConstructionScene() const { return PreviewScene; }

	/** Set the data flow graph editor to create nodes once the tools have ended*/
	void SetDataflowGraphEditor(TSharedPtr<SDataflowGraphEditor> DataflowGraphEditor);

	TObjectPtr<UEditorInteractiveToolsContext> GetActiveToolsContext()
	{
		return ActiveToolsContext;
	}

private:
	friend class FDataflowEditorToolkit;
	friend class FDataflowEditorModeToolkit;

	// UEdMode
	virtual void Enter() final;
	virtual void Exit() override;
	virtual void ModeTick(float DeltaTime) override;
	virtual bool ShouldToolStartBeAllowed(const FString& ToolIdentifier) const override;
	virtual void OnToolStarted(UInteractiveToolManager* Manager, UInteractiveTool* Tool) override;
	virtual void OnToolEnded(UInteractiveToolManager* Manager, UInteractiveTool* Tool) override;
	virtual void CreateToolkit() override;
	virtual void BindCommands() override;


	// UBaseCharacterFXEditorMode
	virtual void AddToolTargetFactories() override;
	virtual void RegisterTools() override;
	virtual void CreateToolTargets(const TArray<TObjectPtr<UObject>>& AssetsIn) override;
	virtual void InitializeTargets(const TArray<TObjectPtr<UObject>>& AssetsIn) override;

	// Use this function to register tools rather than UEdMode::RegisterTool() because we need to specify the ToolsContext
	void RegisterDataflowTool(TSharedPtr<FUICommandInfo> UICommand,
							  FString ToolIdentifier,
							  UInteractiveToolBuilder* Builder,
							  const IDataflowEditorToolBuilder* DataflowToolBuilder,
							  UEditorInteractiveToolsContext* const ToolsContext,
							  EToolsContextScope ToolScope = EToolsContextScope::Default);

	void RegisterAddNodeCommand(TSharedPtr<FUICommandInfo> AddNodeCommand, const FName& NewNodeType, TSharedPtr<FUICommandInfo> StartToolCommand);

	void SetRestSpaceViewportClient(TWeakPtr<FDataflowEditorViewportClient, ESPMode::ThreadSafe> ViewportClient);
	void RefocusRestSpaceViewportClient();
	void FirstTimeFocusRestSpaceViewport();
	bool IsComponentSelected(const UPrimitiveComponent* InComponent);
	void StartToolForSelectedNode(const UObject* SelectedNode);
	void OnDataflowNodeDeleted(const TSet<UObject*>& DeletedNodes);

	/**
	* Return the single selected node in the Dataflow Graph Editor only if it has an output of the specified type
	* If there is not a single node selected, or if it does not have the specified output, return null
	*/
	UEdGraphNode* GetSingleSelectedNodeWithOutputType(const FName& SelectedNodeOutputTypeName) const;

	/**
	 * Create a node with the specified type in the graph
	*/
	UEdGraphNode* CreateNewNode(const FName& NewNodeTypeName);

	/** Create a node with the specified type, then connect it to the output of the specified UpstreamNode.
	* If the specified output of the upstream node is already connected to another node downstream, we first break
	* that connecttion, then insert the new node along the previous connection.
	* We want to turn this:
	*
	* [UpstreamNode] ----> [DownstreamNode(s)]
	*
	* to this:
	*
	* [UpstreamNode] ----> [NewNode] ----> [DownstreamNode(s)]
	*
	*
	* @param NewNodeTypeName The type of node to create, by name
	* @param UpstreamNode Node to connect the new node to
	* @param ConnectionTypeName The type of output of the upstream node to connect our new node to
	* @param NewNodeConnectionName The name of the input/output connection on our new node that will be connected
	* @return The newly-created node
	*/
	UEdGraphNode* CreateAndConnectNewNode(const FName& NewNodeTypeName, UEdGraphNode& UpstreamNode, const FName& ConnectionTypeName, const FName& NewNodeConnectionName);

	void InitializeContextObject();
	void DeleteContextObject();

	/** Dataflow preview scene from the toolkit */
	FDataflowConstructionScene* PreviewScene = nullptr;

	/** Correspondence between node types and commands to launch tools */
	TMap<FName, TSharedPtr<const FUICommandInfo>> NodeTypeToToolCommandMap;

	/** Graph editor is required to add nodes once some tools are complete */
	TWeakPtr<SDataflowGraphEditor> DataflowGraphEditor;

	Dataflow::EDataflowPatternVertexType ConstructionViewMode = Dataflow::EDataflowPatternVertexType::Sim3D;

	// Whether we should restore the previous view mode when a tool ends
	bool bShouldRestoreSavedConstructionViewMode = false;
	
	// The Construction view mode that was active before starting the current tool. When the tool ends, restore this view mode if bShouldRestoreSavedConstructionViewMode is true.
	Dataflow::EDataflowPatternVertexType SavedConstructionViewMode;

	bool bConstructionViewWireframe = false;
	bool bShouldRestoreConstructionViewWireframe = false;

	UPROPERTY()
	TObjectPtr<UEditorInteractiveToolsContext> ActiveToolsContext = nullptr;

	TWeakPtr<FDataflowEditorViewportClient, ESPMode::ThreadSafe> ConstructionViewportClient;

	// The first time we get a valid mesh, refocus the camera on it
	bool bFirstValid2DMesh = true;
	bool bFirstValid3DMesh = true;

	// Whether the rest space viewport should focus on the rest space mesh on the next tick
	bool bShouldFocusRestSpaceView = true;

	//@todo(brice) : Move to Construction
	void RestSpaceViewportResized(FViewport* RestspaceViewport, uint32 Unused);

	// Dataflow node type whose corresponding tool should be started on the next Tick
	FName NodeTypeForPendingToolStart;


};

