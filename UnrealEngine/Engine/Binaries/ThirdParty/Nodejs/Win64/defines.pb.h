// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: defines.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_defines_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_defines_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_defines_2eproto ZPROTOCOL_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct ZPROTOCOL_API TableStruct_defines_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
ZPROTOCOL_API extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_defines_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace idlezt {

enum ItemQuality : int {
  EQ_None = 0,
  EQ_White = 1,
  EQ_Green = 2,
  EQ_Blue = 3,
  EQ_Purple = 4,
  EQ_Orange = 5,
  EQ_Red = 6,
  ItemQuality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemQuality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool ItemQuality_IsValid(int value);
constexpr ItemQuality ItemQuality_MIN = EQ_None;
constexpr ItemQuality ItemQuality_MAX = EQ_Red;
constexpr int ItemQuality_ARRAYSIZE = ItemQuality_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemQuality_descriptor();
template<typename T>
inline const std::string& ItemQuality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemQuality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemQuality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemQuality_descriptor(), enum_t_value);
}
inline bool ItemQuality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemQuality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemQuality>(
    ItemQuality_descriptor(), name, value);
}
enum ItemShowType : int {
  ItemShowType_None = 0,
  ItemShowType_Equipment = 1,
  ItemShowType_Pill = 2,
  ItemShowType_Material = 3,
  ItemShowType_Special = 4,
  ItemShowType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemShowType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool ItemShowType_IsValid(int value);
constexpr ItemShowType ItemShowType_MIN = ItemShowType_None;
constexpr ItemShowType ItemShowType_MAX = ItemShowType_Special;
constexpr int ItemShowType_ARRAYSIZE = ItemShowType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemShowType_descriptor();
template<typename T>
inline const std::string& ItemShowType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemShowType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemShowType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemShowType_descriptor(), enum_t_value);
}
inline bool ItemShowType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemShowType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemShowType>(
    ItemShowType_descriptor(), name, value);
}
enum ItemType : int {
  ItemType_None = 0,
  ItemType_ExpPill = 1,
  ItemType_Weapon = 2,
  ItemType_CLOTHING = 3,
  ItemType_JEWELRY = 4,
  ItemType_SkillEquipment = 5,
  ItemType_RecoverPill = 6,
  ItemType_SkillBook = 7,
  ItemType_SecretPill = 8,
  ItemType_AttrPill = 9,
  ItemType_BreakthroughPill = 10,
  ItemType_PillMaterial = 11,
  ItemType_WeaponMaterial = 12,
  ItemType_PillRecipe = 13,
  ItemType_EquipRecipe = 14,
  ItemType_ForgeMaterial = 15,
  ItemType_GiftPackage = 16,
  ItemType_SpaceMaterial = 17,
  ItemType_ShanHeTu = 20,
  ItemType_QiWen = 21,
  ItemType_QiLing = 22,
  ItemType_QiLingSkill = 25,
  ItemType_Token = 100,
  ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool ItemType_IsValid(int value);
constexpr ItemType ItemType_MIN = ItemType_None;
constexpr ItemType ItemType_MAX = ItemType_Token;
constexpr int ItemType_ARRAYSIZE = ItemType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemType_descriptor();
template<typename T>
inline const std::string& ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemType_descriptor(), enum_t_value);
}
inline bool ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemType>(
    ItemType_descriptor(), name, value);
}
enum EquipmentMainType : int {
  EquipmentMainType_None = 0,
  EquipmentMainType_Weapon = 1,
  EquipmentMainType_CLOTHING = 2,
  EquipmentMainType_JEWELRY = 3,
  EquipmentMainType_AttSkillEquipment = 4,
  EquipmentMainType_DefSkillEquipment = 5,
  EquipmentMainType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EquipmentMainType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool EquipmentMainType_IsValid(int value);
constexpr EquipmentMainType EquipmentMainType_MIN = EquipmentMainType_None;
constexpr EquipmentMainType EquipmentMainType_MAX = EquipmentMainType_DefSkillEquipment;
constexpr int EquipmentMainType_ARRAYSIZE = EquipmentMainType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EquipmentMainType_descriptor();
template<typename T>
inline const std::string& EquipmentMainType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EquipmentMainType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EquipmentMainType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EquipmentMainType_descriptor(), enum_t_value);
}
inline bool EquipmentMainType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EquipmentMainType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EquipmentMainType>(
    EquipmentMainType_descriptor(), name, value);
}
enum PerkValueAddType : int {
  PerkValueAddType_None = 0,
  PerkValueAddType_Add = 1,
  PerkValueAddType_Sub = 2,
  PerkValueAddType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PerkValueAddType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool PerkValueAddType_IsValid(int value);
constexpr PerkValueAddType PerkValueAddType_MIN = PerkValueAddType_None;
constexpr PerkValueAddType PerkValueAddType_MAX = PerkValueAddType_Sub;
constexpr int PerkValueAddType_ARRAYSIZE = PerkValueAddType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerkValueAddType_descriptor();
template<typename T>
inline const std::string& PerkValueAddType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PerkValueAddType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PerkValueAddType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PerkValueAddType_descriptor(), enum_t_value);
}
inline bool PerkValueAddType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PerkValueAddType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerkValueAddType>(
    PerkValueAddType_descriptor(), name, value);
}
enum PerkValueEffectType : int {
  PerkValueEffectType_None = 0,
  PerkValueEffectType_EquipmentBasicAttribute = 1,
  PerkValueEffectType_Attack = 2,
  PerkValueEffectType_HpMp = 3,
  PerkValueEffectType_Defence = 4,
  PerkValueEffectType_CritAndCritDef = 5,
  PerkValueEffectType_CritCoeff = 6,
  PerkValueEffectType_StrengthIntellect = 7,
  PerkValueEffectType_RecoverPercent = 8,
  PerkValueEffectType_Agility = 9,
  PerkValueEffectType_DodgeHit = 10,
  PerkValueEffectType_MoveSpeed = 11,
  PerkValueEffectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PerkValueEffectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool PerkValueEffectType_IsValid(int value);
constexpr PerkValueEffectType PerkValueEffectType_MIN = PerkValueEffectType_None;
constexpr PerkValueEffectType PerkValueEffectType_MAX = PerkValueEffectType_MoveSpeed;
constexpr int PerkValueEffectType_ARRAYSIZE = PerkValueEffectType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerkValueEffectType_descriptor();
template<typename T>
inline const std::string& PerkValueEffectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PerkValueEffectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PerkValueEffectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PerkValueEffectType_descriptor(), enum_t_value);
}
inline bool PerkValueEffectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PerkValueEffectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerkValueEffectType>(
    PerkValueEffectType_descriptor(), name, value);
}
enum PerkIdConsts : int {
  PerkIdConsts_None = 0,
  PerkIdConsts_EquipmentBasicAttribute = 1,
  PerkIdConsts_MagAttack = 2,
  PerkIdConsts_PhyAttack = 3,
  PerkIdConsts_Hp = 4,
  PerkIdConsts_Mp = 5,
  PerkIdConsts_PhyDefence = 6,
  PerkIdConsts_MagDefence = 7,
  PerkIdConsts_Crit = 8,
  PerkIdConsts_CritCoeff = 9,
  PerkIdConsts_Strength = 11,
  PerkIdConsts_Intellect = 12,
  PerkIdConsts_MpRecoverPercent = 13,
  PerkIdConsts_HpRecoverPercent = 14,
  PerkIdConsts_Agility = 15,
  PerkIdConsts_MagDodge = 16,
  PerkIdConsts_PhyDodge = 17,
  PerkIdConsts_CritDef = 18,
  PerkIdConsts_PhyHit = 19,
  PerkIdConsts_MagHit = 20,
  PerkIdConsts_MoveSpeed = 25,
  PerkIdConsts_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PerkIdConsts_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool PerkIdConsts_IsValid(int value);
constexpr PerkIdConsts PerkIdConsts_MIN = PerkIdConsts_None;
constexpr PerkIdConsts PerkIdConsts_MAX = PerkIdConsts_MoveSpeed;
constexpr int PerkIdConsts_ARRAYSIZE = PerkIdConsts_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerkIdConsts_descriptor();
template<typename T>
inline const std::string& PerkIdConsts_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PerkIdConsts>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PerkIdConsts_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PerkIdConsts_descriptor(), enum_t_value);
}
inline bool PerkIdConsts_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PerkIdConsts* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerkIdConsts>(
    PerkIdConsts_descriptor(), name, value);
}
enum EquipmentSlotState : int {
  EquipmentSlotState_Locked = 0,
  EquipmentSlotState_ToUnlock = 1,
  EquipmentSlotState_UnlockNoEquip = 2,
  EquipmentSlotState_UnlockEquipInBag = 3,
  EquipmentSlotState_Slotted = 4,
  EquipmentSlotState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EquipmentSlotState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool EquipmentSlotState_IsValid(int value);
constexpr EquipmentSlotState EquipmentSlotState_MIN = EquipmentSlotState_Locked;
constexpr EquipmentSlotState EquipmentSlotState_MAX = EquipmentSlotState_Slotted;
constexpr int EquipmentSlotState_ARRAYSIZE = EquipmentSlotState_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EquipmentSlotState_descriptor();
template<typename T>
inline const std::string& EquipmentSlotState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EquipmentSlotState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EquipmentSlotState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EquipmentSlotState_descriptor(), enum_t_value);
}
inline bool EquipmentSlotState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EquipmentSlotState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EquipmentSlotState>(
    EquipmentSlotState_descriptor(), name, value);
}
enum AlchemyChanceType : int {
  AlchemyChanceType_Normal = 0,
  AlchemyChanceType_Small = 1,
  AlchemyChanceType_Big = 2,
  AlchemyChanceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AlchemyChanceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool AlchemyChanceType_IsValid(int value);
constexpr AlchemyChanceType AlchemyChanceType_MIN = AlchemyChanceType_Normal;
constexpr AlchemyChanceType AlchemyChanceType_MAX = AlchemyChanceType_Big;
constexpr int AlchemyChanceType_ARRAYSIZE = AlchemyChanceType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AlchemyChanceType_descriptor();
template<typename T>
inline const std::string& AlchemyChanceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AlchemyChanceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AlchemyChanceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AlchemyChanceType_descriptor(), enum_t_value);
}
inline bool AlchemyChanceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AlchemyChanceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AlchemyChanceType>(
    AlchemyChanceType_descriptor(), name, value);
}
enum PillType : int {
  PillType_None = 0,
  PillType_Hp = 1,
  PillType_Mp = 2,
  PillType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PillType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool PillType_IsValid(int value);
constexpr PillType PillType_MIN = PillType_None;
constexpr PillType PillType_MAX = PillType_Mp;
constexpr int PillType_ARRAYSIZE = PillType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PillType_descriptor();
template<typename T>
inline const std::string& PillType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PillType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PillType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PillType_descriptor(), enum_t_value);
}
inline bool PillType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PillType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PillType>(
    PillType_descriptor(), name, value);
}
enum CultivationDirection : int {
  CD_None = 0,
  CD_Physic = 1,
  CD_Magic = 2,
  CultivationDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CultivationDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool CultivationDirection_IsValid(int value);
constexpr CultivationDirection CultivationDirection_MIN = CD_None;
constexpr CultivationDirection CultivationDirection_MAX = CD_Magic;
constexpr int CultivationDirection_ARRAYSIZE = CultivationDirection_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CultivationDirection_descriptor();
template<typename T>
inline const std::string& CultivationDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CultivationDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CultivationDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CultivationDirection_descriptor(), enum_t_value);
}
inline bool CultivationDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CultivationDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CultivationDirection>(
    CultivationDirection_descriptor(), name, value);
}
enum BreakthroughType : int {
  BT_None = 0,
  BT_Layer = 1,
  BT_Stage = 2,
  BT_Degree = 3,
  BreakthroughType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BreakthroughType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool BreakthroughType_IsValid(int value);
constexpr BreakthroughType BreakthroughType_MIN = BT_None;
constexpr BreakthroughType BreakthroughType_MAX = BT_Degree;
constexpr int BreakthroughType_ARRAYSIZE = BreakthroughType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BreakthroughType_descriptor();
template<typename T>
inline const std::string& BreakthroughType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BreakthroughType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BreakthroughType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BreakthroughType_descriptor(), enum_t_value);
}
inline bool BreakthroughType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BreakthroughType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BreakthroughType>(
    BreakthroughType_descriptor(), name, value);
}
enum WorldType : int {
  WT_None = 0,
  WT_ClientOnly = 1,
  WT_Arena = 2,
  WT_Door = 3,
  WT_MonsterTower = 4,
  WT_SoloArena = 5,
  WT_SeptArena = 6,
  WorldType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WorldType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool WorldType_IsValid(int value);
constexpr WorldType WorldType_MIN = WT_None;
constexpr WorldType WorldType_MAX = WT_SeptArena;
constexpr int WorldType_ARRAYSIZE = WorldType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorldType_descriptor();
template<typename T>
inline const std::string& WorldType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorldType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorldType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorldType_descriptor(), enum_t_value);
}
inline bool WorldType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorldType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorldType>(
    WorldType_descriptor(), name, value);
}
enum EntityType : int {
  ET_Unknown = 0,
  ET_Player = 1,
  ET_Npc = 2,
  EntityType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EntityType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool EntityType_IsValid(int value);
constexpr EntityType EntityType_MIN = ET_Unknown;
constexpr EntityType EntityType_MAX = ET_Npc;
constexpr int EntityType_ARRAYSIZE = EntityType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntityType_descriptor();
template<typename T>
inline const std::string& EntityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EntityType_descriptor(), enum_t_value);
}
inline bool EntityType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EntityType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EntityType>(
    EntityType_descriptor(), name, value);
}
enum EntityState : int {
  ES_None = 0,
  ES_Init = 1,
  ES_Normal = 2,
  ES_Death = 3,
  ES_Recycle = 4,
  EntityState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EntityState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool EntityState_IsValid(int value);
constexpr EntityState EntityState_MIN = ES_None;
constexpr EntityState EntityState_MAX = ES_Recycle;
constexpr int EntityState_ARRAYSIZE = EntityState_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntityState_descriptor();
template<typename T>
inline const std::string& EntityState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntityState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntityState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EntityState_descriptor(), enum_t_value);
}
inline bool EntityState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EntityState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EntityState>(
    EntityState_descriptor(), name, value);
}
enum NpcType : int {
  NpcType_None = 0,
  NpcType_Function = 1,
  NpcType_Monster = 2,
  NpcType_SeptStone = 3,
  NpcType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NpcType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool NpcType_IsValid(int value);
constexpr NpcType NpcType_MIN = NpcType_None;
constexpr NpcType NpcType_MAX = NpcType_SeptStone;
constexpr int NpcType_ARRAYSIZE = NpcType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NpcType_descriptor();
template<typename T>
inline const std::string& NpcType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NpcType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NpcType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NpcType_descriptor(), enum_t_value);
}
inline bool NpcType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NpcType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NpcType>(
    NpcType_descriptor(), name, value);
}
enum MonsterType : int {
  MonsterType_None = 0,
  MonsterType_Normal = 1,
  MonsterType_Elite = 2,
  MonsterType_Chief = 3,
  MonsterType_SuperBoss = 4,
  MonsterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MonsterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool MonsterType_IsValid(int value);
constexpr MonsterType MonsterType_MIN = MonsterType_None;
constexpr MonsterType MonsterType_MAX = MonsterType_SuperBoss;
constexpr int MonsterType_ARRAYSIZE = MonsterType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MonsterType_descriptor();
template<typename T>
inline const std::string& MonsterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MonsterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MonsterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MonsterType_descriptor(), enum_t_value);
}
inline bool MonsterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MonsterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MonsterType>(
    MonsterType_descriptor(), name, value);
}
enum CurrencyType : int {
  CurrencyType_None = 0,
  CurrencyType_Money = 1,
  CurrencyType_Soul = 2,
  CurrencyType_Gold = 3,
  CurrencyType_Item = 4,
  CurrencyType_AbilityActivePoint = 5,
  CurrencyType_AbilityUpgradePoint = 6,
  CurrencyType_KungfuPoint = 7,
  CurrencyType_TreasureToken = 8,
  CurrencyType_ChaosStone = 9,
  CurrencyType_StudyPoint = 10,
  CurrencyType_NingWenGem = 11,
  CurrencyType_HeroCard = 12,
  CurrencyType_SeptDonation = 13,
  CurrencyType_SeptStone = 14,
  CurrencyType_SeptQuestExp = 15,
  CurrencyType_SeptQuestToken = 16,
  CurrencyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CurrencyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool CurrencyType_IsValid(int value);
constexpr CurrencyType CurrencyType_MIN = CurrencyType_None;
constexpr CurrencyType CurrencyType_MAX = CurrencyType_SeptQuestToken;
constexpr int CurrencyType_ARRAYSIZE = CurrencyType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CurrencyType_descriptor();
template<typename T>
inline const std::string& CurrencyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CurrencyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CurrencyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CurrencyType_descriptor(), enum_t_value);
}
inline bool CurrencyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CurrencyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CurrencyType>(
    CurrencyType_descriptor(), name, value);
}
enum SoloType : int {
  SoloType_None = 0,
  SoloType_FriendlyPk = 1,
  SoloType_SwordPk = 2,
  SoloType_SwordPkRevenge = 3,
  SoloType_RobberySeptStone = 4,
  SoloType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SoloType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool SoloType_IsValid(int value);
constexpr SoloType SoloType_MIN = SoloType_None;
constexpr SoloType SoloType_MAX = SoloType_RobberySeptStone;
constexpr int SoloType_ARRAYSIZE = SoloType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SoloType_descriptor();
template<typename T>
inline const std::string& SoloType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SoloType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SoloType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SoloType_descriptor(), enum_t_value);
}
inline bool SoloType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SoloType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SoloType>(
    SoloType_descriptor(), name, value);
}
enum QuestRequirementType : int {
  QT_Kill = 0,
  QT_Get = 1,
  QT_Submit = 2,
  QT_Rank = 3,
  QT_Event = 4,
  QT_Alchemy = 5,
  QT_AlchemyRank = 6,
  QT_SkillRank = 7,
  QT_Forge = 8,
  QT_ForgeRank = 9,
  QT_ArenaDoor = 10,
  QT_MonsterTower = 11,
  QT_QiCollector = 12,
  QuestRequirementType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QuestRequirementType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool QuestRequirementType_IsValid(int value);
constexpr QuestRequirementType QuestRequirementType_MIN = QT_Kill;
constexpr QuestRequirementType QuestRequirementType_MAX = QT_QiCollector;
constexpr int QuestRequirementType_ARRAYSIZE = QuestRequirementType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestRequirementType_descriptor();
template<typename T>
inline const std::string& QuestRequirementType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestRequirementType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestRequirementType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestRequirementType_descriptor(), enum_t_value);
}
inline bool QuestRequirementType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestRequirementType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestRequirementType>(
    QuestRequirementType_descriptor(), name, value);
}
enum QuestOpType : int {
  QOp_Accept = 0,
  QOp_Finish = 1,
  QuestOpType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QuestOpType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool QuestOpType_IsValid(int value);
constexpr QuestOpType QuestOpType_MIN = QOp_Accept;
constexpr QuestOpType QuestOpType_MAX = QOp_Finish;
constexpr int QuestOpType_ARRAYSIZE = QuestOpType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestOpType_descriptor();
template<typename T>
inline const std::string& QuestOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestOpType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestOpType_descriptor(), enum_t_value);
}
inline bool QuestOpType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestOpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestOpType>(
    QuestOpType_descriptor(), name, value);
}
enum LeaderboardType : int {
  LBT_Combat = 0,
  LBT_Magic = 1,
  LBT_Phy = 2,
  LBT_Rich = 3,
  LBT_Pet = 4,
  LBT_Sect = 5,
  LBT_Weapon = 6,
  LBT_Armor = 7,
  LBT_Jewelry = 8,
  LBT_Treasure = 9,
  LBT_Shanhetu = 10,
  LBT_Shanhetu_Week = 11,
  LBT_MaxNum = 12,
  LeaderboardType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LeaderboardType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool LeaderboardType_IsValid(int value);
constexpr LeaderboardType LeaderboardType_MIN = LBT_Combat;
constexpr LeaderboardType LeaderboardType_MAX = LBT_MaxNum;
constexpr int LeaderboardType_ARRAYSIZE = LeaderboardType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LeaderboardType_descriptor();
template<typename T>
inline const std::string& LeaderboardType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeaderboardType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeaderboardType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LeaderboardType_descriptor(), enum_t_value);
}
inline bool LeaderboardType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeaderboardType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LeaderboardType>(
    LeaderboardType_descriptor(), name, value);
}
enum AlchemyState : int {
  AlchemyState_None = 0,
  AlchemyState_Running = 1,
  AlchemyState_Done = 2,
  AlchemyState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AlchemyState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool AlchemyState_IsValid(int value);
constexpr AlchemyState AlchemyState_MIN = AlchemyState_None;
constexpr AlchemyState AlchemyState_MAX = AlchemyState_Done;
constexpr int AlchemyState_ARRAYSIZE = AlchemyState_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AlchemyState_descriptor();
template<typename T>
inline const std::string& AlchemyState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AlchemyState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AlchemyState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AlchemyState_descriptor(), enum_t_value);
}
inline bool AlchemyState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AlchemyState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AlchemyState>(
    AlchemyState_descriptor(), name, value);
}
enum WorldState : int {
  WS_None = 0,
  WS_Init = 1,
  WS_Normal = 2,
  WS_Closing = 3,
  WS_Recycle = 4,
  WorldState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WorldState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool WorldState_IsValid(int value);
constexpr WorldState WorldState_MIN = WS_None;
constexpr WorldState WorldState_MAX = WS_Recycle;
constexpr int WorldState_ARRAYSIZE = WorldState_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorldState_descriptor();
template<typename T>
inline const std::string& WorldState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorldState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorldState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorldState_descriptor(), enum_t_value);
}
inline bool WorldState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorldState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorldState>(
    WorldState_descriptor(), name, value);
}
enum FunctionModuleState : int {
  FMS_Hide = 0,
  FMS_Show = 1,
  FMS_CanUnlock = 2,
  FMS_Unlocked = 3,
  FunctionModuleState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FunctionModuleState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool FunctionModuleState_IsValid(int value);
constexpr FunctionModuleState FunctionModuleState_MIN = FMS_Hide;
constexpr FunctionModuleState FunctionModuleState_MAX = FMS_Unlocked;
constexpr int FunctionModuleState_ARRAYSIZE = FunctionModuleState_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FunctionModuleState_descriptor();
template<typename T>
inline const std::string& FunctionModuleState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FunctionModuleState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FunctionModuleState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FunctionModuleState_descriptor(), enum_t_value);
}
inline bool FunctionModuleState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FunctionModuleState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FunctionModuleState>(
    FunctionModuleState_descriptor(), name, value);
}
enum FunctionModuleType : int {
  FMT_None = 0,
  FMT_Alchemy = 1,
  FMT_Shop = 2,
  FMT_DeluxShop = 3,
  FMT_Leaderboard = 4,
  FMT_Mail = 5,
  FMT_Forge = 6,
  FMT_MonsterTower = 7,
  FMT_PillElixir = 8,
  FMT_Ability = 9,
  FMT_GuBao = 10,
  FMT_GongFa = 11,
  FMT_Share = 12,
  FMT_HuangZhuang = 13,
  FMT_ZhuangPei = 14,
  FMT_QiCollector = 15,
  FMT_Checklist = 16,
  FMT_SwordPk = 17,
  FunctionModuleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FunctionModuleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool FunctionModuleType_IsValid(int value);
constexpr FunctionModuleType FunctionModuleType_MIN = FMT_None;
constexpr FunctionModuleType FunctionModuleType_MAX = FMT_SwordPk;
constexpr int FunctionModuleType_ARRAYSIZE = FunctionModuleType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FunctionModuleType_descriptor();
template<typename T>
inline const std::string& FunctionModuleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FunctionModuleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FunctionModuleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FunctionModuleType_descriptor(), enum_t_value);
}
inline bool FunctionModuleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FunctionModuleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FunctionModuleType>(
    FunctionModuleType_descriptor(), name, value);
}
enum MailType : int {
  MT_System = 0,
  MT_Maintenance = 1,
  MT_Official = 2,
  MailType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MailType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool MailType_IsValid(int value);
constexpr MailType MailType_MIN = MT_System;
constexpr MailType MailType_MAX = MT_Official;
constexpr int MailType_ARRAYSIZE = MailType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MailType_descriptor();
template<typename T>
inline const std::string& MailType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MailType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MailType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MailType_descriptor(), enum_t_value);
}
inline bool MailType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MailType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MailType>(
    MailType_descriptor(), name, value);
}
enum MailOperation : int {
  MOP_Fail = 0,
  MOP_Done = 1,
  MOP_InventoryIsFull = 2,
  MailOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MailOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool MailOperation_IsValid(int value);
constexpr MailOperation MailOperation_MIN = MOP_Fail;
constexpr MailOperation MailOperation_MAX = MOP_InventoryIsFull;
constexpr int MailOperation_ARRAYSIZE = MailOperation_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MailOperation_descriptor();
template<typename T>
inline const std::string& MailOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MailOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MailOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MailOperation_descriptor(), enum_t_value);
}
inline bool MailOperation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MailOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MailOperation>(
    MailOperation_descriptor(), name, value);
}
enum ChatMessageType : int {
  CMT_Normal = 0,
  CMT_SystemNotice = 1,
  ChatMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool ChatMessageType_IsValid(int value);
constexpr ChatMessageType ChatMessageType_MIN = CMT_Normal;
constexpr ChatMessageType ChatMessageType_MAX = CMT_SystemNotice;
constexpr int ChatMessageType_ARRAYSIZE = ChatMessageType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatMessageType_descriptor();
template<typename T>
inline const std::string& ChatMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatMessageType_descriptor(), enum_t_value);
}
inline bool ChatMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatMessageType>(
    ChatMessageType_descriptor(), name, value);
}
enum ChatMessageChannel : int {
  CMC_ColonyServers = 0,
  CMC_QuadServers = 1,
  CMC_LocalServer = 2,
  CMC_Organization = 3,
  CMC_Private = 4,
  ChatMessageChannel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatMessageChannel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool ChatMessageChannel_IsValid(int value);
constexpr ChatMessageChannel ChatMessageChannel_MIN = CMC_ColonyServers;
constexpr ChatMessageChannel ChatMessageChannel_MAX = CMC_Private;
constexpr int ChatMessageChannel_ARRAYSIZE = ChatMessageChannel_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatMessageChannel_descriptor();
template<typename T>
inline const std::string& ChatMessageChannel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatMessageChannel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatMessageChannel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatMessageChannel_descriptor(), enum_t_value);
}
inline bool ChatMessageChannel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatMessageChannel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatMessageChannel>(
    ChatMessageChannel_descriptor(), name, value);
}
enum ForgeChanceType : int {
  ForgeChanceType_Normal = 0,
  ForgeChanceType_Small = 1,
  ForgeChanceType_Big = 2,
  ForgeChanceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ForgeChanceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool ForgeChanceType_IsValid(int value);
constexpr ForgeChanceType ForgeChanceType_MIN = ForgeChanceType_Normal;
constexpr ForgeChanceType ForgeChanceType_MAX = ForgeChanceType_Big;
constexpr int ForgeChanceType_ARRAYSIZE = ForgeChanceType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ForgeChanceType_descriptor();
template<typename T>
inline const std::string& ForgeChanceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ForgeChanceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ForgeChanceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ForgeChanceType_descriptor(), enum_t_value);
}
inline bool ForgeChanceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ForgeChanceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ForgeChanceType>(
    ForgeChanceType_descriptor(), name, value);
}
enum ForgeState : int {
  ForgeState_None = 0,
  ForgeState_Running = 1,
  ForgeState_Done = 2,
  ForgeState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ForgeState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool ForgeState_IsValid(int value);
constexpr ForgeState ForgeState_MIN = ForgeState_None;
constexpr ForgeState ForgeState_MAX = ForgeState_Done;
constexpr int ForgeState_ARRAYSIZE = ForgeState_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ForgeState_descriptor();
template<typename T>
inline const std::string& ForgeState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ForgeState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ForgeState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ForgeState_descriptor(), enum_t_value);
}
inline bool ForgeState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ForgeState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ForgeState>(
    ForgeState_descriptor(), name, value);
}
enum PillElixirType : int {
  PillElixirType_Other = 0,
  PillElixirType_Exp = 1,
  PillElixirType_Property = 2,
  PillElixirType_Double = 3,
  PillElixirType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PillElixirType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool PillElixirType_IsValid(int value);
constexpr PillElixirType PillElixirType_MIN = PillElixirType_Other;
constexpr PillElixirType PillElixirType_MAX = PillElixirType_Double;
constexpr int PillElixirType_ARRAYSIZE = PillElixirType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PillElixirType_descriptor();
template<typename T>
inline const std::string& PillElixirType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PillElixirType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PillElixirType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PillElixirType_descriptor(), enum_t_value);
}
inline bool PillElixirType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PillElixirType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PillElixirType>(
    PillElixirType_descriptor(), name, value);
}
enum PillElixrEffectType : int {
  PillElixrEffectType_None = 0,
  PillElixrEffectType_PhyExp = 1,
  PillElixrEffectType_MagicExp = 2,
  PillElixrEffectType_CriticalResist = 3,
  PillElixrEffectType_Critical = 4,
  PillElixrEffectType_MagicDodge = 5,
  PillElixrEffectType_MagicAccuraccy = 6,
  PillElixrEffectType_PhyDodge = 7,
  PillElixrEffectType_PhyAccuraccy = 8,
  PillElixrEffectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PillElixrEffectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool PillElixrEffectType_IsValid(int value);
constexpr PillElixrEffectType PillElixrEffectType_MIN = PillElixrEffectType_None;
constexpr PillElixrEffectType PillElixrEffectType_MAX = PillElixrEffectType_PhyAccuraccy;
constexpr int PillElixrEffectType_ARRAYSIZE = PillElixrEffectType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PillElixrEffectType_descriptor();
template<typename T>
inline const std::string& PillElixrEffectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PillElixrEffectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PillElixrEffectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PillElixrEffectType_descriptor(), enum_t_value);
}
inline bool PillElixrEffectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PillElixrEffectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PillElixrEffectType>(
    PillElixrEffectType_descriptor(), name, value);
}
enum PlayerAbilityActionResult : int {
  PlayerAbilityAction_Success = 0,
  PlayerAbilityAction_Timeout = 1,
  PlayerAbilityAction_InvalidAbility = 2,
  PlayerAbilityAction_GiveFailed_ExistAlready = 10,
  PlayerAbilityAction_GiveFailed_OwnerFailed = 11,
  PlayerAbilityAction_UpgradeFailed_NonExist = 20,
  PlayerAbilityAction_UpgradeFailed_MaxGrade = 21,
  PlayerAbilityAction_UpgradeFailed_OwnerFailed = 22,
  PlayerAbilityActionResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlayerAbilityActionResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool PlayerAbilityActionResult_IsValid(int value);
constexpr PlayerAbilityActionResult PlayerAbilityActionResult_MIN = PlayerAbilityAction_Success;
constexpr PlayerAbilityActionResult PlayerAbilityActionResult_MAX = PlayerAbilityAction_UpgradeFailed_OwnerFailed;
constexpr int PlayerAbilityActionResult_ARRAYSIZE = PlayerAbilityActionResult_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerAbilityActionResult_descriptor();
template<typename T>
inline const std::string& PlayerAbilityActionResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerAbilityActionResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerAbilityActionResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerAbilityActionResult_descriptor(), enum_t_value);
}
inline bool PlayerAbilityActionResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerAbilityActionResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerAbilityActionResult>(
    PlayerAbilityActionResult_descriptor(), name, value);
}
enum FightMode : int {
  FightMode_Peace = 0,
  FightMode_All = 1,
  FightMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FightMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool FightMode_IsValid(int value);
constexpr FightMode FightMode_MIN = FightMode_Peace;
constexpr FightMode FightMode_MAX = FightMode_All;
constexpr int FightMode_ARRAYSIZE = FightMode_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FightMode_descriptor();
template<typename T>
inline const std::string& FightMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FightMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FightMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FightMode_descriptor(), enum_t_value);
}
inline bool FightMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FightMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FightMode>(
    FightMode_descriptor(), name, value);
}
enum AttackLockType : int {
  AttackLockType_MinDistance = 0,
  AttackLockType_LowHpPct = 1,
  AttackLockType_LowHpMpValue = 2,
  AttackLockType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AttackLockType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool AttackLockType_IsValid(int value);
constexpr AttackLockType AttackLockType_MIN = AttackLockType_MinDistance;
constexpr AttackLockType AttackLockType_MAX = AttackLockType_LowHpMpValue;
constexpr int AttackLockType_ARRAYSIZE = AttackLockType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AttackLockType_descriptor();
template<typename T>
inline const std::string& AttackLockType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AttackLockType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AttackLockType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AttackLockType_descriptor(), enum_t_value);
}
inline bool AttackLockType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttackLockType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AttackLockType>(
    AttackLockType_descriptor(), name, value);
}
enum AttackUnlockType : int {
  AttackUnlockType_MaxDistance = 0,
  AttackUnlockType_NearDistance = 1,
  AttackUnlockType_Screen = 2,
  AttackUnlockType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AttackUnlockType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool AttackUnlockType_IsValid(int value);
constexpr AttackUnlockType AttackUnlockType_MIN = AttackUnlockType_MaxDistance;
constexpr AttackUnlockType AttackUnlockType_MAX = AttackUnlockType_Screen;
constexpr int AttackUnlockType_ARRAYSIZE = AttackUnlockType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AttackUnlockType_descriptor();
template<typename T>
inline const std::string& AttackUnlockType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AttackUnlockType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AttackUnlockType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AttackUnlockType_descriptor(), enum_t_value);
}
inline bool AttackUnlockType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttackUnlockType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AttackUnlockType>(
    AttackUnlockType_descriptor(), name, value);
}
enum BossInvasionState : int {
  BossInvasionState_None = 0,
  BossInvasionState_Wait = 1,
  BossInvasionState_Prepare = 2,
  BossInvasionState_Fight = 3,
  BossInvasionState_End = 4,
  BossInvasionState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BossInvasionState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool BossInvasionState_IsValid(int value);
constexpr BossInvasionState BossInvasionState_MIN = BossInvasionState_None;
constexpr BossInvasionState BossInvasionState_MAX = BossInvasionState_End;
constexpr int BossInvasionState_ARRAYSIZE = BossInvasionState_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BossInvasionState_descriptor();
template<typename T>
inline const std::string& BossInvasionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BossInvasionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BossInvasionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BossInvasionState_descriptor(), enum_t_value);
}
inline bool BossInvasionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BossInvasionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BossInvasionState>(
    BossInvasionState_descriptor(), name, value);
}
enum SwordPkState : int {
  SwordPkState_None = 0,
  SwordPkState_Init = 1,
  SwordPkState_SeasonBegin = 2,
  SwordPkState_SeasonDuring = 3,
  SwordPkState_SeasonEnd = 4,
  SwordPkState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SwordPkState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool SwordPkState_IsValid(int value);
constexpr SwordPkState SwordPkState_MIN = SwordPkState_None;
constexpr SwordPkState SwordPkState_MAX = SwordPkState_SeasonEnd;
constexpr int SwordPkState_ARRAYSIZE = SwordPkState_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SwordPkState_descriptor();
template<typename T>
inline const std::string& SwordPkState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SwordPkState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SwordPkState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SwordPkState_descriptor(), enum_t_value);
}
inline bool SwordPkState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SwordPkState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SwordPkState>(
    SwordPkState_descriptor(), name, value);
}
enum CheckListTaskType : int {
  CLTT_None = 0,
  CLTT_Login = 1,
  CLTT_EatPill = 2,
  CLTT_Practice = 3,
  CLTT_BuyInMarket = 4,
  CLTT_MakePill = 5,
  CLTT_Training = 6,
  CLTT_MonsterTower = 7,
  CLTT_Portal = 8,
  CLTT_Plant = 9,
  CLTT_Forge = 10,
  CLTT_Ad = 11,
  CLTT_Ability = 12,
  CLTT_LocalPk = 13,
  CLTT_Bounty = 14,
  CLTT_Reinforce = 15,
  CLTT_CommonPk = 16,
  CLTT_BuyInDeluxShop = 17,
  CLTT_MonsterInvasion = 18,
  CLTT_WorldInvasion = 19,
  CLTT_Mine = 20,
  CLTT_SectContribution = 21,
  CLTT_Quiz = 22,
  CLTT_Share = 23,
  CheckListTaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CheckListTaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool CheckListTaskType_IsValid(int value);
constexpr CheckListTaskType CheckListTaskType_MIN = CLTT_None;
constexpr CheckListTaskType CheckListTaskType_MAX = CLTT_Share;
constexpr int CheckListTaskType_ARRAYSIZE = CheckListTaskType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CheckListTaskType_descriptor();
template<typename T>
inline const std::string& CheckListTaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CheckListTaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CheckListTaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CheckListTaskType_descriptor(), enum_t_value);
}
inline bool CheckListTaskType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckListTaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CheckListTaskType>(
    CheckListTaskType_descriptor(), name, value);
}
enum SeptPosition : int {
  SeptPosition_None = 0,
  SeptPosition_Normal = 1,
  SeptPosition_Manager = 2,
  SeptPosition_Senator = 3,
  SeptPosition_ViceChairman = 4,
  SeptPosition_Chairman = 5,
  SeptPosition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SeptPosition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool SeptPosition_IsValid(int value);
constexpr SeptPosition SeptPosition_MIN = SeptPosition_None;
constexpr SeptPosition SeptPosition_MAX = SeptPosition_Chairman;
constexpr int SeptPosition_ARRAYSIZE = SeptPosition_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SeptPosition_descriptor();
template<typename T>
inline const std::string& SeptPosition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SeptPosition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SeptPosition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SeptPosition_descriptor(), enum_t_value);
}
inline bool SeptPosition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SeptPosition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SeptPosition>(
    SeptPosition_descriptor(), name, value);
}
enum SeptLogType : int {
  SLT_None = 0,
  SLT_Join = 1,
  SLT_Leave = 2,
  SLT_ChangeUp = 3,
  SLT_ChangeDown = 4,
  SeptLogType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SeptLogType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool SeptLogType_IsValid(int value);
constexpr SeptLogType SeptLogType_MIN = SLT_None;
constexpr SeptLogType SeptLogType_MAX = SLT_ChangeDown;
constexpr int SeptLogType_ARRAYSIZE = SeptLogType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SeptLogType_descriptor();
template<typename T>
inline const std::string& SeptLogType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SeptLogType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SeptLogType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SeptLogType_descriptor(), enum_t_value);
}
inline bool SeptLogType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SeptLogType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SeptLogType>(
    SeptLogType_descriptor(), name, value);
}
enum SeptArenaStoneType : int {
  SeptArenaStoneType_None = 0,
  SeptArenaStoneType_Primary = 1,
  SeptArenaStoneType_Intermediate = 2,
  SeptArenaStoneType_Advanced = 3,
  SeptArenaStoneType_Top = 4,
  SeptArenaStoneType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SeptArenaStoneType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
ZPROTOCOL_API bool SeptArenaStoneType_IsValid(int value);
constexpr SeptArenaStoneType SeptArenaStoneType_MIN = SeptArenaStoneType_None;
constexpr SeptArenaStoneType SeptArenaStoneType_MAX = SeptArenaStoneType_Top;
constexpr int SeptArenaStoneType_ARRAYSIZE = SeptArenaStoneType_MAX + 1;

ZPROTOCOL_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SeptArenaStoneType_descriptor();
template<typename T>
inline const std::string& SeptArenaStoneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SeptArenaStoneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SeptArenaStoneType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SeptArenaStoneType_descriptor(), enum_t_value);
}
inline bool SeptArenaStoneType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SeptArenaStoneType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SeptArenaStoneType>(
    SeptArenaStoneType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace idlezt

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::idlezt::ItemQuality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::ItemQuality>() {
  return ::idlezt::ItemQuality_descriptor();
}
template <> struct is_proto_enum< ::idlezt::ItemShowType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::ItemShowType>() {
  return ::idlezt::ItemShowType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::ItemType>() {
  return ::idlezt::ItemType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::EquipmentMainType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::EquipmentMainType>() {
  return ::idlezt::EquipmentMainType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::PerkValueAddType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::PerkValueAddType>() {
  return ::idlezt::PerkValueAddType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::PerkValueEffectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::PerkValueEffectType>() {
  return ::idlezt::PerkValueEffectType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::PerkIdConsts> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::PerkIdConsts>() {
  return ::idlezt::PerkIdConsts_descriptor();
}
template <> struct is_proto_enum< ::idlezt::EquipmentSlotState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::EquipmentSlotState>() {
  return ::idlezt::EquipmentSlotState_descriptor();
}
template <> struct is_proto_enum< ::idlezt::AlchemyChanceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::AlchemyChanceType>() {
  return ::idlezt::AlchemyChanceType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::PillType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::PillType>() {
  return ::idlezt::PillType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::CultivationDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::CultivationDirection>() {
  return ::idlezt::CultivationDirection_descriptor();
}
template <> struct is_proto_enum< ::idlezt::BreakthroughType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::BreakthroughType>() {
  return ::idlezt::BreakthroughType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::WorldType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::WorldType>() {
  return ::idlezt::WorldType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::EntityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::EntityType>() {
  return ::idlezt::EntityType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::EntityState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::EntityState>() {
  return ::idlezt::EntityState_descriptor();
}
template <> struct is_proto_enum< ::idlezt::NpcType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::NpcType>() {
  return ::idlezt::NpcType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::MonsterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::MonsterType>() {
  return ::idlezt::MonsterType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::CurrencyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::CurrencyType>() {
  return ::idlezt::CurrencyType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::SoloType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::SoloType>() {
  return ::idlezt::SoloType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::QuestRequirementType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::QuestRequirementType>() {
  return ::idlezt::QuestRequirementType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::QuestOpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::QuestOpType>() {
  return ::idlezt::QuestOpType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::LeaderboardType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::LeaderboardType>() {
  return ::idlezt::LeaderboardType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::AlchemyState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::AlchemyState>() {
  return ::idlezt::AlchemyState_descriptor();
}
template <> struct is_proto_enum< ::idlezt::WorldState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::WorldState>() {
  return ::idlezt::WorldState_descriptor();
}
template <> struct is_proto_enum< ::idlezt::FunctionModuleState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::FunctionModuleState>() {
  return ::idlezt::FunctionModuleState_descriptor();
}
template <> struct is_proto_enum< ::idlezt::FunctionModuleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::FunctionModuleType>() {
  return ::idlezt::FunctionModuleType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::MailType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::MailType>() {
  return ::idlezt::MailType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::MailOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::MailOperation>() {
  return ::idlezt::MailOperation_descriptor();
}
template <> struct is_proto_enum< ::idlezt::ChatMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::ChatMessageType>() {
  return ::idlezt::ChatMessageType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::ChatMessageChannel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::ChatMessageChannel>() {
  return ::idlezt::ChatMessageChannel_descriptor();
}
template <> struct is_proto_enum< ::idlezt::ForgeChanceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::ForgeChanceType>() {
  return ::idlezt::ForgeChanceType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::ForgeState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::ForgeState>() {
  return ::idlezt::ForgeState_descriptor();
}
template <> struct is_proto_enum< ::idlezt::PillElixirType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::PillElixirType>() {
  return ::idlezt::PillElixirType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::PillElixrEffectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::PillElixrEffectType>() {
  return ::idlezt::PillElixrEffectType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::PlayerAbilityActionResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::PlayerAbilityActionResult>() {
  return ::idlezt::PlayerAbilityActionResult_descriptor();
}
template <> struct is_proto_enum< ::idlezt::FightMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::FightMode>() {
  return ::idlezt::FightMode_descriptor();
}
template <> struct is_proto_enum< ::idlezt::AttackLockType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::AttackLockType>() {
  return ::idlezt::AttackLockType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::AttackUnlockType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::AttackUnlockType>() {
  return ::idlezt::AttackUnlockType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::BossInvasionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::BossInvasionState>() {
  return ::idlezt::BossInvasionState_descriptor();
}
template <> struct is_proto_enum< ::idlezt::SwordPkState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::SwordPkState>() {
  return ::idlezt::SwordPkState_descriptor();
}
template <> struct is_proto_enum< ::idlezt::CheckListTaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::CheckListTaskType>() {
  return ::idlezt::CheckListTaskType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::SeptPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::SeptPosition>() {
  return ::idlezt::SeptPosition_descriptor();
}
template <> struct is_proto_enum< ::idlezt::SeptLogType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::SeptLogType>() {
  return ::idlezt::SeptLogType_descriptor();
}
template <> struct is_proto_enum< ::idlezt::SeptArenaStoneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::idlezt::SeptArenaStoneType>() {
  return ::idlezt::SeptArenaStoneType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_defines_2eproto
