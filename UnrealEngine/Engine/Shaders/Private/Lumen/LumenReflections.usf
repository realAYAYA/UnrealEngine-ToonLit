// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "LumenMaterial.ush"

#include "../SceneTextureParameters.ush"
#include "../BRDF.ush"
#include "../Random.ush"
#include "LumenReflectionCommon.ush"
#include "../ClearCoatCommon.ush"
#include "../FastMath.ush"
#include "LumenRadianceCacheCommon.ush"
#include "LumenReflectionsCombine.ush"

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 1
#endif

#ifndef FRONT_LAYER_TRANSLUCENCY
#define FRONT_LAYER_TRANSLUCENCY 0
#endif

#define FLOAT3_11_11_10_MAX float3(65024.0f, 65024.0f, 64512.0f)
#define FLOAT_32_MAX float(+3.402823466e+38f)

RWBuffer<uint> RWReflectionResolveTileIndirectArgs;
RWBuffer<uint> RWReflectionTracingTileIndirectArgs;
RWTexture2DArray <float> RWDownsampledDepth;

groupshared uint SharedTileNeedsResolve[4][4];
groupshared uint SharedTileNeedsTracing;

FLumenMaterialData ApplySmoothBias(FLumenMaterialData In, bool bTopLayerRoughness)
{
	FLumenMaterialData Out = In;
	if (bTopLayerRoughness)
	{
		Out.TopLayerRoughness = ApplySmoothBias(In.TopLayerRoughness);
	}
	else
	{
		Out.Roughness = ApplySmoothBias(In.Roughness);
	}
	return Out;
}

bool NeedRayTracedReflections(float InRoughness, const FLumenMaterialData In)
{
	bool bNeedReflections = false;

	if (ReflectionPass == 0)
	{
		bNeedReflections = IsValid(In) && (LumenCombineReflectionsAlpha(InRoughness, HasBackfaceDiffuse(In)) > 0.0f || IsClearCoat(In));
	}
	else if (ReflectionPass == 1)
	{
		bNeedReflections = IsSingleLayerWater(In);
	}
	else
	{
		bNeedReflections = IsFrontLayerTranslucency(In);
	}

	return bNeedReflections;
}

// Must match cpp GReflectionResolveTileSize
#define RESOLVE_TILE_SIZE 8

#ifndef PERMUTATION_OVERFLOW_TILE
#define PERMUTATION_OVERFLOW_TILE 0
#endif

RWTexture2DArray<uint> RWResolveTileUsed;

groupshared uint SharedTileClassification;

[numthreads(RESOLVE_TILE_SIZE, RESOLVE_TILE_SIZE, 1)] 
void ReflectionTileClassificationMarkCS(
	uint2 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint2 GroupThreadId : SV_GroupThreadID)
{
	if (DispatchThreadId.x < 3 && DispatchThreadId.y == 0 && DispatchThreadId.z == 0 && PERMUTATION_OVERFLOW_TILE == 0)
	{
		// Clear indirect args for future pass
		RWReflectionResolveTileIndirectArgs[DispatchThreadId.x] = (DispatchThreadId.x == 0) ? 0 : 1;
		RWReflectionTracingTileIndirectArgs[DispatchThreadId.x] = (DispatchThreadId.x == 0) ? 0 : 1;
	}

	if (all(GroupThreadId == 0))
	{
		SharedTileClassification = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	bool bIsValid = all(DispatchThreadId.xy < View.ViewRectMinAndSize.zw);
	bool bIsAnyValid = bIsValid;
	const FLumenMaterialCoord Coord = GetLumenMaterialCoord(DispatchThreadId.xy + View.ViewRectMinAndSize.xy, SUBSTRATE_ENABLED ? DispatchThreadId.z : 0);
	const uint3 FlattenTileCoord = uint3(GroupId, Coord.ClosureIndex);

	const uint2 DownSampleDepthCoord = DispatchThreadId.xy / ReflectionDownsampleFactor;
	const bool bIsDownSampleDepthCoordValid = all(DownSampleDepthCoord < ReflectionTracingViewSize);

#if SUBSTRATE_ENABLED
	if (bIsValid && Coord.ClosureIndex > 0)
	{
		FSubstrateAddressing SubstrateAddressing = GetSubstratePixelDataByteOffset(Coord.SvPosition, uint2(View.BufferSizeAndInvSize.xy), Substrate.MaxBytesPerPixel);
		FSubstratePixelHeader SubstratePixelHeader= UnpackSubstrateHeaderIn(Substrate.MaterialTextureArray, SubstrateAddressing, Substrate.TopLayerTexture);
		bIsValid = Coord.ClosureIndex < SubstratePixelHeader.ClosureCount;
	}
#endif

	if (bIsValid)
	{
		const FLumenMaterialData Material = ApplySmoothBias(ReadMaterialData(Coord, MaxRoughnessToTrace), false /*bTopLayerRoughness*/);
		if (NeedRayTracedReflections(Material.Roughness, Material))
		{
			// Metal compiler issue: it requires `+=` instead of `=` to record the tile as of UE 5.0
			SharedTileClassification += 1;
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (all(GroupThreadId == 0) && bIsAnyValid)
	{
		RWResolveTileUsed[FlattenTileCoord] = SharedTileClassification > 0 ? 1u : 0;
	}

	// Clear tiles that the generate shader won't run on
	if (SharedTileClassification == 0 && bIsDownSampleDepthCoordValid)
	{
		RWDownsampledDepth[uint3(DownSampleDepthCoord, Coord.ClosureIndex)] = -1.0f;
	}
}

RWBuffer<uint> RWReflectionTileIndirectArgs;
RWBuffer<uint> RWReflectionTileData;
Texture2DArray<uint> ResolveTileUsed;

uint2 TileViewportDimensions;
uint2 ResolveTileViewportDimensions;

groupshared uint SharedNumTiles;
groupshared uint SharedTileUsed[THREADGROUP_SIZE * THREADGROUP_SIZE];
groupshared uint SharedTileData[THREADGROUP_SIZE * THREADGROUP_SIZE];
groupshared uint SharedGlobalTileOffset;

FLumenMaterialCoord GetLumenMaterialCoord_Reflection(in uint2 SvPosition, FReflectionTileData InTileData)
{
	FLumenMaterialCoord Out = (FLumenMaterialCoord)0;
	Out.ClosureIndex = SUBSTRATE_ENABLED ? InTileData.ClosureIndex : 0;
	Out.SvPosition = SvPosition;
	Out.SvPositionFlatten = uint3(Out.SvPosition, Out.ClosureIndex);
	return Out;
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)] 
void ReflectionTileClassificationBuildListsCS(
	uint3 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID)
{
	const uint ThreadIndex = GroupThreadId.y * THREADGROUP_SIZE + GroupThreadId.x;

	// When generating downsampled trace tiles we need to downsample ResolveTileUsed to shared memory first
#if SUPPORT_DOWNSAMPLE_FACTOR
	SharedTileUsed[ThreadIndex] = 0;

	GroupMemoryBarrierWithGroupSync();

	uint  TileUsed = 0;
	uint2 TileCoordinate = GroupId.xy * THREADGROUP_SIZE + GroupThreadId;
	uint  ClosureIndex = SUBSTRATE_ENABLED ? GroupId.z : 0;

	// Gather whether any of the resolve tiles corresponding to this tracing tile were used
	for (uint Y = 0; Y < ReflectionDownsampleFactor; Y++)
	{
		for (uint X = 0; X < ReflectionDownsampleFactor; X++)
		{
			uint2 ResolveTileCoordinate = TileCoordinate * ReflectionDownsampleFactor + uint2(X, Y);

			if (all(ResolveTileCoordinate < ResolveTileViewportDimensions))
			{
				TileUsed = TileUsed || ResolveTileUsed[uint3(ResolveTileCoordinate, ClosureIndex)];
			}
		}
	}

	SharedTileUsed[ThreadIndex] = TileUsed;

	GroupMemoryBarrierWithGroupSync();
#endif

	//@todo - parallel version
	if (ThreadIndex == 0)
	{
		SharedNumTiles = 0;

		for (uint x = 0; x < THREADGROUP_SIZE * THREADGROUP_SIZE; x++)
		{
			const uint2 ThreadOffset = ZOrder2D(x, log2(THREADGROUP_SIZE));

			#if PERMUTATION_OVERFLOW_TILE && SUBSTRATE_ENABLED
			const uint LinearIndex = GroupId.x * THREADGROUP_SIZE * THREADGROUP_SIZE + x;
			const bool bIsTileValid = LinearIndex < Substrate.ClosureTileCountBuffer[0];
			FReflectionTileData TileData = (FReflectionTileData)0;
			if (bIsTileValid)
			{
				const FSubstrateClosureTile Tile = UnpackClosureTile(Substrate.ClosureTileBuffer[LinearIndex]);
				TileData.Coord     = Tile.TileCoord;
				TileData.ClosureIndex = Tile.ClosureIndex;
			}
			const bool bIsValid = bIsTileValid && all(TileData.Coord < TileViewportDimensions);
			#else
			// ZOrder tiles to maximize screen locality after converting to 1d for compaction
			// The tile locality ultimately affects trace coherency, since trace compaction pulls from neighboring tiles
			FReflectionTileData TileData;
			TileData.Coord        = GroupId.xy * THREADGROUP_SIZE + ThreadOffset;
			TileData.ClosureIndex = SUBSTRATE_ENABLED ? GroupId.z : 0;
			const bool bIsValid   = all(TileData.Coord < TileViewportDimensions);
			#endif

			if (bIsValid)
			{
				bool bTileUsed;

				#if SUPPORT_DOWNSAMPLE_FACTOR
					bTileUsed = SharedTileUsed[ThreadOffset.y * THREADGROUP_SIZE + ThreadOffset.x];
				#else
					const uint3 TileCoordFlatten = uint3(TileData.Coord, TileData.ClosureIndex);
					bTileUsed = ResolveTileUsed[TileCoordFlatten];
				#endif

				if (bTileUsed)
				{
					uint TileOffset = SharedNumTiles;
					// Note: Must match encoding in WaterTileCatergorisationBuildListsCS
					SharedTileData[TileOffset] = PackTileData(TileData);
					SharedNumTiles = TileOffset + 1;
				}
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (ThreadIndex == 0 && SharedNumTiles > 0)
	{
		InterlockedAdd(RWReflectionTileIndirectArgs[0], SharedNumTiles, SharedGlobalTileOffset);
	}

	GroupMemoryBarrierWithGroupSync();

	if (ThreadIndex < SharedNumTiles)
	{
		RWReflectionTileData[SharedGlobalTileOffset + ThreadIndex] = SharedTileData[ThreadIndex];
	}
}

float GGXSamplingBias;
float MaxTraceDistance;
float RadianceCacheAngleThresholdScale;

RWTexture2DArray<uint> RWRayTraceDistance;
RWTexture2DArray<float4> RWRayBuffer;

float2 GenerateRandom(uint2 InReflectionTracingCoord)
{
#define BLUE_NOISE_LUT 1
#if BLUE_NOISE_LUT
	float2 E = BlueNoiseVec2(InReflectionTracingCoord, ReflectionsRayDirectionFrameIndex);
#else
	uint2 RandomSeed = Rand3DPCG16(int3(InReflectionTracingCoord, ReflectionsStateFrameIndexMod8)).xy;
	float2 E = Hammersley16(0, 1, RandomSeed);
#endif
	E.y *= 1 - GGXSamplingBias;
	return E;
}

[numthreads(REFLECTION_THREADGROUP_SIZE_1D, 1, 1)]
void ReflectionGenerateRaysCS(
	uint GroupId : SV_GroupID,
	uint GroupThreadId : SV_GroupThreadID)
{
	FReflectionTileData TileData;
	uint3 ReflectionTracingCoord = GetReflectionTracingScreenCoord(GroupId, GroupThreadId, TileData);
	bool bIsValid = all(ReflectionTracingCoord.xy < ReflectionTracingViewSize);

	// SvPositionForMaterialCoord is the SvPosition for primary sample, but is PixelCoord for overflow sample
	float2 ScreenJitter = GetScreenTileJitter();
	uint2 SvPositionForMaterialCoord = min(ReflectionTracingCoord.xy * ReflectionDownsampleFactor + uint2(ScreenJitter + .5f) + View.ViewRectMinAndSize.xy, View.ViewRectMinAndSize.xy + View.ViewRectMinAndSize.zw - 1);

	if (bIsValid)
	{
		const FLumenMaterialCoord Coord = GetLumenMaterialCoord_Reflection(SvPositionForMaterialCoord, TileData);
		const FLumenMaterialData Material = ApplySmoothBias(ReadMaterialData(Coord, MaxRoughnessToTrace), true /*bTopLayerRoughness*/);

		float DownsampledDepth = Material.SceneDepth;

		if (NeedRayTracedReflections(Material.TopLayerRoughness, Material))
		{
			float2 ScreenUV = (Coord.SvPosition + .5f) * View.BufferSizeAndInvSize.zw;
			float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, Material.SceneDepth);
			float3 CameraVector = GetCameraVectorFromWorldPosition(WorldPosition);

			float3 RayDirection;
			float ConeAngle = 0.0f;
			bool bMirrorReflectionDebug = false;
			float3 V = -CameraVector;

			// Use Substrate sampling routine only for opaque surface. 
			// When FontLayerTranslucency is enable, LumenMaterial is built from custom packed data (i.e., non-Substrate)
		#if SUBSTRATE_ENABLED && !FRONT_LAYER_TRANSLUCENCY
			{
				FSubstrateAddressing SubstrateAddressing = GetSubstratePixelDataByteOffset(Coord.SvPosition, uint2(View.BufferSizeAndInvSize.xy), Substrate.MaxBytesPerPixel);
				const FSubstratePixelHeader SubstratePixelHeader = UnpackSubstrateHeaderIn(Substrate.MaterialTextureArray, SubstrateAddressing, Substrate.TopLayerTexture);
				const FSubstrateIntegrationSettings Settings = InitSubstrateIntegrationSettings(false /*bForceFullyRough*/, Substrate.bRoughDiffuse, Substrate.PeelLayersAboveDepth, Substrate.bRoughnessTracking);

				if (Coord.ClosureIndex > 0)
				{
					const uint OffsetAddress = UnpackClosureOffsetAtIndex(Substrate.ClosureOffsetTexture[Coord.SvPosition], Coord.ClosureIndex, SubstratePixelHeader.ClosureCount);
					SubstrateSeekClosure(SubstrateAddressing, OffsetAddress);
				}
				FSubstrateBSDF BSDF = UnpackSubstrateBSDF(Substrate.MaterialTextureArray, SubstrateAddressing, SubstratePixelHeader);

				// We set slabs BSDFs as having a single specular lob without haziness.
				// This is to ensure the pdf is computed from a single lobe in order to be able to compute a matching cone angle.
				BSDF.SubstrateSetBSDFRoughness(Material.TopLayerRoughness);
				if (SubstrateGetBSDFType(BSDF) == SUBSTRATE_BSDF_TYPE_SLAB)
				{
					BSDF_SETHASHAZINESS(BSDF, 0);
				}

				const FSubstrateBSDFContext Context = SubstrateCreateBSDFContext(SubstratePixelHeader, BSDF, SubstrateAddressing, V);
				const float2 E = GenerateRandom(ReflectionTracingCoord.xy);
				const FBxDFSample Sample = SubstrateImportanceSampleBSDF(Context, E, SHADING_TERM_SPECULAR, Settings);

				RayDirection = normalize(Sample.L);
				ConeAngle = 1.0f / max(Sample.PDF, 0.0001f);
			}
		#else
			if (Material.TopLayerRoughness < 0.001f || bMirrorReflectionDebug)
			{
				RayDirection = reflect(CameraVector, Material.WorldNormal);
			}
			else
			{
				const float2 E = GenerateRandom(ReflectionTracingCoord.xy);

				float3x3 TangentBasis = GetTangentBasis(Material);
				float3 TangentV = mul(TangentBasis, V);

				float2 Alpha = Pow2(Material.TopLayerRoughness).xx;

				if (HasAnisotropy(Material))
				{
					GetAnisotropicRoughness(Alpha.x, Material.Anisotropy, Alpha.x, Alpha.y);
				}

				float4 GGXSample = ImportanceSampleVisibleGGX(E, Alpha, TangentV);
				float3 WorldH = mul(GGXSample.xyz, TangentBasis);
				RayDirection = reflect(CameraVector, WorldH);
				ConeAngle = 1.0f / max(GGXSample.w, 0.0001f);
			}
		#endif

			ConeAngle = max(ConeAngle, MinReflectionConeAngle);
			RWRayBuffer[ReflectionTracingCoord] = float4(RayDirection, ConeAngle);

			float TraceDistance = MaxTraceDistance;
			bool bUseRadianceCache = false;
		#if RADIANCE_CACHE
			float RadianceCacheConeHalfAngle = RadianceCacheAngleThresholdScale * acosFast(1.0f - 1 / (float)(RadianceProbeResolution * RadianceProbeResolution));

			if (ConeAngle > RadianceCacheConeHalfAngle)
			{
				FRadianceCacheCoverage Coverage = GetRadianceCacheCoverageWithUncertainCoverage(WorldPosition, RayDirection, InterleavedGradientNoise(ReflectionTracingCoord.xy, ReflectionsStateFrameIndexMod8));
				bUseRadianceCache = Coverage.bValid;
				if (bUseRadianceCache)
				{
					float FadeAlpha = saturate((ConeAngle - RadianceCacheConeHalfAngle) / RadianceCacheConeHalfAngle);
					TraceDistance = lerp(.99f * MaxTraceDistance, min(Coverage.MinTraceDistanceBeforeInterpolation, .99f * MaxTraceDistance), FadeAlpha);
				}
			}
		#endif

			RWRayTraceDistance[ReflectionTracingCoord] = PackRayTraceDistance(TraceDistance, bUseRadianceCache);
		}
		else
		{
			// Store invalid ray in sign bit
			DownsampledDepth *= -1.0f;
		}

		RWDownsampledDepth[ReflectionTracingCoord] = DownsampledDepth;
	}
#if SUBSTRATE_ENABLED
	// Check at the tile level if there are several BSDFs
	else if (TileData.ClosureIndex > 0)
	{
		RWDownsampledDepth[ReflectionTracingCoord] = 0;
	}
#endif
}


RWTexture2DArray<float3> RWSpecularIndirect;
RWTexture2DArray<float4> RWSpecularIndirectAccumulated;
RWTexture2DArray<float> RWSpecularIndirectDepth;
RWTexture2DArray<float> RWResolveVariance;

uint NumSpatialReconstructionSamples;
float SpatialReconstructionKernelRadius;
float SpatialReconstructionRoughnessScale;
float SpatialResolveTonemapStrength;

const static float DisocclusionVariance = 1.0f;

float Luma(float3 Color) 
{
	// Rec 709 function for luma.
	return dot(Color, float3(0.2126f, 0.7152f, 0.0722f));
}

float3 TonemapLighting(float3 Lighting)
{
	float Weight = 1.0f / (1.0f + SpatialResolveTonemapStrength * Luma(Lighting));
	return Lighting * Weight;
}

float3 InverseTonemapLighting(float3 TonemappedLighting)
{
	float InvertWeight = 1.0f / (1.0f - SpatialResolveTonemapStrength * Luma(TonemappedLighting));
	return TonemappedLighting * InvertWeight;
}

[numthreads(REFLECTION_THREADGROUP_SIZE_1D, 1, 1)]
void ReflectionResolveCS(
	uint GroupId : SV_GroupID,
	uint GroupThreadId : SV_GroupThreadID)
{
	FReflectionTileData TileData;
	uint2 ScreenCoord = GetReflectionResolveScreenCoord(GroupId, GroupThreadId, TileData);

	const FLumenMaterialCoord Coord = GetLumenMaterialCoord_Reflection(ScreenCoord + View.ViewRectMinAndSize.xy, TileData);

	const bool bIsOverflow = TileData.ClosureIndex > 0;


	const float2 ScreenUV = (Coord.SvPosition + 0.5f) * View.BufferSizeAndInvSize.zw;
	
	float3 ReflectionLighting = 0;
	float ResolveVariance = 0;
	float DepthForReprojection = 0;

	{
		const FLumenMaterialData Material = ApplySmoothBias(ReadMaterialData(Coord, MaxRoughnessToTrace), true /*bTopLayerRoughness*/);
		DepthForReprojection = Material.SceneDepth;

		if (NeedRayTracedReflections(Material.TopLayerRoughness, Material))
		{
			uint2 ReflectionScreenCoord = ScreenCoord / ReflectionDownsampleFactor;
			uint3 ReflectionScreenCoord_Flatten = uint3(ReflectionScreenCoord, Coord.ClosureIndex);

			float ClosestHitDepth = FLOAT_32_MAX;

		#if USE_SPATIAL_RECONSTRUCTION
			{
				const float3 TranslatedWorldPosition = GetTranslatedWorldPositionFromScreenUV(ScreenUV, Material.SceneDepth);
				const float3 V = -normalize(TranslatedWorldPosition - PrimaryView.TranslatedWorldCameraOrigin);
				const float3x3 TangentBasis = GetTangentBasis(Material);
				const float3 TangentV = mul(TangentBasis, V);
				float TotalWeight = 0;
				float Mean = 0;
				float S = 0;

				const bool bHasAnisotropy = HasAnisotropy(Material);
				const float EffectiveRoughness = clamp(Material.TopLayerRoughness * SpatialReconstructionRoughnessScale, 0.0f, 1.0f);
				float2 ax_ay = Pow2(EffectiveRoughness).xx;
				if (bHasAnisotropy)
				{
					GetAnisotropicRoughness(ax_ay.x, Material.Anisotropy, ax_ay.x, ax_ay.y);
				}
				const float a2 = ax_ay.x * ax_ay.y;

				uint2 RandomSeed = Rand3DPCG16(int3(ScreenCoord, ReflectionsStateFrameIndexMod8)).xy;

				// Center sample
				float CenterTraceHitDistance = ClosestHitDepth;

				{
					bool bHit;
					CenterTraceHitDistance = DecodeRayDistance(TraceHit[ReflectionScreenCoord_Flatten].x, bHit);
					ClosestHitDepth = CenterTraceHitDistance;

					const bool bUseCenterSample = ReflectionDownsampleFactor == 1;

					if (bUseCenterSample)
					{
						float3 SampleRadiance = TraceRadiance[ReflectionScreenCoord_Flatten];
						ReflectionLighting = TonemapLighting(SampleRadiance);
						float Weight = 1.0f;
						TotalWeight += Weight;

						#if USE_BILATERAL_FILTER
							//https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Weighted_incremental_algorithm
							float LumaSampleRadiance = Luma(SampleRadiance);
							float OldMean = Mean;
							Mean += Weight / TotalWeight * (LumaSampleRadiance - OldMean);
							S += Weight * (LumaSampleRadiance - OldMean) * (LumaSampleRadiance - Mean);
						#endif
					}
				}

				float MinKernelRadius = ReflectionDownsampleFactor;
				float MaxKernelRadius = SpatialReconstructionKernelRadius;
				float KernelScale = 2.0f * (1.0f - log2((float)ReflectionDownsampleFactor) * .25f);

				float2 KernelDiameter = KernelScale * lerp(MinKernelRadius, MaxKernelRadius, saturate(Material.TopLayerRoughness * 8));
				float2 KernelMajorAxis = float2(KernelDiameter.x,0);
				float2 KernelMinorAxis = float2(0, KernelDiameter.y);

				if (bHasAnisotropy)
				{
					// Scale filtering kernel based on the anisotropy scaling
					KernelDiameter.x = max(KernelDiameter.x * (1.0 + Material.Anisotropy), MinKernelRadius);
					KernelDiameter.y = max(KernelDiameter.y * (1.0 - Material.Anisotropy), MinKernelRadius);

					// Orient filtering kernel along the projected major/minor axis
					float4 ProjX = mul(float4(TranslatedWorldPosition + TangentBasis[0], 1), View.TranslatedWorldToClip);
					float4 ProjY = mul(float4(TranslatedWorldPosition + TangentBasis[1], 1), View.TranslatedWorldToClip);
					ProjX /= ProjX.w;
					ProjY /= ProjY.w;
					ProjX.xy = ProjX.xy * float2(0.5f, -0.5f) + 0.5f;
					ProjY.xy = ProjY.xy * float2(0.5f, -0.5f) + 0.5f;

					KernelMajorAxis = KernelDiameter.x * normalize(ProjX.xy * View.ViewSizeAndInvSize.xy - (Coord.SvPosition + 0.5f));
					KernelMinorAxis = KernelDiameter.y * normalize(ProjY.xy * View.ViewSizeAndInvSize.xy - (Coord.SvPosition + 0.5f));
				}

				for (uint SampleIndex = 0; SampleIndex < NumSpatialReconstructionSamples; SampleIndex++)
				{
					const float2 LocalOffset = (Hammersley16(SampleIndex, NumSpatialReconstructionSamples, RandomSeed) - .5f);
					const float2 Offset = LocalOffset.x * KernelMajorAxis + LocalOffset.y * KernelMinorAxis;

					// When Substrate is enabled, neighbor pixels are considered valid if their BSDF count is greater or equal to the current one. 
					// If it is not valid, then it will fallback onto BSDFIndex=0. Neighboor depth is then used to know if that pixel contains
					// valid reflection data.
					int2 NeighborTracingCoord = (int2)(ReflectionScreenCoord + Offset);
					int2 NeighborTracingCoord_ForDepth = NeighborTracingCoord;
					int3 NeighborTracingCoord_Flatten = int3(NeighborTracingCoord, Coord.ClosureIndex);
					bool bIsValidNeighboor = all(and (NeighborTracingCoord >= int2(0, 0), NeighborTracingCoord < (int2)ReflectionTracingViewSize));

					if (bIsValidNeighboor)
					{
						// DownsampledDepth is valid discriminant to know if a pixel is valid (i.e. has initialized ray/luminance data)
						float2 NeighborScreenUV = GetScreenUVFromReflectionTracingCoord(NeighborTracingCoord);
						float NeighborSceneDepth = DownsampledDepth[NeighborTracingCoord_Flatten].x;

						if (NeighborSceneDepth > 0.0f)
						{
							float3 NeighborTranslatedWorldPosition = GetTranslatedWorldPositionFromScreenUV(NeighborScreenUV, NeighborSceneDepth);
							FRayData RayData = GetRayData(NeighborTracingCoord_Flatten);

							bool bHit;
							float TraceHitDistance = DecodeRayDistance(TraceHit[NeighborTracingCoord_Flatten].x, bHit);

							// Clamp to center distance - preserves contacts and prevents a bias toward trace that hit the background
							TraceHitDistance = min(TraceHitDistance, CenterTraceHitDistance);

							float3 NeighborHitPosition = NeighborTranslatedWorldPosition + RayData.Direction * TraceHitDistance;
							float DistanceToNeighborHit = length(NeighborHitPosition - TranslatedWorldPosition);
							float3 DirectionToNeighborHit = RayData.Direction;

							if (DistanceToNeighborHit > 0)
							{
								DirectionToNeighborHit = (NeighborHitPosition - TranslatedWorldPosition) / DistanceToNeighborHit;
							}
							float3 TangentH = mul(TangentBasis, normalize(V + DirectionToNeighborHit));

							// Re-weight neighbor ray by the ratio of our PDF to neighbor PDF
							float NewPDF = 1.f;
							if (bHasAnisotropy)
							{
								NewPDF = min(VisibleGGXPDF_aniso(TangentV, TangentH, ax_ay), 1.0f / MinReflectionConeAngle);
							}
							else
							{
								NewPDF = min(VisibleGGXPDF(TangentV, TangentH, a2), 1.0f / MinReflectionConeAngle);
							}

							float Weight = NewPDF / RayData.PDF;
							float ClampedWeight = max(1e-6, Weight);
							float3 SampleRadiance = TraceRadiance[NeighborTracingCoord_Flatten];
							ReflectionLighting += TonemapLighting(SampleRadiance) * ClampedWeight;

							TotalWeight += ClampedWeight;

							#if USE_BILATERAL_FILTER
								float LumaSampleRadiance = Luma(SampleRadiance);
								float OldMean = Mean;
								Mean += ClampedWeight / TotalWeight * (LumaSampleRadiance - OldMean);
								S += ClampedWeight * (LumaSampleRadiance - OldMean) * (LumaSampleRadiance - Mean);
							#endif

							if (Weight > .001f)
							{
								ClosestHitDepth = min(ClosestHitDepth, TraceHitDistance);
							}
						}
					}
				}

				if (TotalWeight > 0.0f)
				{
					float InvTotalWeight = 1.0f / TotalWeight;
					ReflectionLighting = InverseTonemapLighting(ReflectionLighting * InvTotalWeight);
					ResolveVariance = S / TotalWeight;
				}
			}
		#else // USE_SPATIAL_RECONSTRUCTION
			{
				ReflectionLighting = TraceRadiance[ReflectionScreenCoord_Flatten];

				bool bHit;
				ClosestHitDepth = DecodeRayDistance(TraceHit[ReflectionScreenCoord_Flatten].x, bHit);
			}
		#endif // USE_SPATIAL_RECONSTRUCTION

			DepthForReprojection = Material.SceneDepth + ClosestHitDepth;
		}
		else
		{
			// Mark invalid values with FLOAT3_11_11_10_MAX for history accumuation
			ReflectionLighting = FLOAT3_11_11_10_MAX;
		}
	}

	RWSpecularIndirect[Coord.SvPositionFlatten] = ReflectionLighting;
	RWSpecularIndirectDepth[Coord.SvPositionFlatten] = ConvertToDeviceZ(DepthForReprojection);

	#if USE_BILATERAL_FILTER
		// Clamp the variance range to not overlap with DisocclusionVariance, so the bilateral filter can detect disocclusion
		ResolveVariance = min(ResolveVariance, DisocclusionVariance - .1f);
		RWResolveVariance[Coord.SvPositionFlatten] = ResolveVariance;
	#endif

#if CLEAR_TILE_NEIGHBORHOOD
	// When the next step is the temporal filter, clear texels in the resolve tile's neighborhood that won't be written to by the resolve shader otherwise
	if (GroupThreadId < (REFLECTION_THREADGROUP_SIZE_2D + 1) * 4)
	{
		uint BorderSide = GroupThreadId / (REFLECTION_THREADGROUP_SIZE_2D + 1);
		int BorderIndex = GroupThreadId - BorderSide * (REFLECTION_THREADGROUP_SIZE_2D + 1);
		int2 Offset = int2(BorderIndex - 1, -1);

		if (BorderSide == 1)
		{
			Offset = int2(REFLECTION_THREADGROUP_SIZE_2D, BorderIndex - 1);
		}
		else if (BorderSide == 2)
		{
			Offset = int2(BorderIndex, REFLECTION_THREADGROUP_SIZE_2D);
		}
		else if (BorderSide == 3)
		{
			Offset = int2(-1, BorderIndex);
		}

		uint2 TileCorner = Coord.SvPosition - uint2(GroupThreadId % REFLECTION_THREADGROUP_SIZE_2D, GroupThreadId / REFLECTION_THREADGROUP_SIZE_2D);
		int3 NeighborSvPosition = int3(TileCorner + Offset, Coord.ClosureIndex);

		if (all(NeighborSvPosition.xy >= 0) && all(NeighborSvPosition.xy < View.ViewRectMinAndSize.xy + View.ViewRectMinAndSize.zw))
		{
			if (!ResolveTileUsed[uint3((NeighborSvPosition.xy - View.ViewRectMinAndSize.xy) / REFLECTION_THREADGROUP_SIZE_2D, Coord.ClosureIndex)])
			{
				// Mark invalid values with FLOAT3_11_11_10_MAX for GetNeighborStatistics
				RWSpecularIndirect[NeighborSvPosition] = FLOAT3_11_11_10_MAX;
				RWSpecularIndirectDepth[NeighborSvPosition] = 0.0f;
			}
		}
	}
#endif
}

RWTexture2DArray<UNORM float> RWNumHistoryFramesAccumulated;
Texture2DArray HistoryNumFramesAccumulated;
Texture2DArray ResolvedReflections;
Texture2DArray ResolvedReflectionsDepth;
Texture2DArray SpecularIndirectHistory;
Texture2D DepthHistory;
Texture2DArray<float> ResolveVariance;
Texture2DArray ResolveVarianceHistory;

float HistoryDistanceThreshold;
float MaxFramesAccumulated;
float NeighborhoodClampExpandWithResolveVariance;

float4 HistoryScreenPositionScaleBias;
float4 HistoryUVMinMax;

Texture2D VelocityTexture;
SamplerState VelocityTextureSampler;

float PrevInvPreExposure;
uint bIsSubstrateTileHistoryValid;

// Note: corners need to be first for GetNeighborStatistics
static const int2 kOffsets3x3[8] =
{
	int2(-1, -1),
	int2( 1, -1),
	int2(-1,  1),
	int2( 1,  1),
	int2( 0, -1),
	int2(-1,  0),
	int2( 1,  0),
	int2( 0,  1),
};

struct FNeighborStatistics
{
	float3 Mean;
	float3 Variance;
	float3 StdDev;
	float3 Min;
	float3 Max;
};

FNeighborStatistics GetNeighborStatistics(
	uint2 ScreenCoord, 
	uint2 MinScreenCoord, 
	uint2 MaxScreenCoord,
	float3 NewLighting,
	uint InBSDFIndex)
{
	FNeighborStatistics Result = (FNeighborStatistics)0;

	int Count = 1;
	float3 M1 = NewLighting;
	float3 M2 = (float3)0;

	Result.Min = NewLighting;
	Result.Max = NewLighting;

	UNROLL
	for(uint NeighborId = 0; NeighborId < 8; NeighborId++)
	{
		int2 SampleOffset = kOffsets3x3[NeighborId];

		uint3 NeighborScreenCoord = uint3(ScreenCoord + SampleOffset, InBSDFIndex);
		NeighborScreenCoord.xy = clamp(NeighborScreenCoord.xy, MinScreenCoord, MaxScreenCoord);

		float3 Sample = ResolvedReflections[NeighborScreenCoord].xyz;

		// ReflectionResolveCS writes FLOAT3_11_11_10_MAX for neighbors which are outside of any valid resolve tile
		if (all(Sample.xyz != FLOAT3_11_11_10_MAX))
		{
			Result.Min = min(Result.Min, Sample);
			Result.Max = max(Result.Max, Sample);

			// Welford's online algorithm for variance.
			// More numerically stable than accumulating squares.
			// https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
			Count += 1;
			float3 Delta1 = Sample - M1;
			M1 += Delta1 / Count;
			float3 Delta2 = Sample - M1;
			M2 += Delta1 * Delta2;
		}
	}

	Result.Mean = M1;
	Result.Variance = M2 / (Count - 1);
	Result.StdDev = sqrt(Result.Variance);

	return Result;
}

bool IsValidHistoryUV(float2 UV)
{
	return !(any(UV > HistoryUVMinMax.zw) || any(UV < HistoryUVMinMax.xy));
}

struct FBilinear
{
	float2 Origin;
	float2 Weights;
};

FBilinear GetBilinearFilter(float2 UV, float2 TextureSize)
{
	FBilinear Result;
	Result.Origin = floor(UV * TextureSize - .5f);
	Result.Weights = frac(UV * TextureSize - .5f);
	return Result;
}

float4 GetBilinearCustomWeights(FBilinear F, float4 CustomWeights)
{
	float4 Weights;
	Weights.x = (1.0f - F.Weights.x) * (1.0f - F.Weights.y);
	Weights.y = F.Weights.x * (1.0f - F.Weights.y);
	Weights.z = (1.0f - F.Weights.x) * F.Weights.y;
	Weights.w = F.Weights.x * F.Weights.y;
	return Weights * CustomWeights;
}

float3 WeightedAverage(float3 V00, float3 V10,  float3 V01,  float3 V11, float4 Weights)
{
	float3 Result = V00 * Weights.x + V10 * Weights.y + V01 * Weights.z + V11 * Weights.w;
	return Result / max(dot(Weights, 1), .00001f);
}

float WeightedAverage(float4 V, float4 Weights)
{	
	return dot(V, Weights) / max(dot(Weights, 1), .00001f);
}


struct FGatherUV
{
	float2 UV00;
	float2 UV10;
	float2 UV11;
	float2 UV01;
};

FGatherUV GetGatherUV(FBilinear In, float2 InTexelSize)
{
	FGatherUV Out;
	Out.UV00 = (In.Origin + .5f) * InTexelSize;
	Out.UV10 = Out.UV00 + float2(InTexelSize.x, 0);
	Out.UV01 = Out.UV00 + float2(0, InTexelSize.y);
	Out.UV11 = Out.UV00 + InTexelSize;
	return Out;
}

struct FSpecularIndirectHistory
{
	float3 SpecularIndirect;
	float4 Weights;
};

// Fetch the specular indirect history
// * Returns the filtered specular indirect value (average only valid history sample
// * Returns the weights of each indirect samples (valid/invalid)
FSpecularIndirectHistory FetchHistory(FBilinear InBilinear, uint InBSDFIndex, float4 InWeights = float4(1,1,1,1))
{
	FSpecularIndirectHistory Out;
	Out.Weights = GetBilinearCustomWeights(InBilinear, InWeights);
	FGatherUV InHistoryBilinear = GetGatherUV(InBilinear, View.BufferSizeAndInvSize.zw);

	const float4 HistorySpecularIndirect00 = Texture2DArraySampleLevel(SpecularIndirectHistory, GlobalPointClampedSampler, float3(InHistoryBilinear.UV00, InBSDFIndex), 0).xyzw;
	const float4 HistorySpecularIndirect10 = Texture2DArraySampleLevel(SpecularIndirectHistory, GlobalPointClampedSampler, float3(InHistoryBilinear.UV10, InBSDFIndex), 0).xyzw;
	const float4 HistorySpecularIndirect01 = Texture2DArraySampleLevel(SpecularIndirectHistory, GlobalPointClampedSampler, float3(InHistoryBilinear.UV01, InBSDFIndex), 0).xyzw;
	const float4 HistorySpecularIndirect11 = Texture2DArraySampleLevel(SpecularIndirectHistory, GlobalPointClampedSampler, float3(InHistoryBilinear.UV11, InBSDFIndex), 0).xyzw;

	Out.Weights.x *= HistorySpecularIndirect00.w > 0 ? 1.f : 0.f;
	Out.Weights.y *= HistorySpecularIndirect10.w > 0 ? 1.f : 0.f;
	Out.Weights.z *= HistorySpecularIndirect01.w > 0 ? 1.f : 0.f;
	Out.Weights.w *= HistorySpecularIndirect11.w > 0 ? 1.f : 0.f;

	Out.SpecularIndirect = WeightedAverage(HistorySpecularIndirect00.xyz, HistorySpecularIndirect10.xyz, HistorySpecularIndirect01.xyz, HistorySpecularIndirect11.xyz, Out.Weights) * (PrevInvPreExposure * View.PreExposure);
	return Out;
}

struct FHistoryCoord
{
	float2    ScreenPosition;		// In normalized screen coord
	float2    UV;					// UV coord
	FBilinear Bilinear;				// Bilinear weights
	bool      bHistoryWasOnscreen;	// True, if the history coord is visible on screen
};

FHistoryCoord GetHistoryCoord(float2 InHistoryScreenPosition, float2 InHistoryUVMin, float2 InHistoryUVMax, bool bClampScreenUV)
{
	FHistoryCoord Out;
	Out.bHistoryWasOnscreen = true;
	Out.ScreenPosition 		= InHistoryScreenPosition;
	Out.UV 					= Out.ScreenPosition.xy * HistoryScreenPositionScaleBias.xy + HistoryScreenPositionScaleBias.wz;;
	if (bClampScreenUV)
	{
		Out.bHistoryWasOnscreen = all(Out.UV < HistoryUVMinMax.zw) && all(Out.UV > HistoryUVMinMax.xy);
		Out.UV 					= clamp(Out.UV, InHistoryUVMin, InHistoryUVMax);
	}
	Out.Bilinear = GetBilinearFilter(Out.UV, View.BufferSizeAndInvSize.xy);
	return Out;
}

[numthreads(REFLECTION_THREADGROUP_SIZE_1D, 1, 1)]
void ReflectionTemporalReprojectionCS(
	uint GroupId : SV_GroupID,
	uint GroupThreadId : SV_GroupThreadID)
{
	FReflectionTileData TileData;
	const uint2 ReflectionScreenCoord = GetReflectionResolveScreenCoord(GroupId, GroupThreadId, TileData);

	const FLumenMaterialCoord Coord = GetLumenMaterialCoord_Reflection(ReflectionScreenCoord + View.ViewRectMinAndSize.xy, TileData);
	bool bIsOverflow = TileData.ClosureIndex > 0;

	const float2 ScreenUV = (Coord.SvPosition + .5f) * View.BufferSizeAndInvSize.zw;
	const float2 ScreenPosition = (ScreenUV.xy - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;

	const float3 NewSpecular = ResolvedReflections[Coord.SvPositionFlatten].xyz;
	const float ReflectionHitDeviceZ = ResolvedReflectionsDepth[Coord.SvPositionFlatten].x;

#if FRONT_LAYER_TRANSLUCENCY
	const float DeviceZ = FrontLayerTranslucencySceneDepth[Coord.SvPosition].x;
#else
	const float DeviceZ = SceneTexturesStruct.SceneDepthTexture[Coord.SvPosition].x;
#endif
	const float SceneDepth = ConvertFromDeviceZ(DeviceZ);

	const float4 EncodedVelocity = VelocityTexture[Coord.SvPosition];

	const float3 HistoryScreenPositionFromSceneDepth = GetHistoryScreenPosition(ScreenPosition, DeviceZ, DeviceZ, EncodedVelocity);
	const float3 HistoryScreenPositionFromReflectHit = GetHistoryScreenPosition(ScreenPosition, DeviceZ, ReflectionHitDeviceZ, EncodedVelocity);

	const FHistoryCoord HistoryCoordFromSceneDepth = GetHistoryCoord(HistoryScreenPositionFromSceneDepth.xy, HistoryUVMinMax.xy, HistoryUVMinMax.zw, true);
	const FHistoryCoord HistoryCoordFromReflectHit = GetHistoryCoord(HistoryScreenPositionFromReflectHit.xy, HistoryUVMinMax.xy, HistoryUVMinMax.zw, false);

	// For depth/num. frame history gather (using GatherRed)
	const float2 HistoryGatherUV = (HistoryCoordFromSceneDepth.Bilinear.Origin + 1.0f) * View.BufferSizeAndInvSize.zw;

	const FLumenMaterialData Material = ReadMaterialData(Coord, MaxRoughnessToTrace);
	const float Noise = InterleavedGradientNoise(ReflectionScreenCoord.xy, ReflectionsStateFrameIndexMod8);
	float DisocclusionDistanceThreshold = HistoryDistanceThreshold * lerp(.5f, 1.5f, Noise);
	const float PrevSceneDepth = ConvertFromDeviceZ(HistoryScreenPositionFromSceneDepth.z);

#if FRONT_LAYER_TRANSLUCENCY == 0
	const float4 HistoryDepthDeviceZ = DepthHistory.GatherRed(GlobalPointClampedSampler, HistoryGatherUV).wzxy;
	const float4 HistorySceneDepth = float4(ConvertFromDeviceZ(HistoryDepthDeviceZ.x), ConvertFromDeviceZ(HistoryDepthDeviceZ.y), ConvertFromDeviceZ(HistoryDepthDeviceZ.z), ConvertFromDeviceZ(HistoryDepthDeviceZ.w));
#else
	// DepthHistoryRT is not copied for translucency reflections, so we ignore disoclusion for now.
	const float4 HistorySceneDepth = PrevSceneDepth.xxxx;
#endif

#define EXPAND_HISTORY_DISTANCE_THRESHOLD_FOR_JITTER 1
#if EXPAND_HISTORY_DISTANCE_THRESHOLD_FOR_JITTER
	const float3 TranslatedWorldPosition = mul(float4(GetScreenPositionForProjectionType(ScreenPosition, SceneDepth), SceneDepth, 1), View.ScreenToTranslatedWorld).xyz;
	const float3 V = normalize(-TranslatedWorldPosition);
	// Raise the threshold at grazing angles to compensate for TAA jitter causing a depth mismatch dependent on the angle
	// This also introduces some ghosting around characters, needs a better solution
	DisocclusionDistanceThreshold /= clamp(saturate(dot(V, Material.WorldNormal)), .1f, 1.0f);
#endif

	// Compute occlusion weight based on depth differences
	float4 OcclusionWeights = 1;
	{
		const float4 DistanceToHistoryValue = abs(HistorySceneDepth - PrevSceneDepth);
		OcclusionWeights = select(DistanceToHistoryValue >= PrevSceneDepth * DisocclusionDistanceThreshold, 1.0, 0.0);
		OcclusionWeights = saturate((HistoryCoordFromSceneDepth.bHistoryWasOnscreen ? 1.0f : 0.0f) - OcclusionWeights);
	}

	// Compute specular indirect history
	const FSpecularIndirectHistory HistoryFromSceneDepth = FetchHistory(HistoryCoordFromSceneDepth.Bilinear, Coord.ClosureIndex, OcclusionWeights);
	const FSpecularIndirectHistory HistoryFromReflectHit = FetchHistory(HistoryCoordFromReflectHit.Bilinear, Coord.ClosureIndex);

	const uint2 MinScreenCoord = View.ViewRectMinAndSize.xy;
	const uint2 MaxScreenCoord = View.ViewRectMinAndSize.xy + View.ViewRectMinAndSize.zw - 1;
	FNeighborStatistics Neighborhood = GetNeighborStatistics(Coord.SvPosition, MinScreenCoord, MaxScreenCoord, NewSpecular, Coord.ClosureIndex);

	const float InvalidHistoryErrorThreshold = 1e6;
	const float ErrorFromReflectHit = IsValidHistoryUV(HistoryCoordFromReflectHit.UV) ? abs(Luma(HistoryFromReflectHit.SpecularIndirect) - Luma(Neighborhood.Mean)) : InvalidHistoryErrorThreshold;
	const float ErrorFromSceneDepth = IsValidHistoryUV(HistoryCoordFromSceneDepth.UV) ? abs(Luma(HistoryFromSceneDepth.SpecularIndirect) - Luma(Neighborhood.Mean)) : InvalidHistoryErrorThreshold;

	float3 HistorySpecularIndirect = ErrorFromReflectHit < ErrorFromSceneDepth
		? HistoryFromReflectHit.SpecularIndirect 
		: HistoryFromSceneDepth.SpecularIndirect;

#if USE_BILATERAL_FILTER
	float VarianceHistoryWeight = IsValidHistoryUV(HistoryCoordFromReflectHit.UV) ? .9f : 0;
	float NewResolveVariance = ResolveVariance[Coord.SvPositionFlatten];

	if (dot(OcclusionWeights, 1.0f) < 1.0f)
	{
		VarianceHistoryWeight = 0.0f;
		NewResolveVariance = DisocclusionVariance;
	}

	float ResolveVarianceHistoryValue = VarianceHistoryWeight > 0.0f ? Texture2DArraySampleLevel(ResolveVarianceHistory, GlobalBilinearClampedSampler, float3(HistoryCoordFromReflectHit.UV, Coord.ClosureIndex), 0).x : 0;
	float AccumulatedResolveVariance = max(lerp(NewResolveVariance, ResolveVarianceHistoryValue, VarianceHistoryWeight), 0);
	RWResolveVariance[Coord.SvPositionFlatten] = AccumulatedResolveVariance;
	float AccumulatedResolveStdDev = sqrt(AccumulatedResolveVariance);
	Neighborhood.StdDev = max(Neighborhood.StdDev, NeighborhoodClampExpandWithResolveVariance * AccumulatedResolveStdDev);
#endif

#define REPROJECTION_USE_STANDARD_DEVIATION_CLAMP 1
#if REPROJECTION_USE_STANDARD_DEVIATION_CLAMP
	const float3 HistoryClampMin = Neighborhood.Mean - Neighborhood.StdDev;
	const float3 HistoryClampMax = Neighborhood.Mean + Neighborhood.StdDev;
#else
	float3 HistoryClampMin = Neighborhood.Min;
	float3 HistoryClampMax = Neighborhood.Max;
#endif

	HistorySpecularIndirect = clamp(HistorySpecularIndirect, HistoryClampMin, HistoryClampMax);

	float4 NumFramesAccumulatedNeighborhood = HistoryNumFramesAccumulated.GatherRed(GlobalPointClampedSampler, float3(HistoryGatherUV, Coord.ClosureIndex)).wzxy * MaxFramesAccumulated;

	float MaxFrames = MaxFramesAccumulated;

	if (ReflectionDownsampleFactor == 1)
	{
		// Allow more aliasing through as we approach mirror to reduce the temporal reprojection diffusion error, which allows TSR to reconstruct a sharper reflection
		MaxFrames = lerp(2, MaxFramesAccumulated, saturate(Material.TopLayerRoughness / .05f));
	}

	NumFramesAccumulatedNeighborhood = min(NumFramesAccumulatedNeighborhood + 1.0f, MaxFrames);
	float NumFramesAccumulated = WeightedAverage(NumFramesAccumulatedNeighborhood, HistoryFromSceneDepth.Weights);

	float NewNumFramesAccumulated = NumFramesAccumulated;
	NewNumFramesAccumulated = HistoryCoordFromSceneDepth.bHistoryWasOnscreen ? NewNumFramesAccumulated : 0;

	float Alpha = 1.0f / (1.0f + NewNumFramesAccumulated);
#if (SUBSTRATE_ENABLED && FRONT_LAYER_TRANSLUCENCY == 0)
	if (bIsSubstrateTileHistoryValid == 0 && Coord.ClosureIndex > 0) { Alpha = 1.0f; }
#endif
	float3 OutReflections = lerp(HistorySpecularIndirect, NewSpecular, Alpha);

	OutReflections = MakeFinite(OutReflections);

	const bool bValid = any(NewSpecular != FLOAT3_11_11_10_MAX);
	RWSpecularIndirectAccumulated[Coord.SvPositionFlatten] = float4(OutReflections, bValid ? 1.0f : 0.f);
	RWNumHistoryFramesAccumulated[Coord.SvPositionFlatten] = NewNumFramesAccumulated / MaxFramesAccumulated;
}

// Greatly reduces fireflies in disoccluded areas, doesn't change overall energy
#define TONEMAP_WEIGHTING_BILATERAL 1

float3 TonemapLightingForBilateral(float3 Lighting)
{
#if TONEMAP_WEIGHTING_BILATERAL
	return Lighting / (1.0f + Luma(Lighting));
#else
	return Lighting;
#endif
}

float3 InverseTonemapLightingForBilateral(float3 TonemappedLighting)
{
#if TONEMAP_WEIGHTING_BILATERAL
	return TonemappedLighting / (1.0f - Luma(TonemappedLighting));
#else
	return TonemappedLighting;
#endif
}

Texture2DArray<float3> SpecularIndirect;

float BilateralFilterSpatialKernelRadius;
uint BilateralFilterNumSamples;
float BilateralFilterDepthWeightScale;
float BilateralFilterNormalAngleThresholdScale;
float BilateralFilterStrongBlurVarianceThreshold;

[numthreads(REFLECTION_THREADGROUP_SIZE_1D, 1, 1)]
void ReflectionBilateralFilterCS(
	uint GroupId : SV_GroupID,
	uint GroupThreadId : SV_GroupThreadID)
{
	FReflectionTileData TileData;
	uint2 ScreenCoord = GetReflectionResolveScreenCoord(GroupId, GroupThreadId, TileData);
	const FLumenMaterialCoord Coord = GetLumenMaterialCoord_Reflection(ScreenCoord + View.ViewRectMinAndSize.xy, TileData);
	bool bIsOverflow = TileData.ClosureIndex > 0;


	float2 ScreenUV = (Coord.SvPosition + 0.5f) * View.BufferSizeAndInvSize.zw;
#if FRONT_LAYER_TRANSLUCENCY
	float SceneDepth = Texture2DSampleLevel(FrontLayerTranslucencySceneDepth, GlobalBilinearClampedSampler, ScreenUV, 0).r;
#else
	float SceneDepth = CalcSceneDepth(ScreenUV);
#endif

	float3 OutReflections = 0;

	const FLumenMaterialData Material = ApplySmoothBias(ReadMaterialData(Coord, MaxRoughnessToTrace), true /*bTopLayerRoughness*/);

	if (NeedRayTracedReflections(Material.TopLayerRoughness, Material))
	{
		OutReflections = TonemapLightingForBilateral(SpecularIndirect[Coord.SvPositionFlatten]);

		float VarianceFromSpatialResolve = ResolveVariance[Coord.SvPositionFlatten];

		float StrongBlur = VarianceFromSpatialResolve > BilateralFilterStrongBlurVarianceThreshold ? 1.0f : 0.0f;
		float DisocclusionBlur = VarianceFromSpatialResolve > DisocclusionVariance - .1f ? 1.0f : 0.0f;
		float MinKernelRadius = 0.0f;
		float MaxKernelRadius = BilateralFilterSpatialKernelRadius * View.ViewSizeAndInvSize.x * lerp(1.0f, 2.0f, StrongBlur);
		float KernelRadius = lerp(MinKernelRadius, MaxKernelRadius, saturate(Material.TopLayerRoughness * 8));

		if (KernelRadius >= .5f && VarianceFromSpatialResolve > .04f)
		{
			float TotalWeight = 1.0f;
			float GuassianNormalize = 2.0f / (KernelRadius * KernelRadius);
			float InvSpecularLobeAngleThreshold = 1.0f / (lerp(.0001f * PI, PI, Material.Roughness * Material.Roughness) * BilateralFilterNormalAngleThresholdScale);
			uint2 RandomSeed = Rand3DPCG16(int3(Coord.SvPosition, ReflectionsStateFrameIndexMod8)).xy;

			float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);
			float4 ScenePlane = float4(Material.WorldNormal, dot(WorldPosition, Material.WorldNormal));

			uint NumBilateralFilterSamples = min(BilateralFilterNumSamples * lerp(1, 2, StrongBlur), 16u);

			for (uint SampleIndex = 0; SampleIndex < NumBilateralFilterSamples; SampleIndex++)
			{
				float2 Offset = (Hammersley16(SampleIndex, NumBilateralFilterSamples, RandomSeed) - .5f) * 2 * KernelRadius;
				int2 NeighborSvPosition = (int2)(Coord.SvPosition + Offset);

				if (all(and(NeighborSvPosition >= (int2)View.ViewRectMinAndSize.xy, NeighborSvPosition < (int2)(View.ViewRectMinAndSize.xy + View.ViewRectMinAndSize.zw))))
				{
					const FLumenMaterialCoord NeighborCoord = GetLumenMaterialCoord(NeighborSvPosition, Coord.ClosureIndex);

					float2 NeighborScreenUV = (NeighborCoord.SvPosition + 0.5f) * View.BufferSizeAndInvSize.zw;
					const FLumenMaterialData NeighborMaterial = ApplySmoothBias(ReadMaterialData(NeighborCoord, MaxRoughnessToTrace), true /*bTopLayerRoughness*/);
					const float3 NeighborWorldPosition = GetWorldPositionFromScreenUV(NeighborScreenUV, NeighborMaterial.SceneDepth);

					// Avoid reading from unprocessed tiles
					if (NeedRayTracedReflections(NeighborMaterial.TopLayerRoughness, NeighborMaterial))
					{
						float PlaneDistance = abs(dot(float4(NeighborWorldPosition, -1), ScenePlane));
						float RelativeDepthDifference = PlaneDistance / SceneDepth;
						float DepthWeight = exp2(-BilateralFilterDepthWeightScale * (RelativeDepthDifference * RelativeDepthDifference));
						float SpatialWeight = exp2(-GuassianNormalize * dot(Offset, Offset));
						float AngleBetweenNormals = acosFast(saturate(dot(ScenePlane.xyz, NeighborMaterial.WorldNormal)));
						float NormalWeight = 1.0f - saturate(AngleBetweenNormals * InvSpecularLobeAngleThreshold);

						float SampleWeight = SpatialWeight * DepthWeight * lerp(NormalWeight, 1, DisocclusionBlur);
						OutReflections += TonemapLightingForBilateral(SpecularIndirect[NeighborCoord.SvPositionFlatten]) * SampleWeight;
						TotalWeight += SampleWeight;
					}
				}
			}

			OutReflections = OutReflections / TotalWeight;

			if (DisocclusionBlur > 0)
			{
				//OutReflections = float3(10, 0, 0);
			}
		}

		OutReflections = InverseTonemapLightingForBilateral(OutReflections);
	}

	RWSpecularIndirect[Coord.SvPositionFlatten] = OutReflections;
}

[numthreads(REFLECTION_THREADGROUP_SIZE_1D, 1, 1)]
void ReflectionPassthroughCopyCS(
	uint GroupId : SV_GroupID,
	uint GroupThreadId : SV_GroupThreadID)
{
	FReflectionTileData TileData;
	uint2 ReflectionScreenCoord = GetReflectionResolveScreenCoord(GroupId, GroupThreadId, TileData);
	const FLumenMaterialCoord Coord = GetLumenMaterialCoord_Reflection(ReflectionScreenCoord + View.ViewRectMinAndSize.xy, TileData);
	bool bIsOverflow = TileData.ClosureIndex > 0;

	const float3 NewSpecular = ResolvedReflections[Coord.SvPositionFlatten].xyz;
	const bool bValid = any(NewSpecular != FLOAT3_11_11_10_MAX);
	RWSpecularIndirectAccumulated[Coord.SvPositionFlatten] = float4(NewSpecular, bValid ? 1 : 0);

	RWNumHistoryFramesAccumulated[Coord.SvPositionFlatten] = 0.0f;

#if USE_BILATERAL_FILTER
	RWResolveVariance[Coord.SvPositionFlatten] = ResolveVariance[Coord.SvPositionFlatten];
#endif
}
