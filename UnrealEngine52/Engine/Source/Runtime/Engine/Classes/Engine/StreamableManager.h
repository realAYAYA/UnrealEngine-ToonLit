// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Containers/ArrayView.h"
#include "Math/NumericLimits.h"
#include "Templates/Casts.h"
#include "Templates/Function.h"
#include "UObject/Class.h"
#include "UObject/GCObject.h"
#include "UObject/ObjectMacros.h"
#include "UObject/SoftObjectPtr.h"

/** Defines FStreamableDelegate delegate interface */
DECLARE_DELEGATE(FStreamableDelegate);
DECLARE_DELEGATE_OneParam(FStreamableUpdateDelegate, TSharedRef<struct FStreamableHandle>);


/** Storage class of the per-class id used in FStreamableHandleContextDataBase */
typedef uint8 TStreamableHandleContextDataTypeID;

enum { TStreamableHandleContextDataTypeIDInvalid = TNumericLimits<TStreamableHandleContextDataTypeID>::Max() };

/** struct to hold a TStreamableHandleContextDataTypeID that is invalid until assigned. */
struct TStreamableHandleContextDataTypeIDStorage
{
private:
	TStreamableHandleContextDataTypeID Value = TStreamableHandleContextDataTypeIDInvalid;
	template <typename SubClassType> friend struct TStreamableHandleContextData;
};

/** Base struct to hold type tag data for TStreamableHandleContextData. */
struct FStreamableHandleContextDataBase : public TSharedFromThis<FStreamableHandleContextDataBase, ESPMode::ThreadSafe>
{
	TStreamableHandleContextDataTypeID GetInstanceTypeId() const
	{
		return InstanceTypeId;
	}
	template <typename SubClassType> bool IsType() const
	{
		return GetInstanceTypeId() == SubClassType::GetClassTypeId();
	}

protected:
	FStreamableHandleContextDataBase(TStreamableHandleContextDataTypeID TypeId)
		: InstanceTypeId(TypeId)
	{}

	ENGINE_API static TStreamableHandleContextDataTypeID AllocateClassTypeId();

private:
	TStreamableHandleContextDataTypeID InstanceTypeId;
};

/**
 * Templated struct that provides type tags (no RTTI) for internal data used on StreamableHandle
 * Type IDs are not stable across multiple processes, so should never be directly serialized or stored.
 */
template <typename SubClassType>
struct TStreamableHandleContextData : public FStreamableHandleContextDataBase
{
	TStreamableHandleContextData()
		: FStreamableHandleContextDataBase(GetClassTypeId())
	{}

	static TStreamableHandleContextDataTypeID GetClassTypeId()
	{
		// Subclasses of TStreamableHandleContextData must implement 
		//     MODULE_API static TStreamableHandleContextDataTypeIDStorage&
		//     TypeIdCrossModuleStorage() { static TStreamableHandleContextDataTypeIDStorage Id; return Id; }
		// With MODULE_API being e.g. ENGINE_API.
		// MODULE_API is required for classes used across modules, to ensure that all modules see the same value.
		TStreamableHandleContextDataTypeIDStorage& ClassTypeId = SubClassType::TypeIdCrossModuleStorage();
		if (ClassTypeId.Value == TStreamableHandleContextDataTypeIDInvalid)
		{
			ClassTypeId.Value = AllocateClassTypeId();
		}
		return ClassTypeId.Value;
	}
};

/** A handle to a synchronous or async load. As long as the handle is Active, loaded assets will stay in memory */
struct ENGINE_API FStreamableHandle : public TSharedFromThis<FStreamableHandle>
{
	/** 
	 * If this request has finished loading, meaning all available assets were loaded
	 * Any assets that failed to load will still be null
	 * This can be true before the completion callback has happened as it may be in the delayed callback queue
	 */
	bool HasLoadCompleted() const
	{
		return bLoadCompleted;
	}

	/** If this request was cancelled. Assets may still have been loaded, but completion delegate was not called */
	bool WasCanceled() const
	{
		return bCanceled;
	}

	/** True if load is still ongoing and we haven't been cancelled */
	bool IsLoadingInProgress() const
	{
		return !bLoadCompleted && !bCanceled;
	}

	/** If this handle is still active, meaning it wasn't canceled or released */
	bool IsActive() const
	{
		return !bCanceled && !bReleased;
	}

	/** If this handle is stalled and waiting for another event to occur before it is actually requested */
	bool IsStalled() const
	{
		return bStalled;
	}

	/** Returns true if this is a combined handle that depends on child handles. */
	bool IsCombinedHandle() const
	{
		return bIsCombinedHandle;
	}

	/** Returns true if we've done all the loading we can now, ie all handles are either completed or stalled */
	bool HasLoadCompletedOrStalled() const;

	/** Allows user code to provide a more detailed name in the cases where a name is autogenerated or otherwise default. */
	void SetDebugNameIfEmptyOrDefault(const FString& NewName);

	/** Returns the debug name for this handle. */
	const FString& GetDebugName() const
	{
		return DebugName;
	}

	/** Returns the streaming priority. */
	TAsyncLoadPriority GetPriority() const
	{
		return Priority;
	}

	/**
	 * Release this handle. This can be called from normal gameplay code to indicate that the loaded assets are no longer needed
	 * This will be called implicitly if all shared pointers to this handle are destroyed
	 * If called before the completion delegate, the release will be delayed until after completion
	 */
	void ReleaseHandle();

	/**
	 * Cancel a request, callable from within the manager or externally
	 * This will immediately release the handle even if it is still in progress, and call the cancel callback if bound
	 * This stops the completion callback from happening, even if it is in the delayed callback queue
	 */
	void CancelHandle();

	/** Tells a stalled handle to start its actual request. */
	void StartStalledHandle();

	/** Check to see whether or not the Complete delegate is bound; useful for doing extra work before/without stomping the existing delegate. */
	bool HasCompleteDelegate() const;

	/** Check to see whether or not the Cancel delegate is bound; useful for doing extra work before/without stomping the existing delegate. */
	bool HasCancelDelegate() const;

	/** Check to see whether or not the Update delegate is bound; useful for doing extra work before/without stomping the existing delegate. */
	bool HasUpdateDelegate() const;

	/** Bind delegate that is called when load completes, only works if loading is in progress. This will overwrite any already bound delegate! */
	bool BindCompleteDelegate(FStreamableDelegate NewDelegate);

	/** Bind delegate that is called if handle is canceled, only works if loading is in progress. This will overwrite any already bound delegate! */
	bool BindCancelDelegate(FStreamableDelegate NewDelegate);

	/** Bind delegate that is called periodically as delegate updates, only works if loading is in progress. This will overwrite any already bound delegate! */
	bool BindUpdateDelegate(FStreamableUpdateDelegate NewDelegate);

	/**
	 * Blocks until the requested assets have loaded. This pushes the requested asset to the top of the priority list,
	 * but does not flush all async loading, usually resulting in faster completion than a LoadObject call
	 *
	 * @param Timeout				Maximum time to wait, if this is 0 it will wait forever
	 * @param StartStalledHandles	If true it will force all handles waiting on external resources to try and load right now
	 */
	EAsyncPackageState::Type WaitUntilComplete(float Timeout = 0.0f, bool bStartStalledHandles = true);

	/** 
	 * Gets list of assets references this load was started with. This will be the paths before redirectors, and not all of these are guaranteed to be loaded 
	 * 
	 * @param AssetList  Output array for requested assets. Array is Reset before adding values.
	 * @param bIncludeChildren Whether the child handles should be included in the search.
	 */
	void GetRequestedAssets(TArray<FSoftObjectPath>& AssetList, bool bIncludeChildren = true) const;

	/** Adds all loaded assets if load has succeeded. Some entries will be null if loading failed */
	void GetLoadedAssets(TArray<UObject *>& LoadedAssets) const;

	/** Returns first asset in requested asset list, if it's been successfully loaded. This will fail if the asset failed to load */
	UObject* GetLoadedAsset() const;

	/** Returns number of assets that have completed loading out of initial list, failed loads will count as loaded */
	void GetLoadedCount(int32& LoadedCount, int32& RequestedCount) const;

	/**
	 * Invokes a callable for each loaded asset if load has succeeded. Some entries will be null if loading failed
	 *
	 * @param Callable	Callable object
	 */
	template <typename CallableT>
	void ForEachLoadedAsset(CallableT Callable) const;

	/** Returns progress as a value between 0.0 and 1.0. */
	float GetProgress() const;

	/** Get the StreamableManager for this handle */
	struct FStreamableManager* GetOwningManager() const;

	/** 
	 * Calls a StreamableDelegate, this will add to the delayed callback queue depending on s.StreamableDelegateDelayFrames
	 *
	 * @param Delegate			Primary delegate to execute
	 * @param AssociatedHandle	Streamable handle associated with this delegate, may be null
	 * @param CancelDelegate	If handle gets cancelled before primary delegate executes, this delegate will be called instead
	 */
	static void ExecuteDelegate(const FStreamableDelegate& Delegate, TSharedPtr<FStreamableHandle> AssociatedHandle = nullptr, const FStreamableDelegate& CancelDelegate = FStreamableDelegate());

	/**
	 * Return a TSharedPtr of the first handle among this and descendants which satisfies the predicate.
	 * 
	 * @param Predicate	Conditional applied to each candidate handle
	 * @return Either the first matching handle, or nullptr
	 * 
	 * @see GetOutermostHandle
	 */
	TSharedPtr<FStreamableHandle> FindMatchingHandle(TFunction<bool(const FStreamableHandle&)> Predicate) const;

	/**
	 * Creates a new merged handle which contains this handle as well as any external handles.
	 * No delegates are moved, and the new handle is returned for convenience. Parent handles no longer directly track `this`,
	 * but will be correctly linked with the newly merged handle (and `this` handle is a child of the merged hande).
	 * 
	 * @param OtherHandles	Container of handles which should be merged with this handle
	 * @return Either the new merged handle or nullptr when merging isn't feasible
	 */
	TSharedPtr<FStreamableHandle> CreateCombinedHandle(const TConstArrayView<TSharedPtr<FStreamableHandle>>& OtherHandles);

	/**
	 * Crawls out to the outermost handle and returns it. Since we could have multiple Parent handles, we might have a tie. 
	 * In cases of a tie, the eldest parent handle (so, lower indices) will win.
	 * 
	 * @return The single parent which is the most outer, or this if no Parent Handle
	 */
	TSharedPtr<FStreamableHandle> GetOutermostHandle();

	/**
	 * Gives you a mutable reference to a contextual data struct of the specified type.
	 *
	 * @return Either a newly constructed T, or one which was previously added to this handle.
	 */
	template <typename T>
	T& FindOrAddContextData()
	{
		TSharedPtr<T> FoundInternally = FindFirstContextDataOfType<T>();
		if (FoundInternally.IsValid())
		{
			return *FoundInternally.Get();
		}

		TSharedPtr<T> FreshlyAdded = MakeShared<T>();
		AddContextData(FreshlyAdded);

		return *FreshlyAdded.Get();
	}

	/**
	 * Unconditionally adds a contextual data struct to this handle. Uniqueness is not enforced.
	 * 
	 * @see FindFirstContextDataOfType
	 */
	template <typename T>
	void AddContextData(const TSharedPtr<T>& NewData)
	{
		AdditionalContextData.Add(NewData);
	}

	/**
	 * Finds the first instance of a contextual data struct which is attached to this handle.
	 *
	 * @return Either nullptr, or TSharedPtr to the first instance of a T on this handle.
	 * @see AddContextData
	 */
	template <typename T>
	TSharedPtr<T> FindFirstContextDataOfType() const
	{
		for (const TSharedPtr<FStreamableHandleContextDataBase>& InternalPtr : AdditionalContextData)
		{
			if (InternalPtr.IsValid() && InternalPtr->IsType<T>())
			{
				return StaticCastSharedPtr<T>(InternalPtr);
			}
		}
		
		return nullptr;
	}

	/**
	 * Finds all instances of a contextual data struct which are attached to this handle
	 *
	 * @return Array filled with all instances of T currently attached to this handle
	 */
	template <typename T>
	TArray<TSharedPtr<T>> GetContextDataOfType() const
	{
		TArray<TSharedPtr<T>> OfType;

		for (const TSharedPtr<FStreamableHandleContextDataBase>& InternalPtr : AdditionalContextData)
		{
			if (InternalPtr.IsValid() && InternalPtr->IsType<T>())
			{
				OfType.Add(StaticCastSharedPtr<T>(InternalPtr));
			}
		}

		return OfType;
	}

	/** Destructor */
	~FStreamableHandle();

	/** Not safe to copy or duplicate */
	FStreamableHandle(const FStreamableHandle&) = delete;
	FStreamableHandle& operator=(const FStreamableHandle&) = delete;

	static const FString HandleDebugName_Preloading;
	static const FString HandleDebugName_AssetList;
	static const FString HandleDebugName_CombinedHandle;

private:
	friend struct FStreamableManager;
	friend struct FStreamable;

	/** Called from self as part of SetDebugNameIfEmptyOrDefault */
	bool IsHandleNameEmptyOrDefault() const;

	/** Called from manager to complete the request */
	void CompleteLoad();

	/** Callback when async load finishes, it's here so we can use a shared pointer for callback safety */
	void AsyncLoadCallbackWrapper(const FName& PackageName, UPackage* LevelPackage, EAsyncLoadingResult::Type Result, FSoftObjectPath TargetName);

	/** Notify all parents that a child completed loading */
	void NotifyParentsOfCompletion();

	/** Notify all parents that a child was canceled */
	void NotifyParentsOfCancellation();

	/** Called on meta handle when a child handle has completed/canceled */
	void UpdateCombinedHandle();

	/** Call to call the update delegate if bound, will propagate to parents */
	void CallUpdateDelegate();

	/** Unbind all of our delegates, called after a cancel/load */
	void UnbindDelegates();

	/** True if this request has finished loading. It may still be active, or it may have been released */
	bool bLoadCompleted;

	/** True if this request was released, which will stop it from keeping hard GC references */
	bool bReleased;

	/** True if this request was explicitly canceled, which stops it from calling the completion delegate and immediately releases it */
	bool bCanceled;

	/** True if this handle has been created but not yet actually requested. This handle is probably waiting for a resource like a chunk to be available */
	bool bStalled;

	/** If true, this handle will be released when it finishes loading */
	bool bReleaseWhenLoaded;

	/** If true, this handle will be released when it finishes loading */
	bool bIsCombinedHandle;

	/** Delegate to call when streaming is completed */
	FStreamableDelegate CompleteDelegate;

	/** Delegate to call when streaming is canceled */
	FStreamableDelegate CancelDelegate;

	/** Called periodically during streaming to update progress UI */
	FStreamableUpdateDelegate UpdateDelegate;

	/** Name of this handle, passed in by caller to help in debugging */
	FString DebugName;

	/** The async priority for this request */
	TAsyncLoadPriority Priority;

	/** How many FStreamables is this waiting on to finish loading */
	int32 StreamablesLoading;

	/** How many of our children that have been completed */
	int32 CompletedChildCount = 0;

	/** How many of our children that have been canceled */
	int32 CanceledChildCount = 0;

	/** List of assets that were referenced by this handle */
	TArray<FSoftObjectPath> RequestedAssets;

	/** List of handles this depends on, these will keep the child references alive */
	TArray<TSharedPtr<FStreamableHandle> > ChildHandles;

	/** Backpointer to handles that depend on this */
	TArray<TWeakPtr<FStreamableHandle> > ParentHandles;

	/** This is set at the time of creation, and will be cleared when request completes or is canceled */
	struct FStreamableManager* OwningManager;

	/** Array of contextual data added by game/engine code */
	TArray<TSharedPtr<FStreamableHandleContextDataBase>> AdditionalContextData;

	FStreamableHandle()
		: bLoadCompleted(false)
		, bReleased(false)
		, bCanceled(false)
		, bStalled(false)
		, bReleaseWhenLoaded(false)
		, bIsCombinedHandle(false)
		, Priority(0)
		, StreamablesLoading(0)
		, OwningManager(nullptr)
	{
	}
};

enum class EStreamableManagerCombinedHandleOptions : uint8 
{
	None = 0,
	/** If present, the DebugName of the merged handle will concatenate DebugName of all merged handles, otherwise it will be set to DebugName argument. */
	MergeDebugNames = 0x01,
	/** If present, existing parent handles will be redirected to point to the merged handle, otherwise they will continue pointing to the child handles directly. */ 
	RedirectParents = 0x02,
	/** If present, nullptr handles are ignored (and will not be present in the merged handle), otherwise merged handle creation will fail when nullptr handles are present. */
	SkipNulls = 0x04,
};

ENUM_CLASS_FLAGS(EStreamableManagerCombinedHandleOptions);

/** A native class for managing streaming assets in and keeping them in memory. AssetManager is the global singleton version of this with blueprint access */
struct ENGINE_API FStreamableManager : public FGCObject
{
	// Default priority for all async loads
	static const TAsyncLoadPriority DefaultAsyncLoadPriority = 0;
	// Priority to try and load immediately
	static const TAsyncLoadPriority AsyncLoadHighPriority = 100;

	/** 
	 * This is the primary streamable operation. Requests streaming of one or more target objects. When complete, a delegate function is called. Returns a Streamable Handle.
	 *
	 * @param TargetsToStream		Assets to load off disk
	 * @param DelegateToCall		Delegate to call when load finishes. Will be called on the next tick if asset is already loaded, or many seconds later
	 * @param Priority				Priority to pass to the streaming system, higher priority will be loaded first
	 * @param bManageActiveHandle	If true, the manager will keep the streamable handle active until explicitly released
	 * @param bStartStalled			If true, the handle will start in a stalled state and will not attempt to actually async load until StartStalledHandle is called on it
	 * @param DebugName				Name of this handle, will be reported in debug tools
	 */
	TSharedPtr<FStreamableHandle> RequestAsyncLoad(TArray<FSoftObjectPath> TargetsToStream, FStreamableDelegate DelegateToCall = FStreamableDelegate(), TAsyncLoadPriority Priority = DefaultAsyncLoadPriority, bool bManageActiveHandle = false, bool bStartStalled = false, FString DebugName = TEXT("ArrayDelegate"));
	TSharedPtr<FStreamableHandle> RequestAsyncLoad(const FSoftObjectPath& TargetToStream, FStreamableDelegate DelegateToCall = FStreamableDelegate(), TAsyncLoadPriority Priority = DefaultAsyncLoadPriority, bool bManageActiveHandle = false, bool bStartStalled = false, FString DebugName = TEXT("SingleDelegate"));

	/** Lambda Wrappers. Be aware that Callback may go off multiple seconds in the future. */
	TSharedPtr<FStreamableHandle> RequestAsyncLoad(TArray<FSoftObjectPath> TargetsToStream, TFunction<void()>&& Callback, TAsyncLoadPriority Priority = DefaultAsyncLoadPriority, bool bManageActiveHandle = false, bool bStartStalled = false, FString DebugName = TEXT("ArrayLambda"));
	TSharedPtr<FStreamableHandle> RequestAsyncLoad(const FSoftObjectPath& TargetToStream, TFunction<void()>&& Callback, TAsyncLoadPriority Priority = DefaultAsyncLoadPriority, bool bManageActiveHandle = false, bool bStartStalled = false, FString DebugName = TEXT("SingleLambda"));

	/** 
	 * Synchronously load a set of assets, and return a handle. This can be very slow and may stall the game thread for several seconds.
	 * 
	 * @param TargetsToStream		Assets to load off disk
	 * @param bManageActiveHandle	If true, the manager will keep the streamable handle active until explicitly released
	 * @param DebugName				Name of this handle, will be reported in debug tools
	 */
	TSharedPtr<FStreamableHandle> RequestSyncLoad(TArray<FSoftObjectPath> TargetsToStream, bool bManageActiveHandle = false, FString DebugName = TEXT("RequestSyncLoad Array"));
	TSharedPtr<FStreamableHandle> RequestSyncLoad(const FSoftObjectPath& TargetToStream, bool bManageActiveHandle = false, FString DebugName = TEXT("RequestSyncLoad Single"));

	/** 
	 * Synchronously load the referred asset and return the loaded object, or nullptr if it can't be found. This can be very slow and may stall the game thread for several seconds.
	 * 
	 * @param Target				Specific asset to load off disk
	 * @param bManageActiveHandle	If true, the manager will keep the streamable handle active until explicitly released
	 * @param RequestHandlePointer	If non-null, this will set the handle to the handle used to make this request. This useful for later releasing the handle
	 */
	UObject* LoadSynchronous(const FSoftObjectPath& Target, bool bManageActiveHandle = false, TSharedPtr<FStreamableHandle>* RequestHandlePointer = nullptr);

	/** Typed wrappers */
	template< typename T >
	T* LoadSynchronous(const FSoftObjectPath& Target, bool bManageActiveHandle = false, TSharedPtr<FStreamableHandle>* RequestHandlePointer = nullptr)
	{
		return Cast<T>(LoadSynchronous(Target, bManageActiveHandle, RequestHandlePointer) );
	}

	template< typename T >
	T* LoadSynchronous(const TSoftObjectPtr<T>& Target, bool bManageActiveHandle = false, TSharedPtr<FStreamableHandle>* RequestHandlePointer = nullptr)
	{
		return Cast<T>(LoadSynchronous(Target.ToSoftObjectPath(), bManageActiveHandle, RequestHandlePointer));
	}

	template< typename T >
	TSubclassOf<T> LoadSynchronous(const TSoftClassPtr<T>& Target, bool bManageActiveHandle = false, TSharedPtr<FStreamableHandle>* RequestHandlePointer = nullptr)
	{
		TSubclassOf<T> ReturnClass;
		ReturnClass = Cast<UClass>(LoadSynchronous(Target.ToSoftObjectPath(), bManageActiveHandle, RequestHandlePointer));
		return ReturnClass;
	}

	/** 
	 * Creates a combined handle, which will wait for other handles to complete before completing.
	 * The child handles will be held as hard references as long as this handle is active.
	 * 
	 * @param ChildHandles			List of handles to wrap into this one
	 * @param DebugName				Name of this handle, will be reported in debug tools
	 */
	TSharedPtr<FStreamableHandle> CreateCombinedHandle(const TConstArrayView<TSharedPtr<FStreamableHandle>>& ChildHandles,
		const FString& DebugName = FStreamableHandle::HandleDebugName_CombinedHandle,
		EStreamableManagerCombinedHandleOptions Options = EStreamableManagerCombinedHandleOptions::None);

	/** 
	 * Gets list of handles that are directly referencing this asset, returns true if any found.
	 * Combined Handles will not be returned by this function.
	 *
	 * @param Target					Asset to get active handles for 
	 * @param HandleList				Fill in list of active handles
	 * @param bOnlyManagedHandles		If true, only return handles that are managed by this manager, other active handles are skipped
	 */
	bool GetActiveHandles(const FSoftObjectPath& Target, TArray<TSharedRef<FStreamableHandle>>& HandleList, bool bOnlyManagedHandles = false) const;

	/** Returns true if all pending async loads have finished for this target */
	bool IsAsyncLoadComplete(const FSoftObjectPath& Target) const;

	/** This will release any managed active handles pointing to the target soft object path, even if they include other requested assets in the same load */
	void Unload(const FSoftObjectPath& Target);

	/** Checks for any redirectors that were previously loaded, and returns the redirected target if found. This will not handle redirects that it doesn't yet know about */
	FSoftObjectPath ResolveRedirects(const FSoftObjectPath& Target) const;

	/** Returns the debug name for this manager */
	const FString& GetManagerName() const;

	/** Modifies the debug name of this manager, used for debugging GC references */
	void SetManagerName(FString InName);

	/** Add referenced objects to stop them from GCing */
	virtual void AddReferencedObjects(FReferenceCollector& Collector) override;
	virtual FString GetReferencerName() const override { return ManagerName; }
	virtual bool GetReferencerPropertyName(UObject* Object, FString& OutPropertyName) const override;

	FStreamableManager();
	~FStreamableManager();

	/** Not safe to copy or duplicate */
	FStreamableManager(const FStreamableManager&) = delete;
	FStreamableManager& operator=(const FStreamableManager&) = delete;
private:
	friend FStreamableHandle;

	void RemoveReferencedAsset(const FSoftObjectPath& Target, TSharedRef<FStreamableHandle> Handle);
	void StartHandleRequests(TSharedRef<FStreamableHandle> Handle);
	void FindInMemory(FSoftObjectPath& InOutTarget, struct FStreamable* Existing, UPackage* Package = nullptr);
	FSoftObjectPath HandleLoadedRedirector(UObjectRedirector* LoadedRedirector, FSoftObjectPath RequestedPath, struct FStreamable* RequestedStreamable);
	struct FStreamable* FindStreamable(const FSoftObjectPath& Target) const;
	struct FStreamable* StreamInternal(const FSoftObjectPath& Target, TAsyncLoadPriority Priority, TSharedRef<FStreamableHandle> Handle);
	UObject* GetStreamed(const FSoftObjectPath& Target) const;
	void CheckCompletedRequests(const FSoftObjectPath& Target, struct FStreamable* Existing);

	void OnPreGarbageCollect();
	void AsyncLoadCallback(FSoftObjectPath Request, UPackage* Package);

	/** Map of paths to streamable objects, this will be the post-redirector name */
	typedef TMap<FSoftObjectPath, struct FStreamable*> TStreamableMap;
	TStreamableMap StreamableItems;

	/** Map of redirected paths */
	struct FRedirectedPath
	{
		/** The path of the non-redirector object loaded */
		FSoftObjectPath NewPath;

		/** The redirector that was loaded off disk, need to keep this around for path resolves until this redirect is freed */
		UObjectRedirector* LoadedRedirector;

		FRedirectedPath() : LoadedRedirector(nullptr) {}
		FRedirectedPath(const FSoftObjectPath& InNewPath, UObjectRedirector* InLoadedRedirector) : NewPath(InNewPath),LoadedRedirector(InLoadedRedirector) {}
	};
	typedef TMap<FSoftObjectPath, FRedirectedPath> TStreamableRedirects;
	TStreamableRedirects StreamableRedirects;

	/** List of explicitly held handles */
	TArray<TSharedRef<FStreamableHandle>> ManagedActiveHandles;

	/** List of combined handles that are still loading, these need to be here to avoid them being deleted */
	TArray<TSharedRef<FStreamableHandle>> PendingCombinedHandles;

	/** If True, temporarily force synchronous loading */
	bool bForceSynchronousLoads;

	/** Debug name of this manager */
	FString ManagerName;
};

template <typename CallableT>
void FStreamableHandle::ForEachLoadedAsset(CallableT Callable) const
{
	if (HasLoadCompleted())
	{
		for (const FSoftObjectPath& Ref : RequestedAssets)
		{
			// Try manager, should be faster and will handle redirects better
			if (IsActive())
			{
				Invoke(Callable, OwningManager->GetStreamed(Ref));
			}
			else
			{
				Invoke(Callable, Ref.ResolveObject());
			}
		}

		// Check child handles
		for (const TSharedPtr<FStreamableHandle>& ChildHandle : ChildHandles)
		{
			for (const FSoftObjectPath& Ref : ChildHandle->RequestedAssets)
			{
				// Try manager, should be faster and will handle redirects better
				if (IsActive())
				{
					Invoke(Callable, OwningManager->GetStreamed(Ref));
				}
				else
				{
					Invoke(Callable, Ref.ResolveObject());
				}
			}
		}
	}
}
