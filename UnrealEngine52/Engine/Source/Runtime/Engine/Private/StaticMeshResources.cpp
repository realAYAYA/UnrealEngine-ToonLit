// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	StaticMeshResources.cpp
=============================================================================*/

#include "StaticMeshResources.h"
#include "RenderingThread.h"
#include "SceneInterface.h"
#include "UObject/UObjectIterator.h"


FStaticMeshComponentRecreateRenderStateContext::FStaticMeshComponentRecreateRenderStateContext(UStaticMesh* InStaticMesh, bool InUnbuildLighting, bool InRefreshBounds)
	: FStaticMeshComponentRecreateRenderStateContext(TArray<UStaticMesh*>{ InStaticMesh }, InUnbuildLighting, InRefreshBounds)
{
}

FStaticMeshComponentRecreateRenderStateContext::FStaticMeshComponentRecreateRenderStateContext(const TArray<UStaticMesh*>& InStaticMeshes, bool InUnbuildLighting, bool InRefreshBounds)
	: bUnbuildLighting(InUnbuildLighting)
	, bRefreshBounds(InRefreshBounds)
{
	StaticMeshComponents.Reserve(InStaticMeshes.Num());
	for (UStaticMesh* StaticMesh : InStaticMeshes)
	{
		if (StaticMesh)
		{
			StaticMeshComponents.Add(StaticMesh);
		}
	}

	if (StaticMeshComponents.Num())
	{
		TSet<FSceneInterface*> Scenes;

		const EObjectFlags AdditionalExclusionFlags = RF_ClassDefaultObject;
		const bool bIncludeDerivedClasses = true;
		const EInternalObjectFlags InternalExclusionFlags = EInternalObjectFlags::Garbage;

		for (TObjectIterator<UStaticMeshComponent> It(AdditionalExclusionFlags, bIncludeDerivedClasses, InternalExclusionFlags); It; ++It)
		{
			UStaticMesh* StaticMesh = It->GetStaticMesh();

			if (StaticMeshComponents.Contains(StaticMesh))
			{
				checkf(!It->IsUnreachable(), TEXT("%s"), *It->GetFullName());

				if (It->bRenderStateCreated)
				{
					check(It->IsRegistered());
					It->DestroyRenderState_Concurrent();
					StaticMeshComponents[StaticMesh].Add(*It);
					Scenes.Add(It->GetScene());
				}
			}
			// Recreate dirty render state, if needed, only for components not using the static mesh we currently have released resources for.
			else if (It->IsRenderStateDirty() && It->IsRegistered() && !It->IsTemplate() && IsValid(*It))
			{
				It->DoDeferredRenderUpdates_Concurrent();
			}
		}

		UpdateAllPrimitiveSceneInfosForScenes(MoveTemp(Scenes));

		// Flush the rendering commands generated by the detachments.
		// The static mesh scene proxies reference the UStaticMesh, and this ensures that they are cleaned up before the UStaticMesh changes.
		FlushRenderingCommands();
	}
}

const TArray<UStaticMeshComponent*>& FStaticMeshComponentRecreateRenderStateContext::GetComponentsUsingMesh(UStaticMesh* StaticMesh) const
{
	return StaticMeshComponents.FindChecked(StaticMesh);
}

FStaticMeshComponentRecreateRenderStateContext::~FStaticMeshComponentRecreateRenderStateContext()
{
	if (StaticMeshComponents.Num())
	{
		TSet<FSceneInterface*> Scenes;

		for (const auto& MeshComponents : StaticMeshComponents)
		{
			for (UStaticMeshComponent* Component : MeshComponents.Value)
			{
				if (bUnbuildLighting)
				{
					// Invalidate the component's static lighting.
					// This unregisters and reregisters so must not be in the constructor
					Component->InvalidateLightingCache();
				}

				if (bRefreshBounds)
				{
					Component->UpdateBounds();
				}

				if (Component->IsRegistered() && !Component->bRenderStateCreated)
				{
					Component->CreateRenderState_Concurrent(nullptr);
					Scenes.Add(Component->GetScene());
				}
			}
		}

		UpdateAllPrimitiveSceneInfosForScenes(MoveTemp(Scenes));
	}
}
