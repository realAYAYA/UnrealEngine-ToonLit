// Copyright Epic Games, Inc. All Rights Reserved.

#include "AzureSpatialAnchorsAndroidInterop.h"

// AzureSpatialAnchorsNDK.hpp includes AzureSpatialAnchorsLibrary_Exports.h.  Both are autogenerated and could change with 
// ASA version updates, so I don't want to edit them.
// Unfortunately  uses #if but locale (included by ostream, included by ssstream) uses #ifdef which
// leaves us confused as to whether __APPLE__, etc are 'true' or 'false'. 
// What we will do, therfore, is set the defines as AzureSpatialAnchorsLibrary_Exports.h needs them, and include it, then set them
// back.

#ifdef __APPLE__
#error AzureSpatialAnchorsAndroidInterop.cpp is being compiled with __APPLE__ set. This is unexpected and the define wranging below will be wrong so fail now.
#endif
#ifdef _WIN32
#error AzureSpatialAnchorsAndroidInterop.cpp is being compiled with _WIN32 set. This is unexpected and the define wranging below will be wrong so fail now.
#endif
#if __ANDROID__ != 1
#error AzureSpatialAnchorsAndroidInterop.cpp is being compiled with __ANDROID__ != 1. This is unexpected so fail now.
#endif
#define __APPLE__ 0
#define _WIN32 0
extern "C" {
#include <AzureSpatialAnchorsLibrary_Exports.h>
}
#undef _WIN32
#undef __APPLE__
#include "AzureSpatialAnchorsNDK.hpp"

#include <memory>
#include <sstream>
#include <string>
#include "ARBlueprintLibrary.h"
#include "GoogleARCoreFunctionLibrary.h"
#include "Async/Async.h"

using namespace Microsoft::Azure::SpatialAnchors;

DEFINE_LOG_CATEGORY(LogAzureSpatialAnchorsAndroidInterop);

TSharedPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe> FAzureSpatialAnchorsAndroidInterop::Create(
	AnchorLocatedCallbackPtr AnchorLocatedCallback,
	LocateAnchorsCompletedCallbackPtr LocateAnchorsCompletedCallback,
	SessionUpdatedCallbackPtr SessionUpdatedCallback)
{
	struct SharedFAzureSpatialAnchorsAndroidInterop : public FAzureSpatialAnchorsAndroidInterop {};
	TSharedPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe> Output = MakeShareable( new SharedFAzureSpatialAnchorsAndroidInterop());
	Output->SetWeakThis(Output);
	Output->SetCallbacks(AnchorLocatedCallback, LocateAnchorsCompletedCallback, SessionUpdatedCallback);
	return Output;
}

FAzureSpatialAnchorsAndroidInterop::FAzureSpatialAnchorsAndroidInterop()
{
}


FAzureSpatialAnchorsAndroidInterop::~FAzureSpatialAnchorsAndroidInterop()
{
}

void FAzureSpatialAnchorsAndroidInterop::SetCallbacks(
	AnchorLocatedCallbackPtr AnchorLocated,
	LocateAnchorsCompletedCallbackPtr LocateAnchorsCompleted,
	SessionUpdatedCallbackPtr SessionUpdated)
{
	this->AnchorLocatedCallback = AnchorLocated;
	this->LocateAnchorsCompletedCallback = LocateAnchorsCompleted;
	this->SessionUpdatedCallback = SessionUpdated;
}

bool FAzureSpatialAnchorsAndroidInterop::CreateSession()
{
	if (UARBlueprintLibrary::GetARSessionStatus().Status != EARSessionStatus::Running)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Failed to create an Azure Spatial Anchors session, no AR Session was found to be running"));
		return false;
	}

	if (Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Warning, TEXT("Creating an Azure Spatial Anchors session when a session already existed"));
	}

    UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Creating an Azure Spatial Anchors session"));
	auto TempARSystem = TSharedPtr<FARSupportInterface, ESPMode::ThreadSafe>{ StaticCastSharedPtr<FXRTrackingSystemBase>(GEngine->XRSystem)->GetARCompositionComponent() };
    if (TempARSystem.IsValid())
    {
        UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors located a valid AR System"));    
		auto TempSession = std::make_shared<CloudSpatialAnchorSession>();
        void* SessionHandle = TempARSystem->GetARSessionRawPointer();
		if (SessionHandle != nullptr)
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors obtained a valid session handle"));
			TempSession->Session(static_cast<ArSession*>(SessionHandle));

			ErrorToken = TempSession->Error([](auto&&, auto&& Args)
			{
				auto errorCode = static_cast<int>(Args->ErrorCode());
				auto errorMessage = Args->ErrorMessage();
				UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors Session Encountered an error, ErrorCode: %d ErrorMessage:%s"), errorCode, UTF8_TO_TCHAR(errorMessage.c_str()));
			});

			TWeakPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe> WeakSelf = WeakThis;
			AnchorLocatedToken = TempSession->AnchorLocated([WeakSelf](auto&&, auto&& Args)
			{
				AsyncTask(
					ENamedThreads::GameThread,
					[WeakSelf, Args]() {
					if (TSharedPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe> SharedSelf = WeakSelf.Pin())
					{
						SharedSelf->OnAnchorLocated(Args);
					}
				});
			});

			LocateAnchorsCompletedToken = TempSession->LocateAnchorsCompleted([WeakSelf](auto&&, auto&& Args)
			{
				if (TSharedPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe> SharedSelf = WeakSelf.Pin())
				{
					SharedSelf->LocateAnchorsCompletedCallback(Args->Watcher()->Identifier(), Args->Cancelled());
				}
			});

			OnLogDebugToken = TempSession->OnLogDebug([](auto&&, auto&& Args)
			{
				auto Message = Args->Message();
				UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors: %s"), UTF8_TO_TCHAR(Message.c_str()));
			});

			SessionUpdatedToken = TempSession->SessionUpdated([WeakSelf](auto&&, auto&& Args)
			{
				auto status = Args->Status();
				if (status != nullptr)
				{
					if (status->UserFeedback() != SessionUserFeedback::None)
					{
						UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors Session Updated: %s"), *SessionUserFeedbackToString(status->UserFeedback()));
					}

					if (TSharedPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe>SharedSelf = WeakSelf.Pin())
					{
						SharedSelf->SessionUpdatedCallback(status->ReadyForCreateProgress(), status->RecommendedForCreateProgress(), status->SessionCreateHash(), status->SessionLocateHash(), static_cast<int32>(status->UserFeedback()));
					}
				}
			});

			ARSystem = TempARSystem;
			Session = TempSession;
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors session successfully created"));
			return true;
		}
		else
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors failed to obtain a valid session handle"));
			return false;
		}
    }
	else
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors failed to find a valid AR System"));
	}

    return false;
}

void FAzureSpatialAnchorsAndroidInterop::DestroySession()
{
	if (!Session)
	{
		return;
	}

	StopSession();

	Session->Error(ErrorToken);
	Session->AnchorLocated(AnchorLocatedToken);
	Session->LocateAnchorsCompleted(LocateAnchorsCompletedToken);
	Session->OnLogDebug(OnLogDebugToken);
	Session->SessionUpdated(SessionUpdatedToken);
	Session = nullptr;

	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors destroyed a session"));
}

void FAzureSpatialAnchorsAndroidInterop::GetAccessTokenWithAccountKeyAsync(const FString& AccountKey, IAzureSpatialAnchors::Callback_Result_String Callback)
{
	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"", L"");
		return;
	}

	Session->GetAccessTokenWithAccountKeyAsync(TCHAR_TO_UTF8(*AccountKey), [Callback](Status status, const std::string& token)
	{
		std::wstringstream string;
		if (status != Status::OK)
		{
			string << L"Failed to obtain access token from account key: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str(), L"");
			return;
		}

		string << token.c_str();
		Callback(EAzureSpatialAnchorsResult::Success, L"", string.str().c_str());
	});
}

void FAzureSpatialAnchorsAndroidInterop::GetAccessTokenWithAuthenticationTokenAsync(const FString& AuthenticationToken, IAzureSpatialAnchors::Callback_Result_String Callback)
{
	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"", L"");
		return;
	}

	Session->GetAccessTokenWithAuthenticationTokenAsync(TCHAR_TO_UTF8(*AuthenticationToken), [Callback](Status status, const std::string& token)
	{
		std::wstringstream string;
		if (status != Status::OK)
		{
			string << L"Failed to obtain access token from authentication token: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str(), L"");
			return;
		}

		string << token.c_str();
		Callback(EAzureSpatialAnchorsResult::Success, L"", string.str().c_str());
	});
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::StartSession()
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors failed to start session, session was null"));
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Attempting to start Azure Spatial Anchors session"));
	Session->Start();
	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors succesfully started a session"));
	bSessionRunning = true;
	return EAzureSpatialAnchorsResult::Success;
}

void FAzureSpatialAnchorsAndroidInterop::UpdateSession()
{
	if (Session != nullptr &&
		ARSystem.IsValid() &&
		bSessionRunning)
	{
		if (UARBlueprintLibrary::GetARSessionStatus().Status != EARSessionStatus::Running)
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Warning, TEXT("AR Session was stopped before azure spatial anchors session was cleaned up."));
			return;
		}

		void* frameHandle = ARSystem->GetGameThreadARFrameRawPointer();
		if (frameHandle != nullptr)
		{
			Session->ProcessFrame(static_cast<ArFrame*>(frameHandle));
		}
		else
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors was unable to obtain a frame handle, failed to update the session"));
		}
	}
}

void FAzureSpatialAnchorsAndroidInterop::StopSession()
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Warning, TEXT("Azure Spatial Anchors failed to stop session, session was null"));
		return;
	}

	if (CurrentWatcher)
	{
		CurrentWatcher->Stop();
		CurrentWatcher = nullptr;
	}

	LocalAnchorMap.Empty();

	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		CloudAnchorMap.Empty();
	}

	Session->Stop();
	bSessionRunning = false;
	
	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors stopped a session"));
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::ResetSession()
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Warning, TEXT("Azure Spatial Anchors failed to reset session, session was null"));
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	Session->Reset();
	return EAzureSpatialAnchorsResult::Success;
}

void FAzureSpatialAnchorsAndroidInterop::DisposeSession()
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Warning, TEXT("Azure Spatial Anchors failed to dispose session, session was null"));
		return;
	}

	Session->Dispose();
	Session = nullptr;
}

void FAzureSpatialAnchorsAndroidInterop::GetSessionStatusAsync(IAzureSpatialAnchors::Callback_Result_SessionStatus Callback)
{
	FAzureSpatialAnchorsSessionStatus SessionStatus;

	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"", SessionStatus);
		return;
	}

	if (!bSessionRunning)
	{
		Callback(EAzureSpatialAnchorsResult::NotStarted, L"", SessionStatus);
		return;
	}

	Session->GetSessionStatusAsync([Callback](Microsoft::Azure::SpatialAnchors::Status status, const std::shared_ptr<Microsoft::Azure::SpatialAnchors::SessionStatus>& sessionStatus)
	{
		FAzureSpatialAnchorsSessionStatus SessionStatus;

		if (status != Status::OK)
		{
			std::wstringstream string;
			string << L"Failed to obtain session status: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str(), SessionStatus);
			return;
		}

		SessionStatus.ReadyForCreateProgress = sessionStatus->ReadyForCreateProgress();
		SessionStatus.RecommendedForCreateProgress = sessionStatus->RecommendedForCreateProgress();
		SessionStatus.SessionCreateHash = sessionStatus->SessionCreateHash();
		SessionStatus.SessionLocateHash = sessionStatus->SessionLocateHash();
		SessionStatus.feedback = static_cast<EAzureSpatialAnchorsSessionUserFeedback>(sessionStatus->UserFeedback());

		Callback(EAzureSpatialAnchorsResult::Success, L"", SessionStatus);
	});
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::ConstructAnchor(UARPin* InARPin, IAzureSpatialAnchors::CloudAnchorID& OutCloudAnchorID)
{
	OutCloudAnchorID = IAzureSpatialAnchors::CloudAnchorID_Invalid;
	if (!Session ||
		!bSessionRunning)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to create an AzureCloudSpatialAnchor when no session is running"));
		return EAzureSpatialAnchorsResult::NotStarted;
	}

	if (!InARPin)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Provided ARPin was null"));
		return EAzureSpatialAnchorsResult::FailNoARPin;
	}

	auto NativeAnchor = static_cast<ArAnchor*>(InARPin->GetNativeResource());
	if (!NativeAnchor)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Provided ARPin did not have a valid associated ArAnchor, Azure Spatial Anchors was unable to create a cloud anchor"));
		return EAzureSpatialAnchorsResult::FailNoLocalAnchor;
	}

	UAzureCloudSpatialAnchor* OutCloudAnchor = NewObject<UAzureCloudSpatialAnchor>();
	OutCloudAnchor->ARPin = InARPin;
	OutCloudAnchor->CloudAnchorID = GetNextID();
	LocalAnchorMap.Add(OutCloudAnchor->CloudAnchorID, OutCloudAnchor);

	std::shared_ptr<CloudSpatialAnchor> CloudAnchor = std::make_shared<CloudSpatialAnchor>();
	CloudAnchor->LocalAnchor(NativeAnchor);

	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		CloudAnchorMap.Add(OutCloudAnchor->CloudAnchorID, CloudAnchor);
	}

	OutCloudAnchorID = OutCloudAnchor->CloudAnchorID;
	return EAzureSpatialAnchorsResult::Success;
}

void FAzureSpatialAnchorsAndroidInterop::CreateAnchorAsync(IAzureSpatialAnchors::CloudAnchorID InCloudAnchorID, IAzureSpatialAnchors::Callback_Result Callback)
{
	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"Azure Spatial Anchors session has not been started/does not exist");
		return;
	}

	if (LocalAnchorMap.Contains(InCloudAnchorID) == 0)
	{
		Callback(EAzureSpatialAnchorsResult::FailAnchorDoesNotExist, L"Provided AzureCloudSpatialAnchor was not known to plugin");
		return;
	}

	auto LocalAnchor = LocalAnchorMap[InCloudAnchorID];

	if (!LocalAnchor->ARPin)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoAnchor, L"Provided ARPin was null");
		return;
	}

	auto arAnchor = static_cast<ArAnchor*>(LocalAnchor->ARPin->GetNativeResource());
	if (!arAnchor)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoLocalAnchor, L"Provided ARPin did not have a valid associated ArAnchor, Azure Spatial Anchors was unable to create a cloud anchor");
		return;
	}

	std::shared_ptr<CloudSpatialAnchor> CloudAnchor;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InCloudAnchorID))
		{
			Callback(EAzureSpatialAnchorsResult::FailAnchorDoesNotExist, L"Provided AzureCloudSpatialAnchor was not known to plugin");
			return;
		}

		CloudAnchor = CloudAnchorMap[InCloudAnchorID];
	}

	CloudAnchor->LocalAnchor(arAnchor);

	Session->CreateAnchorAsync(CloudAnchor, [Callback](Status status) {
		if (status != Status::OK)
		{
			std::wstringstream string;
			string << L"Failed to create azure spatial anchor: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str());
			return;
		}

		Callback(EAzureSpatialAnchorsResult::Success, L"");
	});
}

void FAzureSpatialAnchorsAndroidInterop::DeleteAnchorAsync(IAzureSpatialAnchors::CloudAnchorID InCloudAnchorID, IAzureSpatialAnchors::Callback_Result Callback)
{
	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"Azure Spatial Anchors session has not been started/does not exist");
		return;
	}

	std::shared_ptr<CloudSpatialAnchor> Anchor;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InCloudAnchorID))
		{
			Callback(EAzureSpatialAnchorsResult::FailAnchorDoesNotExist, L"Provided AzureCloudSpatialAnchor was not known to plugin");
			return;
		}

		Anchor = CloudAnchorMap[InCloudAnchorID];
	}

	if (Anchor->Identifier().empty())
	{
		// Anchor only existed locally
		ClearAnchorData(InCloudAnchorID);
		Callback(EAzureSpatialAnchorsResult::Success, L"");
		return;
	}

	TWeakPtr<FAzureSpatialAnchorsAndroidInterop, ESPMode::ThreadSafe> WeakSelf = WeakThis;
	Session->DeleteAnchorAsync(Anchor, [Callback, InCloudAnchorID, WeakSelf](Status status) {
		if (status != Status::OK) {
			std::wstringstream string;
			string << L"Failed to delete azure spatial anchor: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str());
			return;
		}

		if (auto SharedSelf = WeakSelf.Pin())
		{
			SharedSelf->ClearAnchorData(InCloudAnchorID);
		}

		Callback(EAzureSpatialAnchorsResult::Success, L"");
	});
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::CreateWatcher(const FAzureSpatialAnchorsLocateCriteria& InLocateCriteria, float InWorldToMetersScale, IAzureSpatialAnchors::WatcherID& OutWatcherIdentifier, FString& OutErrorString)
{
	OutErrorString = FString{};
	OutWatcherIdentifier = InvalidWatcherIdentifier;

	if (!Session ||
		!bSessionRunning)
	{
		OutErrorString = TEXT("Attempted to create a watcher when no Azure Spatial Anchor session was running");
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	if (CurrentWatcher)
	{
		OutErrorString = TEXT("Attempted to create a watcher when a watcher already exists. Only one watcher is supported at a time");
		return EAzureSpatialAnchorsResult::FailSeeErrorString;
	}

	std::shared_ptr<CloudSpatialAnchor> NearAnchor;
	if (InLocateCriteria.NearAnchor != nullptr)
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InLocateCriteria.NearAnchor->CloudAnchorID))
		{
			OutErrorString = TEXT("Provided near anchor has not been saved/associated with the Azure Spatial Anchor service");
			return EAzureSpatialAnchorsResult::FailBadCloudAnchorIdentifier;
		}

		NearAnchor = CloudAnchorMap[InLocateCriteria.NearAnchor->CloudAnchorID];
	}

	std::shared_ptr<AnchorLocateCriteria> CloudAnchorLocateCriteria = std::make_shared<AnchorLocateCriteria>();
	CloudAnchorLocateCriteria->BypassCache(InLocateCriteria.bBypassCache);
	CloudAnchorLocateCriteria->RequestedCategories(static_cast<AnchorDataCategory>(InLocateCriteria.RequestedCategories));
	CloudAnchorLocateCriteria->Strategy(static_cast<LocateStrategy>(InLocateCriteria.Strategy));

	std::vector<std::string> Identifiers;
	for (FString Identifier : InLocateCriteria.Identifiers)
	{
		Identifiers.push_back(std::string(TCHAR_TO_UTF8(*Identifier)));
	}
	CloudAnchorLocateCriteria->Identifiers(Identifiers);

	if (NearAnchor != nullptr)
	{
		std::shared_ptr<NearAnchorCriteria> AnchorCriteria = std::make_shared<NearAnchorCriteria>();
		AnchorCriteria->SourceAnchor(NearAnchor);
		AnchorCriteria->DistanceInMeters(InLocateCriteria.NearAnchorDistance / 100.0f); // Convert from cm to m
		AnchorCriteria->MaxResultCount(InLocateCriteria.NearAnchorMaxResultCount);
		CloudAnchorLocateCriteria->NearAnchor(AnchorCriteria);
	}

	if (InLocateCriteria.bSearchNearDevice)
	{
		std::shared_ptr<NearDeviceCriteria> DeviceCriteria = std::make_shared<NearDeviceCriteria>();
		DeviceCriteria->DistanceInMeters(InLocateCriteria.NearDeviceDistance / 100.0f); // Convert from cm to m
		DeviceCriteria->MaxResultCount(InLocateCriteria.NearDeviceMaxResultCount);
		CloudAnchorLocateCriteria->NearDevice(DeviceCriteria);
	}

	CurrentWatcher = Session->CreateWatcher(CloudAnchorLocateCriteria);
	OutWatcherIdentifier = CurrentWatcher->Identifier();
	return EAzureSpatialAnchorsResult::Success;
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::GetActiveWatchers(TArray<IAzureSpatialAnchors::WatcherID>& OutWatcherIDs)
{
	OutWatcherIDs.Empty();
	if (CurrentWatcher != nullptr)
	{
		OutWatcherIDs.Add(CurrentWatcher->Identifier());
	}

	return EAzureSpatialAnchorsResult::Success;
}

void FAzureSpatialAnchorsAndroidInterop::GetAnchorPropertiesAsync(const FString& InCloudAnchorIdentifier, IAzureSpatialAnchors::Callback_Result_CloudAnchorID Callback)
{
	if (!Session ||
		!bSessionRunning)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"Attempted to get AzureCloudSpatialAnchor properties when no session was running", IAzureSpatialAnchors::CloudAnchorID_Invalid);
		return;
	}

	if (InCloudAnchorIdentifier.IsEmpty())
	{
		Callback(EAzureSpatialAnchorsResult::FailBadCloudAnchorIdentifier, L"Provided CloudIdentifier was invalid", IAzureSpatialAnchors::CloudAnchorID_Invalid);
		return;
	}

	IAzureSpatialAnchors::CloudAnchorID CloudAnchorID = IAzureSpatialAnchors::CloudAnchorID_Invalid;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		for (auto pair : CloudAnchorMap)
		{
			if (FString{ UTF8_TO_TCHAR(pair.Value->Identifier().c_str()) } == InCloudAnchorIdentifier)
			{
				CloudAnchorID = pair.Key;
			}
		}
	}

	if (CloudAnchorID == IAzureSpatialAnchors::CloudAnchorID_Invalid)
	{
		Callback(EAzureSpatialAnchorsResult::FailBadCloudAnchorIdentifier, L"Provided CloudIdentifier was not known to the plugin", IAzureSpatialAnchors::CloudAnchorID_Invalid);
		return;
	}

	Session->GetAnchorPropertiesAsync(TCHAR_TO_UTF8(*InCloudAnchorIdentifier), [Callback, CloudAnchorID](Status status, const std::shared_ptr<CloudSpatialAnchor>& cloudAnchor) {
		if (status != Status::OK) {
			std::wstringstream string;
			string << L"Failed to refresh azure spatial anchor properties: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str(), IAzureSpatialAnchors::CloudAnchorID_Invalid);
			return;
		}

		Callback(EAzureSpatialAnchorsResult::Success, L"", CloudAnchorID);
	});
}

void FAzureSpatialAnchorsAndroidInterop::RefreshAnchorPropertiesAsync(IAzureSpatialAnchors::CloudAnchorID InCloudAnchorID, IAzureSpatialAnchors::Callback_Result Callback)
{
	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"Attempted to refresh AzureCloudSpatialAnchor properties when no session was running");
		return;
	}

	std::shared_ptr<CloudSpatialAnchor> CloudAnchor;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InCloudAnchorID))
		{
			Callback(EAzureSpatialAnchorsResult::FailAnchorDoesNotExist, L"Provided AzureCloudSpatialAnchor does not have an associated cloud anchor. This anchor was not saved/declared to the Azure Spatial Anchors service");
			return;
		}

		CloudAnchor = CloudAnchorMap[InCloudAnchorID];
	}

	if (CloudAnchor->Identifier().empty())
	{
		Callback(EAzureSpatialAnchorsResult::FailNoCloudAnchor, L"Provided AzureCloudSpatialAnchor has not been saved to the service");
		return;
	}

	Session->RefreshAnchorPropertiesAsync(CloudAnchor, [Callback](Status status) {
		if (status != Status::OK)
		{
			std::wstringstream string;
			string << L"Failed to refresh azure spatial anchor properties: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str());
			return;
		}

		Callback(EAzureSpatialAnchorsResult::Success, L"");
	});
}

void FAzureSpatialAnchorsAndroidInterop::UpdateAnchorPropertiesAsync(IAzureSpatialAnchors::CloudAnchorID InCloudAnchorID, IAzureSpatialAnchors::Callback_Result Callback)
{
	if (!Session ||
		!bSessionRunning)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"Attempted to update AzureCloudSpatialAnchor properties when no session was running");
		return;
	}

	std::shared_ptr<CloudSpatialAnchor> CloudAnchor;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InCloudAnchorID))
		{
			Callback(EAzureSpatialAnchorsResult::FailAnchorDoesNotExist, L"Provided AzureCloudSpatialAnchor does not have an associated cloud anchor. This anchor was not saved/declared to the Azure Spatial Anchors service");
			return;
		}

		CloudAnchor = CloudAnchorMap[InCloudAnchorID];
	}

	if (CloudAnchor->Identifier().empty())
	{
		Callback(EAzureSpatialAnchorsResult::FailNoCloudAnchor, L"Provided AzureCloudSpatialAnchor has not been saved to the service");
		return;
	}

	Session->UpdateAnchorPropertiesAsync(CloudAnchor, [Callback](Status status) {
		if (status != Status::OK)
		{
			std::wstringstream string;
			string << "Failed to update azure spatial anchor properties: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str());
			return;
		}

		Callback(EAzureSpatialAnchorsResult::Success, L"");
	});
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::GetConfiguration(FAzureSpatialAnchorsSessionConfiguration& OutConfig)
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors failed to obtain session configuration, session was null"));
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	auto Configuration = Session->Configuration();
	OutConfig.AccessToken = FString{ Configuration->AccessToken().c_str() };
	OutConfig.AccountId = FString{ Configuration->AccountId().c_str() };
	OutConfig.AccountKey = FString{ Configuration->AccountKey().c_str() };
	OutConfig.AccountDomain = FString{ Configuration->AccountDomain().c_str() };
	OutConfig.AuthenticationToken = FString{ Configuration->AuthenticationToken().c_str() };

	return EAzureSpatialAnchorsResult::Success;
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::SetConfiguration(const FAzureSpatialAnchorsSessionConfiguration& InConfig)
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors failed to configure session, session was null"));
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Attempting to configure Azure Spatial Anchors session"));
	auto Configuration = Session->Configuration();

	if (!InConfig.AccessToken.IsEmpty())
	{
		Configuration->AccessToken(TCHAR_TO_UTF8(*InConfig.AccessToken));
	}

	if (!InConfig.AccountId.IsEmpty())
	{
		Configuration->AccountId(TCHAR_TO_UTF8(*InConfig.AccountId));
	}

	if (!InConfig.AccountKey.IsEmpty())
	{
		Configuration->AccountKey(TCHAR_TO_UTF8(*InConfig.AccountKey));
	}

	if (!InConfig.AccountDomain.IsEmpty())
	{
		Configuration->AccountDomain(TCHAR_TO_UTF8(*InConfig.AccountDomain));
	}

	if (!InConfig.AuthenticationToken.IsEmpty())
	{
		Configuration->AuthenticationToken(TCHAR_TO_UTF8(*InConfig.AuthenticationToken));
	}

	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Azure Spatial Anchors successfully configured session"));
	return EAzureSpatialAnchorsResult::Success;
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::SetLocationProvider(const FCoarseLocalizationSettings& InConfig)
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors failed to set location provider for session, session was null"));
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Attempting to set location provider for Azure Spatial Anchors session"));
	if (InConfig.bEnable)
	{
		std::shared_ptr<PlatformLocationProvider> LocationProvider = std::make_shared<PlatformLocationProvider>();
		std::shared_ptr<SensorCapabilities> Sensors = LocationProvider->Sensors();
		Sensors->GeoLocationEnabled(InConfig.bEnableGPS);
		Sensors->WifiEnabled(InConfig.bEnableWifi);

		bool bBluetoothEnabled = InConfig.BLEBeaconUUIDs.Num() > 0;
		Sensors->BluetoothEnabled(bBluetoothEnabled);
		if (bBluetoothEnabled)
		{
			std::vector<std::string> uuids;
			for (int i = 0; i < InConfig.BLEBeaconUUIDs.Num(); i++)
			{
				uuids.push_back(TCHAR_TO_UTF8(*InConfig.BLEBeaconUUIDs[i]));
			}

			Sensors->KnownBeaconProximityUuids(uuids);
		}

		Session->LocationProvider(LocationProvider);
	}
	else
	{
		// TODO: jeff.fisher - uncomment out this bottom line when the service crash is fixed
		// Session->LocationProvider(nullptr);
	}

	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Log, TEXT("Local provider succesfully set for Azure Spatial Anchors session"));
	return EAzureSpatialAnchorsResult::Success;
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::GetLogLevel(EAzureSpatialAnchorsLogVerbosity& OutLogVerbosity)
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors failed to get log level for session, session was null"));
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	OutLogVerbosity = static_cast<EAzureSpatialAnchorsLogVerbosity>(Session->LogLevel());
	return EAzureSpatialAnchorsResult::Success;
}
	
EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::SetLogLevel(EAzureSpatialAnchorsLogVerbosity InLogVerbosity)
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors failed to set log level for session, session was null"));
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	Session->LogLevel(static_cast<SessionLogLevel>(InLogVerbosity));
	return EAzureSpatialAnchorsResult::Success;
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::GetSessionId(FString& OutSessionID)
{
	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Azure Spatial Anchors failed to get session Id, session was null"));
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	OutSessionID = FString{ UTF8_TO_TCHAR(Session->SessionId().c_str()) };
	return EAzureSpatialAnchorsResult::Success;
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::StopWatcher(IAzureSpatialAnchors::WatcherID InWatcherIdentifier)
{
	if (!Session ||
		!bSessionRunning)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to stop a watcher when no Azure Spatial Anchor session was running"));
		return EAzureSpatialAnchorsResult::NotStarted;
	}

	if (!CurrentWatcher ||
		CurrentWatcher->Identifier() != InWatcherIdentifier)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to stop a watcher that was not known to the current Azure Spatial Anchor"));
		return EAzureSpatialAnchorsResult::FailNoWatcher;
	}

	CurrentWatcher->Stop();
	CurrentWatcher = nullptr;
	return EAzureSpatialAnchorsResult::Success;
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::GetCloudSpatialAnchorIdentifier(IAzureSpatialAnchors::CloudAnchorID CloudAnchorID, FString& OutCloudAnchorIdentifier)
{
	OutCloudAnchorIdentifier = FString{};

	if (!Session)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to get cloud anchor identifier when no Azure Spatial Anchor session is running"));
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	std::shared_ptr<CloudSpatialAnchor> Anchor;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(CloudAnchorID))
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to get cloud anchor identifier when for an anchor not known to the plugin"));
			return EAzureSpatialAnchorsResult::FailNoCloudAnchor;
		}

		Anchor = CloudAnchorMap[CloudAnchorID];
	}

	OutCloudAnchorIdentifier = FString{ UTF8_TO_TCHAR(Anchor->Identifier().c_str()) };
	return EAzureSpatialAnchorsResult::Success;
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::SetCloudAnchorExpiration(IAzureSpatialAnchors::CloudAnchorID InCloudAnchorID, float InLifetimeInSeconds)
{
	if (!Session ||
		!bSessionRunning)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to set cloud anchor expiration when no Azure Spatial Anchors session is running"));
		return EAzureSpatialAnchorsResult::NotStarted;
	}

	std::shared_ptr < CloudSpatialAnchor> Anchor;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InCloudAnchorID))
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to set cloud anchor expiration for an anchor not known to the plugin"));
			return EAzureSpatialAnchorsResult::FailNoCloudAnchor;
		}

		Anchor = CloudAnchorMap[InCloudAnchorID];
	}

    std::chrono::system_clock::time_point Expiration = std::chrono::system_clock::now() + std::chrono::milliseconds(static_cast<int64_t>(InLifetimeInSeconds * 1000));
	const int64_t ExpirationSinceEpochMs = std::chrono::duration_cast<std::chrono::milliseconds>(Expiration.time_since_epoch()).count();

	try
	{
		Anchor->Expiration(ExpirationSinceEpochMs);
		return EAzureSpatialAnchorsResult::Success;
	}
	catch (runtime_error& e)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Exception thrown attempting to set cloud anchor expiration"));
		return EAzureSpatialAnchorsResult::FailUnknown;
	}
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::GetCloudAnchorExpiration(IAzureSpatialAnchors::CloudAnchorID InCloudAnchorID, float& OutLifetimeInSeconds)
{
	OutLifetimeInSeconds = -1;
	if (!Session ||
		!bSessionRunning)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to get cloud anchor expiration when no Azure Spatial Anchors session is running"));
		return EAzureSpatialAnchorsResult::NotStarted;
	}
	
	int64_t ExpirationSinceEpochMs = -1;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InCloudAnchorID))
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to get cloud anchor expiration for an AzureCloudSpatialAnchor not known to the plugin"));
			return EAzureSpatialAnchorsResult::FailNoCloudAnchor;
		}

		ExpirationSinceEpochMs = CloudAnchorMap[InCloudAnchorID]->Expiration();
	}

	auto Expiration = std::chrono::milliseconds(ExpirationSinceEpochMs) - std::chrono::system_clock::now().time_since_epoch();
	int64_t ExpirationMs = std::chrono::duration_cast<std::chrono::milliseconds>(Expiration).count();
	OutLifetimeInSeconds = ExpirationMs / 1000.0f; // milliseconds to seconds
	return EAzureSpatialAnchorsResult::Success;
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::SetCloudAnchorAppProperties(IAzureSpatialAnchors::CloudAnchorID InCloudAnchorID, const TMap<FString, FString>& InAppProperties)
{
	if (!Session ||
		!bSessionRunning)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to set cloud anchor app properties when no Azure Spatial Anchors session is running"));
		return EAzureSpatialAnchorsResult::NotStarted;
	}

	std::shared_ptr<CloudSpatialAnchor> CloudAnchor;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InCloudAnchorID))
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to set cloud anchor app properties for an AzureCloudSpatialAnchor not known to the plugin"));
			return EAzureSpatialAnchorsResult::FailNoCloudAnchor;
		}

		CloudAnchor = CloudAnchorMap[InCloudAnchorID];
	}

	if (CloudAnchor->Identifier().empty())
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to set cloud anchor app properties for an AzureCloudSpatialAnchor not known to the service"));
		return EAzureSpatialAnchorsResult::FailNoCloudAnchor;
	}

	auto Properties = CloudAnchor->AppProperties();
	for (auto Property : InAppProperties)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to set cloud anchor app property for an AzureCloudSpatialAnchor: %s, %s"), *Property.Key, *Property.Value);
		Properties->Insert(std::string(TCHAR_TO_UTF8(*Property.Key)), std::string(TCHAR_TO_UTF8(*Property.Value)));
	}
	
	return EAzureSpatialAnchorsResult::Success;
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::GetCloudAnchorAppProperties(IAzureSpatialAnchors::CloudAnchorID InCloudAnchorID, TMap<FString, FString>& OutAppProperties)
{
	OutAppProperties.Empty();
	if (!Session ||
		!bSessionRunning)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to get cloud anchor app properties when no Azure Spatial Anchors session is running"));
		return EAzureSpatialAnchorsResult::NotStarted;
	}

	std::shared_ptr<IMap<std::string, std::string>> Properties;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InCloudAnchorID))
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to get cloud anchor app properties for an AzureCloudSpatialAnchor not known to the plugin"));
			return EAzureSpatialAnchorsResult::FailNoCloudAnchor;
		}

		Properties = CloudAnchorMap[InCloudAnchorID]->AppProperties();
	}

	for (uint32_t i = 0; i < Properties->Size(); i++)
	{
		auto Pair = Properties->GetAt(i);
		OutAppProperties.Add(FString{ UTF8_TO_TCHAR(Pair.Key().c_str()) }, FString{ UTF8_TO_TCHAR(Pair.Value().c_str()) });
	}

	return EAzureSpatialAnchorsResult::Success;
}

EAzureSpatialAnchorsResult FAzureSpatialAnchorsAndroidInterop::SetDiagnosticsConfig(FAzureSpatialAnchorsDiagnosticsConfig& InConfig)
{
	if (!Session)
	{
		return EAzureSpatialAnchorsResult::FailNoSession;
	}

	auto Diagnostics = Session->Diagnostics();
	Diagnostics->ImagesEnabled(InConfig.bImagesEnabled);
	Diagnostics->LogDirectory(TCHAR_TO_UTF8(*InConfig.LogDirectory));
	Diagnostics->LogLevel(static_cast<SessionLogLevel>(InConfig.LogLevel));
	Diagnostics->MaxDiskSizeInMB(InConfig.MaxDiskSizeInMB);

	return EAzureSpatialAnchorsResult::Success;
}

void FAzureSpatialAnchorsAndroidInterop::CreateDiagnosticsManifestAsync(const FString& Description, IAzureSpatialAnchors::Callback_Result_String Callback)
{
	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"", L"");
	}

	std::string description = std::string(TCHAR_TO_UTF8(*Description));
	Session->Diagnostics()->CreateManifestAsync(description, [Callback](Status status, const std::string& manifest)
	{
		std::wstringstream string;
		if (status != Status::OK)
		{
			string << L"Failed to create diagnostics manifest: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str(), L"");
			return;
		}

		string << manifest.c_str();
		Callback(EAzureSpatialAnchorsResult::Success, L"", string.str().c_str());
	});
}

void FAzureSpatialAnchorsAndroidInterop::SubmitDiagnosticsManifestAsync(const FString& ManifestPath, IAzureSpatialAnchors::Callback_Result Callback)
{
	if (!Session)
	{
		Callback(EAzureSpatialAnchorsResult::FailNoSession, L"");
	}

	std::string manifestPath = std::string(TCHAR_TO_UTF8(*ManifestPath));
	Session->Diagnostics()->SubmitManifestAsync(manifestPath, [Callback](Status status)
	{
		if (status != Status::OK)
		{
			std::wstringstream string;
			string << L"Failed to submit diagnostics manifest: " << static_cast<int32_t>(status);
			Callback(EAzureSpatialAnchorsResult::FailSeeErrorString, string.str().c_str());
			return;
		}

		Callback(EAzureSpatialAnchorsResult::Success, L"");
	});
}

void FAzureSpatialAnchorsAndroidInterop::CreateNamedARPinAroundAnchor(const FString& InLocalAnchorId, UARPin*& OutARPin)
{
	OutARPin = nullptr;
	UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("CreateNamedARPinAroundAnchor is not implemented for ARCore!  Returning Null."));
	// TODO: jeff.fisher - fix this logic
	// ARCore doesn't maintain anchors based on an id. Anchors do map directly to ARPins when understood by the ARCore session.
	// It seems like this function does not belong here
	//jeff.fisher says: I think that is correct, seems like I can remove this entirely.
}

bool FAzureSpatialAnchorsAndroidInterop::CreateARPinAroundAzureCloudSpatialAnchor(const FString& PinId, UAzureCloudSpatialAnchor* InAzureCloudSpatialAnchor, UARPin*& OutARPin)
{
	OutARPin = nullptr;
	if (!ARSystem.IsValid())
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to create an ARPin for an AzureCloudSpatialAnchor when no valid AR System was found"));
		return false;
	}

	if (!Session ||
		!bSessionRunning)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to create an ARPin for an AzureCloudSpatialAnchor when no Azure Spatial Anchor session was running"));
		return false;
	}

	if (!InAzureCloudSpatialAnchor)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to create an ARPin for a null AzureCloudSpatialAnchor"));
		return false;
	}

	if (InAzureCloudSpatialAnchor->ARPin)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Warning, TEXT("Attempted to create an ARPin for an AzureCloudSpatialAnchor that already had an ARPin"));
		return true;
	}

	std::shared_ptr<CloudSpatialAnchor> Anchor;
	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (!CloudAnchorMap.Contains(InAzureCloudSpatialAnchor->CloudAnchorID))
		{
			UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to create an ARPin for an invalid AzureCloudSpatialAnchor"));
			return false;
		}

		Anchor = CloudAnchorMap[InAzureCloudSpatialAnchor->CloudAnchorID];
	}

	ArAnchor* LocalAnchor = Anchor->LocalAnchor();
	if (!LocalAnchor)
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("Attempted to create an ARPin for an AzureCloudSpatialAnchor without a valid ArAnchor"));
		return false;
	}

	UARPin* ARPin = nullptr;
	if (!ARSystem->TryGetOrCreatePinForNativeResource(reinterpret_cast<void*>(LocalAnchor), PinId, ARPin))
	{
		UE_LOG(LogAzureSpatialAnchorsAndroidInterop, Error, TEXT("ARCore failed to create an ARPin for the provided ArAnchor"));
		return false;
	}

	InAzureCloudSpatialAnchor->ARPin = ARPin;
	OutARPin = ARPin;
	return true;
}

FString FAzureSpatialAnchorsAndroidInterop::SessionUserFeedbackToString(SessionUserFeedback userFeedback)
{
	switch (userFeedback)
	{
	case SessionUserFeedback::MotionTooQuick:
		return TEXT("MotionTooQuick");
	case SessionUserFeedback::NotEnoughFeatures:
		return TEXT("NotEnoughFeatures");
	case SessionUserFeedback::NotEnoughMotion:
		return TEXT("NotEnoughMotion");
	case SessionUserFeedback::None:
	default:
		return TEXT("None");
	}
}

IAzureSpatialAnchors::CloudAnchorID FAzureSpatialAnchorsAndroidInterop::GetNextID()
{
	FScopeLock Lock(&CurrentIDMutex);
	int Id = CurrentID;
	CurrentID++;
	return Id;
}

void FAzureSpatialAnchorsAndroidInterop::OnAnchorLocated(const std::shared_ptr<Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs>& Args)
{
	if (Session &&
		bSessionRunning &&
		ARSystem.IsValid())
	{
		std::shared_ptr<CloudSpatialAnchor> Anchor = Args->Anchor();
		if (Anchor != nullptr)
		{
			IAzureSpatialAnchors::CloudAnchorID CloudAnchorID = IAzureSpatialAnchors::CloudAnchorID_Invalid;
			{
				FScopeLock Lock(&CloudAnchorMapMutex);
				for (auto Pair : CloudAnchorMap)
				{
					if (Pair.Value->Identifier() == Anchor->Identifier())
					{
						CloudAnchorID = Pair.Key;
						break;
					}
				}
			}

			if (CloudAnchorID == IAzureSpatialAnchors::CloudAnchorID_Invalid)
			{
				UAzureCloudSpatialAnchor* CloudAnchor = NewObject<UAzureCloudSpatialAnchor>();
				CloudAnchor->ARPin = nullptr;
				CloudAnchor->CloudAnchorID = GetNextID();
				CloudAnchorID = CloudAnchor->CloudAnchorID;

				LocalAnchorMap.Add(CloudAnchor->CloudAnchorID, CloudAnchor);

				{
					FScopeLock Lock(&CloudAnchorMapMutex);
					CloudAnchorMap.Add(CloudAnchor->CloudAnchorID, Anchor);
				}
			}

			AnchorLocatedCallback(Args->Watcher()->Identifier(), static_cast<int32>(Args->Status()), static_cast<int32>(CloudAnchorID));
		}
	}
}

void FAzureSpatialAnchorsAndroidInterop::ClearAnchorData(IAzureSpatialAnchors::CloudAnchorID InCloudAnchorID)
{
	if (LocalAnchorMap.Contains(InCloudAnchorID))
	{
		LocalAnchorMap.Remove(InCloudAnchorID);
	}

	{
		FScopeLock Lock(&CloudAnchorMapMutex);
		if (CloudAnchorMap.Contains(InCloudAnchorID))
		{
			CloudAnchorMap.Remove(InCloudAnchorID);
		}
	}
}