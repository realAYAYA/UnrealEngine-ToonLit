// Copyright Epic Games, Inc. All Rights Reserved.

#include "USDClassesModule.h"

#include "USDLog.h"

#include "AnalyticsEventAttribute.h"
#include "Animation/AnimBlueprint.h"
#include "Animation/AnimSequence.h"
#include "Animation/Skeleton.h"
#include "Engine/Engine.h"
#include "Engine/SkeletalMesh.h"
#include "Engine/SkinnedAssetCommon.h"
#include "Engine/StaticMesh.h"
#include "Engine/Texture2D.h"
#include "EngineAnalytics.h"
#include "GeometryCache.h"
#include "HAL/FileManager.h"
#include "Materials/Material.h"
#include "Materials/MaterialInstance.h"
#include "Misc/EngineVersion.h"
#include "Misc/FileHelper.h"
#include "Misc/PackageName.h"
#include "Misc/Paths.h"
#include "Misc/SecureHash.h"
#include "PhysicsEngine/PhysicsAsset.h"
#include "Serialization/JsonSerializer.h"
#include "UObject/ObjectSaveContext.h"
#include "UObject/Package.h"

DEFINE_LOG_CATEGORY( LogUsd );

namespace UE::USDClasses::Private
{
	TSharedPtr<FJsonObject> ParseJSON( const FString& FileContents )
	{
		if ( FileContents.IsEmpty() )
		{
			return nullptr;
		}

		const TSharedRef< TJsonReader<> >& Reader = TJsonReaderFactory<>::Create( FileContents );

		TSharedPtr<FJsonObject> DescriptorObject;
		if ( FJsonSerializer::Deserialize( Reader, DescriptorObject ) && DescriptorObject.IsValid() )
		{
			return DescriptorObject;
		}
		else
		{
			UE_LOG( LogUsd, Warning, TEXT( "Failed to parse plugInfo.json file: '%s'" ), *Reader->GetErrorMessage() );
		}

		return nullptr;
	}

	TMap<FString, int32> PackagePathNameToDirtyCounter;
}

void IUsdClassesModule::UpdatePlugInfoFiles( const FString& PluginDirectory, const FString& TargetDllFolder )
{
	// Traverse all USD plugins
	TArray<FString> JsonPaths;
	const bool bFiles = true;
	const bool bDirectories = false;
	const bool bClearFileNames = false;  // Whether it needs to reset the output array or not
	IFileManager::Get().FindFilesRecursive( JsonPaths, *PluginDirectory, TEXT( "plugInfo.json" ), bFiles, bDirectories, bClearFileNames );
	for ( const FString& JsonFilePath : JsonPaths )
	{
		FString FileContent;
		if ( !FFileHelper::LoadFileToString( FileContent, *JsonFilePath ) )
		{
			continue;
		}

		// Strip a preamble that looks like this:
		//		# Portions of this file auto-generated by usdGenSchema.
		//		# Edits will survive regeneration except for comments and
		//		# changes to types with autoGenerated=true.
		// We will not save this preamble back into the file, but that's not bad as the file is already in the binaries folder
		// and the preamble is actually invalid json anyway
		int32 FirstOpenBracketPos = FileContent.Find( TEXT( "{" ) );
		int32 NewLen = FileContent.Len() - FirstOpenBracketPos;
		FileContent.RightInline( NewLen );

		TSharedPtr<FJsonObject> DescriptorObject = UE::USDClasses::Private::ParseJSON( FileContent );
		if ( !DescriptorObject.IsValid() )
		{
			continue;
		}

		TSharedPtr<FJsonValue> PluginsField = DescriptorObject->TryGetField( TEXT( "Plugins" ) );
		if ( !PluginsField.IsValid() )
		{
			continue;
		}

		bool bUpdatedFile = false;

		const TArray< TSharedPtr<FJsonValue> >* PluginEntriesPtr = nullptr;
		if ( !PluginsField->TryGetArray( PluginEntriesPtr ) || !PluginEntriesPtr )
		{
			continue;
		}

		for ( const TSharedPtr<FJsonValue>& PluginEntry : *PluginEntriesPtr )
		{
			const TSharedPtr<FJsonObject>* PluginEntryObjectPtr = nullptr;
			if ( !PluginEntry->TryGetObject( PluginEntryObjectPtr ) || !PluginEntryObjectPtr || !PluginEntryObjectPtr->IsValid() )
			{
				continue;
			}

			TSharedPtr<FJsonValue> LibraryPathField = ( *PluginEntryObjectPtr )->TryGetField( TEXT( "LibraryPath" ) );
			if ( !LibraryPathField.IsValid() )
			{
				continue;
			}

			// e.g. "../../../../../../Win64/sdf.dll"
			FString LibraryPath;
			if ( !LibraryPathField->TryGetString( LibraryPath ) )
			{
				continue;
			}

			// e.g. "sdf.dll"
			FString DllName = FPaths::GetCleanFilename( LibraryPath );
			if ( DllName.IsEmpty() )
			{
				continue;
			}

			// e.g. ".."
			FString RootPath;
			if ( TSharedPtr<FJsonValue> RootPathField = ( *PluginEntryObjectPtr )->TryGetField( TEXT( "Root" ) ) )
			{
				RootPathField->TryGetString( RootPath );
			}

			// e.g. "E:/Folder/Workspace/Engine/Binaries/ThirdParty/USD/UsdResources/Win64/plugins/ar/resources/.."
			RootPath = FPaths::Combine( FPaths::GetPath( JsonFilePath ), RootPath );
			FPaths::NormalizeDirectoryName( RootPath );
			FPaths::CollapseRelativeDirectories( RootPath );

			FString PathToDll = TargetDllFolder;

			// Ensure directories end with a slash, otherwise FPaths::MakePathRelativeTo may strip the last folder thinking it's a filename
			if ( !PathToDll.EndsWith( TEXT( "/" ) ) )
			{
				PathToDll.AppendChar( TEXT( '/' ) );
			}
			if ( !RootPath.EndsWith( TEXT( "/" ) ) )
			{
				RootPath.AppendChar( TEXT( '/' ) );
			}

			// e.g. "../../../../../../Win64"
			// This can fail if we're in different drives. Then we're forced to assume that CurrentDllLocation is an absolute path and use it directly
			if ( !FPaths::MakePathRelativeTo( PathToDll, *RootPath ) )
			{
				if ( FPaths::IsRelative( PathToDll ) && !FPaths::DirectoryExists( PathToDll ) )
				{
					UE_LOG( LogUsd, Warning, TEXT( "Failed to handle Current DLL Location '%s' when trying to update plugInfo.json paths" ), *PathToDll );
					continue;
				}
			}

			// e.g. "../../../../../../Win64/sdf.dll"
			FString NewLibraryPath = FPaths::Combine( PathToDll, DllName );
			( *PluginEntryObjectPtr )->SetField( TEXT( "LibraryPath" ), MakeShared<FJsonValueString>( NewLibraryPath ) );
			bUpdatedFile = true;
		}

		// Serialize them back to JSON if we changed anything
		if ( bUpdatedFile )
		{
			FString OutputString;
			TSharedRef< TJsonWriter<> > Writer = TJsonWriterFactory<>::Create( &OutputString );
			FJsonSerializer::Serialize( DescriptorObject.ToSharedRef(), Writer );

			if ( FFileHelper::SaveStringToFile( OutputString, *JsonFilePath, FFileHelper::EEncodingOptions::AutoDetect, &IFileManager::Get(), FILEWRITE_EvenIfReadOnly ) )
			{
				UE_LOG( LogUsd, Log, TEXT( "Updated LibraryPaths for USD plugInfo.json file '%s'" ), *JsonFilePath );
			}
			else
			{
				UE_LOG( LogUsd, Warning, TEXT( "Failed to update LibraryPath for USD plugInfo.json file '%s'" ), *JsonFilePath );
			}
		}
	}
}

void IUsdClassesModule::SendAnalytics( TArray<FAnalyticsEventAttribute>&& InAttributes, const FString& EventName, bool bAutomated, double ElapsedSeconds, double NumberOfFrames, const FString& Extension )
{
	if ( FEngineAnalytics::IsAvailable() )
	{
		TArray<FAnalyticsEventAttribute> Attributes( InAttributes );

		Attributes.Emplace( TEXT( "Automated" ), LexToString( bAutomated ) );
		Attributes.Emplace( TEXT( "FileExtension" ), Extension );
		Attributes.Emplace( TEXT( "NumberOfFrames" ), LexToString( FMath::Abs( NumberOfFrames ) ) );
		Attributes.Emplace( TEXT( "TimeTaken.Seconds" ), ElapsedSeconds );
		Attributes.Emplace( TEXT( "Platform" ), FPlatformProperties::IniPlatformName() );
		Attributes.Emplace( TEXT( "EngineVersion" ), FEngineVersion::Current().ToString() );
		Attributes.Emplace( TEXT( "EngineMode" ), FPlatformMisc::GetEngineMode() );
		Attributes.Emplace( TEXT( "EpicAccountId" ), FPlatformMisc::GetEpicAccountId() );

		const FString EventText = FString::Printf( TEXT( "Engine.Usage.USD.%s" ), *EventName);
		FEngineAnalytics::GetProvider().RecordEvent( EventText, Attributes );
	}
}

bool IUsdClassesModule::HashObjectPackage( const UObject* Object, FSHA1& HashToUpdate )
{
#if WITH_EDITOR
	if ( !Object )
	{
		return false;
	}

	UPackage* Package = Object->GetOutermost();
	if ( !Package )
	{
		return false;
	}

	// Hash package's persistent Guid
	const FGuid& Guid = Package->GetPersistentGuid();
	HashToUpdate.Update( reinterpret_cast< const uint8* >( &Guid ), sizeof( Guid ) );

	// Hash last modified date
	FString PackageFullName = Package->GetPathName();
	FString FileName;
	if ( FPackageName::TryConvertLongPackageNameToFilename( PackageFullName, FileName ) )
	{
		FFileStatData StatData = IFileManager::Get().GetStatData( *FileName );
		if ( StatData.bIsValid )
		{
			FString ModifiedTimeString = StatData.ModificationTime.ToString();
			HashToUpdate.UpdateWithString( *ModifiedTimeString, ModifiedTimeString.Len() );
		}
	}

	// If this asset is currently dirty, also hash how many times it was dirtied in this session.
	// If it's ever saved, we'll reset this counter but update the last saved date
	if ( int32* DirtyCounter = UE::USDClasses::Private::PackagePathNameToDirtyCounter.Find( PackageFullName ) )
	{
		HashToUpdate.Update( reinterpret_cast< const uint8* >( DirtyCounter ), sizeof( *DirtyCounter ) );
	}

	return true;
#else
	return false;
#endif // WITH_EDITOR
}

UWorld* IUsdClassesModule::GetCurrentWorld( bool bEditorWorldsOnly )
{
	UWorld* EditorWorld = nullptr;
	UWorld* LowestPIEWorld = nullptr;
	int32 LowestPIEInstance = TNumericLimits<int32>::Max();

	for ( const FWorldContext& Context : GEngine->GetWorldContexts() )
	{
		UWorld* World = Context.World();
		if ( !World )
		{
			continue;
		}

		if ( !bEditorWorldsOnly && Context.WorldType == EWorldType::PIE )
		{
			if ( !LowestPIEInstance || Context.PIEInstance < LowestPIEInstance )
			{
				LowestPIEWorld = World;
				LowestPIEInstance = Context.PIEInstance;
			}
		}
		else if ( Context.WorldType == EWorldType::Editor )
		{
			EditorWorld = World;
		}
	}

	if ( LowestPIEWorld )
	{
		return LowestPIEWorld;
	}

	return EditorWorld;
}

TSet<UObject*> IUsdClassesModule::GetAssetDependencies(UObject* Asset)
{
	TSet<UObject*> Result;

	if (UMaterial* Material = Cast<UMaterial>(Asset))
	{
		TArray<UTexture*> UsedTextures;
		const bool bAllQualityLevels = true;
		const bool bAllFeatureLevels = true;
		Material->GetUsedTextures(UsedTextures, EMaterialQualityLevel::High, bAllQualityLevels, ERHIFeatureLevel::SM5, bAllFeatureLevels);

		Result.Reserve(Result.Num() + UsedTextures.Num());
		for (UTexture* UsedTexture : UsedTextures)
		{
			Result.Add(UsedTexture);
		}
	}
	else if (UMaterialInstance* MaterialInstance = Cast<UMaterialInstance>(Asset))
	{
		Result.Reserve(Result.Num() + MaterialInstance->TextureParameterValues.Num());
		for (const FTextureParameterValue& TextureValue : MaterialInstance->TextureParameterValues)
		{
			if (UTexture* Texture = TextureValue.ParameterValue)
			{
				Result.Add(Texture);
			}
		}

		// We'll have a dependency on our reference material too of course (this happens for Mdl
		// materials for example, that create new UMaterial assets every time, and also material instances).
		if (UMaterialInterface* ReferenceMaterial = MaterialInstance->Parent.Get())
		{
			Result.Add(ReferenceMaterial);
		}
	}
	else if (USkeletalMesh* SkeletalMesh = Cast<USkeletalMesh>(Asset))
	{
		if (USkeleton* Skeleton = SkeletalMesh->GetSkeleton())
		{
			Result.Add(Skeleton);
		}

		if (UPhysicsAsset* PhysicsAsset = SkeletalMesh->GetPhysicsAsset())
		{
			Result.Add(PhysicsAsset);
		}

		Result.Reserve(Result.Num() + SkeletalMesh->GetMaterials().Num());
		for (const FSkeletalMaterial& SkeletalMaterial : SkeletalMesh->GetMaterials())
		{
			if (UMaterialInterface* UsedMaterial = SkeletalMaterial.MaterialInterface)
			{
				Result.Add(UsedMaterial);
			}
		}
	}
	else if (UStaticMesh* StaticMesh = Cast<UStaticMesh>(Asset))
	{
		Result.Reserve(Result.Num() + StaticMesh->GetStaticMaterials().Num());
		for (const FStaticMaterial& StaticMaterial : StaticMesh->GetStaticMaterials())
		{
			if (UMaterialInterface* UsedMaterial = StaticMaterial.MaterialInterface)
			{
				Result.Add(UsedMaterial);
			}
		}
	}
	else if (UGeometryCache* GeometryCache = Cast<UGeometryCache>(Asset))
	{
		for (UMaterialInterface* UsedMaterial : GeometryCache->Materials)
		{
			if (UsedMaterial)
			{
				Result.Add(UsedMaterial);
			}
		}
	}
	else if (UAnimSequence* AnimSequence = Cast<UAnimSequence>(Asset))
	{
		if (USkeletalMesh* Mesh = AnimSequence->GetPreviewMesh())
		{
			Result.Add(Mesh);
		}

		if (USkeleton* Skeleton = AnimSequence->GetSkeleton())
		{
			Result.Add(Skeleton);
		}
	}
	else if (UTexture* Texture = Cast<UTexture>(Asset))
	{
		// Do nothing. Textures have no additional dependencies
	}
	else if (USkeleton* Skeleton = Cast<USkeleton>(Asset))
	{
		// Do nothing. Skeletons have no additional dependencies
	}
	else if (UPhysicsAsset* PhysicsAsset = Cast<UPhysicsAsset>(Asset))
	{
		// Do nothing. PhysicsAssets have no additional dependencies
	}
	else if (UAnimBlueprint* AnimBP = Cast<UAnimBlueprint>(Asset))
	{
		// Do nothing. AnimBlueprints have no additional dependencies
	}
	else
	{
		UE_LOG(LogUsd, Warning, TEXT("Unknown asset '%s' encountered when collecting dependencies."), Asset ? *Asset->GetName() : TEXT("nullptr"));
	}

	return Result;
}

class FUsdClassesModule : public IUsdClassesModule
{

public:
	virtual void StartupModule() override
	{
		PackageMarkedDirtyEventHandle = UPackage::PackageMarkedDirtyEvent.AddLambda(
			[]( const UPackage* Package, bool bWasDirty )
			{
				if ( Package )
				{
					UE::USDClasses::Private::PackagePathNameToDirtyCounter.FindOrAdd( Package->GetPathName() )++;
				}
			}
		);

		PackageSavedWithContextEventHandle = UPackage::PackageSavedWithContextEvent.AddLambda(
			[]( const FString& PackageFilename, UPackage* Package, FObjectPostSaveContext ObjectSaveContext )
			{
				if ( Package )
				{
					UE::USDClasses::Private::PackagePathNameToDirtyCounter.Remove( Package->GetPathName() );
				}
			}
		);
	}

	virtual void ShutdownModule() override
	{
		UPackage::PackageSavedWithContextEvent.Remove( PackageSavedWithContextEventHandle );
		UPackage::PackageMarkedDirtyEvent.Remove( PackageMarkedDirtyEventHandle );
	}

private:
	FDelegateHandle PackageMarkedDirtyEventHandle;
	FDelegateHandle PackageSavedWithContextEventHandle;
};

IMPLEMENT_MODULE( FUsdClassesModule, USDClasses );

