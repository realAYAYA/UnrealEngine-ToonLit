// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

/**

Data Channel Write Interface.
Enables Niagara Systems to push data into a NiagaraDataChannel for access later by another System or Game code/BP.

We write into an intermediate buffer on the DI which is then published to the Data Channel on post tick.
This is simple and avoids race conditions and synchronization headaches but does introduce additional copying work that in many cases may be avoided.
In the future we may allow for direct writes into the data channel buffers and/or avoiding separate writes entirely by publishing the owning emitter particle buffers.
Though these other options have their own downsides.

Accessor functions on the Data Channel Read and Write DIs can have any number of parameters, allowing a single function call to access arbitrary data from the Channel.
This avoids cumbersome work in the graph to access data but requires special handling inside the DI.

*/


#include "NiagaraDataInterfaceDataChannelCommon.h"
#include "NiagaraDataInterface.h"
#include "NiagaraDataInterfaceDataChannelWrite.generated.h"

/** Additional compile time information used by the Write DI. */
USTRUCT()
struct FNDIDataChannelWriteCompiledData : public FNDIDataChannelCompiledData
{
	GENERATED_BODY()

	/** Internal buffer layout. Contains only the data actually written by this DI. */
	UPROPERTY()
	FNiagaraDataSetCompiledData DataLayout;

	bool Init(UNiagaraSystem* System, UNiagaraDataInterfaceDataChannelWrite* OwnerDI);
};

UCLASS(Experimental, EditInlineNew, Category = "Data Channels", meta = (DisplayName = "Data Channel Writer"))
class NIAGARA_API UNiagaraDataInterfaceDataChannelWrite : public UNiagaraDataInterface
{
	GENERATED_UCLASS_BODY()

public:

	/** How should we allocate the buffer into which we write data. */
	UPROPERTY(EditAnywhere, Category = "Data Channel")
	ENiagaraDataChannelAllocationMode AllocationMode = ENiagaraDataChannelAllocationMode::Static;

	/** How many elements to allocate for writing per frame? Usage is defendant on AllocationMode. TODO: Allow allocation count to be controlled dynamically from script? */
	UPROPERTY(EditAnywhere, Category = "Data Channel")
	uint32 AllocationCount = 0;

	/** Whether the data generated by this DI should be published to the world game data channel. This is require to allow game BP and C++ to read this data. */
	UPROPERTY(EditAnywhere, Category = "Data Channel")
	bool bPublishToGame = false;

	/** Whether the data generated by this DI should be published to the world CPUSim data channel. This is required for CPU emitters in other Niagara Systems to read this data. */
	UPROPERTY(EditAnywhere, Category = "Data Channel")
	bool bPublishToCPU = false;

	/** Whether the data generated by this DI should be published to a world data channel. This is required to allow GPU emitters in other Niagara Systems to read this data.  */
	UPROPERTY(EditAnywhere, Category = "Data Channel")
	bool bPublishToGPU = false;

	/** When writing externally, the channel to use. */
	UPROPERTY(EditAnywhere, Category = "Data Channel", meta = (EditCondition = "bPublishToWorld"))
	FNiagaraDataChannelReference Channel;

	//UObject Interface
	virtual void PostInitProperties() override;
	//UObject Interface End

	//UNiagaraDataInterface Interface
	virtual void GetFunctions(TArray<FNiagaraFunctionSignature>& OutFunctions) override;
	virtual void GetVMExternalFunction(const FVMExternalFunctionBindingInfo& BindingInfo, void* InstanceData, FVMExternalFunction& OutFunc) override;
	virtual bool CanExecuteOnTarget(ENiagaraSimTarget Target) const override { return true; }
#if WITH_EDITORONLY_DATA
	virtual bool AppendCompileHash(FNiagaraCompileHashVisitor* InVisitor) const override;
	virtual void GetCommonHLSL(FString& OutHLSL)override;
	virtual bool GetFunctionHLSL(FNiagaraDataInterfaceHlslGenerationContext& HlslGenContext, FString& OutHLSL) override;
	virtual void GetParameterDefinitionHLSL(FNiagaraDataInterfaceHlslGenerationContext& HlslGenContext, FString& OutHLSL) override;

	virtual void PostCompile()override;
#endif
	virtual void BuildShaderParameters(FNiagaraShaderParametersBuilder& ShaderParametersBuilder) const override;
	virtual void SetShaderParameters(const FNiagaraDataInterfaceSetShaderParametersContext& Context) const override;

	virtual bool Equals(const UNiagaraDataInterface* Other) const override;

	virtual bool InitPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance) override;
	virtual void DestroyPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance) override;
	virtual int32 PerInstanceDataSize() const override;
	virtual bool HasPreSimulateTick() const override { return true; }
	virtual bool HasPostSimulateTick() const override { return true; }
	virtual bool PerInstanceTick(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance, float DeltaSeconds) override;
	virtual bool PerInstanceTickPostSimulate(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance, float DeltaSeconds) override;
	virtual void ProvidePerInstanceDataForRenderThread(void* DataForRenderThread, void* PerInstanceData, const FNiagaraSystemInstanceID& SystemInstance) override;
	//UNiagaraDataInterface Interface

	void Num(FVectorVMExternalFunctionContext& Context);
	void Write(FVectorVMExternalFunctionContext& Context, int32 FuncIdx);
	void Append(FVectorVMExternalFunctionContext& Context, int32 FuncIdx);

	const FNDIDataChannelWriteCompiledData& GetCompiledData()const { return CompiledData; }

	bool ShouldPublish()const { return bPublishToGame || bPublishToCPU || bPublishToGPU; }

protected:
	virtual bool CopyToInternal(UNiagaraDataInterface* Destination) const override;

	UPROPERTY()
	FNDIDataChannelWriteCompiledData CompiledData;
};