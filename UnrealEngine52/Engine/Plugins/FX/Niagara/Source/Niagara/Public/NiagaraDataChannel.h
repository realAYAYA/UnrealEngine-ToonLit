// Copyright Epic Games, Inc. All Rights Reserved.

/*==============================================================================
NiagaraDataChannel.h: Code dealing with Niagara Data Channels and their management.

Niagara Data Channels are a system for communication between Niagara Systems and with Game code/BP.

Niagara Data Channels define a common payload and other settings for a particular named Data Channel.
Niagara Data Channel Handlers are the runtime handler class that will provide access to the data channel to it's users and manage it's internal data.

Niagara Systems can read from and write to Data Channels via data interfaces.
Blueprint and game code can also read from and write to Data Channels.
Each of these writes optionally being made visible to Game, CPU and/or GPU Systems.

At the "Game" level, all data is held in LWC compatible types in AoS format.
When making this data available to Niagara Systems it is converted to SWC, SoA layout that is compatible with Niagara simulation.

EXPERIMENTAL:
Data Channels are currently experimental and undergoing heavy development.
Anything and everything can change, including content breaking changes.

Some Current limitations:

Tick Ordering:
Niagara Systems can chose to read the current frame's data or the previous frame.
Reading from the current frame allows zero latency but introduces a frame dependency, i.e. you must ensure that the reader ticks after the writer.
This frame dependency needs work to be more robust and less error prone.
Reading the previous frames data introduces a frame of latency but removes the need to tick later than the writer. Also means you're sure to get a complete frame worth of data.

GPU Support:
Currently GPU support is very limited.
Only Game->GPU and CPUSim->GPU are supported.
Only the Read function of the DI is supported.
GPU simulations always use the current frame's CPU data as this is all pushed to the at the end of the frame.
When GPU->GPU is supported, the frame dependency issue have more meaning for GPU systems.

==============================================================================*/

#pragma once

#include "NiagaraDataChannelCommon.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "NiagaraDataChannel.generated.h"

DECLARE_STATS_GROUP(TEXT("Niagara Data Channels"), STATGROUP_NiagaraDataChannels, STATCAT_Advanced);

class UNiagaraDataChannelHandler;

/** Buffer containing a single FNiagaraVariable's data at the game level. AoS layout. LWC Types. */
struct FNiagaraDataChannelVariableBuffer
{
	TArray<uint8> Data;
	int32 Size = 0;
	
	void Init(const FNiagaraVariableBase& Var)
	{
		Size = Var.GetSizeInBytes();
	}

	void Empty(){ Data.Empty(); }
	void Reset(){ Data.Reset(); }
	
	template<typename T>
	bool Write(int32 Index, const T& InData)
	{
		check(sizeof(T) == Size);
		if (Index >= 0 && Index < Num())
		{
			T* Dest = ((T*)Data.GetData()) + Index;
			*Dest = InData;

			return true;
		}
		return false;
	}

	template<typename T>
	bool Read(int32 Index, T& OutData)const
	{
		check(sizeof(T) == Size);
		if (Index >= 0 && Index < Num())
		{
			T* Src = ((T*)Data.GetData()) + Index;
			OutData = *Src;

			return true;
		}
		return false;
	}

	void SetNum(int32 Num)
	{
		Data.SetNumZeroed(Size * Num);
	}

	int32 Num()const { return Data.Num() / Size; }
};

USTRUCT()
struct FNiagaraDataChannelGameDataLayout
{
	GENERATED_BODY();

	/** Map of all variables contained in this DataChannel data and the indices into data arrays for game data. */
	UPROPERTY()
	TMap<FNiagaraVariableBase, int32> VariableIndices;

	/** Helpers for converting LWC types into Niagara simulation SWC types. */
	UPROPERTY()
	TArray<FNiagaraLwcStructConverter> LwcConverters;

	void Init(const TArray<FNiagaraVariable>& Variables);
};

/** Storage for game level DataChannels generated by BP / C++ */
struct FNiagaraDataChannelGameData : public TSharedFromThis<FNiagaraDataChannelGameData>
{
private:
	
	/** Per variable storage buffers. */
	TArray<FNiagaraDataChannelVariableBuffer> VariableData;

	int32 NumElements = 0;

	TWeakObjectPtr<const UNiagaraDataChannel> DataChannel;

public:

	void Init(const UNiagaraDataChannel* InDataChannel);
	void Empty();
	void Reset();
	void SetNum(int32 NewNum);
	int32 Num() const { return NumElements; }

	FNiagaraDataChannelVariableBuffer* FindVariableBuffer(const FNiagaraVariableBase& Var);

	void WriteToDataSet(FNiagaraDataBuffer* DestBuffer, int32 DestStartIdx);

	void AppendFromGameData(const FNiagaraDataChannelGameData& GameData);

	void AppendFromDataSet(const FNiagaraDataBuffer* SrcBuffer, FVector3f LwcTile);

	const UNiagaraDataChannel* GetDataChannel()const { return DataChannel.Get(); }

	const TConstArrayView<FNiagaraDataChannelVariableBuffer> GetVariableBuffers()const { return VariableData; }
};

//////////////////////////////////////////////////////////////////////////

/** Storage for DataChannels the world level. */
struct NIAGARA_API FNiagaraWorldDataChannelStore
{

	/** DataChannel data accessible from Game/BP. AoS Layout. LWC types. */
	FNiagaraDataChannelGameDataPtr GameData;

	//		▲	CPU Sim Data can optionally be made visible to the Game Data.
	//		|
	//		|
	//		|
	//		▼	Game/BP Data can optionally be made visible to CPU sims.

	/** DataChannel data accessible to Niagara CPU sims. SoA layout. Non LWC types. */
	FNiagaraDataSet* CPUSimData = nullptr;

	// Cached off buffer with the previous frame's CPU Sim accessible data.
	// Some systems can choose to read this to avoid any current frame tick ordering issues.
	FNiagaraDataBuffer* PrevCPUSimData = nullptr;
	
	//		▲	GPU Sim Data can optionally be made visible to CPU Sims and Game Data.
	//		|
	//		|
	//		|
	//		▼	CPU Sim and Game Data can optionally be made visible to the GPU.

	/** DataChannel data accessible to Niagara GPU sims. SoA layout. Non LWC types. */
	FNiagaraDataSet* GPUSimData = nullptr;
	
	~FNiagaraWorldDataChannelStore();

	bool IsInitialized()const {return CPUSimData != nullptr; }
	void Empty();
	void Init(UNiagaraDataChannelHandler* Owner);
	void Tick(UNiagaraDataChannelHandler* Owner);
};


DECLARE_MULTICAST_DELEGATE_OneParam(FOnDataChannelChanged, const UNiagaraDataChannel*);

UCLASS(Experimental, abstract, EditInlineNew)
class NIAGARA_API UNiagaraDataChannel : public UObject
{
public:
	GENERATED_BODY()

	//UObject Interface
	virtual void PostLoad();
	virtual void BeginDestroy();
#if WITH_EDITOR
	virtual void PreEditChange(FProperty* PropertyAboutToChange)override;
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedDataChannel)override;
#endif
	//UObject Interface End.

	FName GetChannelName()const { return ChannelName; }
	TConstArrayView<FNiagaraVariable> GetVariables()const { return Variables; }

	/** If true, we keep our previous frame's data. Some users will prefer a frame of latency to tick dependency. */
	bool KeepPreviousFrameData()const { return bKeepPreviousFrameData; }

	/** Returns the compiled data describing the data layout for DataChannels in this channel. */
	const FNiagaraDataSetCompiledData& GetCompiledData(ENiagaraSimTarget SimTarget)const;

	/** Create the appropriate handler object for this data channel. */
	virtual UNiagaraDataChannelHandler* CreateHandler() const PURE_VIRTUAL(UNiagaraDataChannel::CreateHandler, {return nullptr;} );

#if WITH_EDITOR
	FOnDataChannelChanged& OnChanged() { return OnChangedDelegate; }
#endif
	
	const FNiagaraDataChannelGameDataLayout& GetGameDataLayout()const { return GameDataLayout; }

	FNiagaraDataChannelGameDataPtr CreateGameData()const;

	bool IsValid()const;

private:
	UPROPERTY(EditAnywhere, Category = "Data Channel")
	FName ChannelName;

	/** The variables that define the data contained in this Data Channel. */
	UPROPERTY(EditAnywhere, Category = "Data Channel")
	TArray<FNiagaraVariable> Variables;

	/** If true, we keep our previous frame's data. Some users will prefer a frame of latency to tick dependency. */
	UPROPERTY(EditAnywhere, Category = "Data Channel")
	bool bKeepPreviousFrameData = false;
		
	/**
	Data layout for payloads in Niagara datasets.
	*/
	UPROPERTY()
	mutable FNiagaraDataSetCompiledData CompiledData;

	UPROPERTY()
	mutable FNiagaraDataSetCompiledData CompiledDataGPU;

#if WITH_EDITOR
	FOnDataChannelChanged OnChangedDelegate;
#endif

	/** Layout information for any data stored at the "Game" level. i.e. From game code/BP. AoS layout and LWC types. */
	UPROPERTY()
	FNiagaraDataChannelGameDataLayout GameDataLayout;
};

/**
* A C++ and Blueprint accessible library of utility functions for accessing Niagara DataChannel
*/
UCLASS(Experimental)
class NIAGARA_API UNiagaraDataChannelLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_UCLASS_BODY()

	UFUNCTION(BlueprintCallable, Category = NiagaraDataChannel, meta = (Keywords = "niagara DataChannel", WorldContext = "WorldContextObject", UnsafeDuringActorConstruction = "true"))
	static UNiagaraDataChannelHandler* GetNiagaraDataChannel(const UObject* WorldContextObject, FName Channel);
};
