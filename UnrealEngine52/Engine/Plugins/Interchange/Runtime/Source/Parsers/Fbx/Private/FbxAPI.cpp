// Copyright Epic Games, Inc. All Rights Reserved.

#include "FbxAPI.h"

#include "CoreMinimal.h"
#include "FbxCamera.h"
#include "FbxConvert.h"
#include "FbxHelper.h"
#include "FbxInclude.h"
#include "FbxLight.h"
#include "FbxMaterial.h"
#include "FbxMesh.h"
#include "FbxScene.h"
#include "InterchangeTextureNode.h"
#include "Nodes/InterchangeBaseNodeContainer.h"

#define LOCTEXT_NAMESPACE "InterchangeFbxParser"

namespace UE
{
	namespace Interchange
	{
		namespace Private
		{
			FFbxParser::~FFbxParser()
			{
				PayloadContexts.Empty();
				FbxHelper = nullptr;
			}
			
			const TSharedPtr<FFbxHelper> FFbxParser::GetFbxHelper()
			{
				if (!FbxHelper.IsValid())
				{
					FbxHelper = MakeShared<FFbxHelper>();
				}
				check(FbxHelper.IsValid());
				return FbxHelper;
			}

			bool FFbxParser::LoadFbxFile(const FString& Filename)
			{
				SourceFilename = Filename;
				int32 SDKMajor, SDKMinor, SDKRevision;
				
				//The first thing to do is to create the FBX Manager which is the object allocator for almost all the classes in the SDK
				SDKManager = FbxManager::Create();
				if (!SDKManager)
				{
					UInterchangeResultError_Generic* Message = AddMessage<UInterchangeResultError_Generic>();
					Message->Text = LOCTEXT("CannotCreateFBXManager", "Cannot create FBX SDK manager.");
					return false;
				}

				//Create an IOSettings object. This object holds all import/export settings.
				FbxIOSettings* ios = FbxIOSettings::Create(SDKManager, IOSROOT);
				ios->SetBoolProp(IMP_FBX_MATERIAL, true);
				ios->SetBoolProp(IMP_FBX_TEXTURE, true);
				ios->SetBoolProp(IMP_FBX_LINK, true);
				ios->SetBoolProp(IMP_FBX_SHAPE, true);
				ios->SetBoolProp(IMP_FBX_GOBO, true);
				ios->SetBoolProp(IMP_FBX_ANIMATION, true);
				ios->SetBoolProp(IMP_SKINS, true);
				ios->SetBoolProp(IMP_DEFORMATION, true);
				ios->SetBoolProp(IMP_FBX_GLOBAL_SETTINGS, true);
				ios->SetBoolProp(IMP_TAKE, true);
				SDKManager->SetIOSettings(ios);

				SDKGeometryConverter = new FbxGeometryConverter(SDKManager);

				//Create an FBX scene. This object holds most objects imported/exported from/to files.
				SDKScene = FbxScene::Create(SDKManager, "My Scene");
				if (!SDKScene)
				{
					UInterchangeResultError_Generic* Message = AddMessage<UInterchangeResultError_Generic>();
					Message->Text = LOCTEXT("CannotCreateFBXScene", "Cannot create FBX SDK scene.");
					return false;
				}
				
				// Create an importer.
				SDKImporter = FbxImporter::Create(SDKManager, "");

				// Get the version number of the FBX files generated by the
				// version of FBX SDK that you are using.
				FbxManager::GetFileFormatVersion(SDKMajor, SDKMinor, SDKRevision);

				// Initialize the importer by providing a filename.
				const bool bImportStatus = SDKImporter->Initialize(TCHAR_TO_UTF8(*Filename));
				if (!bImportStatus)
				{
					FFormatNamedArguments FilenameText
					{
						{ TEXT("Filename"), FText::FromString(Filename) }
					};
					UInterchangeResultError_Generic* Message = AddMessage<UInterchangeResultError_Generic>();
					Message->Text = FText::Format(LOCTEXT("CannotOpenFBXFile", "Cannot open FBX file '{Filename}'."), FilenameText);
					return false;
				}

				bool bStatus = SDKImporter->Import(SDKScene);

				const FbxGlobalSettings& GlobalSettings = SDKScene->GetGlobalSettings();
				FbxTime::EMode TimeMode = GlobalSettings.GetTimeMode();
				//Set the original framerate from the current fbx file
				float FbxFramerate = FbxTime::GetFrameRate(TimeMode);

				//We always convert scene to UE axis and units
				FFbxConvert::ConvertScene(SDKScene);

				return true;
			}

			void FFbxParser::FillContainerWithFbxScene(UInterchangeBaseNodeContainer& NodeContainer)
			{
				CleanupFbxData();

				FFbxMaterial FbxMaterial(*this);
				FbxMaterial.AddAllTextures(SDKScene, NodeContainer);
				FbxMaterial.AddAllMaterials(SDKScene, NodeContainer);

				FFbxMesh FbxMesh(*this);
				FbxMesh.AddAllMeshes(SDKScene, SDKGeometryConverter, NodeContainer, PayloadContexts);

				FFbxLight FbxLight(*this);
				FbxLight.AddAllLights(SDKScene, NodeContainer);

				FFbxCamera FbxCamera(*this);
				FbxCamera.AddAllCameras(SDKScene, NodeContainer);

				FFbxScene FbxScene(*this);
				FbxScene.AddHierarchy(SDKScene, NodeContainer, PayloadContexts);
			}

			bool FFbxParser::FetchPayloadData(const FString& PayloadKey, const FString& PayloadFilepath)
			{
				if (!PayloadContexts.Contains(PayloadKey))
				{
					UInterchangeResultError_Generic* Message = AddMessage<UInterchangeResultError_Generic>();
					Message->Text = LOCTEXT("CannotRetrievePayload", "Cannot retrieve payload; payload key doesn't have any context.");
					return false;
				}

				{
					//Critical section to force payload to be fetch one by one with no concurrency.
					FScopeLock Lock(&PayloadCriticalSection);
					TSharedPtr<FPayloadContextBase>& PayloadContext = PayloadContexts.FindChecked(PayloadKey);
					return PayloadContext->FetchPayloadToFile(*this, PayloadFilepath);
				}
			}

			bool FFbxParser::FetchAnimationBakeTransformPayload(const FString& PayloadKey, const double BakeFrequency, const double RangeStartTime, const double RangeEndTime, const FString& PayloadFilepath)
			{
				if (!PayloadContexts.Contains(PayloadKey))
				{
					UInterchangeResultError_Generic* Message = AddMessage<UInterchangeResultError_Generic>();
					Message->Text = LOCTEXT("CannotRetrievePayload", "Cannot retrieve payload; payload key doesn't have any context.");
					return false;
				}

				{
					//Critical section to force payload to be fetch one by one with no concurrency.
					FScopeLock Lock(&PayloadCriticalSection);
					TSharedPtr<FPayloadContextBase>& PayloadContext = PayloadContexts.FindChecked(PayloadKey);
					return PayloadContext->FetchAnimationBakeTransformPayloadToFile(*this, BakeFrequency, RangeStartTime, RangeEndTime, PayloadFilepath);
				}
			}

			void FFbxParser::CleanupFbxData()
			{
				//////////////////////////////////////////////////////////////////////////
				// Make sure there is a valid bind pose

				//Find root bones
				const int32 Default_NbPoses = SDKScene->GetFbxManager()->GetBindPoseCount(SDKScene);
				// If there are no BindPoses, the following will generate them.
				SDKScene->GetFbxManager()->CreateMissingBindPoses(SDKScene);
				//if we created missing bind poses, update the number of bind poses
				const int32 NbPoses = SDKScene->GetFbxManager()->GetBindPoseCount(SDKScene);
				if (NbPoses != Default_NbPoses)
				{
					UInterchangeResultWarning_Generic* Message = AddMessage<UInterchangeResultWarning_Generic>();
					Message->Text = LOCTEXT("MissingBindPose", "Missing bind pose - the FBX SDK has created one.");
				}

				//////////////////////////////////////////////////////////////////////////
				// Scene conversion
			}
		} //ns Private
	} //ns Interchange
} //ns UE

#undef LOCTEXT_NAMESPACE
